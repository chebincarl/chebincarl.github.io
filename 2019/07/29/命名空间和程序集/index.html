<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  C#的编译过程是什么样的？ VS中的解决方案与项目是什么关系？ 什么是类库？扩展名是.exe吗？如何创建类库？如何引用类库？ 程序集和类库有什么区别？ 什么是命名空间？为什么要使用命名空间？如何使用命名空间？ 程序集包含哪四个部分？ 什么是强命名和弱命名程序集？有什么区别？ 如何创建强命名程序集？ 什么是私有程序集？">
<meta name="keywords" content="C#图解教程">
<meta property="og:type" content="article">
<meta property="og:title" content="命名空间和程序集">
<meta property="og:url" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/index.html">
<meta property="og:site_name" content="车斌的博客">
<meta property="og:description" content="思考并回答以下问题：  C#的编译过程是什么样的？ VS中的解决方案与项目是什么关系？ 什么是类库？扩展名是.exe吗？如何创建类库？如何引用类库？ 程序集和类库有什么区别？ 什么是命名空间？为什么要使用命名空间？如何使用命名空间？ 程序集包含哪四个部分？ 什么是强命名和弱命名程序集？有什么区别？ 如何创建强命名程序集？ 什么是私有程序集？">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/1.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/5.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/5-1.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/2.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/3.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/4.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/6.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/7.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/8.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/9.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/10.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/11.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/12.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/13.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/14.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/26.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/15.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/16.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/17.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/18.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/19.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/20.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/23.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/24.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/25.png">
<meta property="og:updated_time" content="2019-08-05T13:36:55.990Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="命名空间和程序集">
<meta name="twitter:description" content="思考并回答以下问题：  C#的编译过程是什么样的？ VS中的解决方案与项目是什么关系？ 什么是类库？扩展名是.exe吗？如何创建类库？如何引用类库？ 程序集和类库有什么区别？ 什么是命名空间？为什么要使用命名空间？如何使用命名空间？ 程序集包含哪四个部分？ 什么是强命名和弱命名程序集？有什么区别？ 如何创建强命名程序集？ 什么是私有程序集？">
<meta name="twitter:image" content="http://chebincarl.github.io/2019/07/29/命名空间和程序集/1.png">






  <link rel="canonical" href="http://chebincarl.github.io/2019/07/29/命名空间和程序集/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>命名空间和程序集 | 车斌的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">专注，重复10遍</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chebincarl.github.io/2019/07/29/命名空间和程序集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chebin">
      <meta itemprop="description" content="记录自己的学习过程">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">命名空间和程序集

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-29 11:08:17" itemprop="dateCreated datePublished" datetime="2019-07-29T11:08:17+08:00">2019-07-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-05 21:36:55" itemprop="dateModified" datetime="2019-08-05T21:36:55+08:00">2019-08-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C#</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">13k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">12 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>C#的编译过程是什么样的？</li>
<li>VS中的解决方案与项目是什么关系？</li>
<li>什么是类库？扩展名是.exe吗？如何创建类库？如何引用类库？</li>
<li>程序集和类库有什么区别？</li>
<li>什么是命名空间？为什么要使用命名空间？如何使用命名空间？</li>
<li>程序集包含哪四个部分？</li>
<li>什么是强命名和弱命名程序集？有什么区别？</li>
<li>如何创建强命名程序集？</li>
<li>什么是私有程序集？</li>
</ul>
<a id="more"></a>
<p>本章涵盖：</p>
<ul>
<li>引用其他程序集</li>
<li>命名空间</li>
<li>using指令</li>
<li>程序集的结构</li>
<li>程序集标识符</li>
<li>强命名程序集</li>
<li>程序集的私有方式部署</li>
<li>共享程序集和GAC</li>
<li>配置文件</li>
<li>延迟签名</li>
</ul>
<h1 id="引用其他程序集"><a href="#引用其他程序集" class="headerlink" title="引用其他程序集"></a><span style="color:#039BE5;">引用其他程序集</span></h1><p>之前的学习中，我们在高层次上观察了编译过程。<span style="color:red">编译器接受源代码文件并生称名称为程序集的输出文件。</span>这一章中，我们将详细阐述程序集以及它们是如何生成和部署的。你还会看到命名空间是如何帮助组织类型的。</p>
<p>在迄今为止所看到的所有程序中，大部分都声明并使用它们自己的类。然而，在许多项目中，你会想使用来自其他程序集的类或类型。这些其他的程序集可能来自BCL，或来自一个第三方供应商，或你自己创建了它们。<span style="color:red">这些程序集称为<strong>类库</strong>，而且它们的程序集文件的名称通常以.dll扩展名结尾而不是.exe扩展名。</span></p>
<p>例如，假设你想创建一个类库，它包含可以被其他程序集使用的类和类型。一个简单库的源代码如下面示例中所示，它包含在名称为SuperLib.cs的文件中。该库含有单独一个名称为SquareWidget的公有类。图1阐明了DLL的生成。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SuperLib.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SquareWidget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> SideLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> Area</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> SideLength * SideLength; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>图1 SuperLib源代码和结果程序集<br><img src="/2019/07/29/命名空间和程序集/1.png"></p>
</blockquote>
<p>要使用Visual Studio创建类库，要在已安装的Windows模板中创建类库模板。具体来说，在Visual Studio中进行的操作步骤如下。</p>
<p>(1)选择File-&gt;New-&gt;Project，然后会打开New Project窗口。</p>
<p>(2)左边的面板，在Installed-&gt;Templates面板中找到Visual C#节点并选中。</p>
<p>(3)在中间的面板中选择Class Library模板。</p>
<img src="/2019/07/29/命名空间和程序集/5.png">
<p>如果选择的是Console Application（控制台应用程序），则生成的是exe。</p>
<img src="/2019/07/29/命名空间和程序集/5-1.png">
<p>假设你还要写一个名称为MyWidgets的程序，而且你想使用SquareWidget类。程序的代码在一个名称为MyWidgets.cs的文件中，如下面的示例所示。这段代码简单创建一个类型为SquareWidget的对象并使用该对象的成员。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyWidgets.cs</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WidgetsProgram</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        SquareWidget sq = <span class="keyword">new</span> SquareWidget(); <span class="comment">// 来自类库</span></span><br><span class="line">        <span class="comment">// ↑ 未在当前程序集中声明</span></span><br><span class="line"></span><br><span class="line">        sq.SideLength = <span class="number">5.0</span>; <span class="comment">// 设置边长</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(sq.Area); <span class="comment">// 输出该区域</span></span><br><span class="line">        <span class="comment">// ↑ 未在当前程序集中声明</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这段代码没有声明类SquareWidget。相反，使用的是定义在SuperLib中的类。然而，当你编译MyWidgets程序时，编译器必须知道你的代码在使用程序集Superlib，这样它才能得到关于类SquareWidget的信息。要实现这点，需要给编译器一个到该程序集的引用，给出它的名称和位置。</p>
<p>在Visual Studio中，可以用下面的方法把引用添加到项目。</p>
<ul>
<li>选择Solution Explorer，并在该项目名下找到References目录。References目录包含项目使用的程序集的列表。</li>
<li>右键单击References目录并选择Add Reference。有5个可以从中选择的标签页，允许你以不同的方法找到类库</li>
<li>对于我们的程序，选择Browse标签，浏览到包含SquareWidget类定义的DLL文件，并选择它。</li>
<li>点击OK按钮，引用就被加入到项目了。</li>
</ul>
<p>在添加了引用之后，可以编译MyWidgets了。图2阐明了全部的编译过程。</p>
<blockquote>
<p>图2 引用另一个程序集<br><img src="/2019/07/29/命名空间和程序集/2.png"></p>
</blockquote>
<p><strong>mscorlib库</strong></p>
<p>有一个类库，我几乎在先前的每一个示例中都使用它。它就是包含Console类的那个库。Console类被定义在名称为mscorlib的程序集中，在名称为mscorlib.dll的文件里。然而，你不会看到这个程序集被列在References目录中。程序集mscorlib.dll含有C#类型以及大部分.NET语言的基本类型的定义。在编译C#程序时，它必须总是被引用，所以Visual Studio不把它显示在References目录中。</p>
<p>如果算上mscorlib，MyWidgets的编译过程看起来更像图3所示的表述。在此之后，我会假定使用mscorlib程序集而不再描述它。</p>
<blockquote>
<p>图3 引用类库<br><img src="/2019/07/29/命名空间和程序集/3.png"></p>
</blockquote>
<p>现在假设你的程序已经很好地用SquareWidget类工作了，但你想扩展它的能力以使用一个名称为CircleWidget的类，它被定义在另一个名称为UltraLib的程序集中。MyWidgets的源代码看上去像下面这样。它创建一个SquareWidget对象和一个CircleWidget对象，它们分别定义在SuperLib中和UltraLib中。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WidgetsProgram</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        SquareWidget sq = <span class="keyword">new</span> SquareWidget(); <span class="comment">// 来自SuperLib</span></span><br><span class="line">        CircleWidget circle = <span class="keyword">new</span> CircleWidget(); <span class="comment">// 来自UltraLib</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类库UltralLib的源代码如下面的示例所示。注意，除了类CircleWidget之外，就像库SuperLib，它还声明了一个名称为SquareWidget的类。可以把UltraLib编译成一个DLL并加入到项目MyWidgets的引用列表中。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SquareWidget</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CircleWidget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> Radius = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> Area</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为两个库都含有名称为SquareWidget的类，当你试图编译程序MyWidgets时，编译器产生一条错误消息，因为它不知道使用类SquareWidgets的哪个版本。图4阐明了这种<strong>命名冲突</strong>。</p>
<blockquote>
<p>图4 由于程序集SuperLib和UltraLib都含有名称为SquareWidget的类的声明，编译器不知道实例化哪一个<br><img src="/2019/07/29/命名空间和程序集/4.png"></p>
</blockquote>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a><span style="color:#039BE5;">命名空间</span></h1>
<p>在MyWidgets示例中，由于你有源代码，你能通过在SuperLib源代码或UltraLib源代码中仅仅改变SquareWidget类的名称来解决命名冲突。但是，如果这些类是由不同的公司开发的，而且你还不能拥有源代码会怎么样呢？假设SuperLib由一个名称为MyCorp的公司生产，Ultralib由ABCCorp公司生产。在这种情况下，如果你使用了任何有冲突的类或类型，你将不能把这两个库放在一起使用。</p>
<p>你能想象得出，在你做开发的机器上含有数打（如果不是几百个的话）不同的公司生产的程序集，很可能有一定数量的类名重复。如果仅仅因为它们碰巧有共同的类型名，不能把两个程序集用在一个程序中，这将很可惜。</p>
<p>但是，假设MyCorp有一个策略，让所有类的前缀都是公司名字加上类产品名和描述名。并且进一步假设ABCCorp也有相同的策略。这样的话，我们示例中的3个类名就可能是MyCorpSuperLibSquareWidget、ABCCorpUltraLibSquareWidget和ABCCorpUltraLibCircleWidget，如图5所示。这当然是完全有效的类名，并且一个公司类库的类不太可能与其他公司类库的类发生冲突。</p>
<blockquote>
<p>图5 有了消除歧义的字符串前缀，类库之间不会有冲突<br><img src="/2019/07/29/命名空间和程序集/6.png"></p>
</blockquote>
<p>但是，在我们的示例程序中，需要使用冗长的名字，看上去如下所示：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">WidgetsProgram</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MyCorpSuperLibSquareWidget sq = <span class="keyword">new</span> MyCorpSuperLibSquareWidget(); <span class="comment">// 来自SuperLib</span></span><br><span class="line">        ABCCorpUltraLibCircleWidget circle = <span class="keyword">new</span> ABCCorpUltraLibCircleWidget(); <span class="comment">// 来自UltraLib</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管这可以解决冲突问题，但是即使有智能感知，这些新的、已消除歧义的名字还是难以阅读并且容易出错。</p>
<p>不过，假设除了标识符中一般允许的字符，还可以在字符串中使用点——尽管不是在类名的最前面或最后面，那么这些名字就更好理解了，比如MyCorp.SuperLib.SquareWidget、ABCCorp.UltraLib.SquareWidget及ABCCorp.UltraLib.CircleWidget。现在代码看上去如下所示：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">WidgetsProgram</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MyCorp.SuperLib.SquareWidget sq = <span class="keyword">new</span> MyCorp.SuperLib.SquareWidget(); <span class="comment">// 来自SuperLib</span></span><br><span class="line">        ABCCorp.UltraLib.CircleWidget circle = <span class="keyword">new</span> ABCCorp.UltraLib.CircleWidget(); <span class="comment">// 来自UltraLib</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就给了我们命名空间名和命名空间的定义。</p>
<ul>
<li>你可以把命名空间名视为一个字符串（在字符串中可以使用点），它加在类名或类型名的前面并且通过点进行分隔。</li>
<li>包括命名空间名、分隔点，以及类名的完整字符串叫做类的<strong>完全限定名</strong>。</li>
<li>命名空间是共享命名空间名的一组类和类型。</li>
</ul>
<p>图6演示了这些定义。</p>
<blockquote>
<p>图6 命名空间是共享同一命名空间名的一组类型定义<br><img src="/2019/07/29/命名空间和程序集/7.png"></p>
</blockquote>
<p>你可以使用命名空间来把一组类型组织在一起并且给它们起一个名字。一般而言，命名空间名描述的是命名空间中包含的类型，并且和其他命名空间名不同。</p>
<p>你可以通过在包含你的类型声明的源文件中声明命名空间，从而创建命名空间。如下代码演示了声明命名空间的语法。然后在命名空间声明的大括号中声明你的所有类和其他类型。那么这些类型就是这个命名空间的成员了。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ↓ 关键字   ↓ 命名空间名</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">NamespaceName</span></span><br><span class="line">&#123;</span><br><span class="line">    TypeDeclarations    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如下代码演示了MyCorp的程序员如何创建MyCorp.SuperLib命名空间以及声明其中的SquareWidget类。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//          ↓ 公司名 </span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyCorp.SuperLib</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//          ↑ 点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SquareWidget</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span> SideLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span> Area</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span>&#123; <span class="keyword">return</span> SideLength * SideLength; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当MyCorp公司给你配上更新的程序集时，你可以通过按照如下方式修改MyWidgets程序来使用它。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">WidgetsProgram</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// MyCorp.SuperLib.SquareWidget是完全限定名</span></span><br><span class="line">        <span class="comment">// MyCorp.SuperLib是命名空间名</span></span><br><span class="line">        <span class="comment">// SquareWidget是类名</span></span><br><span class="line">        MyCorp.SuperLib.SquareWidget sq = <span class="keyword">new</span> MyCorp.SuperLib.SquareWidget();</span><br><span class="line">        CircleWidget circle = <span class="keyword">new</span> CircleWidget();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既然你在代码中显式指定了SquareWidget的SuperLib版本，编译器不会再有区分类的问题了。完全限定名称输入起来有点长，但至少你现在能使用两个库了。在本章稍后，会阐述using别名指令以解决不得不在完全限定名称中重复输入的麻烦。</p>
<p>如果UltraLib程序集也被生产它的公司（ABCCorp）使用命名空间更新，那么编译过程会如图7所示。</p>
<blockquote>
<p>图7 带命名空间的类库<br><img src="/2019/07/29/命名空间和程序集/8.png"></p>
</blockquote>
<h2 id="命名空间名称"><a href="#命名空间名称" class="headerlink" title="命名空间名称"></a>命名空间名称</h2><p>如你所见，命名空间的名称可以包含创建该程序集的公司的名称。除了标识公司以外，该名称还用于帮助程序员快速了解定义在命名空间内的类型的种类。关于命名空间名称的一些要点如下。</p>
<ul>
<li>命名空间名称可以是任何有效标识符。</li>
<li>另外，命名空间名称可以包括句点符号，用于把类型组织成层次。</li>
</ul>
<p>例如，表1列出了一些在.NET BCL中的命名空间的名称。</p>
<blockquote>
<p>表1 来自BCL的命名空间示例</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">System</th>
<th style="text-align:left">System.IO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">System.Data</td>
<td style="text-align:left">Microsoft.CSharp</td>
</tr>
<tr>
<td style="text-align:left">System.Drawing</td>
<td style="text-align:left">Microsoft.VisualBasic</td>
</tr>
</tbody>
</table>
</div>
<p>下面是命名空间命名指南：</p>
<ul>
<li>使用公司名开始命名空间名称；</li>
<li>在公司名之后跟着技术名称；</li>
<li>不要把命名空间命名为与类或类型相同的名称。</li>
</ul>
<p>例如，Acme Widget公司的软件开发部门在下面3个命名空间中开发软件，如下面的代码所示：</p>
<ul>
<li>AcmeWidgets.SuperWidget</li>
<li>AcmeWidgets.Media</li>
<li>AcmeWidgets.Games</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">AcmeWidgets.SuperWidget</span></span><br><span class="line">&#123;</span><br><span class="line">    class SPDBase...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命名空间的补充"><a href="#命名空间的补充" class="headerlink" title="命名空间的补充"></a>命名空间的补充</h2><p>关于命名空间，有其他几个要点应该知道。</p>
<ul>
<li>在命名空间内，每个类型名必须有别于所有其他类型。</li>
<li>命名空间内的类型称为命名空间的成员。</li>
<li>一个源文件可以包含任意数目的命名空间声明，可以顺序也可以嵌套。</li>
</ul>
<p>图8在左边展示了一个源文件，它顺序声明了两个命名空间，每个命名空间内有几个类型。注意，尽管命名空间内含有几个共有的类名，它们被命名空间名称区分开来，如右边的程序集所示。</p>
<blockquote>
<p>图8 多个命名空间在一个源文件中<br><img src="/2019/07/29/命名空间和程序集/9.png"></p>
</blockquote>
<p>.NET框架BCL提供了数千个已定义的类和类型以供生成程序时选择。为了帮助组织这组有用的功能，相关功能的类型被声明在相同的命名空间里。BCL使用超过100个命名空间来组织它的类型。</p>
<h2 id="命名空间跨文件伸展"><a href="#命名空间跨文件伸展" class="headerlink" title="命名空间跨文件伸展"></a>命名空间跨文件伸展</h2><p>命名空间不是封闭的。这意味着可以在该源文件的后面或另一个源文件中再次声明它，以对它增加更多的类型声明。</p>
<p>例如，图9展示了三个类的声明，它们都在相同的命名空间中，但声明在分离的源文件中。源文件可以被编译成单一的程序集，如图9所示，或编译成外离的程序集，如图10所示。</p>
<blockquote>
<p>图9 命名空间可以跨源文件伸展并编译成单一程序集<br><img src="/2019/07/29/命名空间和程序集/10.png"></p>
<p>图10 命名空间可以跨源文件伸展并编译成分离的程序集<br><img src="/2019/07/29/命名空间和程序集/11.png"></p>
</blockquote>
<h2 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h2><p>命名空间可以被嵌套，从而产生<strong>嵌套的命名空间</strong>。嵌套命名空间允许你创建类型的概念层次。有两种方法声明一个嵌套的命名空间，如下所示。</p>
<ul>
<li>原文嵌套<br>可以把命名空间的声明放在一个封装的命名空间声明体内部，从而创建一个嵌套的命名空间。图11的左边阐明了这种方法。在这个示例中，命名空间OtherNs嵌套在命名空间MyNamespace中。</li>
<li>分离的声明<br>也可以为嵌套命名空间创建分离的声明，但必须在声明中使用它的完全限定名称。图11的右边阐明了这种方法。注意在嵌套命名空间OtherNs的声明中，使用全路径命名MyNamespace.OtherNs.</li>
</ul>
<blockquote>
<p>图11 声明嵌套命名空间的两种形式是等价的<br><img src="/2019/07/29/命名空间和程序集/12.png"></p>
</blockquote>
<p>图11所示的两种形式的嵌套命名空间声明生成相同的程序集，如图12所阐明的。该图展示了两个声明在SomeLib.cs文件中的类，使用它们的完全限定名。</p>
<blockquote>
<p>图12 嵌套命名空间结构<br><img src="/2019/07/29/命名空间和程序集/13.png"></p>
</blockquote>
<p>虽然嵌套命名空间位于父命名空间内部，但是其成员并不属于包裹的父命名空间。有一个常见的误区，认为既然嵌套的命名空间位于父命名空间内部，其成员也是父命名空间的子集，这是不正确的，命名空间之间是相互独立的。</p>
<h1 id="using指令"><a href="#using指令" class="headerlink" title="using指令"></a><span style="color:#039BE5;">using指令</span></h1><p>完全限定名可能相当长，在代码中通篇使用它们会变得十分乏味。然而，有两个编译器指令，可以使你避免不得不使用完全限定名：using命名空间指令和using别名指令。<br>关于using指令的两个要点如下。</p>
<ul>
<li>它们必须放在源文件的顶端，在任何类型声明之前。</li>
<li>它们应用于当前源文件中的所有命名空间。</li>
</ul>
<h2 id="using命名空间指令"><a href="#using命名空间指令" class="headerlink" title="using命名空间指令"></a>using命名空间指令</h2><p>在MyWidgets示例中，你看到多个部分使用完全限定名称指定一个类。可以通过在源文件的顶端放置using命名空间指令以避免不得不使用长名称。</p>
<p>using命名空间指令通知编译器你将要使用来自某个指定命名空间的类型。然后你可以继续，并使用简单类名而不必全路径修饰它们。</p>
<p>当编译器遇到一个不在当前命名空间的名称时，它检查在using命名空间指令中给出的命名空间列表，并把该未知名称加到列表中的第一个命名空间后面。如果结果完全限定名称匹配了这个程序集或引用程序集中的一个类，编译器将使用那个类。如果不匹配，那么它试验列表中下一个命名空间。</p>
<p>using命名空间指令由关键字using跟着一个命名空间标识符组成。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ↓ 关键字</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="comment">//      ↑ 命名空间的名称</span></span><br></pre></td></tr></table></figure></p>
<p>一个已经在通篇文字中使用的方法是WriteLine方法，它是类Console的成员，在System命名空间中。不是在通篇代码中使用它的完全限定名，我只是简化了一点我们的工作，在代码的顶端使用using命名空间指令。</p>
<p>例如，下面的代码在第一行使用using命名空间指令以描述该代码使用来自System命名空间的类或其他类型。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System; <span class="comment">// using命名空间指令</span></span><br><span class="line">...</span><br><span class="line">System.Console.WriteLine(<span class="string">"This is text 1"</span>); <span class="comment">// 使用完全限定名称</span></span><br><span class="line">Console.WriteLine(<span class="string">"This is text 2"</span>); <span class="comment">// 使用指令</span></span><br></pre></td></tr></table></figure></p>
<h2 id="using别名指令"><a href="#using别名指令" class="headerlink" title="using别名指令"></a>using别名指令</h2><p>using别名指令允许起一个别名给：</p>
<ul>
<li>命名空间；</li>
<li>命名空间内的一个类型。</li>
</ul>
<p>例如，下面的代码展示了两个using别名指令的使用。第一个指令告诉编译器标识符Syst是命名空间System的别名。第二个指令表明标识符SC是类System.Console的别名。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ↓ 关键字     ↓ 命名空间</span></span><br><span class="line"><span class="keyword">using</span> Syst = System;</span><br><span class="line"><span class="keyword">using</span> SC = System.Console;</span><br><span class="line"><span class="comment">//     ↑ 别名       ↑ 类</span></span><br></pre></td></tr></table></figure></p>
<p>下面的代码使用这些别名。在Main中3行代码都调用System.Console.WriteLine方法。</p>
<ul>
<li>Main的第一条语句使用命名空间（System）的别名。</li>
<li>第二条语句使用该方法的完全限定名。</li>
<li>第三条语句使用类（Console）的别名。</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Syst = System; <span class="comment">// using别名指令</span></span><br><span class="line"><span class="keyword">using</span> SC = System.Console; <span class="comment">// using别名指令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyNamespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">SomeClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;   </span><br><span class="line">          <span class="comment">// ↓ 命名空间的别名</span></span><br><span class="line">            Syst.Console.WriteLine();</span><br><span class="line">            System.Console.WriteLine()</span><br><span class="line">            SC.WriteLine();</span><br><span class="line">         <span class="comment">// ↑ 类的别名</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="程序集的结构"><a href="#程序集的结构" class="headerlink" title="程序集的结构"></a><span style="color:#039BE5;">程序集的结构</span></h1><p>程序集不包含本地机器代码，而是公共中间语言代码。它还包含实时编译器（JIT）在运行时转换CIL到本机代码所需的一切，包括对它所引用的其他程序集的引用。程序集的文件扩展名通常为.exe或.dll.</p>
<p>大部分程序集由一个单独的文件构成。图13阐明了程序集的4个主要部分。</p>
<ul>
<li>程序集的清单（manifest）包含以下几点。<ul>
<li>程序集名称标识符。</li>
<li>组成程序集的文件列表。</li>
<li>一个指示程序集中内容在哪里的地图。</li>
<li>关于引用的其他程序集的信息。</li>
</ul>
</li>
<li><strong>类型元数据</strong>部分包含该程序集中定义的所有类型的信息。这些信息包含关于每个类型要知道的所有事情。</li>
<li>CIL部分包含程序集的所有中间代码。</li>
<li>资源部分是可选的，但可以包含图形或语言资源。</li>
</ul>
<blockquote>
<p>图13 单文件程序集的结构<br><img src="/2019/07/29/命名空间和程序集/14.png"></p>
</blockquote>
<img src="/2019/07/29/命名空间和程序集/26.png">
<p>程序集代码文件称为<strong>模块</strong>。尽管大部分程序集由单文件组成，但有些也有多个文件。对于有多个模块的程序集，一个文件是主模块（primary module），而其他的是次要模块（secondary modules）。</p>
<ul>
<li>主模块含有程序集的清单和到次要模块的引用。</li>
<li>次要模块的文件名以扩展名.netmodule结尾。</li>
<li>多文件程序集被视为一个单一单元。它们一起部署并一起定版。</li>
</ul>
<p>图14闸明了一个带次要模块的多文件程序集。</p>
<blockquote>
<p>图14 多文件程序集<br><img src="/2019/07/29/命名空间和程序集/15.png"></p>
</blockquote>
<h1 id="程序集标识符"><a href="#程序集标识符" class="headerlink" title="程序集标识符"></a><span style="color:#039BE5;">程序集标识符</span></h1><p>在.NET框架中，程序集的文件名不像在其他操作系统和环境中那么重要，更重要的是程序集的<strong>标识符</strong>（identity）。</p>
<p>程序集的标识符有4个组成部分，它们一起唯一标识了该程序集，如下所示。</p>
<ul>
<li><strong>简单名</strong> 这只是不带文件扩展名的文件名。每个程序集都有一个简单名。它也被称为程序集名或友好名称( friendly name )。</li>
<li><strong>版本号</strong> 它由4个句点分开的整数字符串组成，形式为MajorVersion.MinorVersion.Build.Revision，例如2.0.35.9.</li>
<li>文化信息 它是一个字符串，由2-5个字符组成，代表一种语言，或代表一种语言和一个国家或地区。例如，在美国使用英语的文化名是en-US。在德国使用德语，它是de-DE。</li>
<li>公钥 这个128字节字符串应该是生产该程序集的公司唯一的。</li>
</ul>
<p>公钥是公钥/私钥对的一部分，它们是一组两个非常大的、特别选择的数字，可以用于创建安全的数字签名。公钥，顾名思义，可以被公开。私钥必须被拥有者保护起来。公钥是程序集的标识符的一部分。我们稍后会在本章看到私钥的使用。</p>
<p>程序集名称的组成被包含在程序集清单中。图15阐明了清单部分。</p>
<blockquote>
<p>图15 清单中程序集标识符的组成部分<br><img src="/2019/07/29/命名空间和程序集/16.png"></p>
</blockquote>
<p>图16展示了用在.NET文档和书籍中的关于程序集标识符的一些术语。</p>
<blockquote>
<p>图16 关于程序集标识符的术语<br><img src="/2019/07/29/命名空间和程序集/17.png"></p>
</blockquote>
<h1 id="强命名程序集"><a href="#强命名程序集" class="headerlink" title="强命名程序集"></a><span style="color:#039BE5;">强命名程序集</span></h1><p><strong>强命名</strong>（strongly named）程序集有一个唯一的数字签名依附于它。强命名程序集比没有强名称的程序集更加安全，原因有以下几点。</p>
<ul>
<li>强名称唯一标识了程序集。没有其他人能创建一个与之有相同名称的程序集，所以用户可以确信该程序集来自于其声称的来源。</li>
<li>没有CLR安全组件来捕获更改，带强名称的程序集的内容不能被改变。</li>
</ul>
<p><strong>弱命名</strong>（weakly named）程序集是没有被强命名的程序集。由于弱命名程序集没有数字签名，它天生是不安全的。因为一根链的强度只和它最弱的一环相同，所以强命名程序集默认只能访问其他强命名程序集（还存在一种方法允许“部分地相信调用者”，但我不会阐述这个主题）。</p>
<p>程序员不产生强名称。编译器产生它，接受关于程序集的信息，并散列化（hash）这些信息以创建一个唯一的数据签名依附到该程序集。它在散列处理中使用的信息如下:</p>
<ul>
<li>组成程序集的字节序列；</li>
<li>简单名称；</li>
<li>版本号；</li>
<li>文化信息；</li>
<li>公钥/私钥对。</li>
</ul>
<p><strong>创建强命名程序集</strong></p>
<p>要使用Visual Studio强命名一个程序集，必须有一份公钥/私钥对文件的副本。如果没有密钥文件，可以让Visual Studio产生一个。可以实行以下步骤。<br>(1)打开工程的属性。<br>(2)选择签名页。<br>(3)选择Sign the Assembly复选框并输入密钥文件的位置或创建一个新的。</p>
<p>在编译代码时，编译器会生成一个强命名的程序集。编译器的输入和输出在图17中阐明。</p>
<blockquote>
<p>图17 创建强命名程序集<br><img src="/2019/07/29/命名空间和程序集/18.png"></p>
<p>说明<br>要创建强命名程序集还可以使用Strong Name工具（sn.exe），这个工具在安装Visual Studio的时候会自动安装。它是个命令行工具，允许程序员为程序集签名，还能提供大量管理密钥和签名的其他选项。如果Visual Studio IDE还不符合你的要求，它能提供更多选择。</p>
</blockquote>
<h1 id="程序集的私有方式部署"><a href="#程序集的私有方式部署" class="headerlink" title="程序集的私有方式部署"></a><span style="color:#039BE5;">程序集的私有方式部署</span></h1><p>在目标机器上部署一个程序就像在该机器上创建一个目录并把应用程序复制过去一样简单。如果应用程序不需要其他程序集（比如DLL），或如果所需的DLL在同一目录下，那么程序应该会就在它所在的地方良好工作。这种方法部署的程序集称为<strong>私有程序集</strong>，而且这种部署方法称为<strong>复制文件</strong>（XCopy）部署。</p>
<p>私有程序集几乎可以被放在任何目录中，而且只要它们依赖的文件都在同一目录或子目录下就足够了。事实上，可以在文件系统的不同部分有多个目录，每个目录都有同样的一组程序集，并且它们都会在它们各自不同的位置良好工作。<br>关于私有程序集部署的一些重要事情如下。</p>
<ul>
<li>私有程序集所在的目录被称为<strong>应用程序目录</strong>。</li>
<li>私有程序集可以是强命名的也可以是弱命名的。</li>
<li>没有必要在注册表中注册组件。</li>
<li>要卸载一个私有程序集，只要从文件系统中删除它即可。</li>
</ul>
<h1 id="共享程序集和GAC"><a href="#共享程序集和GAC" class="headerlink" title="共享程序集和GAC"></a><span style="color:#039BE5;">共享程序集和GAC</span></h1><p>私有程序集是非常有用的，但有时你会想把一个DLL放在一个中心位置，这样一个单独的复制就能被系统中其他的程序集共享。.NET有这样的贮藏库，称为<strong>全局程序集缓存（GAC）</strong>。放进GAC的程序集称为<strong>共享程序集</strong>。</p>
<p>关于GAC的一些重要内容如下。</p>
<ul>
<li>只有强命名程序集能被添加到GAC.</li>
<li>GAC的早期版本只接受带.dll扩展名的文件，现在也可以添加带.exe扩展名的程序集了。</li>
<li>GAC位于Windows系统目录的子目录中。.NET4.0之前位于\Windows\Assembly中，从.NET4.0开始位于\Windows\Microsoft.NET\assembly中。</li>
</ul>
<h2 id="把程序集安装到GAC"><a href="#把程序集安装到GAC" class="headerlink" title="把程序集安装到GAC"></a>把程序集安装到GAC</h2><p>当试图安装一个程序集到GAC时，CLR的安全组件首先必须检验程序集上的数字签名是否有效。如果没有数据签名，或它是无效的，系统将不会把它安装到GAC.</p>
<p>然而，这是个一次性检查。在程序集已经在GAC内之后，当它被一个正在运行的程序引用时，不再需要进一步的检查。</p>
<p>gacutil.exe命令行工具允许从GAC添加或删除程序集，并列出GAC包含的程序集。它的3个最有用的参数标记如下所示</p>
<ul>
<li>/i：把一个程序集插入GAC。</li>
<li>/u：从GAC卸载一个程序集。</li>
<li>/l：列出GAC中的程序集。</li>
</ul>
<h2 id="GAC内的并肩执行"><a href="#GAC内的并肩执行" class="headerlink" title="GAC内的并肩执行"></a>GAC内的并肩执行</h2><p>在程序集部署到GAC之后，它就能被系统中其他程序集使用了。然而，请记住程序集的标识符由完全限定名称的全部4个部分组成。所以，如果一个库的版本号改变了，或如果它有一个不同的公钥，这些区别指定了不同的程序集。</p>
<p>结果就是在GAC中可以有许多不同的程序集，它们有相同的文件名。虽然它们有相同的文件名，但<strong>它们是不同的程序集</strong>而且在GAC中完美地共存。这使不同的应用程序在同一时间很容易使用不同版本的同一DLL，因为它们是带不同标识符的不同程序集。这被称为并肩执行（side-by-side Execution）。</p>
<p>图18阐明了GAC中4个不同的DLL，它们都有相同的文件名MyLibary.dll。看这个图，可以看出前3个来自于同一公司，因为它们有相同的公钥，第4个来源不同，因为它有一个不同的公钥。这些版本如下:</p>
<ul>
<li>英文V1.0.0.0版，来自A公司；</li>
<li>英文V2.0.0.0版，来自A公司；</li>
<li>德文V1.0.0.0版，来自A公司；</li>
<li>英文V1.0.0.0版，来自B公司。</li>
</ul>
<blockquote>
<p>图18 在GAC中4个不同的并肩DLL<br><img src="/2019/07/29/命名空间和程序集/19.png"></p>
</blockquote>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><span style="color:#039BE5;">配置文件</span></h1><p>配置文件含有关于应用程序的信息，供CLR在运行时使用。它们可以指示CLR去做这样的事情，比如使用一个不同版本的DLL，或搜索程序引用的DLL时在附加目录中查找。</p>
<p>配置文件由XML代码组成，并不包含C#代码。编写XML代码的细节超出了本书的范围，但应当理解配置文件的目的以及它们如何使用。它们的一种用途是更新一个应用程序集以使用新版本的DLL。</p>
<p>例如，假设有一个应用程序引用了GAC中的一个DLL。在应用程序的清单中，该引用的标识符必须完全匹配GAC中程序集的标识符。如果一个新版本的DLL发布了，它可以被添加到GAC中，在那里它可以幸福地和老版本共存。</p>
<p>然而，应用程序仍然在它的清单中包括老版本DLL的标识符。除非重新编译应用程序并使它引用新版本的DLL，否则它会继续使用老版本。如果这是你想要的，那也不错。</p>
<p>然而，如果你不想重新编译程序但又希望它使用新的DLL，那么你可以创建一个配置文件告诉CLR去使用新的版本而不是旧版本。配置文件被放在应用程序目录中。</p>
<p>图19阐明了运行时过程中的对象。左边的应用程序MyProgram.exe调用MyLibrary.dll的1.0.0.0版，如点化线箭头所示。但应用程序有一个配置文件，而它指示CLR加载2.0.0.0版。注意配置文件的名称由可执行文件的全名（包括扩展名）加上附加扩展名.config组成。</p>
<blockquote>
<p>图19 使用配置文件绑定一个新版本<br><img src="/2019/07/29/命名空间和程序集/20.png"></p>
</blockquote>
<h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><p>Unity的Project的名字就是解决方案的名字。</p>
<p>Unity创建Project后并新建一个脚本后，VS中项目默认的名字是Assembly-CSharp。</p>
<img src="/2019/07/29/命名空间和程序集/23.png">
<p>引用下面的都是类库。例如System.dll。</p>
<img src="/2019/07/29/命名空间和程序集/24.png">
<img src="/2019/07/29/命名空间和程序集/25.png">
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C-图解教程/" rel="tag"># C#图解教程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/29/反射和特性/" rel="next" title="反射和特性">
                <i class="fa fa-chevron-left"></i> 反射和特性
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/29/第16章-构建自定义集合/" rel="prev" title="第16章-构建自定义集合">
                第16章-构建自定义集合 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Chebin">
            
              <p class="site-author-name" itemprop="name">Chebin</p>
              <div class="site-description motion-element" itemprop="description">记录自己的学习过程</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">407</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">65</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2020/04/19/第9关-关卡设计/" title="第9关 关卡设计" target="_blank">第9关 关卡设计</a>
                  </li>
                
                  <li>
                    <a href="/2020/04/18/第3章-体验发生于场景/" title="第3章-体验发生于场景" target="_blank">第3章-体验发生于场景</a>
                  </li>
                
                  <li>
                    <a href="/2020/04/18/第7章-确定操作感/" title="第7章-确定操作感" target="_blank">第7章-确定操作感</a>
                  </li>
                
                  <li>
                    <a href="/2020/04/17/Laravel-Throttle/" title="Laravel-Throttle" target="_blank">Laravel-Throttle</a>
                  </li>
                
                  <li>
                    <a href="/2020/04/16/Unity-责任链模式/" title="Unity-责任链模式" target="_blank">Unity-责任链模式</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#引用其他程序集"><span class="nav-number">1.</span> <span class="nav-text">引用其他程序集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#命名空间"><span class="nav-number">2.</span> <span class="nav-text">命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#命名空间名称"><span class="nav-number">2.1.</span> <span class="nav-text">命名空间名称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名空间的补充"><span class="nav-number">2.2.</span> <span class="nav-text">命名空间的补充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名空间跨文件伸展"><span class="nav-number">2.3.</span> <span class="nav-text">命名空间跨文件伸展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套命名空间"><span class="nav-number">2.4.</span> <span class="nav-text">嵌套命名空间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#using指令"><span class="nav-number">3.</span> <span class="nav-text">using指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#using命名空间指令"><span class="nav-number">3.1.</span> <span class="nav-text">using命名空间指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#using别名指令"><span class="nav-number">3.2.</span> <span class="nav-text">using别名指令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#程序集的结构"><span class="nav-number">4.</span> <span class="nav-text">程序集的结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#程序集标识符"><span class="nav-number">5.</span> <span class="nav-text">程序集标识符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#强命名程序集"><span class="nav-number">6.</span> <span class="nav-text">强命名程序集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#程序集的私有方式部署"><span class="nav-number">7.</span> <span class="nav-text">程序集的私有方式部署</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#共享程序集和GAC"><span class="nav-number">8.</span> <span class="nav-text">共享程序集和GAC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#把程序集安装到GAC"><span class="nav-number">8.1.</span> <span class="nav-text">把程序集安装到GAC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GAC内的并肩执行"><span class="nav-number">8.2.</span> <span class="nav-text">GAC内的并肩执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#配置文件"><span class="nav-number">9.</span> <span class="nav-text">配置文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Unity"><span class="nav-number">10.</span> <span class="nav-text">Unity</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chebin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">4.3m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">65:35</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
