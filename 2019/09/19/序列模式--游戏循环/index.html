<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：">
<meta name="keywords" content="游戏设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="序列模式--游戏循环">
<meta property="og:url" content="http://chebincarl.github.io/2019/09/19/序列模式--游戏循环/index.html">
<meta property="og:site_name" content="车斌的博客">
<meta property="og:description" content="思考并回答以下问题：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://chebincarl.github.io/2019/09/19/序列模式--游戏循环/1.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/09/19/序列模式--游戏循环/2.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/09/19/序列模式--游戏循环/3.png">
<meta property="og:image" content="http://chebincarl.github.io/2019/09/19/序列模式--游戏循环/4.png">
<meta property="og:updated_time" content="2019-10-07T13:17:19.835Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="序列模式--游戏循环">
<meta name="twitter:description" content="思考并回答以下问题：">
<meta name="twitter:image" content="http://chebincarl.github.io/2019/09/19/序列模式--游戏循环/1.png">






  <link rel="canonical" href="http://chebincarl.github.io/2019/09/19/序列模式--游戏循环/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>序列模式--游戏循环 | 车斌的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">专注，重复10遍</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chebincarl.github.io/2019/09/19/序列模式--游戏循环/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chebin">
      <meta itemprop="description" content="记录自己的学习过程">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">序列模式--游戏循环

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-19 15:04:37" itemprop="dateCreated datePublished" datetime="2019-09-19T15:04:37+08:00">2019-09-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-10-07 21:17:19" itemprop="dateModified" datetime="2019-10-07T21:17:19+08:00">2019-10-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">9.4k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">9 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<a id="more"></a>

<p>本章涵盖：</p>
<h1 id="意图"><a href="#意图" class="headerlink" title="意图"></a><span style="color:#339AFF;">意图</span></h1><p><strong>将游戏的进行和玩家的输入解耦，和处理器速度解耦。</strong></p>
<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a><span style="color:#339AFF;">动机</span></h1><p>如果本书中有一个模式不可或缺，那非这个模式莫属了。游戏循环是“游戏编程模式”的精髓。几乎每个游戏都有，两两不同，而在非游戏的程序几乎没有使用。</p>
<p>为了看看它多有用，让我们快速缅怀一遍往事。在每个编写计算机程序的人都留着胡子的时代，程序像洗碗机一样工作。你输入一堆代码，按个按钮，等待，然后获得结果，完成。程序全都是<strong>批处理模式</strong>的——一旦工作完成，程序就停止了。</p>
<p>你在今日仍然能看到这些程序。终端脚本，命令行程序，甚至将Markdown翻译成这本书的Python脚本都是批处理程序。</p>
<h2 id="采访CPU"><a href="#采访CPU" class="headerlink" title="采访CPU"></a><span style="color:#00ACC1;">采访CPU</span></h2><p>最终，程序员意识到将批处理代码留在计算办公室，等几个小时后拿到结果才能开始找程序漏洞的方式实在低效。他们想要立即的反馈。<strong>交互式</strong>程序诞生了。第一批交互式程序中就有游戏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YOU ARE STANDING AT THE END OF A ROAD BEFORE A SMALL BRICK BUILDING . AROUND YOU IS A FOREST. A SMALL</span><br><span class="line">STREAM FLOWS OUT OF THE BUILDING AND DOWN A GULLY.</span><br><span class="line"></span><br><span class="line">&gt; GO IN</span><br><span class="line">YOU ARE INSIDE A BUILDING, A WELL HOUSE FOR A LARGE SPRING.</span><br></pre></td></tr></table></figure>

<p>你可以和这个程序进行实时交互。它等待你的输入，然后进行响应。你再输入，这样一唱一和，就像相声一样。当轮到你时，它停在那里啥也不做。像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* command = readCommand();</span><br><span class="line">    handleCommand(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这程序会永久循环，所以没法退出游戏。真实的游戏会做些while(!done)进行检查，然后通过设置done为真来退出游戏。我省去了那些内容，保持简明。</p>
</blockquote>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a><span style="color:#00ACC1;">事件循环</span></h2><p>如果你剥开现代的图形UI的外皮，会惊讶地发现它们与老旧的冒险游戏差不多。文本处理器通常呆在那里什么也不做，直到你按了个键或者点了什么东西：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Event* event = waitForEvent();</span><br><span class="line">    dispatchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这与冒险游戏主要的不同是，程序不是等待<strong>文本指令</strong>，而是等待<strong>用户输入事件</strong>——鼠标点击、按键按下之类的。其他部分还是和以前的老式文本冒险游戏一样，程序<strong>阻塞</strong>等待用户的输入，这是个问题。</p>
<blockquote>
<p>事件循环有“空转”事件，这样你可以无需用户输入间歇地做些事情。这对于闪烁的光标或者进度条已经足够了，但对于游戏就太原始了。</p>
</blockquote>
<p>不像其他大多数软件，游戏即使在没有玩家输入时也继续运行。如果你站在那里看着屏幕，游戏不会冻结。动画继续动着。视觉效果继续闪烁。如果运气不好的话，怪物会继续吞噬英雄。</p>
<p>这是真实游戏循环的第一个关键部分：<strong>它处理用户输入，但是不等待它</strong>。循环总是继续旋转：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    processInput();</span><br><span class="line">    update();</span><br><span class="line">    render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们之后会改善它，但是基本的部分都在这里了。processInput()处理上次调用到现在的任何输入。然后update()让游戏模拟一步。运行AI和物理（通常是这种顺序）。最终，render()绘制游戏，这样玩家可以看到发生了什么。</p>
<blockquote>
<p>就像你可以从名字中猜到的，update()是使用<a href="/2019/10/07/序列模式--更新方法/" title="更新方法">更新方法</a>模式的好地方。</p>
</blockquote>
<h2 id="时间之外的世界"><a href="#时间之外的世界" class="headerlink" title="时间之外的世界"></a><span style="color:#00ACC1;">时间之外的世界</span></h2><p>如果这个循环没有因为输入而阻塞，这就带来了明显的问题，要运转多<strong>快</strong>呢？每次进行游戏循环都会推动一定的游戏状态的发展。在游戏世界的居民看来，他们手上的表就会滴答一下。</p>
<blockquote>
<p>运行游戏循环一次的常用术语就是“滴答”（tick）和“帧”（frame）。</p>
</blockquote>
<p>同时，<strong>玩家的</strong>真实手表也在滴答着。如果我们用实际时间来测算游戏循环运行的速度，就得到了游戏的“帧率”（FPS）。如果游戏循环的更快，FPS就更高，游戏运行得更流畅、更快。如果循环得过慢，游戏看上去就像是慢动作电影。</p>
<p>我们现在写的这个循环是能转多快转多快，两个因素决定了帧率。 一个是<strong>每帧要做多少工作</strong>。复杂的物理，众多游戏对象，图形细节都让CPU和GPU繁忙，这决定了需要多久能完成一帧。</p>
<p>另一个是<strong>底层平台的速度</strong>。更快的芯片可以在同样的时间里执行更多的代码。多核，GPU组，独立声卡，以及系统的调度都影响了在一次滴答中能够做多少东西。</p>
<h2 id="每秒的帧数"><a href="#每秒的帧数" class="headerlink" title="每秒的帧数"></a>每秒的帧数</h2><p>在早期的视频游戏中，第二个因素是固定的。如果你为NES或者Apple IIe写游戏，你<strong>明确</strong>知道游戏运行在什么CPU上。你可以（也必须）为它特制代码。你只需担忧第一个因素：每次滴答要做多少工作。</p>
<p>早期的游戏被仔细地编码，一帧只做一定的工作，开发者可以让游戏以想要的速率运行。但是如果你想要在快些或者慢些的机器上运行同一游戏，游戏本身就会加速或减速。</p>
<blockquote>
<p>这就是为什么老式计算机通常有“turbo”按钮。新的计算机运行得太快了，无法玩老游戏，因为游戏也会运行得过快。<strong>关闭</strong>turbo按钮，会减慢计算机的运行速度，就可以运行老游戏了。</p>
</blockquote>
<p>现在，很少有开发者可以奢侈地知道游戏运行的硬件条件。游戏必须自动适应多种设备。</p>
<p>这就是游戏循环的另一个关键任务：<strong>不管潜在的硬件条件，以固定速度运行游戏。</strong></p>
<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a><span style="color:#339AFF;">模式</span></h1><p>一个<strong>游戏循环</strong>在游玩中不断运行。每一次循环，它无阻塞地<strong>处理玩家输入</strong>，<strong>更新游戏状态</strong>，<strong>渲染游戏</strong>。它追踪时间的消耗并<strong>控制游戏的速度</strong>。</p>
<h1 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a><span style="color:#339AFF;">何时使用</span></h1><p>使用错误的模式比不使用模式更糟，所以这节通常告诫你不要过于热衷设计模式。设计模式的目标不是往代码库里尽可能的塞东西。</p>
<p>但是这个模式有所不同。我可以很自信的说你会使用这个模式。如果你使用游戏引擎，你不需要自己编写，但是它还在那里。</p>
<blockquote>
<p>对于我而言，这是“引擎”与“库”的不同之处。使用库时，你拥有游戏循环，调用库代码。使用引擎时，引擎拥有游戏循环，调用你的代码。</p>
</blockquote>
<p>你可能认为在做回合制游戏时不需要它。但是哪怕是那里，就算<strong>游戏状态</strong>到玩家回合才改变，<strong>视觉和听觉</strong>状态仍会改变。哪怕游戏在“等待”你进行你的回合，动画和音乐也会继续运行。</p>
<h1 id="记住"><a href="#记住" class="headerlink" title="记住"></a><span style="color:#339AFF;">记住</span></h1><p>我们这里谈到的循环是游戏代码中最重要的部分。有人说程序会花费90%的时间在10%的代码上。游戏循环代码肯定在这10%中。你必须小心谨慎，时时注意效率。</p>
<h2 id="你也许需要与平台的事件循环相协调"><a href="#你也许需要与平台的事件循环相协调" class="headerlink" title="你也许需要与平台的事件循环相协调"></a><span style="color:#00ACC1;">你也许需要与平台的事件循环相协调</span></h2><p>如果你在操作系统的顶层或者有图形UI和内建事件循环的平台上构建游戏，那你就有了两个应用循环在同时运作。它们需要很好地协调。</p>
<p>有时候，你可以进行控制，只运行你的游戏循环。举个例子，如果舍弃了Windows的珍贵API，main()可以只用游戏循环。其中你可以调用PeekMessage()来处理和分发系统的事件。不像GetMessage()，PeekMessage()不会阻塞等待用户输入，因此你的游戏循环会保持运作。</p>
<p>其他的平台不会让你这么轻松地摆脱事件循环。如果你使用网页浏览器作为平台，事件循环已被内建在浏览器的执行模型深处。这样，你得用事件循环作为游戏循环。你会调用requestAnimationFrame()之类的函数，它会回调你的代码，保持游戏继续运行。</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><span style="color:#339AFF;">示例代码</span></h1><p>在如此长的介绍之后，游戏循环的代码实际上很直观。我们会浏览一堆变种，比较它们的好处和坏处。</p>
<p>游戏循环驱动了AI，渲染和其他游戏系统，但这些不是模式的要点，所以我们会调用虚构的方法。在实现了render()，update()之后，剩下的作为给读者的练习（挑战！）。</p>
<h2 id="跑，能跑多快跑多快"><a href="#跑，能跑多快跑多快" class="headerlink" title="跑，能跑多快跑多快"></a><span style="color:#00ACC1;">跑，能跑多快跑多快</span></h2><p>我们已经见过了可能是最简单的游戏循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    processInput();</span><br><span class="line">    update();</span><br><span class="line">    render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的问题是你不能控制游戏运行得有多快。在快速机器上，循环会运行得太快，玩家看不清发生了什么。在慢速机器上，游戏慢的跟在爬一样。如果游戏的一部分有大量内容或者做了很多AI或物理运算，游戏就会慢一些。</p>
<h2 id="休息一下"><a href="#休息一下" class="headerlink" title="休息一下"></a><span style="color:#00ACC1;">休息一下</span></h2><p>我们看看增加一个简单的小修正如何。假设你想要你的游戏以60FPS运行。这样每帧大约16毫秒。只要你用少于这个的时长进行游戏所有的处理和渲染，就可以以稳定的帧率运行。你需要做的就是处理这一帧然后等待，直到处理下一帧的时候，就像这样：</p>
<blockquote>
<p>一个简单的游戏循环流程图。处理输入 → 更新游戏 → 渲染 → 等待，然后从头开始。</p>
</blockquote>
<img src="/2019/09/19/序列模式--游戏循环/1.png">

<blockquote>
<p>1000 毫秒 / 帧率 = 毫秒每帧.</p>
</blockquote>
<p>代码看上去像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> start = getCurrentTime();</span><br><span class="line">    processInput();</span><br><span class="line">    update();</span><br><span class="line">    render();</span><br><span class="line"></span><br><span class="line">    sleep(start + MS_PER_FRAME - getCurrentTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果它很快地处理完一帧，这里的sleep()保证了游戏不会运行太<strong>快</strong>。如果你的游戏运行太<strong>慢</strong>，这无济于事。如果需要超过16ms来更新并渲染一帧，休眠的时间就变成了<strong>负的</strong>。如果计算机能回退时间，很多事情就很容易了，但是它不能。</p>
<p>相反，游戏变慢了。可以通过每帧少做些工作来解决这个问题——减少物理效果和绚丽光影，或者把AI变笨。但是这影响了那些有快速机器的玩家的游玩体验。</p>
<h2 id="一小步，一大步"><a href="#一小步，一大步" class="headerlink" title="一小步，一大步"></a><span style="color:#00ACC1;">一小步，一大步</span></h2><p>让我们尝试一些更加复杂的东西。我们拥有的问题基本上是：</p>
<ul>
<li>1.每次更新将游戏时间推动一个固定量。</li>
<li>2.这消耗一定量的<strong>真实</strong>时间来处理它。</li>
</ul>
<p>如果第二步消耗的时间超过第一步，游戏就变慢了。如果它需要超过16ms来推动游戏时间16ms，那它永远也跟不上。但是如果一步中推动游戏时间<strong>超过</strong>16ms，那我们可以减少更新频率，就可以跟得上了。</p>
<p>接着的思路是基于上帧到现在有多少<strong>真实</strong>时间流逝来选择前进的时间。这一帧花费的时间越长，游戏的间隔越大。它总能跟上真实时间，因为它走的步子越来越大。有人称之为<strong>变化的</strong>或者<strong>流动的</strong>时间间隔。它看上去像是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> lastTime = getCurrentTime();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> current = getCurrentTime();</span><br><span class="line">    <span class="keyword">double</span> elapsed = current - lastTime;</span><br><span class="line">    processInput();</span><br><span class="line">    update(elapsed);</span><br><span class="line">    render();</span><br><span class="line">    lastTime = current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一帧，我们计算上次游戏更新到现在有多少<strong>真实</strong>时间过去了（即变量elapsed）。当我们更新游戏状态时将其传入。然后游戏引擎让游戏世界推进一定的时间量。</p>
<p>假设有一颗子弹跨过屏幕。使用固定的时间间隔，在每一帧中，你根据它的速度移动它。使用变化的时间间隔，你<strong>根据过去的时间拉伸速度</strong>。随着时间间隔增加，子弹在每帧间移动得更远。无论是二十个快的小间隔还是四个慢的大间隔，子弹在<strong>真实</strong>时间里移动<strong>同样</strong>多的距离。这看上去成功了：</p>
<ul>
<li>游戏在不同的硬件上以固定的速度运行。</li>
<li>使用高端机器的玩家获得了更流畅的游戏体验。</li>
</ul>
<p>但悲剧的是，这里有一个严重的问题：游戏不再是确定的了，也不再稳定。这是我们给自己挖的一个坑：</p>
<p>假设我们有个双人联网游戏，Fred的游戏机是台性能猛兽，而George正在使用他祖母的老爷机。前面提到的子弹在他们的屏幕上飞行。在Fred的机器上，游戏跑得超级快，每个时间间隔都很小。比如，我们塞了50帧在子弹穿过屏幕的那一秒。可怜的George的机器只能塞进大约5帧。</p>
<p>这就意味着在Fred的机器上，物理引擎每秒更新50次位置，但是George的只更新5次。大多数游戏使用浮点数，它们有舍入误差。每次你将两个浮点数加在一起，获得的结果就会有点偏差。Fred的机器做了10倍的操作，所以他的误差要比George的更大。同样的子弹最终在他们的机器上到了不同的位置。</p>
<p>“确定的”代表每次你运行程序，如果给了它同样的输入，就获得同样的输出。可以想得到，在确定的程序中追踪漏洞更容易——一旦找到造成漏洞的输入，每次你都能重现之。</p>
<p>计算机本身是确定的；它们机械地执行程序。在纷乱的真实世界搀合进来，非确定性就出现了。例如，网络，系统时钟，线程调度都依赖于超出程序控制的外部世界。</p>
<p>这是使用变化时间可引起的问题之一，还有更多问题呢。为了实时运行，游戏物理引擎做的是实际机制法则的近似。为了避免飞天遁地，物理引擎添加了阻尼。这个阻尼运算被小心地安排成以固定的时间间隔运行。改变了它，物理就不再稳定。</p>
<p>“飞天遁地”在这里使用的是它的字面意思。当物理引擎卡住，对象获得了完全错误的速度，就会飞到天上或者掉入地底。</p>
<p>这种不稳定性太糟了，这个例子在这里的唯一原因是作为警示寓言，引领我们到更好的东西……</p>
<h2 id="追逐时间"><a href="#追逐时间" class="headerlink" title="追逐时间"></a><span style="color:#00ACC1;">追逐时间</span></h2><p>游戏中渲染通常不会被动态时间间隔影响到。由于渲染引擎表现的是时间上的一瞬间，它不会计算上次到现在过了多久。它只是将当前事物渲染在所在的地方。</p>
<p>这或多或少是成立的。像动态模糊的东西会被时间间隔影响，但如果有一点延迟，玩家通常也不会注意到。</p>
<p>我们可以利用这点。以固定的时间间隔更新游戏，因为这让所有事情变得简单，物理和AI也更加稳定。但是我们允许灵活调整渲染的时刻，释放一些处理器时间。</p>
<p>它像这样运作：自上一次游戏循环过去了一定量的真实时间。需要为游戏的“当前时间”模拟推进相同长度的时间，以追上玩家的时间。我们使用一系列的固定时间步长。代码大致如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> previous = getCurrentTime();</span><br><span class="line"><span class="keyword">double</span> lag = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> current = getCurrentTime();</span><br><span class="line">    <span class="keyword">double</span> elapsed = current - previous;</span><br><span class="line">    previous = current;</span><br><span class="line">    lag += elapsed;</span><br><span class="line"></span><br><span class="line">    processInput();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lag &gt;= MS_PER_UPDATE)</span><br><span class="line">    &#123;</span><br><span class="line">        update();</span><br><span class="line">        lag -= MS_PER_UPDATE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几个部分。在每帧的开始，根据过去了多少真实的时间，更新lag。这个变量表明了游戏世界时钟比真实世界落后了多少，然后我们使用一个固定时间步长的内部循环进行追赶。一旦我们追上真实时间，我们就渲染然后开始新一轮循环。你可以将其画成这样：</p>
<blockquote>
<p>修改后的流程图。处理输入 → 更新游戏 → 等待，然重回更新这步 → 渲染 → 回到开始。</p>
</blockquote>
<img src="/2019/09/19/序列模式--游戏循环/2.png">

<p>注意这里的时间步长不是视觉上的帧率了。MS_PER_UPDATE只是我们更新游戏的间隔。这个间隔越短，就需要越多的处理次数来追上真实时间。它越长，游戏抖动得越厉害。理想上，你想要它足够短，通常快过60FPS，这样游戏在高速机器上会有高效的表现。</p>
<p>但是小心不要把它整得太短了。你需要保证即使在最慢的机器上，这个时间步长也超过处理一次update()的时间。否则，你的游戏就跟不上现实时间了。</p>
<p>我不会详谈这个，但你可以通过限定内层循环的最大次数来保证这一点。游戏会变慢，但是比完全卡死要好。</p>
<p>幸运的是，我们给自己了一些喘息的空间。技巧在于我们将渲染拉出了更新循环。这释放了一大块CPU时间。最终结果是游戏以固定时间步长模拟，该时间步长与硬件不相关。只是使用低端硬件的玩家看到的内容会有抖动。</p>
<h2 id="卡在中间"><a href="#卡在中间" class="headerlink" title="卡在中间"></a><span style="color:#00ACC1;">卡在中间</span></h2><p>我们还剩一个问题，就是剩下的延迟。以固定的时间步长更新游戏，在任意时刻渲染。这就意味着从玩家的角度看，游戏经常在两次更新之间时显示。</p>
<p>这是时间线：</p>
<blockquote>
<p>一条时间线，上面是均匀分布的更新时刻和不均匀的渲染时刻。</p>
</blockquote>
<img src="/2019/09/19/序列模式--游戏循环/3.png">

<p>就像你看到的那样，我们以紧凑固定的时间步长进行更新。同时，我们在任何可能的时候渲染。它比更新发生得要少，而且也不稳定。两者都没问题。糟糕的是，我们不总能在正确的时间点渲染。看看第三次渲染时间。它发生在两次更新之间。</p>
<blockquote>
<p>时间线的一部分，渲染发生在两次更新之间。</p>
</blockquote>
<img src="/2019/09/19/序列模式--游戏循环/4.png">

<p>想象一颗子弹飞过屏幕。第一次更新时，它在左边。第二次更新将它移到了右边。这个游戏在两次更新之间的时间点渲染，所以玩家期望看到子弹在屏幕的中间。而现在的实现中，它还在左边。这意味着看上去移动发生了卡顿。</p>
<p>方便的是，我们实际知道渲染时距离两次更新的时间：它被存储在lag中。我们在lag比更新时间间隔小时，而不是lag是零时，跳出循环进行渲染。lag的剩余量？那就是到下一帧的时间。</p>
<p>当我们要渲染时，我们将它传入：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render(lag / MS_PER_UPDATE);</span><br></pre></td></tr></table></figure>

<p>我们在这里除以MS_PER_UPDATE来归一化值。不管更新的时间步长是多少，传给render()的值总在0（恰巧在前一帧）到1.0（恰巧在下一帧）之间。这样，渲染引擎不必担心帧率。它只需处理0到1的值。</p>
<p>渲染器知道每个游戏对象以及它当前的速度。假设子弹在屏幕左边20像素的地方，正在以400像素每帧的速度向右移动。如果在两帧正中渲染，我们会给render()传0.5。它绘制了半帧之前的图形，在220像素，啊哈，平滑的移动。</p>
<p>当然，也许这种推断是错误的。在我们计算下一帧时，也许会发现子弹碰撞到另一障碍，或者减速，又或者别的什么。我们只是在上一帧位置和我们认为的下一帧位置之间插值。但只有在完成物理和AI更新后，我们才能知道真正的位置。</p>
<p>所以推断有猜测的成分，有时候结果是错误的。但是，幸运地，这种修正通常不可感知。最起码，比你不使用推断导致的卡顿更不明显。</p>
<h1 id="设计决策"><a href="#设计决策" class="headerlink" title="设计决策"></a><span style="color:#339AFF;">设计决策</span></h1><p>虽然这章我讲了很多，但是有更多的东西我没讲。一旦你考虑显示刷新频率的同步，多线程，多GPU，真正的游戏循环会变得更加复杂。即使在高层，这里还有一些问题需要你回答：</p>
<h2 id="拥有游戏循环的是你，还是平台？"><a href="#拥有游戏循环的是你，还是平台？" class="headerlink" title="拥有游戏循环的是你，还是平台？"></a><span style="color:#00ACC1;">拥有游戏循环的是你，还是平台？</span></h2><p>这个选择通常是已经由平台决定的。如果你在做浏览器中的游戏，很可能你<strong>不能</strong>编写自己的经典游戏循环。浏览器本身的事件驱动机制阻碍了这一点。类似地，如果你使用现存的游戏引擎，你很可能依赖于它的游戏循环而不是自己写一个。</p>
<ul>
<li><p><u><strong>使用平台的事件循环</strong></u>：</p>
<ul>
<li><p><strong>简单</strong>。你不必担心编写和优化自己的游戏核心循环。</p>
</li>
<li><p><strong>平台友好</strong>。 你不必明确地给平台一段时间让它处理它自己的事件，不必缓存事件，不必管理任何平台输入模型和你的不匹配之处。</p>
</li>
<li><p><strong>你失去了对时间的控制</strong>。平台会在它方便时调用代码。如果这不如你想要的那样平滑或者频繁，太糟了。更糟的是，大多数应用的事件循环并未为游戏设计，通常是又慢又卡顿。</p>
</li>
</ul>
</li>
<li><p><u><strong>使用游戏引擎的循环</strong></u>：</p>
<ul>
<li><p><strong>不必自己编写</strong>。 编写游戏循环非常需要技巧。由于是每帧都要执行的核心代码，小小的漏洞或者性能问题就对游戏有巨大的影响。稳固的游戏循环是使用现有引擎的原因之一。</p>
</li>
<li><p><strong>不必自己编写</strong>。当然，硬币的另一面是，如果引擎无法满足你<strong>真正的</strong>需求，你也没法获得控制权。</p>
</li>
</ul>
</li>
<li><p><u><strong>自己写</strong></u>：</p>
<ul>
<li><p><strong>完全的控制</strong>。 你可以做任何想做的事情。你可以为游戏的需求订制开发。</p>
</li>
<li><p><strong>你需要与平台交互</strong>。应用框架和操作系统通常需要时间片去处理自己的事件和其他工作。如果你拥有应用的核心循环，平台就没有这些时间片了。你得显式定期检查，保证框架没有挂起或者混乱。</p>
</li>
</ul>
</li>
</ul>
<h2 id="如何管理能量消耗？"><a href="#如何管理能量消耗？" class="headerlink" title="如何管理能量消耗？"></a><span style="color:#00ACC1;">如何管理能量消耗？</span></h2><p>在五年前这还不是问题。游戏运行在插到插座上的机器上或者专用的手持设备上。但是随着智能手机，笔记本以及移动游戏的发展，现在需要关注这个问题了。画面绚丽，但会耗干三十分钟前充的电，并将手机变成空间加热器的游戏，可不能让人开心。</p>
<p>现在，你需要考虑的不仅仅是让游戏看上去很棒，同时也要尽可能少地使用CPU。你需要设置一个性能的<strong>上限</strong>：完成一帧之内所需的工作后，让CPU休眠。</p>
<ul>
<li><p><u><strong>尽可能快地运行</strong></u>：</p>
<p>  这是PC游戏的常态（即使越来越多的人在笔记本上运行游戏）。 游戏循环永远不会显式告诉系统休眠。相反，空闲的循环被划在提升FPS或者图像显示效果上了。</p>
<p>  这会给你最好的游戏体验。但是，也会尽可能多地使用电量。如果玩家在笔记本电脑上游玩，他们就得到了一个很好的加热器。</p>
</li>
<li><p><u><strong>固定帧率</strong></u></p>
<p>  移动游戏更加注意游戏的体验质量，而不是最大化图像画质。很多这种游戏都会设置最大帧率（通常是30或60FPS）。如果游戏循环在分配的时间片消耗完之前完成，剩余的时间它会休眠。</p>
<p>  这给了玩家“足够好的”游戏体验，也让电池轻松了一点。</p>
</li>
</ul>
<h2 id="你如何控制游戏速度？"><a href="#你如何控制游戏速度？" class="headerlink" title="你如何控制游戏速度？"></a><span style="color:#00ACC1;">你如何控制游戏速度？</span></h2><p>游戏循环有两个关键部分：不阻塞用户输入和自适应的帧时间步长。输入部分很直观。关键在于你如何处理时间。这里有数不尽的游戏可运行的平台，每个游戏都需要在其中一些平台上运行。如何适应平台的变化就是关键。</p>
<ul>
<li><p><u><strong>固定时间步长，没有同步</strong></u>：</p>
<p>  见我们第一个样例中的代码。你只需尽可能快地运行游戏。</p>
<ul>
<li><p><strong>简单</strong>。这是主要的（好吧，唯一的）好处。</p>
</li>
<li><p><strong>游戏速度直接受到硬件和游戏复杂度影响</strong>。主要的缺点是，如果有所变化，会直接影响游戏速度。游戏速度与游戏循环紧密相关。</p>
</li>
</ul>
</li>
<li><p><u><strong>固定时间步长，有同步</strong></u>：</p>
<p>  对复杂度控制的下一步是使用固定的时间间隔，但在循环的末尾增加同步点，保证游戏不会运行得过快。</p>
<ul>
<li><p><strong>还是很简单</strong>。 这比过于简单以至于不可行的例子只多了一行代码。在多数游戏循环中，你可能总需要做一些同步。你可能需要双缓冲图形并将缓冲块与更新显示的频率同步。</p>
</li>
<li><p><strong>电量友好</strong>。 这对移动游戏至关重要。你不想消耗不必要的电量。通过简单地休眠几个毫秒而不是试图每帧塞入更多的处理，你就节约了电量。</p>
</li>
<li><p><strong>游戏不会运行得太快</strong>。 这解决了固定循环速度的一半问题。</p>
</li>
<li><p><strong>游戏可能运行的太慢</strong>。 如果花了太多时间更新和渲染一帧，播放也会减缓。 因为这种方案没有分离更新和渲染，它比更高级的方案更容易遇到这点。没法扔掉<strong>渲染</strong>帧来追上真实时间，游戏本身会变慢。</p>
</li>
</ul>
</li>
<li><p><u><strong>动态时间步长</strong></u>：</p>
<p>  我把这个方案放在这里作为问题的解决办法之一，附加警告：大多数我认识的游戏开发者反对它。 不过记住<strong>为什么</strong>反对它是很有价值的。</p>
<ul>
<li><p><strong>能适应并调整，避免运行得太快或者太慢</strong>。如果游戏不能追上真实时间，它用越来越长的时间步长更新，直到追上。</p>
</li>
<li><p><strong>让游戏不确定而且不稳定</strong>。这是真正的问题，当然。在物理和网络部分使用动态时间步长会遇见更多的困难。</p>
</li>
</ul>
</li>
<li><p><u><strong>固定更新时间步长，动态渲染</strong></u>：</p>
<p>  在示例代码中提到的最后一个选项是最复杂的，但是也是最有适应性的。它以固定时间步长更新，但是如果需要赶上玩家的时间，可以扔掉一些<strong>渲染</strong>帧。</p>
<ul>
<li><p><strong>能适应并调整，避免运行得太快或者太慢</strong>。 只要能实时<strong>更新</strong>，游戏状态就不会落后于真实时间。如果玩家用高端的机器，它会回以更平滑的游戏体验。</p>
</li>
<li><p><strong>更复杂</strong>。 主要负面问题是需要在实现中写更多东西。你需要将更新的时间步长调整得尽可能小来适应高端机，同时不至于在低端机上太慢。</p>
</li>
</ul>
</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/游戏设计模式/" rel="tag"># 游戏设计模式</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/19/Unity游戏设计模式（二）观察者模式（Observer-Pattern）/" rel="next" title="Unity游戏设计模式（二）观察者模式（Observer Pattern）">
                <i class="fa fa-chevron-left"></i> Unity游戏设计模式（二）观察者模式（Observer Pattern）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/19/组件模式/" rel="prev" title="组件模式">
                组件模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Chebin">
            
              <p class="site-author-name" itemprop="name">Chebin</p>
              <div class="site-description motion-element" itemprop="description">记录自己的学习过程</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">533</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">60</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2019/10/23/xLua游戏中的热更新/" title="xLua游戏中的热更新" target="_blank">xLua游戏中的热更新</a>
                  </li>
                
                  <li>
                    <a href="/2019/10/22/xLua热更新5之Hotfix（下篇）/" title="xLua热更新5之Hotfix（下篇）" target="_blank">xLua热更新5之Hotfix（下篇）</a>
                  </li>
                
                  <li>
                    <a href="/2019/10/22/xLua热更新4之Hotfix（上篇）/" title="xLua热更新4之Hotfix（上篇）" target="_blank">xLua热更新4之Hotfix（上篇）</a>
                  </li>
                
                  <li>
                    <a href="/2019/10/21/贪吃蛇/" title="贪吃蛇" target="_blank">贪吃蛇</a>
                  </li>
                
                  <li>
                    <a href="/2019/10/21/Json读取配置文件/" title="Json读取配置文件" target="_blank">Json读取配置文件</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#意图"><span class="nav-number">1.</span> <span class="nav-text">意图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动机"><span class="nav-number">2.</span> <span class="nav-text">动机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#采访CPU"><span class="nav-number">2.1.</span> <span class="nav-text">采访CPU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件循环"><span class="nav-number">2.2.</span> <span class="nav-text">事件循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间之外的世界"><span class="nav-number">2.3.</span> <span class="nav-text">时间之外的世界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#每秒的帧数"><span class="nav-number">2.4.</span> <span class="nav-text">每秒的帧数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模式"><span class="nav-number">3.</span> <span class="nav-text">模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#何时使用"><span class="nav-number">4.</span> <span class="nav-text">何时使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#记住"><span class="nav-number">5.</span> <span class="nav-text">记住</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#你也许需要与平台的事件循环相协调"><span class="nav-number">5.1.</span> <span class="nav-text">你也许需要与平台的事件循环相协调</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例代码"><span class="nav-number">6.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#跑，能跑多快跑多快"><span class="nav-number">6.1.</span> <span class="nav-text">跑，能跑多快跑多快</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#休息一下"><span class="nav-number">6.2.</span> <span class="nav-text">休息一下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一小步，一大步"><span class="nav-number">6.3.</span> <span class="nav-text">一小步，一大步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#追逐时间"><span class="nav-number">6.4.</span> <span class="nav-text">追逐时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#卡在中间"><span class="nav-number">6.5.</span> <span class="nav-text">卡在中间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计决策"><span class="nav-number">7.</span> <span class="nav-text">设计决策</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#拥有游戏循环的是你，还是平台？"><span class="nav-number">7.1.</span> <span class="nav-text">拥有游戏循环的是你，还是平台？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何管理能量消耗？"><span class="nav-number">7.2.</span> <span class="nav-text">如何管理能量消耗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你如何控制游戏速度？"><span class="nav-number">7.3.</span> <span class="nav-text">你如何控制游戏速度？</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chebin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">3.7m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">56:28</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
