<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[游戏角色的产生--工厂方法模式]]></title>
    <url>%2F2019%2F08%2F14%2F%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%9A%84%E4%BA%A7%E7%94%9F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 产生角色按照之前的游戏需求说明可以得知：玩家通过兵营接口决定训练角色后，玩家角色就会从所属的3个兵营中产生出来；而敌方角色对象则是由关卡系统（StageSystem）负责产生，关卡系统则是根据企划人员的设置，在不同进度条件下，产生不同的敌方角色对象，如图1所示。 图1 两方阵营兵种的产生方式 如果用比较直观的设计方式，我们可以在兵营类中实现下列程序代码，用来产生玩家角色对象： Lisiting 1 Soldier兵营类中可以产生所有的玩家角色单位 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class SoldierCamp&#123; // 训练Rookie单位 public ISoldier TrainRookie(ENUM_Weapon emWeapon,int Lv) &#123; // 产生对象 SoldierRookie theSoldier = new SoldierRookie(); // 设置模型 GameObject tmpGameObject = CreateGameObject("RookieGameObjectName"); tmpGameObject.gameObject.name = "SoldierRookie"; theSoldier.SetGameObject( tmpGameObject ); // 加入武器 IWeapon Weapon = CreateWeapon(emWeapon); theSoldier.SetWeapon( Weapon ); // 获取Soldier的属性，设置给角色 SoldierAttr theSoldierAttr = CreateSoliderAttr(1); theSoldierAttr.SetSoldierLv(Lv); theSoldier.SetCharacterAttr(theSoldierAttr); // 加入AI SoldierAI theAI = CreateSoldierAI(); theSoldier.SetAI( theAI ); // 加入管理器 PBaseDefenseGame.Instance.AddSoldier( theSoldier as ISoldier ); return theSoldier as ISoldier; &#125; // 训练Sergeant单位 public ISoldier TrainSergeant(ENUM_Weapon emWeapon,int Lv) &#123; // 产生对象 SoldierSergeant theSoldier = new SoldierSergeant(); // 设置模型 GameObject tmpGameObject = CreateGameObject("SergeantGameObjectName"); tmpGameObject.gameObject.name = "SoldierSergeant"; theSoldier.SetGameObject( tmpGameObject ); // 加入武器 IWeapon Weapon = CreateWeapon(emWeapon); theSoldier.SetWeapon( Weapon ); // 获取Soldier的属性，设置给角色 SoldierAttr theSoldierAttr = CreateSoliderAttr(2); theSoldierAttr.SetSoldierLv(Lv); theSoldier.SetCharacterAttr(theSoldierAttr); // 加入AI SoldierAI theAI = CreateSoldierAI(); theSoldier.SetAI( theAI ); // 加入管理器 PBaseDefenseGame.Instance.AddSoldier( theSoldier as ISoldier ); return theSoldier as ISoldier; &#125; // 训练Caption单位 public ISoldier TrainCaption(ENUM_Weapon emWeapon,int Lv) &#123; // 产生对象 SoldierCaptain theSoldier = new SoldierCaptain(); // 设置模型 GameObject tmpGameObject = CreateGameObject("CaptainGameObjectName"); tmpGameObject.gameObject.name = "SoldierCaptain"; theSoldier.SetGameObject( tmpGameObject ); // 加入武器 IWeapon Weapon = CreateWeapon(emWeapon); theSoldier.SetWeapon( Weapon ); // 获取Soldier的属性，设置给角色 SoldierAttr theSoldierAttr = CreateSoliderAttr(3); theSoldierAttr.SetSoldierLv(Lv); theSoldier.SetCharacterAttr(theSoldierAttr); // 加入AI SoldierAI theAI = CreateSoldierAI(); theSoldier.SetAI( theAI ); // 加入管理器 PBaseDefenseGame.Instance.AddSoldier( theSoldier as ISoldier ); return theSoldier as ISoldier; &#125;&#125; 在兵营类中，针对三种玩家角色类实现了3个方法，每个方法中都会先产生对应的玩家角色对象，之后再根据需求产生Unity3D模型、武器、角色属性、角色AI等功能的对象，产生后的对象都逐一设置给角色对象。 敌方角色对象的产生方式与玩家角色相似，不同的是，敌方角色是从关卡系统产生的： Lisiting 2 在关卡控制系统中产生所有的敌方角色对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class StageSystem&#123; // 加入Elf单位 public IEnemy AddElf(ENUM_Weapon emWeapon) &#123; // 产生对象 EnemyElf theEnmey = new EnemyElf(); // 设置模型 GameObject tmpGameObject = CreateGameObject("ElfGameObjectName"); tmpGameObject.gameObject.name = "EnemyElf"; theEnmey.SetGameObject( tmpGameObject ); // 加入武器 IWeapon Weapon = CreateWeapon(emWeapon); theEnmey.SetWeapon( Weapon ); // 获取Soldier的属性，设置给角色 EnemyAttr theEnemyAttr = CreateEnemyAttr(1); theEnmey.SetCharacterAttr(theEnemyAttr); // 加入AI EnemyAI theAI = CreateEnemyAI(); theEnmey.SetAI( theAI ); // 加入管理器 PBaseDefenseGame.Instance.AddEnemy( theEnmey as IEnemy ); return theEnmey as IEnemy; &#125; // 加入Ogre单位 public IEnemy AddOgre(ENUM_Weapon emWeapon) &#123; // 产生对象 EnemyOgre theEnmey = new EnemyOgre(); // 设置模型 GameObject tmpGameObject = CreateGameObject("OgreGameObjectName"); tmpGameObject.gameObject.name = "EnemyOgre"; theEnmey.SetGameObject( tmpGameObject ); // 加入武器 IWeapon Weapon = CreateWeapon(emWeapon); theEnmey.SetWeapon( Weapon ); // 获取Soldier的属性，设置给角色 EnemyAttr theEnemyAttr = CreateEnemyAttr(2); theEnmey.SetCharacterAttr(theEnemyAttr); // 加入AI EnemyAI theAI = CreateEnemyAI(); theEnmey.SetAI( theAI ); // 加入管理器 PBaseDefenseGame.Instance.AddEnemy( theEnmey as IEnemy ); return theEnmey as IEnemy; &#125; // 加入Troll单位 public IEnemy AddTroll(ENUM_Weapon emWeapon) &#123; // 产生对象 EnemyTroll theEnmey = new EnemyTroll(); // 设置模型 GameObject tmpGameObject = CreateGameObject("TrollGameObjectName"); tmpGameObject.gameObject.name = "EnemyTroll"; theEnmey.SetGameObject( tmpGameObject ); // 加入武器 IWeapon Weapon = CreateWeapon(emWeapon); theEnmey.SetWeapon( Weapon ); // 获取Soldier的属性，设置给角色 EnemyAttr theEnemyAttr = CreateEnemyAttr(3); theEnmey.SetCharacterAttr(theEnemyAttr); // 加入AI EnemyAI theAI = CreateEnemyAI(); theEnmey.SetAI( theAI ); // 加入管理器 PBaseDefenseGame.Instance.AddEnemy( theEnmey as IEnemy ); return theEnmey as IEnemy; &#125;&#125; 同样地，3个方法中都会先产生对应的敌方角色对象，之后再按顺序产生Unity3D模型、武器、角色属性、角色AI等功能对象并设置给敌方角色。 在两个类中，共声明了6个方法来产生不同的角色对象。在实践中，声明功能相似性过高的方法会有不易管理的问题，而且这一次实现的6个方法中，每个角色对象的组装流程重复性太高。此外，将产生相同类群组对象的实现，分散在不同的游戏功能下不易管理和维护。 所以，是否可以将这些方法都集合在一个类下实现，并且以更灵活的方式来决定产生对象的类呢？GoF的工厂方法模式为上述问题提供了答案。 工厂方法模式提到“工厂”，大多数人的概念可能是可以大量生产东西的地方，并且是以有组织、有规则的方式来生产东西。它会有多条生产线，每一条生产线都有特殊的配置，专门用来生产特定的东西。没错，工厂方法模式就是用来搭建专门生产软件对象的地方，而且这样的软件工厂，也能针对特定的类配置特定的组装流程，来满足客户端的要求。 工厂方法模式的定义GoF对工厂方法模式（Factory Method）的解释是： 1定义一个可以产生对象的接口，但是让子类决定要产生哪一个类的对象。工厂方法模式让类的实例化程序延迟到子类中实施。 工厂方法模式就是将类“产生对象的流程”集合管理的模式。集合管理带来的好处是： ①能针对对象产生的流程制定规则； ②减少客户端参与对象生成的过程，尤其是对于那种类对象生产过程过于复杂的，如果让客户端操作对象的组装过程，将使得客户端与该类的耦合度（即依赖度）过高，不利于后续的项目维护。 工厂方法模式是先定义一个产生对象的接口，之后让它的子类去决定产生哪一种对象，这有助于将庞大的类群组进行分类。例如一家生产汽车的公司，生产各种房车、小货车、大卡车等等，而每一个大类下又有品牌和不同功能之分。 因此，生产部门可以先定义一个“生产车”的接口，从这个接口可以获取生产部门所产生的“车”。之后这个接口会衍生3个子类，每一个子类负责生产这家公司的一款车型，分别为：房车工厂、小货车工厂、大卡车工厂，如图2所示。当业务部门接到50辆房车的订单后，只要获取“房车工厂”对象，之后就能对房车工厂下达生产的命令。 图2 各种类型的汽车与工厂对应，并由业务部门下单的示意图 最后，业务部门就能获取50辆房车，至于这50辆房车是怎么在生产线上进行组装的，业务部门不需要知道。 工厂方法模式的说明定义一个可以产生对象的接口，让子类决定要产生哪一个类的对象，其基本架构如图3所示。 图3运用工厂方法模式的类结构图 参与者的说明如下： Product（产品类） 定义产品类的操作接口，而这个产品将由工厂产出。 ConcreteProduct（产品实现） 实现产品功能的类，可以不只定义一个产品实现类，这些产品实现类的对象都会由ConcreteCreator（工厂实现类）产生。 Creator（工厂类） 定义能产生Product（产品类）的方法：FactoryMethod。 ConcreteCreator（工厂实现类） 实现FactoryMethod，并产生指定的ConcreteProduct（产品实现）。 工厂方法模式的实现范例在实现工厂方法模式的选择上并非是固定的，而是按照程序设计语言的特性来决定有多少种实现方式。因为C#支持泛型程序设计，所以有4种实现方式。 第一种方式：由子类产生 定义一个可以产生对象的接口，让子类决定要产生哪一个类的对象，实现上并不会太复杂： Listing 3 声明Factory类（FactoryMethod.cs） 12345public abstract class Creator&#123; // 子类返回对应的Product类型之对象 public abstract Product FactoryMethod();&#125; FactoryMethod方法负责产生Product类的对象，Product类及其子类的实现如下： Listing 4 产生对象类及子类（FactoryMethod.cs） 1234567891011121314151617181920public abstract class Product&#123;&#125;// 产品对象类Apublic class ConcreteProductA : Product&#123; public ConcreteProductA() &#123; Debug.Log("生成对象类A"); &#125;&#125;// 产品对象类Bpublic class ConcreteProductB : Product&#123; public ConcreteProductB() &#123; Debug.Log("生成对象类B"); &#125;&#125; 之后，让分别继承自Creator的子类产生对应的产品类对象： Listing 5 实现能产生产品的工厂（FactoryMethod.cs） 1234567891011121314151617181920212223242526// 产生ProductA的工厂public class ConcreteCreatorProductA : Creator&#123; public ConcreteCreatorProductA() &#123; Debug.Log("产生工厂:ConcreteCreatorProductA"); &#125; public override Product FactoryMethod() &#123; return new ConcreteProductA(); &#125;&#125;// 产生ProductB的工厂public class ConcreteCreatorProductB : Creator&#123; public ConcreteCreatorProductB() &#123; Debug.Log("产生工厂:ConcreteCreatorProductB"); &#125; public override Product FactoryMethod() &#123; return new ConcreteProductB(); &#125;&#125; 第一个子类：ConcreteCreatorProductA，它的FactoryMethod方法负责产生ConcreteProductA的对象；第二个子类：ConcreteCreatorProduceB，它的FactoryMethod方法负责产生ConcreteProductB的对象。 测试方法如下： Listing 6 测试工厂模式（FactoryMethodTest.cs） 12345678910111213141516void UnitTest () &#123; // 产品 Product theProduct = null; // 工厂接口 Creator theCreator = null; // 设置为负责ProduceA的工厂 theCreator = new ConcreteCreatorProductA(); theProduct = theCreator.FactoryMethod(); // 设置为负责ProduceB的工厂 theCreator = new ConcreteCreatorProductB(); theProduct = theCreator.FactoryMethod();&#125; 要获取ProductA对象时，工厂接口要指定为能生产ProductA的ConcreteCreatorProductA工厂类，之后调用FactoryMethod来获取ProductA对象。接下来的ProductB也是一样的流程。输出的信息也反应两个工厂类产生了不同的Product子类的对象： 执行结果 1234产生工厂:ConcreteCreatorProductA生成对象类A产生工厂:ConcretecreatorProductB生成对象类B 第二种方式：在FactoryMethod增加参数 由不同的子类工厂产生不同的产品类对象，在遇到产品类对象非常多的时候，很容易造成“工厂子类暴增”的情况，这对于后续维护来说，是比较辛苦的。所以，当有上述情况时，可以改成由单一FactoryMethod方法配合传入参数的方式，来决定要产生的产品类对象是哪一个： Listing 7 声明FactoryMethod，它会按照参数Type的提示返回对应Product类对象（FactoryMethod.cs） 123456789101112131415161718192021222324252627// 声明FactoryMethod，它会依参数Type的提示返回对应Product类的对象public abstract class Creator_MethodType&#123; public abstract Product FactoryMethod(int Type);&#125;// 重新实现FactoryMethod，以返回Product类之对象public class ConcreteCreator_MethodType: Creator_MethodType&#123; public ConcreteCreator_MethodType() &#123; Debug.Log("产生工厂:ConcreteCreator_MethodType"); &#125; public override Product FactoryMethod(int Type) &#123; switch( Type ) &#123; case 1: return new ConcreteProductA(); case 2: return new ConcreteProductB(); &#125; Debug.Log("Type["+Type+"]无法产生对象"); return null; &#125;&#125; 子类在实现FactoryMethod时，会按照传入的Type，使用switch case语句来决定要产生的产品类对象。在测试程序中，直接产生子类工厂对象后，就能利用不同的参数来产生对应的产品类对象： Listing 8 测试FactoryMethod（FactoryMethodTest.cs） 123456789void UnitTest () &#123; // 工厂接口 Creator_MethodType theCreatorMethodType = new ConcreteCreator_MethodType(); // 获取两个产品 theProduct = theCreatorMethodType.FactoryMethod(1); theProduct = theCreatorMethodType.FactoryMethod(2);&#125; 输出的信息如下： 执行结果 123产生工厂:ConcreteCreator_MethodType生成对象类A生成对象类B FactoryMethod是比较常用的实现方式，但是对于switch case语句带来的缺点，则必须加以衡量。就笔者的经验来说，如果选择了FactoryMethod的方式，那么就会在switch case语句的最后加上default区段，区段中加上警告信息，提醒有忽略的Type被传入，以避免新增产品类时，忽略要修改这一段程序代码。 不过，是否存在既可以产生对应的产品类，又不想用太多的工厂子类去实现，也不想用switch case语句来列出所有产品类的方式呢？答案是有的，只是需要程序设计语言本身支持“相关语句”即可。这里所说的“相关语句”指的是程序设计语言具备“泛型程序设计”的语句。 “泛型程序设计”在C++语句中，指的是template相关语句，而在Unity3D使用的C#语句中，指的是Generic相关语句。所以，既然C#提供了语句，那就可以使用泛型语句来实现工厂类。一般还可以分为两种实现方式：泛型类（Generic Class）和泛型方法（Generic Method）。 第三种方式：Creator泛型类 首先是采用泛型类（Generic Class）的实现，与第一种实现方式比较起来，可省去继承的实现方式，改用指定“T类类型”的方式，产生对应类的对象： Listing 9 声明Generic Factory类（FactoryMethod.cs） 12345678910111213// 声明Generic factory类型public class Creator_GenericClass&lt;T&gt; where T : Product,new()&#123; public Creator_GenericClass() &#123; Debug.Log("产生工厂:Creator_GenericClass&lt;"+typeof(T).ToString()+"&gt;"); &#125; public Product FactoryMethod() &#123; return new T(); &#125;&#125; 使用泛型类（Generic Class）实现时很简洁，只有一个类需要实现。另外，可以使用public class Creator_GenericClass&lt;T&gt; where T : Product的语句来限定T类类型，只可以带入Product群组内的类。 在客户端使用时，与第一种实现方式（由子类产生）一样，要先获取能产生特定产品类的工厂对象，之后再调用工厂对象的FactoryMethod来产生对象： Listing 10 测试泛型类（FactoryMethodTest.cs） 1234567891011void UnitTest () &#123; // 使用Generic Class // 负责ProduceA的工厂 Creator_GenericClass&lt;ConcreteProductA&gt; Creator_ProductA = new Creator_GenericClass&lt;ConcreteProductA&gt;(); theProduct = Creator_ProductA.FactoryMethod(); // 负责ProduceA的工厂 Creator_GenericClass&lt;ConcreteProductB&gt; Creator_ProductB = new Creator_GenericClass&lt;ConcreteProductB&gt;(); theProduct = Creator_ProductB.FactoryMethod();&#125; 输出的信息如下： 执行结果 1234产生工厂:Creator_GenericClass&lt;DesignPattern_FactoryMethod.ConcreteProductA&gt;生成对象类A产生工厂:Creator_GenericClass&lt;DesignPattern_FactoryMethod.ConcreteProductB&gt;生成对象类B 第四种方式：FactoryMethod泛型方法 因为泛型类（Generic Class）不使用继承的方式实现，客户端无法获取“工厂接口”，所以当需要获取工厂接口时，则可改用泛型方法（Generic Method）来实现工厂方法模式： Listing 11 声明FactoryMethod接口，并使用Generic定义方法（FactoryMethod.cs） 12345678910111213141516171819// 声明FactoryMethod接口，并使用Generic定义方法interface Creator_GenericMethod&#123; Product FactoryMethod&lt;T&gt;() where T: Product, new();&#125;// 重新实现FactoryMethod，以返回Product类之对象public class ConcreteCreator_GenericMethod : Creator_GenericMethod&#123; public ConcreteCreator_GenericMethod() &#123; Debug.Log("产生工厂:ConcreteCreator_GenericMethod"); &#125; public Product FactoryMethod&lt;T&gt;() where T: Product, new() &#123; return new T(); &#125;&#125; 使用C# interface语句声明一个接口Creator_GenericMethod，并定义一个泛型方法FactoryMethod&lt;T&gt;。客户端可以指定要产生的产品类T，实现的类就会将T类的对象产生出来并返回。而T类在声明时，必须指定为Product类，且能使用new的方式产生。 在测试程序中，通过传入不同的T类型，就能产生对应的产品类对象： Listing 12 泛型方法的测试（FactoryMethodTest.cs） 12345// 使用Generic MethodConcreteCreator_GenericMethod theCreatorGM = new ConcreteCreator_GenericMethod();theProduct = theCreatorGM.FactoryMethod&lt;ConcreteProductA&gt;();theProduct = theCreatorGM.FactoryMethod&lt;ConcreteProductB&gt;(); 执行结果 123产生工厂:ConcreteCreator_MethodType生成对象类A生成对象类B 使用Generic Method的方法实现，除了拥有“工厂接口”之外，还能免去使用switch case语句带来的缺点。另外，可以限定传入T的类型，必须是Product类，所以当有不属于Product群组的类被传入时，C#在编译阶段就能发现错误。 4种实现方式的选择，一般会按实际情况，分析工厂类与其他游戏系统、客户端的互动情况来决定。不过，在不知选择哪种方式时，笔者建议可以先选择第二种：“利用传入参数来决定要产生的类对象”的方式，因为它能避免产生过多的工厂子类，也不必去编写较复杂的泛型语句。但唯一要忍受不便的是，其中switch case语句所带来的缺点，而这也是项目实现中少数可能出现switch case语句的地方。 使用工厂方法模式产生角色对象当类的对象产生时，若出现下列情况： 需要复杂的流程； 需要加载外部资源，如从网络、存储设备、数据库； 有对象上限； 可重复使用。 建议使用工厂方法模式来实现一个工厂类，而这个工厂类内还可以搭配其他的设计模式，让对象的产生与管理更有效率。 角色工厂类在《P级阵地》中，将角色类ICharacter的对象产生地点，全部整合在同一个角色工厂类下，有助于后续游戏项目的维护，类结构图如图4所示。 图4 角色工厂类的类结构图 参与者的说明如下： ICharacterFactory：负责产生角色类ICharacter的工厂接口，并提供两个工厂方法来产生不同阵营的角色对象：CharacterSoldier负责产生玩家阵营的角色对象；CharacterEnemy负责产生敌方阵营的角色对象。 CharacterFactory：继承并实现ICharacter工厂接口的类，其中实现的工厂方法是实际产生对象的地方。 ISoldier、SoldierCaption…：工厂类产生的“产品”，在《P级阵地》中为玩家角色。 IEnemy、EnemyElf…：工厂类产生的另一项“产品”，在《P级阵地》中为敌方角色。 实现说明ICharacterFactory为抽象类，定义了两个可产生双方阵营角色的工厂方法： Listing 13 产生游戏角色的工厂接口（ICharacterFactory.cs） 123456789// 产生游戏角色工厂接口public abstract class ICharacterFactory&#123; // 产生Soldier public abstract ISoldier CreateSoldier( ENUM_Soldier emSoldier, ENUM_Weapon emWeapon, int Lv,Vector3 SpawnPosition); // 产生Enemy public abstract IEnemy CreateEnemy( ENUM_Enemy emEnemy, ENUM_Weapon emWeapon, Vector3 SpawnPosition, Vector3 AttackPosition);&#125; 在声明的方法中，除了将要产生的角色类型使用枚举（enum）语句加以指定外，也将对象产生时所需要的额外信息，如武器类型、等级、集合点等一起传递给工厂方法。CharacterFactory为实现上述接口的类： Listing 14 实现产生游戏角色的工厂（CharacterFactory.cs） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class CharacterFactory : ICharacterFactory&#123; // 产生Soldier public override ISoldier CreateSoldier( ENUM_Soldier emSoldier, ENUM_Weapon emWeapon, int Lv, Vector3 SpawnPosition) &#123; // 產生Soldier的參數 SoldierBuildParam SoldierParam = new SoldierBuildParam(); // 產生對應的Character switch( emSoldier) &#123; case ENUM_Soldier.Rookie: SoldierParam.NewCharacter = new SoldierRookie(); break; case ENUM_Soldier.Sergeant: SoldierParam.NewCharacter = new SoldierSergeant(); break; case ENUM_Soldier.Captain: SoldierParam.NewCharacter = new SoldierCaptain(); break; default: Debug.LogWarning("CreateSoldier:無法建立[" + emSoldier + "]"); return null; &#125; if( SoldierParam.NewCharacter == null) return null; // 設定共用參數 SoldierParam.emWeapon = emWeapon; SoldierParam.SpawnPosition = SpawnPosition; SoldierParam.Lv = Lv; // 產生對應的Builder及設定參數 SoldierBuilder theSoldierBuilder = new SoldierBuilder(); theSoldierBuilder.SetBuildParam( SoldierParam ); // 產生 m_BuilderDirector.Construct( theSoldierBuilder ); return SoldierParam.NewCharacter as ISoldier; &#125; // 建立Enemy public override IEnemy CreateEnemy( ENUM_Enemy emEnemy, ENUM_Weapon emWeapon, Vector3 SpawnPosition, Vector3 AttackPosition) &#123; // 產生Enemy的參數 EnemyBuildParam EnemyParam = new EnemyBuildParam(); // 產生對應的Character switch( emEnemy) &#123; case ENUM_Enemy.Elf: EnemyParam.NewCharacter = new EnemyElf(); break; case ENUM_Enemy.Troll: EnemyParam.NewCharacter = new EnemyTroll(); break; case ENUM_Enemy.Ogre: EnemyParam.NewCharacter = new EnemyOgre(); break; default: Debug.LogWarning("無法建立["+emEnemy+"]"); return null; &#125; if( EnemyParam.NewCharacter == null) return null; // 設定共用參數 EnemyParam.emWeapon = emWeapon; EnemyParam.SpawnPosition = SpawnPosition; EnemyParam.AttackPosition = AttackPosition; // 產生對應的Builder及設定參數 EnemyBuilder theEnemyBuilder = new EnemyBuilder(); theEnemyBuilder.SetBuildParam( EnemyParam ); // 產生 m_BuilderDirector.Construct( theEnemyBuilder ); return EnemyParam.NewCharacter as IEnemy; &#125;&#125; 两个工厂方法都包含角色类型列举的参数，使用switch case语句来产生不同的角色对象。为了减少因为switch case语句产生的缺失，在switch语句的最后加上了default：区段，用来提示列举项目无法产生对应角色对象的情况。除了产生对应的类对象，工厂方法（FactoryMethod）也将对象后续所需的功能设置程序一并整合进来。最后将新增的角色通过PBaseDefenseGame.Instance.AddEnemy方法添加到游戏角色管理系统（CharacterSystem）中。 使用工厂方法模式的优点角色工厂类CharacterFactory将“角色类群组”产生对象的实现，都整合到两个工厂方法（FactoryMethod）下，并将有关的程序从客户端删除，同时降低了客户端与“角色产生过程”的耦合度（或称为依赖度）。此外，角色生成后的后续设置功能（给武器、设置属性、设置AI等），也都在同一个地方实现，让开发人员能快速了解类之间的关联性及设置的先后顺序。 话虽如此，但这两个工厂方法对于对象产生之后的相关功能设置，其实还有改进的空间。这一部分的重构，将在下一个章中进行说明。 工厂方法模式的实现说明在上一小节中，我们将角色的产生运用了工厂方法模式来产生对象，事实上，在《P级阵地》中还有一些实现方面的考虑与延伸应用，简述如下。 使用泛型方法Generic Method来实现 在本章第2节曾提及，可使用泛型程序设计中的“泛型方法（Generic Method）”来减少使用switch case语句。如果要在《P级阵地》中使用泛型方法来实现厂方法模式，可能会增加其他系统在调用泛型方法时的负担。 因为调用泛型方法的系统，必须知道可以传入泛型方法的T类是哪一个，但知道越多的T类，对于系统的独立性就越不利。所以，权衡之下， 《P级阵地》还是使用了switch case语句，让调用的系统只需要知道枚举类型（ENUM_Soldier, ENUM_Enemy），以减少耦合度（即依赖度）。 不过，笔者还是将以泛型方法实现的角色工厂列出，供读者引用。而这些程序代码在实际游戏运行中，是不会被执行的： Listing 15 产生游戏角色工厂接口（Generic Method）（TCharacterFactory.cs ） 12 其他的工厂 在《P级阵地》中采用“将类对象的产生，都以一个工厂类来实现”这种概念来实现的，不只角色工厂一个。以下是《P级阵地》中的各种工厂： IAssetFactory：资源加载工厂，负责将放置在文件目录下的Unity3D资源Asset实例化的工厂，这些资源包含3D模型、2D图文件、音效音乐文件等。因为Unity3D在Asset加载时有些策略和步骤是具有选择性或可进行优化，并且也能减少客户端直接获取Unity3D资源的依赖度，所以在《P级阵地》中，会将资源实例化的工作交给IAssetFactory工厂来实现。 IWeaponFactory：武器工厂，负责产生角色单位使用的武器。虽然当前在游戏的设置上只有3种武器，但产生过程也需要多个步骤才能完成，所以也集中在一个工厂中实现。 IAttrFactory：属性产生工厂，双方角色都必须使用属性来代表能力（生命力、移动速度）。而这些属性组合在游戏设计过程中，是需要被量化和能事先计算设计的，所以“属性”往往以一组一组的方式被记录和初始化，并以指定编号的方式将特定的属性指定给角色。IAttrFactory属性产生工厂，即是通过指定编号的方式产生属性组合，其中也包舍了可以优化的操作，这部分将在“第16章游戏属性管理功能”中进行说明。 工厂类对象的管理 在《P级阵地》中存在4个工厂，而这些工厂都是“接口类”，所以一定会在项目的某个地方进行“产生对象new”的操作，让这些工厂能通过对象进行运行。因为资源优化的需求，也希望整个项目中的每个工厂类都只产生一个对象，所以《P级阵地》特别设计了一个“静态类”PBDFactory来管理这些工厂： Listing 17 获取PBaseDefenseGame中所使用的工厂（PBDFactory.cs） 1public static class PBDFactory 因为PBDFactory是使用“静态类”设计的，所以它的类成员也是以“静态成员”的方式来声明。当调用该类的方法获取对应的工厂时，PBDFactory类可以确保静态成员只会被产生一次，而且返回的是各工厂的“接口”，正好呼应“第5章获取游戏服务的唯一对象”中所描述的需求——可以使用静态类的静态方法来获取某个类的唯一对象，而不必使用单例模式来完成。 游戏程序代码中的客户端获取工厂之后，可用下列方式来获得所需要的类对象： Listing 18 执行训练Soldier（TrainSoldierExecute.cs） 12 工厂方法模式面对变化时当把对象的产生交给各类工厂负责之后，对于项目后期的变更要求来说，修改会更有效率，例如：针对某一个工厂方法想要新增一个参数设置时，虽然这个变更的修改会改变接口规则，必须同时修改所有客户端，但对于修改的程度和影响范围而言，仍比较容易预估。因为使用程序的集成开发环境工具（IDE）的“查找被引用”功能，能快速找出所有方法被使用的地方，所以当发现修改的范围过大时，就能对于修改的方式做出其他决定，甚至是变更需求。另外，当想要变更对象的产生流程及功能组装的规则时，也只需要修改工厂方法内的实现程序代码，将修改范围局限在一个地方即可。 当工厂是以“接口”的形式存在时，代表有机会更换不同的“实现工厂类”来满足不同的设计需求，如《P级阵地》中的IAssetFactory资源加载工厂，负责Unity3D的资源加载。对于一个Unity3D资源而言，它可以存在于不同的物理位置中，例如： 项目的Resource目录下。 可以使用目录符号C:\xxx\xxx获取的文件资源，包含本地计算机目录和局域网中的计算机目录。 使用UnityEngine.WWW类获取放在网页服务器（Web Server）上的AssetBundle资源。 为了应用不同的资源获取方式，《P级阵地》中的IAssetFactory资源加载工厂有3个子类，分别负责不同资源的获取方式，如图5所示。 图5 IAssetFactory类及其3个子类的类结构图 ResourceAssetFactor：从项目的Resource中，将Unity3D Asset实例化成GameObject。 LocalAssetFactory：从本地（存储设备）中，将Unity3D Asset实例化成GameObject。 RemoteAssetFactory：从远程（网络WebServer）中，将Unity3D Asset实例化成GameObject。 IAssetFactory资源加载工厂的实现如下： Listing 19 获取将Unity Asset实例化的工厂 12 由上述的程序代码可知，在获取工厂时，可因项目的需求返回不同的工厂，这有助于面对未来的变化。 结论工厂方法模式的优点是，将类群组对象的产生流程整合于同一个类下实现，并提供唯一的工厂方法，让项目内的“对象产生流程”更加独立。不过，当类群组过多时，无论使用哪种方式，都会出现工厂子类爆量或switch case语句过长的问题，这是美中不足的地方。 与其他模式（Pattern）的合作 角色工厂（CharacterFactory）中，产生不同阵营的角色时，会搭配建造者模式（Builder）的需求，将需要的参数设置给各角色的建造者。 本地资源加载工厂（ResourceAssetFactor）若同时要求系统性能的优化，可使用代理者模式（Proxy）来优化加载性能。 属性产生工厂（AttrFactory）可使用享元模式（Flyweight）来减少重复对象的产生。 其他应用方式。 就如同本章的重点，如果系统实现人员想要将对象的产生及相关的初始化工作集中在一个地方完成，那么都可以使用工厂方法模式来完成，换句话来说，就是工厂方法模式的应用层面非常广泛。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式与游戏完美开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的Join]]></title>
    <url>%2F2019%2F08%2F14%2FMySQL%E7%9A%84Join%2F</url>
    <content type="text"><![CDATA[select a.*,b.class_name from student as a left join class as b on a.class_id = b.id; 查出来的表就是临时表。因为MySQL中不存在这个表，只是查询结果集。 关键字 on 数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。 在使用 left jion 时，on 和 where 条件的区别如下： 1、on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。2、where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。 Left Join和Right Join的主要用途是把a表中的id替换为字符串。无论什么情况，a表都会返回所有数据。如果b表中不存在此id，临时表的class_name字段为空。 where条件无论是使用哪一个表的，都是对临时表进行的。而临时表是绝对会有那个where字段的，因为没有的话通不过sql语法检查，直接报错。 假设有两张表： 表1：tab2 id size1 102 203 30表2：tab2 size name10 AAA20 BBB20 CCC两条 SQL: select * form tab1 left join tab2 on (tab1.size = tab2.size) where tab2.name=’AAA’ select * form tab1 left join tab2 on (tab1.size = tab2.size and tab2.name=’AAA’) 第一条SQL的过程： 1、中间表on条件:tab1.size = tab2.sizetab1.id tab1.size tab2.size tab2.name1 10 10 AAA2 20 20 BBB2 20 20 CCC3 30 (null) (null) 2、再对中间表过滤where 条件：tab2.name=’AAA’tab1.id tab1.size tab2.size tab2.name1 10 10 AAA 第二条SQL的过程： 1、中间表on条件:tab1.size = tab2.size and tab2.name=’AAA’(条件不为真也会返回左表中的记录)tab1.id tab1.size tab2.size tab2.name1 10 10 AAA2 20 (null) (null)3 30 (null) (null) Inner Joinstudent表的class_id是100，但是class表中没有这个班级，inner join的时候凡是class_id为100的学生都不会出现。 Full Joinb表有个班id是10，class_name是10，学生表a表里没有学生是这个班的。 Full Join后，有一条记录是a的所有字段都是空，然后b的where字段class_name是10。当然此行毫无意义。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏内各系统的整合--中介者模式]]></title>
    <url>%2F2019%2F08%2F13%2F%E6%B8%B8%E6%88%8F%E5%86%85%E5%90%84%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B4%E5%90%88-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 游戏系统之间的沟通 中介者模式 中介者模式的定义 中介者模式的说明 中介者模式的实现范例 中介者模式作为系统之间的沟通接口 使用中介者模式的系统架构 实现说明 使用中介者模式的优点 实现中介者模式时的注意事 中介者模式面对变化时 结论 游戏系统之间的沟通在游戏主要类--外观模式曾提到过，《P级阵地》将整个游戏需要执行的系统切分成好几个，包含的游戏系统如下： 游戏事件系统（GameEventSystem）； 兵营系统（CampSystem）； 关卡系统（StageSystem）； 角色管理系统（CharacterSystem）； 行动力系统（APSystem）； 成就系统（AchievementSystem）。 另外，还有之前没提到过的，用来与玩家互动的界面： 兵营界面（CampInfoUI）； 战士信息界面（SoldierlnfoUI）； 游戏状态界面（GameStateInfoUI）； 游戏暂停界面（GamePauseUI）。 回顾单一职责原则（SRP）强调的是，将系统功能细分、封装，让每一个类都能各司其职，负责系统中的某一项功能。因此，一个分析设计良好的软件或游戏，都是由一群子功能或子系统一起组合起来运行的。 整个游戏系统在面对客户端时，可以使用第4章提到的外观模式（Facade）整合出一个高级界面供客户端使用，减少它们接触游戏系统的运行，并加强安全性及减少耦合度。但对于内部子系统之间的沟通，又该如何处理呢？ 在《P级阵地》规划的游戏系统中，有些系统在运行时，需要其他系统的协助或将信息传递给其他系统。例如，玩家想要产生战士：①兵营界面（CampInfoUI）接收到玩家的指令后，②向兵营系统（CampSystem）发出要训练一名战士的需求。③兵营系统（CampSystem）接收到通知后，向行动力系统（APSystem）询问是否有足够的行动力可以生产。④行动力系统（APSystem）回复有足够的行动力后，⑤兵营系统（CampSystem）便执行产生战士的功能，⑥然后通知行动力系统（APSystem）扣除行动力，⑦接着通知游戏状态界面（GameStateInfoUI）显示当前的行动力。⑧最后则是将产生的战士交给角色管理系统（CharacterSystem）来管理。 上述的8个流程中，一共有3个游戏系统及2个玩家界面参与其中运行，如图1所示。 图1 游戏运行流程中游戏系统参与运行的示例图 因为项目一开始时，各系统是慢慢构建起来的，所以可能会实现下列程序代码： Listing 1 内部系统交错使用的情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// 兵营界面public class CampInfoUI&#123; CampSystem m_CampSystem; // 兵营系统 // 训练战士 public void TrainSoldier(int SoldierID) &#123; m_CampSystem.TrainSoldier(SoldierID); &#125;&#125;// 兵营系统public class CampSystem&#123; APSystem m_APSystem; // 行动力系统 CharacterSystem m_CharacterSystem; // 角色管理系统 // 训练战士 public void TrainSoldier(int SoldierID) &#123; //向行动力系统（APSystem）询问是否有足够的行动力可以生产 if(m_APSystem.CheckTrainSoldier(SoldierID) == false) return; // 行动力系统（APSystem）回复有足够的行动力之后，兵营系统（CampSystem）便执行产生战士功能 ISoldier NewSoldier = CreateSoldier(SoldierID); if (NewSoldier == null) return; // 再通知行动力系统（APSystem）扣除行动力 m_APSystem.DescAP(10); // 最后将产生的战士交由角色管理系统（CharacterSystem）管理 m_CharacterSystem.AddSoldier(NewSoldier); &#125; // 执行训练战士 private ISoldier CreateSoldier(int SoldierID) &#123; ... &#125;&#125;// 行动力系统public class APSystem&#123; GameStateInfoUI m_StateInfoUI; // 游戏状态界面 int m_AP; // 是否可以训练战士 public bool CheckTrainSoldier(int SoldierID) &#123; return true; &#125; // 扣除AP public void DescAP(int Value) &#123; m_AP -= Value; m_StateInfoUI.UpdateUI(); &#125; // 获取AP public int GetAP() &#123; return m_AP; &#125;&#125;// 游戏状态界面public class GameStateInfoUI&#123; APSystem m_ApSystem; // 行动力系统 // 更新界面 public void UpdateUI() &#123; int NowAP = m_ApSystem.GetAP(); &#125;&#125;// 角色管理系统public class CharacterSystem&#123; // 加入战士 public void AddSoldier(ISoldier NewSoldier) &#123; ... &#125;&#125; 从上面的程序代码可以看出，所有系统在实现上都必须引用其他系统的对象，而这些被引用的对象都必须在功能执行前设置好，或者在调用方法时通过参数传入。但这些方式都会增加系统之间的依赖程度，也与最少知识原则（LKP）有所抵触。 上面的流程只呈现了《P级阵地》众多功能中的一个。如果将各个功能执行时所需要连接的系统，都绘制成关联图的话，最后可能如图2所示。如果我们运用计算多边形各个顶点连线条数（或者连接数）的公式，应该能获知系统间的复杂度是多少。 系统切分越细，则意味着系统之间的沟通越复杂，如果系统内部持续存在这样的连接，就会产生以下缺点： 单一系统引入太多其他系统的功能，不利于单一系统的转换和维护； 单一系统被过多的系统所依赖，不利于接口的更改，容易牵一发而动全身； 因为需提供给其他系统操作，系统的接口可能会过于庞大，不容易维护。 要解决上述问题，可以使用中介者模式的设计方式。 图2 各个系统设计时依赖性或关联性过大的极端情况 中介者模式（Mediator）简单解释的话，比较类似于中央管理的概念。建立一个信息集中的中心，任何子系统要与它的子系统沟通时，都必须先将请求交给中央单位，再由中央单位分派给对应的子系统。这种交给中央单位统一分配的方式，在物流业中已证明是最有效率的方式，如图3所示。 图3 物流业的货物流动示意图 同样地，《P级阵地》的子系统也希望在运用中介者模式后，能够由统一的接口来进行接收和转发信息，如图4所示。 图4 《P级阵地》运用中介者模式后系统间关联性的示意图 中介者模式刚开始学习中介者模式时，会觉得为什么要如此麻烦，让两个功能直接调用就好了。但随着经验的累积，接触过许多项目，并且想要跨项目转换某个功能时就会知道，减少类之间的耦合度是一项很重要的设计原则。中介者模式在内部系统的整合上，扮演着重要的角色。 中介者模式的定义中介者模式在GoF中的说明是： 1定义一个接口用来封装一群对象的互动行为。中介者通过移除对象之间的引用，来减少它们之间的耦合度，并且能改变它们之间的互动独立性。 以运输业的运营方式来说明中介者模式，可以解释为： 1设置一个物品集货中心，让所有收货点的物品都必须先集中到集货中心后，再分配出去，各集货点之间不必知道其他集货点的位置，省去各自在货物运送上的浪费。 以一个拥有上百个集货点的货运行来说，各集货点不必自行运送到其他点，统一送到中央集货中心（或物流中心）后再分送出去，才是比较有效率的方式。 中介者模式的说明中介者模式的结构如图5所示。 图5 中介者模式的结构示意图 参与者的说明如下： Colleague（同事接口） 拥有一个Mediator属性成员，可以通过它来调用中介者的功能。 ConcreteColleagueX（同事接口实现类） 实现Colleague界面的类，对于单一实现类而言，只会依赖一个Mediator接口。 Mediator（中介者接口）、ConcreteMediator（中介者接口实现类） 由Mediator定义让Colleague类操作的接口。 ConcreteMediator实现类中包含所有ConcreteColleague的对象引用。 ConcreteMediator类之间的互动会在ConcreteMediator中发生。 中介者模式的实现范例在GoF范例程序中，Colleague（同事接口）如下： Listing 2 Mediator所控管的Colleague（Mediator.cs） 123456789101112public abstract class Colleague&#123; protected Mediator m_Mediator = null; // 通过Mediator对外沟通 public Colleague( Mediator theMediator) &#123; m_Mediator = theMediator; &#125; // Mediator通知请求 public abstract void Request(string Message);&#125; Colleague为抽象类，拥有一个类型为Mediator的属性成员m_Mediator，用来指向中介者，而这个中介者会在建造者中被指定。 ConcreateColleague1、ConcreateColleague2继承了Colleague类，并重新定义父类中的抽象方法： Listing 3 实现各Colleague类（Mediator.cs） 123456789101112131415161718192021222324252627282930313233343536373839// 实现Colleague的类1public class ConcreateColleague1 : Colleague&#123; public ConcreateColleague1( Mediator theMediator) : base(theMediator) &#123;&#125; // 执行动作 public void Action() &#123; // 执行后需要通知其它Colleague m_Mediator.SendMessage(this,"Colleague1发出通知"); &#125; // Mediator通知請求 public override void Request(string Message) &#123; Debug.Log("ConcreateColleague1.Request:"+Message); &#125;&#125; // 实现Colleague的类2public class ConcreateColleague2 : Colleague&#123; public ConcreateColleague2( Mediator theMediator) : base(theMediator) &#123;&#125; // 执行动作 public void Action() &#123; // 执行后需要通知其它Colleague m_Mediator.SendMessage(this,"Colleague2发出通知"); &#125; // Mediator通知请求 public override void Request(string Message) &#123; Debug.Log("ConcreateColleague2.Request:"+Message); &#125;&#125; 每一个继承自Colleague的ConcreteColleagueX类，需要对外界沟通时，都会通过m_Mediator来传递信息。而来自Mediator的请求也会通过父类的抽象方法Request()来进行通知。 以下是Mediator的接口： Listing 4 用来管理Colleague对象的接口（Mediator.cs） 1234public abstract class Mediator&#123; public abstract void SendMessage(Colleague theColleague,string Message);&#125; Mediator定义了一个抽象方法SendMessage()，主要用于从外界传递信息给Colleague。 最后实现ConcreteMediator类，该类拥有所有“要在内部进行沟通的Colleague子类的引用”： Listing 5 实现Mediator接口，并集合管理Colleague对象（Mediator.cs） 123456789101112131415161718192021222324252627public class ConcreteMediator : Mediator&#123; ConcreateColleague1 m_Colleague1 = null; ConcreateColleague2 m_Colleague2 = null; public void SetColleague1( ConcreateColleague1 theColleague ) &#123; m_Colleague1 = theColleague; &#125; public void SetColleague2( ConcreateColleague2 theColleague ) &#123; m_Colleague2 = theColleague; &#125; // 收到来自Colleague的通知请求 public override void SendMessage(Colleague theColleague,string Message) &#123; // 收到Colleague1通知Colleague2 if( m_Colleague1 == theColleague) m_Colleague2.Request( Message); // 收到Colleague2通知Colleague1 if( m_Colleague2 == theColleague) m_Colleague1.Request( Message); &#125;&#125; 因为测试程序只实现两个子类，所以在SendMessage中只是进行简单地判断，然后就转发给另一个Colleague。但在实际应用时，Colleague类会有许多个，必须使用别的转发方式才能提升效率，在后面的章节中会有相关的说明。以下是测试程序： Listing 6 中介者模式的测试（MediatorTest.cs） 1234567891011121314151617void UnitTest () &#123; // 产生中介者 ConcreteMediator pMediator = new ConcreteMediator(); // 产生两个Colleague ConcreateColleague1 pColleague1 = new ConcreateColleague1(pMediator); ConcreateColleague2 pColleague2 = new ConcreateColleague2(pMediator); // 设置给中介者 pMediator.SetColleague1( pColleague1 ); pMediator.SetColleague2( pColleague2 ); // 执行 pColleague1.Action(); pColleague2.Action(); &#125; 先产生中介者ConcreteMediator的对象之后，接着产生两个Colleague对象，并将其设置给中介者。分别调用两个Colleague对象的Action方法，查看信息是否通过Mediator传递给另一个Colleague类： 执行结果 中介者模式的测试执行结果 12ConcreateColleague2.Request:Colleague1发出通知ConcreateColleague1.Request:Colleague2发出通知 Console窗口上会显示两个Colleague类发出的信息，表示都已正确地接收了另一个类传送过来的信息。 中介者模式作为系统之间的沟通接口在游戏主要类--外观模式的介绍中，说明了如何将PBaseDefenseGame类运用外观模式让游戏系统整合在单一界面之下，“对外”作为对客户端的操作界面时使用。而在本章中，则是将PBaseDefenseGame类运用中介者模式让其“对内”也成为游戏系统之间的沟通接口。 使用中介者模式的系统架构经过重新分析设计之后，PBaseDefenseGame类的中介者模式将串接《P级阵地》中的两个主要的类群组：“游戏系统”与“玩家界面”，如图6所示。 图6 PBaseDefenseGame类的中介者模式，串接《P级阵地》中的两个主要的类群组：“游戏系统”与“玩家界面”。 参与者的说明如下： PBaseDefenseGame：担任中介者角色，定义相关的操作界面给所有游戏系统与玩家界面来使用，并包含这些游戏系统和玩家界面的对象，同时负责相关的初始化流程。 IGameSystem：游戏系统的共同父类，包含一个指向PBaseDefenseGame对象的类成员，在其下的子类都能通过这个成员向PBaseDefenseGame发出需求。 GameEventSystem、CampSystem、…：负责游戏内的系统实现，这些系统之间不会互相引用及操作，必须通过PBaseDefenseGame来完成。 IUserInterface：玩家界面的共同父类，包含一个指向PBaseDefenseGame对象的类成员，在其下的子类都能通过这个成员向PBaseDefenseGame发出需求。 SoldierInfoUI，CampInfoUI、…：负责各玩家界面的实现，这些玩家界面与游戏系统之间不会互相引用及操作，必须通过PBaseDefenseGame来完成。 实现说明以下是PBaseDefenseGame类在实现中介者模式后的程序代码： 123456789101112131415161718192021222324252627282930313233343536373839404142public class PBaseDefenseGame&#123; // 游戏系统 private GameEventSystem m_GameEventSystem = null; // 游戏事件系统 private CampSystem m_CampSystem = null; // 兵营系统 private StageSystem m_StageSystem = null;// 关卡系统 private CharacterSystem m_CharacterSystem = null; // 角色管理系统 private APSystem m_ApSystem = null; // 行动力系统 private AchievementSystem m_AchievementSystem = null; // 成就系统 // 界面 private CampInfoUI m_CampInfoUI = null; // 兵营界面 private SoldierInfoUI m_SoldierInfoUI = null; // 战士信息界面 private GameStateInfoUI m_GameStateInfoUI = null; // 游戏状态界面 private GamePauseUI m_GamePauseUI = null; // 游戏暂停界面 // 初始化P-BaseDefense游戏的相关设置 public void Initinal() &#123; // 场景状态控制 m_bGameOver = false; // 游戏系统 m_GameEventSystem = new GameEventSystem(this); // 游戏事件系统 m_CampSystem = new CampSystem(this); // 兵营系统 m_StageSystem = new StageSystem(this); // 关卡系统 m_CharacterSystem = new CharacterSystem(this); // 角色管理系统 m_ApSystem = new APSystem(this); // 行动力系统 m_AchievementSystem = new AchievementSystem(this); // 成就系统 // 界面 m_CampInfoUI = new CampInfoUI(this);// 兵营信息 m_SoldierInfoUI = new SoldierInfoUI(this); // Soldier信息 m_GameStateInfoUI = new GameStateInfoUI(this); // 游戏数据 m_GamePauseUI = new GamePauseUI (this); // 游戏暂停 // 注入到其它系统 EnemyAI.SetStageSystem( m_StageSystem ); ... &#125; ...&#125; 类内包含所有游戏系统及玩家界面等对象，并负责它们的产生和初始化，另外也提供了游戏系统之间相互沟通时的方法： 123456789101112131415161718192021222324252627282930313233343536...// 升级Soldierpublic void UpgradeSoldier( ISoldier theSoldier)&#123; if(m_CharacterSystem != null) m_CharacterSystem.UpgradeSoldier( theSoldier );&#125;// 增加Soldierpublic void AddSoldier( ISoldier theSoldier)&#123; if( m_CharacterSystem !=null) m_CharacterSystem.AddSoldier( theSoldier );&#125;// 删除Soldierpublic void RemoveSoldier( ISoldier theSoldier)&#123; if( m_CharacterSystem !=null) m_CharacterSystem.RemoveSoldier( theSoldier );&#125;// 增加Enemypublic void AddEnemy( IEnemy theEnemy)&#123; if( m_CharacterSystem !=null) m_CharacterSystem.AddEnemy( theEnemy );&#125;// 删除Enemypublic void RemoveEnemy( IEnemy theEnemy)&#123; if( m_CharacterSystem !=null) m_CharacterSystem.RemoveEnemy( theEnemy );&#125;... 上面几个是游戏玩家单位Soldier和敌方单位Enemy相关操作的方法。从实现中可以看到，这几个方法主要是转发给角色管理系统（CharacterSystem）做后续的处理，而这些方法都可以由其他游戏系统或玩家界面调用。 在操作游戏系统或玩家界面时，可以同时转发给不止一个的系统或界面。为了满足游戏设计的需求，可以同时通知不同的子系统和玩家界面： 12345678910111213// 显示兵营信息public void ShowCampInfo( ICamp Camp )&#123; m_CampInfoUI.ShowInfo( Camp ); m_SoldierInfoUI.Hide();&#125;// 显示Soldier信息public void ShowSoldierInfo( ISoldier Soldier )&#123; m_SoldierInfoUI.ShowInfo( Soldier ); m_CampInfoUI.Hide();&#125; 为了能够更灵活地处理游戏系统之间的沟通，《P级阵地》也实现了观察者模式（Observer），游戏事件系统（GameEventSystem）即观察者模式的类。通过它能减少在PBaseDefenseGame中增加接口方法，并且让信息的通知更有效率。而它的相关操作也是通过PBaseDefenseGame提供的方法来完成的： 123456789101112// PBaseDefenseGame.cs// 注册游戏事件public void RegisterGameEvent( ENUM_GameEvent emGameEvent, IGameEventObserver Observer)&#123; m_GameEventSystem.RegisterObserver( emGameEvent , Observer );&#125;// 通知游戏事件public void NotifyGameEvent( ENUM_GameEvent emGameEvent, System.Object Param )&#123; m_GameEventSystem.NotifySubject( emGameEvent, Param);&#125; IGameSystem类和IUserInterface类，分别作为“游戏系统类”和“玩家界面类”的共同接口： Listing 7 游戏系统共享接口（IGameSystem.cs） 12345678910111213public abstract class IGameSystem&#123; protected PBaseDefenseGame m_PBDGame = null; public IGameSystem( PBaseDefenseGame PBDGame ) &#123; m_PBDGame = PBDGame; &#125; public virtual void Initialize()&#123;&#125; public virtual void Release()&#123;&#125; public virtual void Update()&#123;&#125;&#125; Listing 8 玩家界面的操作接口定义（IUserInterface.cs） 123456789101112131415161718192021222324252627282930313233// 游戏使用者界面public abstract class IUserInterface&#123; protected PBaseDefenseGame m_PBDGame = null; protected GameObject m_RootUI = null; private bool m_bActive = true; public IUserInterface( PBaseDefenseGame PBDGame ) &#123; m_PBDGame = PBDGame; &#125; public bool IsVisible() &#123; return m_bActive; &#125; public virtual void Show() &#123; m_RootUI.SetActive(true); m_bActive = true; &#125; public virtual void Hide() &#123; m_RootUI.SetActive(false); m_bActive = false; &#125; public virtual void Initialize()&#123;&#125; public virtual void Release()&#123;&#125; public virtual void Update()&#123;&#125;&#125; 在这两个类中，都包含一个指向PBaseDefenseGame对象的类成员m_PBDGame，在各个子类对象产生的同时就必须完成设置。这两个类也都定义了提供客户端使用的方法，部分方法必须由子类继承后重新定义。 下面是继承自IGameSystem类的关卡控制系统（StageSystem）: Listing 9 关卡控制系统的实现（StageSystem.cs） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class StageSystem : IGameSystem&#123; ... public StageSystem(PBaseDefenseGame PBDGame):base(PBDGame) &#123; Initialize(); &#125; public override void Initialize() &#123; ... // 注册游戏事件 m_PBDGame.RegisterGameEvent( ENUM_GameEvent.EnemyKilled, new EnemyKilledObserverStageScore(this)); &#125; // 更新 public override void Update() &#123; // 更新当前的关卡 m_NowStageHandler.Update(); // 是否要切换下一个关卡 if(m_PBDGame.GetEnemyCount() == 0 ) &#123; // 取得下一关 IStageHandler NewStageData = m_NowStageHandler.CheckStage(); // 是否为新的关卡 if( m_NowStageHandler != NewStageData) &#123; m_NowStageHandler.Reset(); // 通知进入下一关 NotiyfNewStage(); &#125; &#125; &#125; // 通知新的关卡 private void NotiyfNewStage() &#123; m_PBDGame.ShowGameMsg("新的关卡"); m_NowStageLv++; // 显示 m_PBDGame.ShowNowStageLv(m_NowStageLv); // 事件 m_PBDGame.NotifyGameEvent( ENUM_GameEvent.NewStage , m_NowStageLv ); &#125; // 通知损失 public void LoseHeart() &#123; m_NowHeart -= m_NowStageHandler.LoseHeart(); m_PBDGame.ShowHeart( m_NowHeart ); &#125; ...&#125; 在关卡系统初始化的过程中（在Initialize方法中），通过在父类中指向PBaseDefenseGame的属性成员m_PBDGame，来调用游戏事件注册功能： 123456public override void Initialize()&#123; ... // 注册游戏事件 m_PBDGame.RegisterGameEvent( ENUM_GameEvent.EnemyKilled, new EnemyKilledObserverStageScore(this)); &#125; 关卡系统在《P级阵地》中是负责战斗场景关卡的更新功能。所以，在每次关卡系统“定时更新”时，会判断是否需要产生新的关卡。除了通过m_PBDGame获取当前敌方单位的数量外，当系统决定要转换到下一个关卡时（在Notify NewStage方法中），也会利用m_PBDGame来通知当前关卡已经更新，并通知其他相关的系统。 每个游戏系统都有一个定期更新的方法，Update可以重新定义。这个机制是在《P级阵地》中特别设计的，主要是提供“单一的游戏系统”更新使用。其中一部分的说明，我们将在第7章中进行介绍。 类似地，在玩家界面中，游戏状态信息（GameStateInfoUI）负责游戏相关信息的呈现： 123456789101112131415161718192021222324252627282930// GameStateInfoUI.cs// 游戏状态信息public class GameStateInfoUI : IUserInterface&#123; public override void Update () &#123; base.Update (); ... // 双方数量 m_SoldierCountText.text = string.Format("我方单位数:&#123;0&#125;", m_UnitCountVisitor.GetUnitCount( ENUM_Soldier.Null )); m_EnemyCountText.text = string.Format("敌方单位数:&#123;0&#125;", m_UnitCountVisitor.GetUnitCount( ENUM_Enemy.Null )); &#125; ... // Continue private void OnContinueBtnClick() &#123; Time.timeScale = 1; // 换回开始State m_PBDGame.ChangeToMainMenu(); &#125; // Pause private void OnPauseBtnClick() &#123; // 显示暂停 m_PBDGame.GamePause(); &#125; ...&#125; 运行上也是通过父类的属性成员m_PBDGame向PBaseDefenseGame类获取游戏相关信息或发出转换接口的请求。除此之外，并没有直接与其他游戏系统或玩家界面类相关的互动。 使用中介者模式的优点在本章中，将PBaseDefenseGame类运用中介者模式，具备以下优点： 不会引入太多其他的系统 从上面《P级阵地》的实现来看，每一个游戏系统和玩家界面除了会引用与本身功能相关的类外，无论是对外的信息获取还是信息的传递，都只通过PBaseDefenseGame类对象来完成。这使得每一个游戏系统、玩家界面对外的依赖度缩小到只有一个类（PBaseDefenseGame）。 系统被依赖的程度也降低 每一个游戏系统或玩家界面，也只在PBaseDefenseGame类的方法中被调用。所以，当游戏系统或玩家界面有所更动时，受影响的也仅仅局限于PBaseDefenseGame类，因此可以减少系统维护的难度。 实现中介者模式时的注意事项由于PBaseDefenseGame类担任中介者的角色，再加上各个游戏系统和玩家界面都必须通过它来进行信息交换及沟通，所以要注意的是，PBaseDefenseGame类会因为担任过多中介者的角色而容易出现“操作接口爆炸”的情况。因此，在实现上，我们可以搭配其他设计模式来避免发生这种情况。在前面的说明中，我们提及的游戏事件系统（GameEventSystem），其作用就是用来提供更好的信息传递方式，以减轻PBaseDefenseGame类的负担。 在GoF的实现结构图上，存在一个中介者接口类，但PBaseDefenseGame类却没有继承任何一个中介者接口，这是为什么呢？请读者回顾第5章中所提到的：为了呈现单例模式（Singleton）在《P级阵地》中的使用情形，将PBaseDefenseGame类运用单例模式，而单例模式的特性之一是“返回实现类”，因此PBaseDefenseGame没有继承任何接口类。不过，如果能删除单例模式的应用，将PBaseDefenseGame转化成一个接口类，那么对于所有的游戏系统和玩家界面而言，它们所依赖的将是“接口”而不是“实现”，这样会更符合开一闭原则（OCP），从而提高游戏系统和玩家界面的可移植性。 中介者模式面对变化时任何软件系统都会面临需求的变化，采用中介者模式设计的软件同样会面对这些变化。在本节中，我们将探讨中介者模式如何面对变化，以及如何面对更常见的“新增子类”这种变化。 如何应对变化 当游戏系统或玩家界面需要新增功能，且该功能需要由外界提供信息才能完成时，可以先在PBaseDefenseGame类中增加获取信息的方法，之后再通过PBaseDefenseGame类来获取信息完成新的功能。这样一来，项目的修改可以保持在两个类或最多3个类的更改，而不会影响任何类的“依赖性”。 如何面对新增 当需要新增加游戏系统或玩家界面时，只要是继承自IGameSystem或IUserInterface的游戏系统和玩家界面，都可以直接加入PBaseDefenseGame的类成员中，并通过现有的接口进行实现或增加功能。这时候项目更改的幅度，可能只是新增一个程序文件和修改一个PBaseDefenseGame类而己，不太容易影响到其他系统或接口。 结论中介者模式的优点是能让系统之间的耦合度降低，提升系统的可维护性。但身为模式中的中介者角色类，也会存在着接口过大的风险，此时必须再配合其他模式来进行优化。 与其他模式（Pattern）的合作 PBaseDefenseGame类在《P级阵地》中，除了是中介者模式中的中介者之外，也是外观模式中对外系统整合接口的主要类，并且还运用单例模式来产生唯一的类对象。 此外，为了降低PBaseDefenseGame类有接口过大的问题，其子系统“游戏事件系统”（GameEventSystem）专门运用观察者模式来解决游戏系统之间，对于信息的产生和通知的需求，减少这些信息和通知的方法充满在PBaseDefenseGame类之中。 在进行分析设计时，集合多种设计模式是良好设计常见的方式，如何将所学设计模式融合并适当地运用，才是设计模式之道。 其他应用方式 网络引擎：连线管理系统与网络数据封包管理系统之间，如果可以通过中介者模式进行沟通，那么就能轻松地针对连线管理系统抽换所使用的通信方式（TCP或UDP）。 数据库引擎：内部可以分成数个子系统，有专门负责数据库连接的功能与产生数据库操作语句的功能，两个子功能之间的沟通可以通过中介者模式来进行，让两者之间不相互依赖，方便抽换另一个子系统。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式与游戏完美开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity通用场景管理器]]></title>
    <url>%2F2019%2F08%2F13%2FUnity%E9%80%9A%E7%94%A8%E5%9C%BA%E6%99%AF%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[笔者开发的Unity通用场景管理器，实现了异步场景切换、加载界面进度条显示、退回上一个场景功能 前言场景切换是每一个游戏都会遇到的功能需求，当需要加载的场景较大时，同步加载会造成界面卡住很久再进入下一个场景的问题，导致很差的玩家体验。 笔者通过对网上分享的思路进行优化，完成了方便的全局场景管理器，通过异步加载场景解决卡顿问题。 基本思路Unity通过以下函数提供给开发者场景异步加载功能： 我们可以通过开启一个协程调用异步加载函数实现异步加载场景功能。以下代码展示了基础功能的实现方式： 123456789101112131415publicstring nextSceneName;private void Start() &#123; //开启协程 StartCoroutine("LoadScene");&#125;IEnumerator LoadScene() &#123; //异步加载场景 async = SceneManager.LoadSceneAsync(nextSceneName); yield return null;&#125; 实现项目中我们通过调用SceneManager完成场景管理的全部功能，以下为代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/***********************************************@file SceneManager.cs*@brief 场景管理器*@author LouisLiu*@date 2019/07/22*@note 修改说明**********************************************/using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class SceneManager : MonoBehaviour&#123; private static SceneManager m_instance; //私有单例 private Action m_onSceneLoaded = null; //场景加载完成回调 private string m_strNextSceneName = null; //将要加载的场景名 private string m_strCurSceneName = null; //当前场景名，如若没有场景，则默认返回Login private string m_strPreSceneName = null; //上一个场景名 private bool m_bLoading = false; //是否正在加载中 private bool m_bDestroyAuto = true; //自动删除loading背景 private const string m_strLoadSceneName = "LoadingScene"; //加载场景名字 private GameObject m_objLoadProgress = null; //加载进度显示对象 //获取当前场景名 public static string s_strLoadedSceneName =&gt; m_instance.m_strCurSceneName; public static void CreateInstance(GameObject go) &#123; if (null != m_instance) &#123; return; &#125; m_instance = go.AddComponent&lt;SceneManager&gt;(); DontDestroyOnLoad(m_instance); m_instance.m_strCurSceneName = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name; &#125; public static void LoadPreScene() &#123; if (string.IsNullOrEmpty(m_instance.m_strPreSceneName)) &#123; return; &#125; LoadScene(m_instance.m_strPreSceneName); &#125; public static void LoadScene(string strLevelName) &#123; m_instance.LoadLevel(strLevelName, null); &#125; public static void LoadScene(string strLevelName, Action onSecenLoaded) &#123; m_instance.LoadLevel(strLevelName, onSecenLoaded); &#125; private void LoadLevel(string strLevelName, Action onSecenLoaded, bool isDestroyAuto = true) &#123; if (m_bLoading || m_strCurSceneName == strLevelName) &#123; return; &#125; m_bLoading = true; //锁屏 //*开始加载 m_onSceneLoaded = onSecenLoaded; m_strNextSceneName = strLevelName; m_strPreSceneName = m_strCurSceneName; m_strCurSceneName = m_strLoadSceneName; m_bDestroyAuto = isDestroyAuto; //先异步加载Loading界面 StartCoroutine(StartLoadSceneOnEditor(m_strLoadSceneName, OnLoadingSceneLoaded, null)); &#125; /************************************** *@fn OnLoadingSceneLoaded *@brief 过渡场景加载完成回调 *@return void **************************************/ private void OnLoadingSceneLoaded() &#123; //过渡场景加载完成后加载下一个场景 StartCoroutine(StartLoadSceneOnEditor(m_strNextSceneName, OnNextSceneLoaded, OnNextSceneProgress)); &#125; /************************************** *@fn StartLoadSceneOnEditor *@brief 开始加载 *@param[in] string strLevelName *@param[in] Action OnSecenLoaded 场景加载完成后回调 *@param[in] Action OnSceneProgress *@return System.Collections.Generic.IEnumerator **************************************/ private IEnumerator StartLoadSceneOnEditor(string strLevelName, Action OnSecenLoaded, Action&lt;float&gt; OnSceneProgress) &#123; AsyncOperation async = UnityEngine.SceneManagement.SceneManager.LoadSceneAsync(strLevelName); if (null == async) &#123; yield break; &#125; //*加载进度 while (!async.isDone) &#123; float fProgressValue; if (async.progress &lt; 0.9f) &#123; fProgressValue = async.progress; &#125; else &#123; fProgressValue = 1.0f; &#125; OnSceneProgress?.Invoke(fProgressValue); yield return null; &#125; OnSecenLoaded?.Invoke(); &#125; /************************************** *@fn OnNextSceneLoaded *@brief 加载下一场景完成回调 *@return void **************************************/ private void OnNextSceneLoaded() &#123; m_bLoading = false; OnNextSceneProgress(1); m_strCurSceneName = m_strNextSceneName; m_strNextSceneName = null; m_onSceneLoaded?.Invoke(); &#125; /************************************** *@fn OnNextSceneProgress *@brief 场景加载进度变化 *@param[in] float fProgress *@return void **************************************/ private void OnNextSceneProgress(float fProgress) &#123; if (null == m_objLoadProgress) &#123; m_objLoadProgress = GameObject.Find("TextLoadProgress"); &#125; Text textLoadProgress = m_objLoadProgress.GetComponent&lt;Text&gt;(); if (null == textLoadProgress) &#123; return; &#125; textLoadProgress.text = (fProgress*100).ToString() + "%"; &#125;&#125; 使用1.制作Loading场景，在OnNextSceneProgress()中写入展示进度的逻辑(以上代码中，笔者用的是一个Text展示进度) 2.打开File =&gt; BuildingSettings =&gt; AddOpenScenes 把全部场景加入Scene In Build列表中，不然系统会找不到需要跳转的场景 3.在游戏第一个需要跳转的场景中调用以下函数，生成全局的场景管理器GameObject（跳转场景不会被删除）： 12345private void OnStart()&#123; GameObject objSceneManager = new GameObject("SceneManager"); SceneManager.CreateInstance(objSceneManager);&#125; 4.以后需要切换场景功能的场景直接调用以下函数进行场景的切换 1SceneManager.LoadScene("跳转目标场景名称"); 5.需要返回到上一个场景调用以下函数 1SceneManager.LoadPreScene();]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D的界面设计--组合模式]]></title>
    <url>%2F2019%2F08%2F13%2FUnity3D%E7%9A%84%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 玩家界面设计图1所示是在编辑模式中，组装战斗场景（Battle Scene）会使用到的界面。 图1 组装界面 在Hierarchy窗口中（如图2所示）可以看到，Canvas下除了一个BackGroundImage的背景图像外，还包含了4个组群，而这4个群组代表在《P级阵地》中是用来与玩家互动的4个主要的“用户界面”。 图2 加入用户界面 CampInfoUI：兵营界面，提供给玩家查看当前兵营信息和单位训练情况，以及提供升级按钮来升级兵营，如图3所示。 图3 兵营界面 SoldierInfoUI：玩家单位信息，提供玩家查看我方某个单位当前的生命力、行动力等等信息，如图4所示。 图4 玩家单位信息 GameStateInfo：游戏状态界面，用来主动向玩家提供当前的游戏状态等信息，包含当前左上角阵地被占领的状态、右上方当前的关卡提示、下面则是当前的精力值（AP）、暂停按钮以及中间的提示信息，如图5所示。 图5 游戏状态界面 GamePauseUI：游戏暂停界面，提供给玩家用来中断游戏的按钮，并提供当前游戏的记录等信息，如图6所示。 图6 游戏暂停界面 这些界面都是直接使用Unity3D的界面工具组装而成，输入完成相关的参数之后就可以使用，并与游戏系统产生互动，如图7所示。 图7 Unity3D的界面工具 这些Unity3D的2D组件的互动对象通常是，已经放置在相同场景下的游戏对象，或者是一个已经继承自MonoBehaviour脚本类内的操作方法。所以，一般会在Inspector窗口中输入要互动的游戏对象GameObject或脚本组件中的方法名称。 但是，《P级阵地》就如同“第7章游戏的主循环”中所说的，采用的是“类不继承MonoBehaviour”的开发方式，再加上场景上的角色单位都是随着游戏进行而由系统实时产生的。所以在Unity3D的编辑模式中，根本无法指定要互动的对象。 另外，游戏系统的信息在某些情况下，必须通过2D组件（Text组件）主动显示在屏幕画面上，所以系统还必须事先记录这些组件的引用（object reference），并通过这些组件引用把信息显示给玩家。所以，《P级阵地》中2D界面组件的互动方式，将采用另一种实现方式： 1在游戏运行的状态下，在程序代码中主动获取这些UI组件的GameObject后，针对每个组件希望互动的方式，再指定对应的行为。 因此，了解UI组件的组装以及如何在运行模式下正确有效地获取2D组件的引用，是实现上必须清楚了解的前提。 UI组件的组装 在设计UI界面时，通常会将整个功能界面，以一个单独文件的形式存储起来，Unity3D也可以使用相同的方式来呈现，就如图8中显示的编排方式：《P级阵地》中使用一个xxxxUI结尾的游戏对象来代表一整个完整的界面，而这个游戏对象也可以转换为Unity3D的Prefab形式，最终以一个资源形式（Asset）存储起来。 图8 UI的组装方式 我们先通过对CampInfoUI的说明，让读者了解《P级阵地》UI的设计实现方式。CampInfoUI代表兵营界面中所有可显示的组件，这些2D组件都归类在CampInfoUI之下，成为其子组件。当然，如果再复杂一点的界面，可能还会有更多“分层”的展现。开发过界面功能的程序设计师会知道，将2D组件按照功能关系按层次摆放，是比较容易了解、设计和修改的。 “分层式管理架构”一般也称为“树状结构”，是经常出现在软件实现和应用中的一种结构。而Unity3D对于游戏对象的管理，也应用了“树状结构”的概念，让游戏对象之间可以被当成子对象或设置为父对象的方式来连接两个对象。就像上面提到的UI组装安排：组件B在组件A之下，所以组件B是组件A的子对象，而组件A是组件B的父对象。 若是能先清楚了解Unity3D游戏对象在“分层管理”上的设计原理，将有助于程序人员在实现时“正确有效”地获取场景上的游戏对象。 而通过GoF对组合模式（Composite）的说明将更能了解，这个在软件业中最常被使用的“分层式/树状管理架构”，如何在组合模式下被呈现，并且提供一般化的实现解决方案。最后通过这个过程，让我们从中了解到，Unity3D是如何设计他们的游戏对象分层管理功能。 组合模式在“数据结构与算法”的课程中，“树状结构”是必须要学习的一种数据组织方式。定义好子节点与父节点的关系和顺序，再配合不同的搜索算法，让树状结构成为软件系统中不可或缺的一种设计方式。例如有名的开放源码数据库系统在索引值的建立上使用B-Tree，而Unity3D也将其应用在游戏对象的管理上。 组合模式的定义GoF对于组合模式的定义是： 1将对象以树状结构组合，用以表现部分-全体的层次关系。组合模式让客户端在操作各个对象或组合对象时是一致的。 分层式/树状架构除了常见于软件应用时，现今生活中的公司组织架构，通常也是以“分层式/树状管理架构”的方式呈现，如图9所示。 图9 基本的公司组织结构图 只要公司的公文内提到“研发部”，那么通常会连同之下的“研发一部”“研发二部”都会被一起包含进来，也就是“部分全体”概念。而后半段的说明“组合模式让客户端在操作各个对象或组合对象时是一致的”则是希望，之后相同的公文发送时，只需要更改“受文者”的对象，无论对象是整个“部门”还是“单一个人”，公文内容在解释时，并不会有太大的差异，都一体通用，这就是“让客户端在操作各个对象或组合对象时是一致的”所要表达的意思。 GoF的组合模式中说明，它使用“树状结构”来组合各个对象，所以实现时包含了“根节点”与“叶节点”的概念。而“根节点”中会包含“叶节点”的对象，所以当根节点被删除时，叶节点也会被一起删除，并且希望对于“根节点”和“叶节点”在操作方法上能够一致。这表示，这两种节点都是继承自同一个操作界面，能够对根节点调用的操作，同样能在叶节点上使用。 组合模式的说明无论是根节点还是叶节点，都是继承自同一个操作界面，其结构图如图10所示。 图10 采用组合模式的类结构示意图 GoF参与者的说明如下： Component（组件界面） 定义树状结构中，每一个节点可以使用的操作方法。 Composite（组合节点） 即根节点的概念； 会包含叶节点的对象； 会实现Component（组件界面）中与子节点操作有关的方法，如Add、Remove、GetChild等。 Leaf（叶节点） 不再包含任何子节点的最终节点； 实现Component（组件界面）中基本的行为，对于与子节点操作有关的方法可以不实现、也可提出警告或弹出异常（Exception）。 组合模式的实现范例先定义树状结构中每一个组件/节点应有的操作界面： Listing 17-1 组合体内含对象之界面（Composite.cs） 1234567891011121314151617181920212223public abstract class IComponent&#123; protected string m_Value; // 一般操作 public abstract void Operation(); // 加入节点 public virtual void Add( IComponent theComponent) &#123; Debug.LogWarning("子类没实现"); &#125; // 删除节点 public virtual void Remove( IComponent theComponent) &#123; Debug.LogWarning("子类没实现"); &#125; // 获取子节点 public virtual IComponent GetChild(int Index) &#123; Debug.LogWarning("子类没实现"); return null; &#125; &#125; 其中包含Add、Remove和GetChild3个方法，这些都是与“根节点”有关的操作，如果继承的子类包含其他组件/节点时，这3个方法就必须重新实现。由于Composite类因为包含其他子组件/节点，所以实现了上面3个方法: Lisiting 2 代表组合结构的元节点之行为（Composite.cs） 12 Composite类使用“List容器”来管理子组件，通过Add、Remove让客户端操作容器内容。而GetChild则返回List容器指定位置上的组件/节点。 Leaf是最终节点的实现，因为不包含其他组件/节点，所以仅实现了Operation一项方法： Listing 3 代表组合结构之终端对象(Composite.cs) 1234567891011public class Leaf : IComponent&#123; public Leaf(string Value) &#123; m_Value = Value; &#125; public override void Operation() &#123; Debug.Log("Leaf["+ m_Value +"]执行Operation()"); &#125;&#125; 虽然操作上使用相同的界面，但还是分为Composite和Leaf两种类，在初始化对象和操作对象上需要留意： Listing 4 测试组合模式1（CompositeTest.cs） 12 执行Root节点的Operation后，信息上会出现整个树状结构的组成方式： 执行结果 123456789Leaf[Leaf1]执行Operation()Leaf[Leaf2]执行Operation()Composite[Child1]Leaf[Child1.Leaf1]执行Operation()Leaf[Child1.Leaf2]执行Operation()Composite[Child2]Leaf[Child2.Leaf1]执行Operation()Leaf[Child2.Leaf2]执行Operation()Leaf[Child2.Leaf3]执行Operation() 如果不小心错将Leaf对象加入节点，会出现以下信息： Listing 5 测试组合模式2（CompositeTest.cs） 12 执行结果：出现警告信息 1子类没实现 分了两个子类但是要使用同一个操作界面因为设计和实现上的需要，所以将其分成Composite和Leaf两个类来应付不同的情况，但同时还要让它们有相同的操作行为，确实有点为难。 例如获取子组件/节点GetChild操作，在最终/叶节点上调用这个方法是没有意义的，其他如Add、Remove也是。至于组合模式（Composite）中要定义最终/叶节点，则是系统设计上必然产生的，因为如果某方法在子类重新实现上有差异的话，就必须定义出不同的子类来显示这个差异。但要维持两个差异很大的子类共享同一个界面，在实现上确实是个挑战。 实现一套“文件管理”工具，同样是运用组合模式（Composite）来完成该工具的实现。由于设计上的需求，必须设计以下两个类： File类，用来表示最终存放在硬盘的文件； Directory类，即目录类，用来包含其他目录及File类对象。 同样的，这两个类都继承了Node节点类，同时Node类也定义了两个子类共享的操作界面。对于搜索功能而言，文件管理工具如果返回的是Node类，则比较能符合搜索功能的定义，因为我们可能想找的是“目录”，也可能是“文件”，并不限定是哪一种。但是对于有针对性的功能，就有设计上的考虑。 在过程中，对于“针对性的功能（只对某一个类有意义）”提出了一些看法： 将针对性的功能直接定义在其中一个子类，会对客户端产生负担。因为客户端必须针对获取的Node类，利用“类判断”语句，先判断是属于哪一个子类后，再调用该类才有的操作方法。对于这一类必须判断才能执行的功能，并不直接否认这样做不好，如果这个方式能在编译时期就可以检查出严重错误，那么也可以采用这个方式来强化程序执行时的安全性。 反之，如果这个功能操作后不会产生严重的错误后果，那么将对应的方法声明在Node类中，并不是什么坏事，因为统一的界面将为整体系统带来简单性和良好的扩展性。 “设计时必须考虑到安全性（Safety）和透明性（Transparency）之间的权衡”。 当然，如果能让Node界面停止不断地扩张，就可能不必面对这些选择。所以John Vilssides在Node结构中增加了访问者模式（Visitor）的功能，让界面不会因为功能的增加而不断地扩张，同时又能满足功能增加的需求。此外，将原本客户端需要使用转型语句判断的地方，改用模板方法模式（Template）实现，来减少客户端必须写出if else或switch语句的程序代码。前提是，这样的功能对于程序执行时的安全性没有重大影响，而且模式之间也可以相互配合应用。在John Vilssides的文件管理工具范例中，将这些模式的整合表现得相当好，有兴趣的读者可以参考看看。 Unity3D游戏对象的分层式管理功能有了组合模式的概念之后，让我们回头来看看Unity3D中的游戏对象GameObject类，如何实现分层管理功能。 游戏对象的分层管理在Unity3D引擎中，每一个可以放入场景上的对象，都是一个游戏对象GameObject，Unity3D可以通过Hierarchy窗口来查看当前放在场景的GameObject，以及它们之间的层次关系。 利用程序代码操作这些关系的变化。 在程序代码实现时，要获取GameOject中的Transform组件只需要调用： 1UnityEngine.GameObject.transform 即可获取该组件。而Transform组件提供了许多可以让脚本语言操作的方法，如位置设置、旋转、缩放等。 其中，Transform组件提供了几个和游戏对象分层操作有关的方法和变量： 变量 childCound：代表子组件数量， parent：代表父组件中的Transform对象引用， 方法 DetachChildren：解除所有子组件与本身的关联 Find：寻找子组件。 GetChild：使用Index的方式取回子组件。 IsChildOf：判断某个Transform对象是否为其子组件。 SetParent：设置某个Transform对象为其父组件。 若再仔细分析，则可以将Unity3D的Transform类当成是一个通用类，因为它并不明显可以察觉出其下又被再分成“目录节点”或是单纯的“终端节点”。其实应该这样说， Transform类完全符合组合模式的需求：“让客户端在操作各个对象或组合对象时是一致的”。因此对于场景上所有的游戏对象GameObject，可以不管它们最终代表的是什么，对于所有操作都能正确反应。 正确有效地获取UI的游戏对象在了解Unity3D对于对象的分层管理方式后，让我们回到本章想要解决的问题上，也就是“如何在游戏运行的状态下，在程序代码中能够正确且有效地获取这些UI组件的GameObject，并根据每个组件期望互动的方式再指定其对应的行为”。 以下面例子为例：在兵营界面中，有一个用来显示当前兵营名称的Text组件，被命名为“CampNameText”，如图17-15所示。 在游戏运行时，它的对象引用需要被获取并且保存下来，因为当玩家单击选中某一个兵营时它会被用来显示当前的兵营名称。 那么首先要做的是，在“运行状态”下，如何在场景中寻找名称为”CampNameText”的游戏对象GameObject?而当前它被存放在Canvas-CampInfoUl下。 图17-15 显示兵营名称 为了解决这个问题， Unity3D的开发者通常会使用GameObject.Find()这个方法来表示，但会产生下列问题:性能问题: GameObject.Find()会遍历所有场景上的对象，寻找名称相符的游戏对象。如果场景上的对象不多，还可以接受;如果场景上的对象过多，而且“过度”调用GameObject.Find()的话，就很容易造成系统性能的问题。名称重复: Unity3D并不限制放在场景中的游戏对象GameObject的名称必须唯一，所以当有两个名称相同的游戏对象GameObject都在场景上时，很难预期GameObject.Find）会返回其中的哪一个，这会造成不确定性，也容易产生程序错误（Bug ）. 所以，直接使用GameObjet.Find）在“性能”与“正确性”上会存在些问题。因此，在《P级阵地》中使用的是另一种比较折中的办法: 1，先利用GameObjet.Find()寻找2D画布Canvas的游戏对象，不过实现者还是要先确保场景中只能有一个名称为Canvas的游戏对象。这可以直接在Hierarchy窗口中，用搜索的方式来确定。 2，再利用Canvas游戏对象中Transform组件的分层管理功能，去寻找其下符合名称的游戏对象。当然， Canvas下也有可能发生名称重复的问题，必须再结合“界面群组”功能，将搜索范围缩小，并且也在“搜索工具”中加入“重复名称警告”功能，让整个对象的搜索能够更加效率和正确上述这些操作都发生在“游戏用户界面（IUselnterface）”及其子类中。17.3.3 游戏用户界面的实现在《P级阵地》中，每一个主要游戏功能都属于1GameSystem的子类，这些子类负责实现《P图17-16 用户界面的类结构图 就如同游戏系统（IGameSystem）那样，对内可以通过PBaseDefenseGame类的中介者模式（Mediator）来通知其他系统或界面，对外也可以通过PBaseDefenseGame类的外观模式（Facade），让客户端存取和更新与用户界面相关的功能。 兵营界面的实现建立《P级阵地》用户界面的基本架构之后，再回到前面提到的问题:在场景对象中找到名称，为CampNameText的Text组件，并在上面显示当前用鼠标单击而选中的兵营的名称。 在运用新的用户界面架构之后，对于场景中2D组件的获取及对象的保留，都可以在“兵营界面CampInfoUl”类下实现:Listing 17-8 兵营界面（Camplnfo.cs） Listing 9 游戏中使用的UI工具（UITools.cs） 12 通过搜索“只能出现在特定目标下的游戏对象”，可减少名称的重复性。而已经被搜索过的Canvas2D画布对象也被保存下来，避免重新搜索而造成的性能损失。另一个工具类UnityTool，则是利用Transform类的分层管理功能，来搜索特定游戏对象GameObject下的子对象： 12 在UnityTool工具类中，FindChildGameObject方法是用来搜索某游戏对象下的子对象。从程序代码中可以看到，先是遍历某个游戏对象下的所有子组件，判断目标对象是否存在，并在方法的最后返回找到游戏对象。此外，程序代码中也对重复命名的问题加以“防呆”（防止出错的处理），发现有名称相同游戏对象时，会提出警告要求开发人员注意。虽然实现上还是遍历了所有子对象一次，会有效率上的损失，但是“重复命名提示警告信息”这项功能，可减少重复命名所造成的错误。所以，笔者在选择上会以避免重复命名为优先（笔者在多个游戏引擎下都会遇到这个问题，每次都会浪费大量的时间进行调试）。另外，由于界面组件的搜索，只会在初始化时执行一次而已，所以因搜索对象而产生的性能损失，只会在前期发生，后期在游戏运行状态下，并不会一直使用搜索界面组件的功能。 有了这两项工具之后，兵营界面CamInfoUI就能获取所有跟兵营信息有关的2D组件，并加以保留： 12 结论利用本章介绍的方式来实现游戏的用户界面时，就笔者过去的开发经验，可提出下列优缺点，与读者分享： 优点： 界面与功能分离：若每一个界面组件都只是单纯的“显示设置”和“版面安排”，上面并不绑定任何与游戏功能相关的脚本组件，那么基本上就符合了“接口”与“功能”分离的要求。因此，就单纯的界面而言，很容易就能转換到其他项目下共享，尤其是项目之间共享的界面，如登录界面、公司版权页等。 工作切分更容易：以往的界面设计，不太容易切分是由哪个部门或小组来专职负责，程序设计师、企划、美术都可能接触到。当程序功能脚本从界面设计上移除后，就很容易让程序设计师从用户界面设计中脱离，完全交由美术或企划组装。 界面更改不影响项目：只要维持组件的名称不变，那么界面的更改就不太容易影响到现有程序功能的运行，如更改组件的大小、外观、显示的色彩、图标等，大多可以独立设置。 缺点： 组件名称重复：如果组件搜索没有设置好策略以及界面设计上没有将层级切分好的话，就很容易发生组件名称重复的问题。预防的方式即是《P级阵地》中所示范的，在工具类UnityTool中加上“名称重复警告”功能，用以提示界面设计或测试人员，发生了“重复命名”的问题。 组件更名不易： 当界面组件因为设计需要而进行更名时，会让原本程序预期获取的组件无法再获取，严重时会导致游戏功能不正确并造成程序的宕机或App的闪退。应对的方法一样是在工具类UnityTool中加上“无法获取”的警告信息，以提示界面设计或测试人员，发生了“组件无法获取”的问题。 就整体来看，笔者认为，本章所介绍的用户界面开发方式，优点多于缺点。而缺点部分也能使用“警告提示”来避免，因此将此方法带到《P级阵地》中作为玩家界面的实现方式。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式与游戏完美开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成就系统--观察者模式]]></title>
    <url>%2F2019%2F08%2F13%2F%E6%88%90%E5%B0%B1%E7%B3%BB%E7%BB%9F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 成就系统成就系统(AchievementSystem),是早期单机游戏就出现的一种系统,例如:收集到多少颗星星就能开启特定关卡、全装备收集完成就能额外获得另一组套装等等。这些收集的项目并不会影响游戏主线的进行,也不与游戏主要的玩法相关。但增加这些成就项目,有助于游戏的可玩性,并提升玩家对游戏的挑战和目标的追求 成就系统(AchievementSystem)中的项目,都会和游戏本身有关,并且在玩家游玩的过程中,就能顺便收集,或是反复进行某项操作就能实现目标。一般可以先将成就项目分门别类,例如属于总数类的可能有累积击杀敌方角色达100次、训练我单位达100个等;也有的是目标完成的项目,如完成训练一个等级3的玩家角色、成功打倒一个Boss等。所以,在实现成就系统之前,需要企划单位先将需要的成就事件列出来,并在项目完成到某个段落之后,才开始加入实现开发中。实现上,会先定义“游戏事件”,如敌方角色阵亡、玩家角色阵亡、玩家角色升级等。当游戏进行过程中,有任何“游戏事件”被触发时,系统就要通知对应的“成就项目”,进行累积或条件判断,如果达到,则完成“成就项目”并通知玩家或直接给予奖励,如图21-1所示。 图21-1 成就系统与玩家奖励 一个简单的设计方式是,我们可以把通知成就系统的程序代码加入到“成就事件触发”的方法中。例如,击杀敌方角色,实现时就可以加在敌方角色阵亡的地方:Listing 21-1 Enemy角色接口 事件触发后,调用成就系统(AchievementSystem)中的NotifyGameEvent方法,并将触发的游戏事件及触发时的敌方角色传入。上述范例中,使用枚举(ENUM)的方式来定义“游戏事件”,并将事件从参数行传入,而不是针对每一个游戏事件定义特定的调用方法,这样做可以避免成就系统定义过多的接口方法。而成就系统的NotifyGameEvent方法,可根据参数传入的“游戏事件”参数,来决定后续的处理流程: 因为“游戏事件”非常多,所以在NotifyGameEvent方法中先判断emGameEvent的参属性,再分别调用对应的私有成员方法,而每个私有成员方法,再按照企划的需求,累积计属性或判断单次成就是否实现。Listing 21-3成就系统 如果让成就系统(AchievementSystem)负责每一个游戏事件的方法,并针对每一个单独的游戏事件,去进行“成就项目的累积或判断”,会让成就系统的扩充被限制在每个游戏事件处理方法中。当以后需要针对某一个游戏事件增加成就项目时,就必须通过修改原有“游戏事件处理方法”中的程序代码才能达成。例如,想再增加一个成就项目“杀死装备武器为Rocket以上的敌人数”,那么就只能修改Notify-EnemyKilled方法,在其中追加程序代码来实现修改的目标。 此外, “游戏事件”发生时可能不是只有成就系统会被影响,其他系统也可能需要追踪相关的游戏事件。因此,如果都是在“游戏事件”的触发点进行每个系统调用的话,那么触发点的程序代码将会变得非常复杂: 所以要将“游戏事件”与“成就系统”分开,让成就系统仅关注于某些游戏事件的发生;而游戏事件的发生,也不是只提供给成就系统使用。这样的设计才是适当的设计。 要如何完成这样的设计呢?如果能将“游戏事件的产生与通知”独立成为一个系统,并且让其他系统能通过“订阅”或“关注”的方式,来追踪游戏事件系统发生的事。也就是,当游戏事件系统发生事件时,会负责去通知所有“订阅”了游戏事件的系统,此时被通知的系统,再根据自己的系统逻辑自行决定后续的处理操作。如果能按照上述流程来进行设计,就是一个极为适当的设计。上述的流程,其实就是观察者模式(Observer)所要表达的内容,如图21-2所示。 图21-2 由事件触发其他相关的系统 观察者模式(Observer)观察者模式(Observer)与命令模式(Command)是很相似的模式,两者都是希望“事件发生”与“功能执行”之间不要有太多的依赖性,不过,还是可以按照系统的使用需求,分析出应该运用哪个模式。命令模式(Command)已经在第19章中详细说明过了,接下来将说明观察者模式(Observer),另外,在21.3.4节中也将说明,如何根据系统的需要在这两个模式中,选择合适的模式进行实现。 观察者模式(Observer)的定义GoF对观察者模式(Observer)的定义为: ,在对象之间定义一个一对多的连接方法,当一个对象变换状态时,其他关联的对象都会自动收到通知。” 土交网站就是最佳的观察者模式(Observer)实现范例。当我们在社交网站上,与另一位用户成为好友、加入一个粉丝团或关注另一位用户的状态,那么当这些好友、粉丝团、用户有任何的新的动态或状态变动时,就会在我们动态页面上“主动”看到这些对象更新的情况,而不必到每一位好友或粉丝团中查看,如图21-3所示。 图21-3社交网站上的关注对象的更新 在早期社交网站还没广泛流行之前,说明观察者模式(Observer)常以“报社-订户”来做说明:多位订户向报社“订阅(Subscribe)”了一份报纸,而报社针对昨天的新闻整理编辑之后,在今天一早进行“发布(Publish)”的工作,接着送报生会主动按照订阅的信息,将每份报纸送到订户手上,如图21-4所示。 图214 向报社订阅后,报纸每日会送达到指定的订户手上 在上面的案例中,都存在“主题目标”与其他“订阅者/关注者”之间的关系(一对多),当主题有变化时,就会通过之前建立的“关系”,将更动态的信息传送给“订阅者/关注者”。因此,实现上可分为以下儿点: 主题者、订阅者的角色;如何建立订阅者与主题者的关系;主题者发布信息时,如何通知所有订阅者。21.2.2观察者模式(Observer)的说明GoF定义的观察者模式(Observer)的类结构图如图21-5所示。 图21-5 GOF定义的观察者模式(Observer)的类结构图GoF参与者的说明如下:Subject (主题接口)&gt;定义主题的接口。让观察者通过接口方法,来订阅、解除订阅主题。这些观察者在主题内部可使用泛型容器加以管理。在主题更新时,通知所有观察者。ConcreteSubject (主题实现)&gt;实现主题接口。&gt;设置主题的内容及更新,当主题变化时,使用父类的通知方法告知所有的观察者。Observer (观察者接口).定义观察者的接口。&gt;提供更新通知方法,让主题可以通知更新。ConcreteObserver (观察者实现)&gt;实现观察者接口。&gt;针对主题的更新,按需求向主题获取更新状态. 在类定义中,使用了一个C#的List泛型容器(m Observers)来管理所有的Observer(观察者),并实现了3个与Observer (观察者)相关的方法。当某一个Observer (观察者),对Subject (主题)感兴趣时,就利用Attach方法将自己加入主题的管理器中,通过这样的方式, Observer (观察者)就能主动与Subject (主题)建立关系。当Subject (主题)被更改而需要通知Observer (观察者)时,只要遍历m Observers就能通知每一个在容器内的Observer (观察者)现在有Subject (主题)发生了更改。 以下程序范例实现了一个主题 Listing 21-5 主题实现(Observer.cs)]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式与游戏完美开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兵营训练单位--命令模式]]></title>
    <url>%2F2019%2F08%2F13%2F%E5%85%B5%E8%90%A5%E8%AE%AD%E7%BB%83%E5%8D%95%E4%BD%8D-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 兵营界面上的命令上一章讲解了《P级阵地》中，兵营系统与兵营信息显示的方式及流程。而在兵营界面（CampInfoUI）上，除了显示基本的信息外，还有4个功能按钮（如图1所示），让玩家可以针对兵营执行不同的操作。 兵营升级：提升兵营等级，让该兵营产生角色的等级（SoliderLv）提升，可用来增加防守优势。 武器升级：每个兵营产生角色时，身上装备的武器等级为“枪”，通过升级功能可以让新产生的角色装备长枪和火箭筒加强角色的攻击能力。 训练：对兵营下达训练角色，并且可以连续下达命令，兵营会记录当前还没训练完成的数量。训练成功后，界面会显示准备训练的作战单位数。 取消训练：因为每个兵营都可以下达多个训练作战单位，所以也提供取消训练单位的功能，让资源（生产能力）能重新分配给其他命令。 配合Unity3D的界面设计，可以在兵营界面中放置4个UI按钮（Button）供玩家选择，如同在“第17章Unity3D的界面设计”中提到的，我们希望界面组件的响应能够在程序中进行设置，以让UI组件能在编辑模式下，“不”与任何一个游戏系统进行绑定。所以在《P级阵地》的玩家界面上，单击按钮后要执行哪一段功能，也会在每一个界面初始化时决定。以兵营界面（CampInfoUI）为例，在界面初始化方法（Initialize）中，除了将显示信息用的文字（Text）组件的引用记录下来之外，也会针对画面上的4个命令按钮（Button），设置它们被“单击”时分别要调用的是哪一种方法： Listing 1 兵营界面（CampInfoUl.cs） 12345678910111213141516171819202122232425262728public class CampInfoUI : IUserInterface&#123; ... // 初始化 public override void Initialize() &#123; ... // 训练时间 m_TrainTimerText = UITool.GetUIComponent&lt;Text&gt;(m_RootUI, "TrainTimerText"); // 玩家的互动 // 升级 m_LevelUpBtn = UITool.GetUIComponent&lt;Button&gt;(m_RootUI, "CampLevelUpBtn"); m_LevelUpBtn.onClick.AddListener( ()=&gt; OnLevelUpBtnClick() ); // 武器升級 m_WeaponLvUpBtn = UITool.GetUIComponent&lt;Button&gt;(m_RootUI, "WeaponLevelUpBtn"); m_WeaponLvUpBtn.onClick.AddListener( ()=&gt; OnWeaponLevelUpBtnClick() ); // 训练 m_TrainBtn = UITool.GetUIComponent&lt;Button&gt;(m_RootUI, "TrainSoldierBtn"); m_TrainBtn.onClick.AddListener( ()=&gt; OnTrainBtnClick() ); // 取消训练 m_CancelBtn = UITool.GetUIComponent&lt;Button&gt;(m_RootUI, "CancelTrainBtn"); m_CancelBtn.onClick.AddListener( ()=&gt; OnCancelBtnClick() ); ... &#125; ...&#125; 通过UITool的GetUIComponent&lt;T&gt;方法，可以获取玩家界面中的按钮（Button）组件，然后在按钮（Button）组件的onClick成员上增加“监听函数”（Listener），因为每一个按钮（Button）组件对应的功能不同，所以需要针对每一个按钮设置不同的监听函数，而监听函数可以是类中的某一个成员方法： Listing 2 兵营界面（CampInfoUI.cs） 123456789101112131415161718192021222324252627public class CampInfoUI : IUserInterface&#123; // 升级 private void OnLevelUpBtnClick() &#123; ... &#125; // 武器升级 private void OnWeaponLevelUpBtnClick() &#123; ... &#125; // 训练 private void OnTrainBtnClick() &#123; ... &#125; // 取消训练 private void OnCancelBtnClick() &#123; ... &#125;&#125; 通过实时获取玩家界面上的按钮（Button）组件，再指定监听函数的方式，就可以将界面上的按钮与《P级阵地》的功能加以连接。 训练作战单位的命令 《P级阵地》对兵营角色进行训练时，要求提供“训练时间”功能，也就是对兵营下命令时，不能马上产生角色并立即放入战场中，而是要给定某长度的训练时间，当训练时间到达后，角色才能产生并放入战场。因为游戏流畅度的要求，所以可以对兵营下达多个训练命令，让兵营在训练完一个作战单位之后，能接着产生下一个。因此，在实现上，需要设计一个管理机制来管理这些“排队”中的“训练命令”，这些训练命令还可以通过“取消训练”的指令，来减少排队中的命令数量。 如果只是单纯地想将玩家界面按钮与功能的执行分开，那么可以在每一个按钮的监听函数中调用功能提供者的方法，这样就能达成“命令”与“执行”分开的目标。但是如果还要加上能对这些命令“进行管理”，如新增、删除、调度等功能，则需要加入其他设计模式才行。而GoF提出的设计模式中，命令模式可以解决这样的设计需求。 界面上显示当前用鼠标单击兵营的基本信息包含名称、等级、武器等级等，另外还有4个功能按钮，为玩家提供对兵营下达命令的界面。而这些从界面下达的命令将会使用命令模式，让玩家的操作与游戏的功能产生关联并执行。 命令模式在本节使用软件开发作为范例说明设计模式之前，我们先举个较为生活化的例子来说明命令模式。例如，在餐厅用餐就是命令模式的一种表现，当餐厅的前台服务人员接收到客人的点餐之后，就会将餐点内容记载在点餐单（命令）上，这张点餐单（命令）就会随着其他客人的点餐单（命令）一起排入厨房的“待做”列表（命令管理器）内。厨房内的厨师（功能提供者）根据先到先做的原则，将点餐单（命令）上的内容一个个制作（执行）出来。当然，如果餐厅不计较的话，那么等待很久的客人，也可以选择不继续等待（取消命令），改去其他餐厅用餐。 命令模式的定义GoF对于命令模式（Command）的定义如下： 1将请求封装成为对象，让你可以将客户端的不同请求参数化，并配合队列、记录、复原等方法来执行请求的操作。 上述定义可以简单分成两部分来看待： 请求的封装； 请求的操作。 请求的封装 所谓的请求，简单来说就是某个客户端组件，想要调用执行某种功能，而这个某种功能是被实现在某个类中。一般来说，如果想要使用某个类的方法，通常最直接的方式就是通过直接调用该类对象的方法。但有的时候，调用一个功能的请求需要传入许多参数，让功能执行端能够正确地按照客户端的需求来执行，常见的做法是使用参数行的方式，将这些调用时要引用的设置传入方法中。但是，当功能执行端提供过多的参数让客户端选择时，就会发生参数行过多的情况。因此为了方便阅读，通常会建议将这些参数行上的设置以一个类加以封装[7]，参数封装的示意图如图19-2所示。利用这样的方式，将调用功能时所需的参数加以封装，就是“请求的封装”。如果以餐厅点餐的例子来看，请求的封装就如同前台服务人员将客人的点餐内容写在点餐单上。 图2 参数封装 在第15章介绍建造者模式（Builder）时，针对产生每个角色时所需要的设置参数，在“请求”SoliderBuilder执行建造功能前，都先使用SoldierBuildParam类对象，将所有参数集中设置在其中，除了方便阅读外，这样的方式也可视为简易的“请求的封装”： 12345678910111213141516171819202122232425262728293031323334353637383940414243// c产生游戏角色工厂public class CharacterFactory : ICharacterFactory&#123; // 产生Soldier public override ISoldier CreateSoldier( ENUM_Soldier emSoldier, ENUM_Weapon emWeapon, int Lv, Vector3 SpawnPosition) &#123; // 产生Soldier的參數 SoldierBuildParam SoldierParam = new SoldierBuildParam(); // 产生对应的Character switch( emSoldier) &#123; case ENUM_Soldier.Rookie: SoldierParam.NewCharacter = new SoldierRookie(); break; case ENUM_Soldier.Sergeant: SoldierParam.NewCharacter = new SoldierSergeant(); break; case ENUM_Soldier.Captain: SoldierParam.NewCharacter = new SoldierCaptain(); break; default: Debug.LogWarning("CreateSoldier:无法产生[" + emSoldier + "]"); return null; &#125; if( SoldierParam.NewCharacter == null) return null; // 设置共享参数 SoldierParam.emWeapon = emWeapon; SoldierParam.SpawnPosition = SpawnPosition; SoldierParam.Lv = Lv; // 产生对应的Builder及设置参数 SoldierBuilder theSoldierBuilder = new SoldierBuilder(); theSoldierBuilder.SetBuildParam( SoldierParam ); // 产生 m_BuilderDirector.Construct( theSoldierBuilder ); return SoldierParam.NewCharacter as ISoldier; &#125;&#125; 如果将“封装”的操作再进一步的话，也就是连同要调用的“功能执行端”一起被封装到类中，如图3所示。这种情况通常发生在功能执行端（类）不确定、有多个选择或客户端是一个通用组件不想与特定实现绑在一起时。 图3 调用的对象也可以被封装进去 请求的操作 当请求可以被封装成一个对象时，那么这个请求对象就可以被操作，例如： 存储：可以将“请求对象”放入一个“数据结构”中进行排序、排队、搬移、删除、暂缓执行等操作，如图4所示。 记录：当某一个请求对象被执行后，可以先不删除，将其移入“已执行”数据容器内。通过查看“已执行”数据容器的内容，就可以知道系统过去执行命令的流程和轨迹 复原：延续上一项记录功能，若系统针对每项请求命令实现了“反向”操作时，可以将已执行的请求复原，这在大部分的文字编辑软件和绘图编辑软件中是很常见的。 图4 请求被放入容器内时，可执行的操作 命令模式的说明命令模式的结构如图5所示。 图5命令模式的结构图 GoF参与者的说明如下： Command（命令界面）：定义命令封装后要具备的操作界面。 ConcreteCommand（命令实现）：实现命令封装和界面，会包含每一个命令的参数和Receiver（功能执行者）。 Receiver（功能执行者）：被封装在ConcreteCommand（命令实现）类中，真正执行功能的类对象。 Client（客户端/命令发起者）：产生命令的客户端，可以视情况设置命令给Receiver（功能执行者）。 Invoker（命令管理者）：命令对象的管理容器或是管理类，并负责要求每个Command命令）执行其功能。 命令模式的实现范例实现上，在运用命令模式之前，功能执行的类通常都已经在项目中实现好了。假设现存的系统中已有两个功能执行的类：Receiver1和Receiver2。 Listing 3 两个可以执行功能的类（Command.cs） 12345678910111213141516171819// 负责执行命令1public class Receiver1&#123; public Receiver1()&#123;&#125; public void Action(string Command) &#123; Debug.Log ("Receiver1.Action:Command["+Command+"]"); &#125;&#125;// 负责执行命令2public class Receiver2&#123; public Receiver2()&#123;&#125; public void Action(int Param) &#123; Debug.Log ("Receiver2.Action:Param["+Param.ToString()+"]"); &#125;&#125; 如果想要让这两个类的“功能执行”能够被“管理”，则需要将它们分别封装进“命令类”中。首先定义命令界面： Listing 4 执行命令的界面（Command.cs） 1234public abstract class Command&#123; public abstract void Execute();&#125; 界面只定义了一个执行（Execute）方法，让命令管理者（Invoker）能够要求Receiver（功能执行者）执行命令。因为有两个功能执行类，所以分别实现两个命令子类来封装它们： Listing 5 将命令和Receiver1对象绑定起来（Command.cs） 12345678910111213141516public class ConcreteCommand1 : Command&#123; Receiver1 m_Receiver = null; string m_Command = ""; public ConcreteCommand1( Receiver1 Receiver, string Command ) &#123; m_Receiver = Receiver; m_Command = Command; &#125; public override void Execute() &#123; m_Receiver.Action(m_Command); &#125;&#125; Listing 6 将命令和Receiver2对象绑定起来（Command.cs） 12345678910111213141516public class ConcreteCommand2 : Command&#123; Receiver2 m_Receiver = null; int m_Param = 0; public ConcreteCommand2( Receiver2 Receiver,int Param ) &#123; m_Receiver = Receiver; m_Param = Param; &#125; public override void Execute() &#123; m_Receiver.Action( m_Param ); &#125; &#125; 每个命令在构建时，都会指定“功能执行者”的对象引用和所需的参数。而传入的对象引用及参数都会定义为命令类的成员，封装在类中。每一个命令对象都可以加入Invoker（命令管理者）中。 Listing 7 命令管理者（Command.cs） 1234567891011121314151617181920public class Invoker&#123; List&lt;Command&gt; m_Commands = new List&lt;Command&gt;(); // 加入命令 public void AddCommand( Command theCommand ) &#123; m_Commands.Add( theCommand ); &#125; // 执行命令 public void ExecuteCommand() &#123; // 执行 foreach(Command theCommand in m_Commands) theCommand.Execute(); // 清空 m_Commands.Clear(); &#125;&#125; Invoker（命令管理者）中，使用List泛型容器来暂存命令对象，并在执行命令（ExecuteCommand）方法被调用时，才一次执行所有命令，并清空所有已经被执行的命令，等待下一次的执行。 测试程序本身就是Client（客户端），用来产生命令并加入Invoker（命令管理者）： Listing 8 测试命令模式 1234567891011121314void UnitTest () &#123; Invoker theInvoker = new Invoker(); Command theCommand = null; // 将命令与执行结合 theCommand = new ConcreteCommand1( new Receiver1(),"你好"); theInvoker.AddCommand( theCommand ); theCommand = new ConcreteCommand2( new Receiver2(),999); theInvoker.AddCommand( theCommand ); // 执行 theInvoker.ExecuteCommand();&#125; 产生两个命令之后，再将它们分别加入Invoker（命令管理者）中，然后一次执行所有的命令，信息窗口上可以看到下列信息，表示命令都被正确执行： 12Receiver1.Action:Command[你好]Receiver2.Action:Param[999] 上述范例看似颇为简单，也正因为如此，让命令模式在实现上的弹性非常大，也出现许多变化的形式。在实际分析时，可以着重在“命令对象”的“操作行为”加以分析： 如果希望让“命令对象”能包含最多可能的执行方法数量，那么就加强在命令类群组的设计分析。以餐厅点餐的例子来看，就是要思考，是否将餐点与饮料的点餐单合并为一张。 如果希望能让命令可以任意地执行和撤消，那么就需要着重在命令管理者（Invoker）的设计实现上。以餐厅点餐的例子来看，就是要思考这些点餐单是要用人工管理还是要使用计算机系统来辅助管理。 此外，如果让命令具备任意撤消或不执行的功能，那么系统对于命令的“反向操作”的定义也必须加以实现，或者将反向操作的执行参数，也一并封装在命令类中。 读者可以试着分析任何一套文字编辑工具或程序开发用的集成开发环境IDE工具中的“撤消”和“取消撤消”功能。可以假设这些工具都将用户的操作或“功能请求”加以记录（封装），并在下达“撤消”指令时，将原有的操作取消，而取消时的操作本身必须由原操作执行了什么行为而定。 使用命令模式实现兵营训练角色将“玩家指令（请求）封装”后再显示给玩家看的游戏还挺多的。笔者最先想到的是早期的即时战略游戏（RTS：Real-time Strategy Game），每次下达兵营训练士兵的命令或兵工厂下达生产战车的命令时，画面上都排满了图标——表示等待被生产的单位，近期的城镇经营游戏也常看到相同的呈现方式。因此，《P级阵地》也以类似的手法，将训练命令实现在游戏中。 训练命令的实现分析《P级阵地》对于兵营命令的需求如下： 每个兵营都有自己的等级以及可训练的兵种，必须按照不同兵营，下达不同的训练命令。 有“训练时间”的功能，所以每一个训练命令都会先被暂存而不是马上被执行。 可以对兵营下达多个训练命令，所以会有多个命令同时存在必须被保存的需求。 “取消训练”来减少训练命令发出的数量。 按照上述的分析，对于《P级阵地》中的训练命令，我们可以规划出几个实现目标：可以将命令封装成类，让每一个兵营能针对本身的属性下达训练命令；使用训练命令管理者将所有命令进行暂存，并按照训练时间的设置，执行每一个训练命令；提供界面让命令可以被添加或删除。 所以，我们在《P级阵地》的兵营（ICamp）类中增加了“命令管理容器”和操作界面来完成命令模式的实现，如图6所示。 图6 兵营（ICamp）类中增加了“命令管理容器”和操作界面来完成命令模式的实现 参与者的说明如下： ITrainCommand：训练命令界面，定义了《P级阵地》中训练一个作战单位应有的命令格式和执行方法。 TrainSoldierCommand：封装训练玩家角色的命令，将要训练角色的参数定义为成员，并在执行时调用“功能执行类”去执行指定的命令。 ICharacterFactory：角色工厂，实际产生角色单位的“功能执行类”。 ICamp：兵营界面，包含“管理训练作战单位的命令”的功能，即担任Invoker（命令管理者）的角色。使用泛型来暂存所有的训练命令，并且使用相关的操作方法来添加、删除训练命令。 SoldierCamp：Soldier兵营界面，负责玩家角色的作战单位训练。当收到训练命令时，会产生命令对象，并按照当前兵营的状态来设置命令对象的参数，最后使用ICamp类提供的界面，将命令加入管理器内。 实现说明在《P级阵地》的游戏设计需求中，因为只有“训练角色”需要管理命令的功能，所以先定义一个名为ITrainCommand的训练命令界面： Listing 9 执行训练命令的界面（TrainCommand.cs） 1234public abstract class ITrainCommand&#123; public abstract void Execute();&#125; 界面中只定义了一个操作方法：Execute执行命令。后续从ITrainCommand延伸出一个子类——TrainSoldierCommand，用来封装训练玩家阵营角色的命令： Listing 10 训练Soldier（TrainSoldierCommand.cs） 123456789101112131415161718192021222324public class TrainSoldierCommand : ITrainCommand&#123; ENUM_Soldier m_emSoldier; // 兵种 ENUM_Weapon m_emWeapon; // 使用的武器 int m_Lv; // 等级 Vector3 m_Position; // 出现位置 // 训练 public TrainSoldierCommand( ENUM_Soldier emSoldier, ENUM_Weapon emWeapon, int Lv, Vector3 Position) &#123; m_emSoldier = emSoldier; m_emWeapon = emWeapon; m_Lv = Lv; m_Position = Position; &#125; // 执行 public override void Execute() &#123; // 产生Soldier ICharacterFactory Factory = PBDFactory.GetCharacterFactory(); ISoldier Soldier = Factory.CreateSoldier( m_emSoldier, m_emWeapon, m_Lv , m_Position ); &#125;&#125; Soldier训练命令类（TrainSoldierCommand）中，将产生玩家角色时所需的参数设置为类成员，并在命令被产生时就全部指定。而TrainSoldierCommand的“功能执行类”就是角色工厂（ICharacterFactory），这些参数在执行命令（Execute）方法中被当成参数传入角色工厂类的方法中，执行产生角色的功能。 在同时担任“命令管理者”的兵营（ICamp）类中，使用List泛型容器来暂存训练命令： Listing 11 兵营界面（ICamp.cs） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public abstract class ICamp &#123; // 训练命令 protected List&lt;ITrainCommand&gt; m_TrainCommands = new List&lt;ITrainCommand&gt;(); protected float m_CommandTimer = 0; // 当前冷却剩余时间 protected float m_TrainCoolDown = 0; // 冷却时间 ... // 新增训练命令 protected void AddTrainCommand( ITrainCommand Command ) &#123; m_TrainCommands.Add( Command ); &#125; // 删除训练命令 public void RemoveLastTrainCommand() &#123; if( m_TrainCommands.Count == 0 ) return ; // 删除最后一个 m_TrainCommands.RemoveAt( m_TrainCommands.Count -1 ); &#125; // 当前训练命令数量 public int GetTrainCommandCount() &#123; return m_TrainCommands.Count; &#125; // 执行命令 public void RunCommand() &#123; // 没有命令则不执行 if( m_TrainCommands.Count == 0 ) return ; // 冷却时间是否到了 m_CommandTimer -= Time.deltaTime; if( m_CommandTimer &gt; 0) return ; m_CommandTimer = m_TrainCoolDown; // 执行第一个命令 m_TrainCommands[0].Execute(); // 删除 m_TrainCommands.RemoveAt( 0 ); &#125; ...&#125; 除了新增的命令管理容器之外（m_TrainCommands），另外还新增了4个与命令管理容器有关的操作方法供客户端使用。在执行命令方法RunCommand中，会先判断当前训练的冷却时间到了与否，如果到了，则执行命令管理容器（m_TrainCommands）的第一个命令，执行完成后就将命令从命令管理容器（m_TrainCommands）中删除。 至于定期调用每一个兵营（ICamp）类的RunCommand方法，则由兵营系统的定时更新（Update）来负责： Listing 12 兵营系统（CampSystem.cs） 1234567891011121314public class CampSystem : IGameSystem&#123; private Dictionary&lt;ENUM_Soldier, ICamp&gt; m_SoldierCamps = new Dictionary&lt;ENUM_Soldier,ICamp&gt;(); ... // 更新 public override void Update() &#123; // 兵营执行命令 foreach( SoldierCamp Camp in m_SoldierCamps.Values ) Camp.RunCommand(); &#125; ...&#125; 在训练Soldier的Train方法中，直接产生一个训练Soldier单位（Train SoldierCommand）的命令对象，并以当前兵营记录的状态设置封装命令的参属性，最后利用父类定义的增加训练命令AddTrainCommand方法，将命令加入父类ICamp的命令管理器中，并等待系统的调用来执行命令。 最后，在兵营界面（CampInfoUI）中，将“训练按钮”和“取消训练按钮”的监听函数，设置为调用Soldier兵营界面（SoldierCamp）中对应的“训练方法”和“取消训练的方法”，来完成整个玩家通过界面下达训练作战单位的命令流程： Listing 14 兵营界面（CampInfoUI.cs） 123456789101112131415161718192021222324252627282930public class CampInfoUI : IUserInterface&#123; private ICamp m_Camp = null; // 显示的兵营 ... // 训练 private void OnTrainBtnClick() &#123; int Cost = m_Camp.GetTrainCost(); if( CheckRule( Cost &gt; 0 ,"无法训练" )==false ) return ; // 是否足够 string Msg = string.Format("AP不足无法训练，需要&#123;0&#125;点AP",Cost); if( CheckRule( m_PBDGame.CostAP(Cost), Msg ) ==false) return ; // 产生训练命令 m_Camp.Train(); ShowInfo( m_Camp ); &#125; // 取消训练 private void OnCancelBtnClick() &#123; // 取消训练命令 m_Camp.RemoveLastTrainCommand(); ShowInfo( m_Camp ); &#125;&#125; 执行流程各类对象之间的执行流程，可通过如图7所示的流程图来了解。 图7 各类对象之间的执行流程 实现命令模式时的注意事项命令模式并不难理解与实现，但在实现上仍须多方考虑。 命令模式实现上的选择 《P级阵地》的兵营界面上，除了与训练单位有关的两个命令（训练、取消训练）之外，另外还有两个与升级有关的命令按钮（兵营升级、武器升级）。但针对这两个界面命令，《P级阵地》并没有运用命令模式来实现： Listing 15 兵营界面（CampInfoUI.cs） 12345678910111213141516171819202122232425262728293031323334353637383940public class CampInfoUI : IUserInterface&#123; private ICamp m_Camp = null; // 显示的兵营 ... // 升级 private void OnLevelUpBtnClick() &#123; int Cost = m_Camp.GetLevelUpCost(); if( CheckRule( Cost &gt; 0 , "已达最高等级")==false ) return ; // 是否足够 string Msg = string.Format("AP不足无法升级,需要&#123;0&#125;点AP",Cost); if( CheckRule( m_PBDGame.CostAP(Cost), Msg ) ==false) return ; // 升级 m_Camp.LevelUp(); ShowInfo( m_Camp ); &#125; // 武器升级 private void OnWeaponLevelUpBtnClick() &#123; int Cost = m_Camp.GetWeaponLevelUpCost(); if( CheckRule( Cost &gt; 0 ,"已达最高等级" )==false ) return ; // 是否足够 string Msg = string.Format("AP不足无法升级,需要&#123;0&#125;点AP",Cost); if( CheckRule( m_PBDGame.CostAP(Cost), Msg ) ==false) return ; // 升级 m_Camp.WeaponLevelUp(); ShowInfo( m_Camp ); &#125; ...&#125; 调用Icamp界面中的方法，这些方法并没有使用命令模式来封装： Listing 16 Soldier兵营（SoldierCamp.cs） 1234567891011121314151617public class SoldierCamp : ICamp&#123; ... // 升级 public override void LevelUp() &#123; m_Lv++; m_Lv = Mathf.Min( m_Lv , MAX_LV); &#125; // 武器等级 public override ENUM_Weapon GetWeaponType() &#123; return m_emWeapon; &#125; ...&#125; 不运用命令模式的主要原因在于： 类过多：如果游戏的每一个功能请求都运用命令模式，那么就有能会出现类过多的问题。每一个命令都将产生一个类来负责封装，大量的类会造成项目不易维护。 请求对象并不需要被管理：指的是兵营升级和武器升级两个命令，在执行上并没有任何延迟或需要被暂存的需求，也就是当请求发出时，功能就要被立即执行。因此，在实现上，只要通过界面类提供的方法（ICamp.LevelUp、ICamp.WeaponLevelUp）来执行即可，让功能的实现类（SoldierCamp）与客户端（CampInfoUI）分离，就可以达成这些功能的设计目标了。 因此，在《P级阵地》中，选择实现命令模式的标准在于： 1当请求被对象化后，对于请求对象是否有“管理”上的需求。如果有，则以命令模式实现。 需要实现大量的请求命令时 随着实现游戏的类型越来越多，可能会遇到需要使用大量请求命令的项目，比如需要与游戏服务器（Game Server）沟通的多人在线游戏（MMO）。大部分在设计服务器（Server）与客户端（Client）的信息沟通时，也会以请求命令的概念来设计，所以实现上也大多会使用命令模式来完成。 但是，一个中小型规模的多人在线游戏，Server与Client之间的请求命令可能多达上千个，若每一个请求命令都需产生类的话，那么就真的会发生“类过多”的问题。为了避免这样的问题发生，可以改用下列的方式来实现： 1，使用“注册回调函数（Callback Function）”：同样将所有的命令以管理容器组织起来，并针对每一个命令，注册一个回调函数（Callback Function），并将“功能执行者”（Receiver）改为一个“函数/方法”，而非类对象。最后，将多个相同功能的回调函数（Callback Function）以一个类封装在一起。 2，使用泛型程序设计：将命令界面（ICommand）以泛型方式来设计，将“功能执行者”（Receiver）定义为泛型类，命令执行时调用泛型类中的“固定方法”。但以这种方式实现时，限制会比较大，必须限定每个命令可以封装的参数数量，而且封装参数的名称比较不直观，也就是将参数以Parm1、Param2的方式命名。 因为固定调用“功能执行者”（Receiver）中的某一个方法，所以方法名称会固定，比较不容易与实际功能联想。 话虽如此，但如果系统中的每个命令都很“单纯”时，使用泛型程序设计可以省去重复定义类或回调函数（Callback Function）的麻烦。 命令模式面对变化时当“请求”可以被封装对象化之后，那么对于可产生“请求”的地点，灵活度就比较大： 企划：“小程啊，是这样的，最近测试人员反应，他们在进行极限值测试时，不是很方便。因为要将每个兵营的等级提升到最高级，需要花点时间。他们是想，我们能不能提供一个可以快速、马上就能产生玩家角色的功能” 小程：“可以啊，那么我另外提供一个测试界面，这个界面上可以指定要产生的单位兵种、等级、武器等信息，单击指令后，就可以马上在战场上产生角色”，于是小程新增了一个测试界面（TestToolUI），如图8所示。 在界面的“产生单位按钮Create”的监听测试中，获取界面的设置值之后，直接产生Soldier训练命令，并且立即执行： 1234567891011121314private void OnAddSoldier()&#123; ENUM_Weapon emWeapon = GetWeaponType(); // 武器等级 int Lv = GetLv(); // 兵营等级 Vector3 Position = GetPosition(); // 训练完成后的集合点 ENUM_Soldier emSoldier = GetSoldierType(); // 兵种 // 产生一个训练命令 TrainSoldierCommand NewCommand = new TrainSoldierCommand(emSoldier, emWeapon, Lv, Position); // 马上执行 NewCommand.Execute();&#125; 因为《P级阵地》已经将“训练角色命令”对象化了。因此，只要将所需要的参数，在命令产生时都正确设置的话，那么在任何功能需求点，都能快速产生训练命令并执行。另外，因为不必指定命令功能执行的对象，所以当系统因需求改变而要更换功能执行的类时，不需要修改所有命令产生的地点，这一部分已经被命令类（ITrainCommand）隔离了。 结论命令模式的优点是，将请求命令封装为对象后，对于命令的执行，可加上额外的操作和参数化。但因为命令模式的应用广泛，在分析时需要针对系统需求加以分析，以避免产生过多的命令类。 其他应用方式 实现网络在线型游戏时，对于Client/Server间数据封包的传递，大多会使用命令模式来实现。但对于数据封包命令的管理，可能不会实现撤消操作，一般比较侧重于执行和记录上。而“记录”则是网络在线型游戏的另一个重点，通过记录，可以分析玩家与游戏服务器之间的互动，了解玩家在操作游戏时的行为，另外也有防黑客预警的作用。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式与游戏完美开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现依赖注入]]></title>
    <url>%2F2019%2F08%2F10%2F%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 背景介绍 示例情景 Constructor注入 Setter注入 接口注入 基于Attribute实现注入--Attributer 小结 背景介绍设计模式中，尤其是结构型模式很多时候解决的就是对象间的依赖关系，变依赖具体为依赖抽象。平时开发中如果发现客户程序依赖某个（或某类）对象，我们常常会对它们进行一次抽象，形成抽象的抽象类、接口，这样客户程序就可以摆脱所依赖的具体类型。这个过程中有个环节被忽略了--谁来选择客户程序需要的满足抽象类型的具体类型呢？通过后面的介绍你会发现很多时候创建型模式可以比较优雅地解决这个问题。但另一问题出现了，如果您设计的不是具体业务逻辑，而是公共库或框架程序，这时候您是一个“服务方”，不是您调用那些构造类型，而是它们把抽象类型传给你，怎么松散地把加工好的抽象类型传递给客户程序就是另一回事了。 这个情形也就是常说的“控制反转”，IOC: Inverse of Control；框架程序与抽象类型的调用关系就像常说的好莱坞规则：Don’t call me,I’ll call you. 我们可以采用“依赖注入”的方式将加工好的抽象类型实例“注入”到客户程序中，本书的示例也将大量采用这种方式将各种依赖项“注入”到模式实现的外部——客户程序。下面我们结合一个具体的示例看看为什么需要依赖注入，以及Martin Fowler文中提到的三种经典方式，然后依据C#语言的特质，再扩展出一个基于Atriter方式注入（参考原有的Setter命名，这里将基于Attribute的方法称为Attributer）。 示例情景客户程序需要一个提供System.DateTime类型当前系统时间的对象，然后根据需要仅仅把其中的年份部分提取出来，因此最初的实现代码如下: 12345678910111213141516171819using System;using System.Diagnostics;namespace ChebinWorks.PracticalPattern.Concept.DependencyInjection.Example1&#123; class TimeProvider &#123; public DateTime CurrentDate &#123; get &#123; return DateTime.Now; &#125; &#125; &#125; public class Client &#123; public int GetYear() &#123; TimeProvider timeProvider = new TimeProvider(); return timeProvider.CurrentDate.Year; &#125; &#125;&#125; 123456789101112131415161718// Program.csusing System;using ChebinWorks.PracticalPattern.Concept.DependencyInjection.Example1;namespace ConsoleApplication&#123; class Program &#123; static void Main(string[] args) &#123; Client cl = new Client(); int year = cl.GetYear(); Console.WriteLine(year); // 2019 Console.ReadKey(); &#125; &#125;&#125; 后来因为某种原因，发现使用.NET Framework自带的日期类型精度不够，需要提供其他来源的TimeProvider，确保在不同精度要求的功能模块中使用不同的TimeProvider。这样问题集中在TimeProvider的变化会影响客户程序，但其实客户程序仅需要抽象地使用其获取当前时间的方法。为此，增加一个抽象接口，确保客户程序仅依赖这个接口ITimeProvider，由于这部分客户程序仅需要精确到年，因此它可以使用一个名为SystemTimeProvider（:TimeProvider）的类型。新的实现代码如下： 12345678910111213141516171819202122232425using System;using System.Diagnostics;namespace ChebinWorks.PracticalPattern.Concept.DependencyInjection.Example1&#123; interface ITimeProvider &#123; DateTime CurrentDate &#123; get; &#125; &#125; class TimeProvider : ITimeProvider &#123; public DateTime CurrentDate &#123; get &#123; return DateTime.Now; &#125; &#125; &#125; public class Client &#123; public int GetYear() &#123; TimeProvider timeProvider = new TimeProvider(); return timeProvider.CurrentDate.Year; &#125; &#125;&#125; 这样看上去客户程序后续处理权都依赖于抽象的ITimeProvider，问题似乎解决了？没有，它还要知道具体的SystemTimeProvider。因此，需要增加一个对象，由它选择某种方式把ITimeProvider实例传递给客户程序，这个对象被称为Assembler。新的结构如图1所示。 图1 增建装配对象后新的依赖关系 其中，Assembler的职责如下: 知道每个具体TimeProviderImpl的类型。 可根据客户程序的需要，将抽象ITimeProvider反馈给客户程序。 本身还负责对TimeProviderImpl的创建。 下面是一个Assembler的示例实现: 123456789101112131415public class Assembler/1/ &lt;summary&gt;11保存“抽象类型/实体类型”对应关系的字典11/ &lt;/summary&gt;private static Dictionary&lt;Type， Type&gt; dictionary =new Dictionary&lt;Type， Type&gt;();static Assembler ()//注册抽象类型需要使用的实体类型，1/实际的配置信息可以从外层机制获得，例如通过配置定义dictionary. Add (typeof (ITimeProvider)， typeof (SystemTimeProvider) ); 根据客户程序需要的抽象类型选择相应的实体类型，并返回类型实例/// &lt;returns&gt;实体类型实例&lt;/returns&gt;public object create (Type type) 1/主要用于非泛型方式调用if ((type == null) I1 !dictionary.containsKey (type)) throw newNullReferenceException();Type targetType = dictionary [type];return Activator.createInstance (targetType);/// &lt;typeparam name="T"&gt;抽象类型(抽象类/接口/或者某种基类) &lt;/typeparam&gt;public T create&lt;T&gt;() //主要用于泛型方式调用return (T) Create (typeof (T)); Constructor注入构造函数注入，顾名思义，就是在构造函数的时候，通过Assembler或其他机制把抽象类型作为参数传递给客户类型。这种方式虽然相对其他方式有些粗糙，而且仅在构造过程中通过“一锤子”方式设置好，但很多时候我们设计上正好就需要这种Read Only的注入方式。其实现方式如下: 12345678910111213111在构造函数中注入class clientprivate IimeProvider timeProvider;public client (ITimeProvider timeProvider).this.timeProvider = timeprovider;Unit Test(TestClass].public class TestclientTestMethodpublic void Test ()ITimeProvider timeProvider(new Assembler()).Create&lt;ITimeProvider&gt;();Assert. IsNotNu11 (timeProvider); //确认可以正常获得抽象类型宏例client client = new Client (timeProvider); 1/在构造函数中注入 Setter注入Setter注入是通过属性赋值的办法解决的，由于Java等很多语言中没有真正的属性，所以Setter注入一般通过一个set()方法实现，C#语言由于本身就有可写属性，所以实现起来更简洁，更像Setter。相比较Constructor方式而言，Setter给了客户类型后续修改的机会，它比较适应于客户类型实例存活时间较长，但Assembler修改抽象类型指定的具体实体类型相对较快的情景；不过也可以由客户程序根据需要动态设置所需的类型。其实现方式如下: 123451/通过Setter实现注入class ciientprivate ITimeProvider timeProvider;public ITimeprovider TimeProviderget &#123; return this.timeprovider; &#125; // getter本身和以Setter方式实现 注入没有关系set &#123; this.timeProvider = value; &#125; // Setter. Unit Test 12345[Testclass]public class Testclient[TestMethod)public void Test ()ITimeProvider timeProvider=(new Assembler()).create&lt;ITimeProvider&gt;();Assert. IsNotNul1 (timeProvider); //确认可以正常获得抽象类型实例!client client = new client();client.TimeProvider = timeProvider; //通过Setter实现注入 接口注入接口注入是将包括抽象类型注入的入口以方法的形式定义在一个接口里，如果客户类型需要实现这个注入过程，则实现这个接口，客户类型自己考虑如何把抽象类型“引入”内部。实际上接口注入有很强的侵入性，除了要求客户类型增加需要的Setter或Constructor注入的代码外，还显式地定义了一个新的接口并要求客户类型实现它。除非还有更外层容器使用的要求，或者有完善的配置系统，可以通过反射动态实现接口方式注入，否则笔者并不建议采用接口注入方式。 既然Martin Fowler文中提到了这个实现方式，就给出如下示例： 12345678111定义需要注入ITimeProvider的类型interface 1objectwithTimeProviderrTimeProvider TimeProvider ( get;set;&#125;&#125;111通过接口方式注入class client: IObjectWithTimeProviderprivate ITimeProvider timeProvider;1// IObiectwithTimeProvider Memberspublic ITimeProvider TimeProviderget &#123; return this.timeProvider; &#125;set [ this.timeProvider = value; &#125; Unit Test 1234567Testclass]public class Testclient[TestMethod]public void rest()ITimeProvider timeProvider = (newAssembler()).Create&lt;ITimeProvider&gt;();ssert. IsNotNul1 (timeProvider); /1确认可以正常获得抽象类型实例IobjectwithTimeProvider objectwithTimeProvider = new client();objectwithrimeProvider.TimeProvider = timeProvider; //通过接口方式注入 基于Attribute实现注入——Attributer如果做个归纳，Martin Fowler之前所介绍的三种模式都是在对象部分进行扩展的，随着语言的发展（.NET从1.0开始，Java从5开始），很多在类元数据层次扩展的机制相继出现，比如C#可以通过Attribute将附加的内容注入到对象上。直观上的客户对象有可能在使用上做出让步以适应这种变化，但这违背了依赖注入的初衷，三个角色（客户对象、Assembler、抽象类型）之中两个不能变，那只好在Assembler上下功夫，谁叫它的职责就是负责组装呢？为了实现上的简洁，上面三个经典实现方式实际将抽象对象注入到客户类型都是在客户程序中（也就是那三个Unit Test部分）完成的，其实同样可以把这个工作交给Assembler完成；而对于Attrbute方式注入，最简单的方式则是直接把实现了抽象类型的Attribute定义在客户类型上，例如： 1234(错误的实现情况)class SystemTimeAttribute : Attribute， ITimeProvider &#123;.. &#125;[SystemTimeclass client &#123;. &#125; 相信你也发现了，这样虽然把客户类型需要的ITimeProvider通过“贴标签”的方式告诉它了，但事实上又把客户程序与SystemTimeAttribute“绑”上了，它们紧密地耦合在一起。参考上面的三个实现，当抽象类型与客户对象耦合的时候我们引入了Assembler，当Attribute方式出现类似的情况时，我们写个AttributeAssembler不就行了么？还不行。设计上要把Attribute设计成一个“通道”，考虑到扩展和通用性，它本身要协助AttributeAssembler完成ITimeProvider的装配，最好还可以同时装载其他抽象类型来修饰客户类型。示例代码如下: 1234567891011121314151617181920212223242526[AttributeUsage (AttributeTargets.Class， AllowMultiplestrue)]sealed class DecoratorAttribute : Attribute/11实现客户类型实际需要的抽象类型的实体类型实例，即得注入客户类型的内容public readonly object Injector;private Type type;public DecoratorAttribute (Type type)if (type == null) throw new ArgumentNullException("type");this.type = type;Injector = (new Assembler()).Create(this.type);/1/客户类型需要的抽象对象类型public Type Type &#123; get &#123; return this.type; &#125;&#125;11/帮助客户类型和客户程序获取其Attribute定义中需要的抽象类型实例的工具类，static class AttributeHelperpublic static r Injector&lt;T&gt; (object target)where T: classif (target as null) throw new ArgumentNul1Exception ("target");Type targetType = target.GetType();object [] attributes = targetType.GetCustomAttributes (typeof (DecoratorAttribute)， false).if ((attributes == null) 11 (attributes.Length &lt;= 0)) return null;foreach (DecoratorAttribute attribute in(DecoratorAttribute[])attributes)if (attribute.Type =s typeof (T)) return (T) attribute. Injector;eturn null;[Decorator (typeof (ITimeProvider))]11应用Attribute，定义需要将ITimeProvider通过它注入class client(public int GetYear ()//与其他方式注入不同的是，这里使用的ITimeProvider来自自己的AttributeITimeProvider provider=AttributeHelper. Injector&lt;ITimeProvider&gt;(this);return provider.currentDate.Year;Unit TestTestMethod]public void Test()Client client = new client();Assert. IsTrue (client.GetYear() &gt;0); 小结依赖注入虽然被Marin Fowler称为一个模式，但平时使用中，它更多地作为一项实现技巧出现，开发中很多时候需要借助这项技巧把各个设计模式所加工的成果传递给客户程序。各种实现方式虽然最终目标一致，但在使用特性上有很多区别。 Constructor方式：它的注入是一次性的，当客户类型构造的时候就确定了。它很适合那种生命期不长的对象，比如在其存续期间不需要重新适配的对象。此外，相对Setter方式而言，在实现上Constructor可以节省很多代码； Setter方式：一个很灵活的实现方式，对于生命期较长的客户对象而言，可以在运行过程中随时适配； 接口方式：作为注入方式具有侵入性，很大程度上它适于需要同时约束一批客户类型的情况； 属性方式：随着开发语言的发展引入的新方式，它本身具有范围较小的固定内容侵入性（一个DecoratorAttribute），它也很适合需要同时约束一批客户类型情景。它本身实现相对复杂一些，但客户类型使用的时候非常方便——“打标签”即可。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式：基于C#的工程化实现与扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[帧同步]]></title>
    <url>%2F2019%2F08%2F10%2F%E5%B8%A7%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 帧同步与单机有什么差别？ 服务器每隔多少时间触发一个帧合适？ 为什么我们不用TCP？UDP的优点与缺点同样明显怎么理解？ 帧同步基本流程，采用TCP+ UDP（帧数据传送）模式是怎么样的？ 服务器，客户端没有收到数据包会怎么样？ 断线重连了，会怎么样？ 2个手柄: A,B对战:手柄操作-》A:-&gt;用户的操作 》游戏逻辑,推动游戏的发展;手柄操作一》B:一&gt;用户的操作 》游戏逻辑,推动游戏的发展; 帧同步:服务器每隔一段时间,向客户端,发送所有客户端当前的操作,一帧所有客户端收到这个帧的事件, (所有玩家的操作一&gt;客户端送代正确的结果:同时将操作上报给服务器,以便下一个帧来发送当前客户端的操作; =?多少帧出发合适?一如果帧太搞了,网络响应达不到; 2:我们服务器每隔多少时间触发一个合适:(1)你秒钟能点多少此鼠标?(2)你每秒能按多少按键?(3)人的操作反应时间(50-100M) 1000/5~20, 100 100 10 10 20 10] 1&gt;王者荣經[15FPS的手感操作15FPS (服务器的逻辑帧)客户端的手感,服务器的带宽网络响应的时间,也是没有问题的; FPS:游戏引擎的FPS-》手机跑游戏,每秒刷新多少字-&gt; 60FPS,左右;动画帧逻辑的FPS, )赖同步的,服务器,每隔多少时间像客户端发送一个顿数据操作;15FPS赖同步: -t管游戏计算,比如掉血,攻击,走逻辑帧驱动: 3:为什么我们不用TCP, UDP的优点与缺点同样明显: TCP:核心意涵是什么?可靠的通讯协议, A-) B, A-数据报B, B–A回一个确认,给A, A才会发下一个包; 好处,就是可靠,不会丢包, 一个数据包,你至少要在网络上传送两次:一&gt;手感,打击太打了;UDP:核心意涵是什么?不可靠的传送协议, A发送一个数据包给B,马上发送出去,发完了就不管了;A马上可以在发一个数据B;缺点：(1)由于网络传送,可能丢包(2)发送数据包1,发送数据包2,一&gt;数据包2,数据包1,优点:你发,我就马上给你发;4:赖同步基本流程,采用TCP+ UDP(顿数据传送)模式普通的游戏,我们采用TCP,来做数据链接,普通的功能我们用TCP来做链接;游戏逻辑服务器,帧同步,采用UDP:客户端-》逻辑服务器; 大家不要想太多,先把流程梳理清楚(1)集结玩家成功以后,服务器启动一个定时器,每隔一段时间,出发一个逻辑,;每隔66ms,我们服务器向客户端,触发发一个赖:(2)我们服务器发了什么样的数据给客户端呢?所有玩家的操作的采集数据: match frames:保存所有的游戏的帧? 一&gt;多大呢?]]></content>
  </entry>
  <entry>
    <title><![CDATA[在Unity3D中使用泛型]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%9C%A8Unity3D%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 安全检查从运行时转移到了编译时怎么理解？ 类型也可以成为一种参数怎么理解？ 泛型方法如何表现类型参数？写在圆括号()可以吗？为了不和原参数冲突，使用&lt;&gt;表示怎么理解？ 泛型的本质是“类型是参数”怎么理解？ 方法使用的时候是不是要圆括号里面写参数，泛型既然用尖括号定义了形参 那调用的时候就还需要尖括号里传入实参怎么理解？ 泛型没出现之前有什么问题？ 为什么说object类型其本身其实是一个很“没有用”的存在？ 泛型类的虚方法更少如何理解？ 本章涵盖： 为什么需要泛型机制 Unity 3D中常见的泛型 泛型机制的基础 由于泛型的引入，使得大量的安全检查从运行时（通过编译，运行出错）转移到了编译时（写错通不过编译）进行，C#的代码也因此获得了更加丰富的表现力。 其实从本质上来说，泛型实现了类型和方法的参数化，即类型也可以成为一种参数。就如同在一般的方法中，需要告诉该方法它所需要的参数是什么。同样在涉及到泛型类型的方法时，就像需要向方法提供参数一样，同样要告诉这个方法使用了什么类型。 那么既然是作为C#2所引入的最重要的一个功能，我们显然必须要先了解泛型这种机制出现的必然性。 为什么需要泛型机制面向对象的开发模式之所以受人推崇，其中的一个好处便是代码的复用，也正是由于代码复用，因此使用面向对象编程时，开发效率很高。 举一个简单的例子，假设我们有一个基类已经定义了它的各种功能，如果需要拓展这个基类的功能，只需要在这个基类的基础上派生出一个新的类，让它继承基类的所有能力。而派生类所做的只是重写基类的虚方法，或者是添加一些新的方法，这样就可以实现拓展基类功能的目的。但这个和本节要说的泛型机制有什么关系呢？其实很简单，泛型机制的出现，最主要的目的也是实现另一种形式的代码复用，即“逻辑复用”。 在泛型机制出现之前的C#1的时代，由于没有泛型的概念，因此面对不同的类型，即便使用的是同一套逻辑，仍然需要对类型进行强制转换。任何方法只要将object作为参数类型或者返回类型使用，那么就会有可能在某个时候触发强制类型转换。这显然是低效率的，而且可能会带来很多Bug。而泛型的出现，则使得逻辑复用变成了可能，甚至是一件理所当然的事情。 简单地说，泛型出现之后，开发底层逻辑的人员只需要定义好功能逻辑，例如常见的排序、搜索、元素交换、元素比较等，或者是游戏中常见的寻敌、状态循环等游戏逻辑。但是定义这些逻辑的人员，并不需要指定特定的数据类型。例如List&lt;T&gt;这个数据结构，开发这个数据结构的开发人员无须事先假定List&lt;T&gt;中涉及到的排序、搜索、交换等操作的类型具体是什么。又比如一个游戏中的单位可能有英雄、士兵、怪物等，但是在开发寻找敌人的通用逻辑时，逻辑开发者不必知道在具体使用时，操作的到底是英雄、士兵、怪物。也就是说，该算法可以广泛地应用于不同类型的对象。而指定逻辑要具体操作的数据类型，则是使用该逻辑的开发人员需要考虑的。 在Unity 3D中，C#脚本语言只允许创建泛型引用类型和泛型值类型，但是要注意的是，创建泛型枚举类型是不被允许的。 作为开发中最常见的一种数据结构，也是最常见的一个泛型类，下面用List&lt;T&gt;作为例子，来讲解一下泛型的表现形式和具体操作方法，代码如下。 12 在上面这段代码中，由于List&lt;T&gt;定义在System.Collections.Generic命名空间中，因此首先要引入这个命名空间。之后可以看到泛型List类的写法是类名（List）+&lt;T&gt;的格式，表示List类操作的是一个没有指定的数据类型（T） 。在定义泛型类型或泛型方法时，为类型指定的任何变量都被称为类型参数，即本章刚开始的时候所提到的类型参数化，参数变量名为T。在上面的这段代码中，T是string，意思是这个List类的实例操作的是string型的对象。另一个例子是索引器方法，即C#游戏脚本语言中的this。索引器有一个get访问器方法，它返回T类型的值以及一个set访问器方法，它接受T类型的参数。 在设计List&lt;T&gt;的开发人员定义好List&lt;T&gt;中的各个逻辑方法后，就可以在使用它所提供的方法时选择具体的操作类型了。例如在上面的这段代码中，指定了一个string类型的实参来使用List的各种方法，当依次使用Add方法，为列表添加新的string型对象时，都能很顺利地执行，当执行到使用Add方法为列表添加一个int型对象时，编译器会提示错误。 通过上面的讲解和例子，各位读者都应该已经明白了C#语言引入泛型机制的原因和必要性了。下面做一个简单的总结，引入泛型所提供的好处有以下3点。 (1)类型安全：使用泛型类型或泛型方法来操作一个具体的数据类型时，编译器能够理解开发人员的意图，并且保证只有与制定数据类型兼容的对象才能用于该泛型类型或泛型方法。当使用不兼容类型的对象时，则会造成编译错误，甚至是在运行时抛出异常。例如在上面的代码中，对一个声明了操作类型为string的列表添加int型数据时，编译器会报错。 (2)更加清晰的代码：正如本章开始所说的，在没有引入泛型机制的C#1的时代，源代码中不得不进行的强制类型转换次数是很多的，因此代码相对不易维护和拓展。在引入了泛型机制后，源代码中不必进行很多强制类型转换，因此代码变得更加容易维护。例如在上面的代码中，将List&lt;T&gt;中索引为0的元素取出来，并且赋值给一个sting型的变量s的过程中并没有强制类型转换。 (3)更加优秀的性能：同样在本章开始就提到过的，如果没有泛型机制的话，为了使用同一套常规化的逻辑方法，则必须使用object作为参数或返回值的类型。但一个不得不承认的事实是，object类型其本身其实是一个很“没有用”的存在，这是由于如果要使用object做一些真正具体有意义的事情，则几乎不得不进行强制类型转换，转换成目标类型。同时，由于object是引用类型，当实际操作类型是值类型时，则又面临另一个十分影响性能的操作——装箱操作。Mono运行时将不得不在调用该逻辑方法之前对值类型实例进行装箱。但是，引入泛型机制后，由于能够通过该机制创建一个泛型类型或泛型方法来操作值类型，因此值类型的实例就无须执行装箱操作，反而可以直接通过传值的方式来传递了。与此同时，由于无须进行强制类型转换，因此在Mono运行时无须去验证这种转型是否类型安全。泛型机制使得大量的安全检查从运行时转移到了编译时进行，因此提高了代码的运行速度。 Unity 3D中常见的泛型由于C#2的语言规范提供了丰富的实现细节，基本涵盖了泛型在所有可以预见的情况下可能的行为。不过，这并不意味着我们必须了解泛型所有的实现细节，才能写出高效简洁的代码。因此，为了让各位读者尽可能快的了解和掌握泛型在Unity 3D开发中的使用方法，本节将主要介绍在日常开发过程中使用泛型所需要的大多数的知识点。 首先要说明的一点是，使用泛型机制最明显的是一些集合类。例如在System.Collections.Generic和System.Collections.ObjectModel命名空间中提供了很多泛型集合类，例如之前用到的泛型类List&lt;T&gt;。而基于前一节中的结论，即使用泛型集合类是类型安全的，而且代码更加清晰、易于维护，同时还拥有更加出色的运行性能。除此之外，泛型类比非泛型类拥有更好的对象模型，一个直观的事实就是泛型类的虚方法更少，性能更好。因此建议各位读者使用泛型集合类，而不要使用非泛型类。 当然， C#游戏脚本语言还提供了许多泛型接口。而插入集合中的元素则可以通过实现接口来执行例如排序、查找等操作。常常提到的List&lt;T&gt;类就实现了IList&lt;T&gt;泛型接口，而常用的泛型接口往往也定义在System.Collection.Generic命名空间中。 除此之外，一个看上去和泛型好像没有什么关系的类——System.Array类，同样值得注意。作为所有数组类型的基类，System.Array类提供了很多静态泛型方法，例如AsReadOnly、BinarySearch、ConvertAll、Exists、Find、FindAll、FindIndex、FindLast、FindLastIndex、ForEach、IndexOf、LastIndexOf、Resize、Sort、TrueForAll等。 Array中定义的这些静态泛型方法的使用，代码如下。 12 另一个使用泛型的例子，是随着泛型机制的引入而引入的泛型字典——Dictionary&lt;TKey, TValue&gt;类。那么接下来会使用Dictionary&lt;TKey, TValue&gt;类来说明泛型类型是如何使用的。此时无须了解泛型是如何使用的，也无须熟悉泛型的语法，通过下面对Dictionary&lt;TKey, TValue&gt;类的操作，很快就能了解泛型的使用方法，并且摸索到如何写出可以运行的代码的方法。而泛型更加方便的一点，就在于泛型的出现将很多运行时才需要的检查转移到了编译时。因此，如果能够顺利通过编译时，那么这段代码就有很大的几率能够正常运行，这对初次接触泛型的开发者来说是一件十分方便的事情。 假设要开发一款战略游戏，其中存在军队（Army类）、英雄（Hero类）、士兵（Soldier类）的概念，军队是英雄和士兵的集合，而英雄和士兵又同时从同一个基类——游戏单位（BaseUnit类）派生而来，那么下面通过一个使用Dictionary&lt;TKey, TValue&gt;类来统计某个军队中某个种类的英雄出现次数的例子，来学习泛型的使用方法，代码如下。 12 首先要说的是，在CountHeros这个方法中，实现了将英雄名字（string类型）和该英雄的出现次数（int类型）一一映射的功能。对于当前军队中的每一个英雄的名字，都要先检查一下它是否已经存在了这种映射关系，也就是说在字典中是否有以该英雄名字作为Key的那组映射关系。如果存在，则计数加一，也就是对应的Value的值加一。如果不存在，则要为这个英雄的名字和它出现的次数创建一种映射关系，也就是说要在字典中增加一个以英雄名字为Key， 1为Value的元素。这里要注意的是，对Value值的修改，并不需要执行int型的强制类型转换，因为使计数递增的步骤是先对映射的索引器执行一次取值操作，取得当前的值之后再执行加一，最后在对索引器执行赋值操作。 其实“tempCounts[bu.name] += 1;”这行代码等效于下面3行代码。 123int temp = tempCounts[bu.name];temp += 1;tempCounts[bu.name] = temp; 而最后需要指出的一点是如何遍历一个字典。在代码中，使用了KeyValuePair&lt;TKey, TValue&gt;这个泛型类来实现对字典的访问，其中这个类型拥有两个属性，即Key和Value，而Key和Value的返回类型通过传递类型实参便可以确定。 但是在没有引入泛型机制之前，和Dictionary&lt;TKey, TValue&gt;类功能类似的一个类，也是在第4章提到过的Hashtable类中，也有类似的类来实现遍历和访问的功能，那就是DictionaryEntry类，其中也有Key和Value这两个属性。但是由于没有泛型机制，因此为了实现普遍兼容各个类型的目的，Key和Value这两个属性返回的都是object类型。因此，如果不引入泛型机制，则在遍历字典时对heroName和count这两个变量赋值前需要进行从object到string和int的强制类型转换。同时，由于要调用Debug.Log方法，count还需要执行装箱操作。从这个小小的细节也能看出引入泛型机制的重要性。 接下来让我们继续通过Dictionary&lt;TKey, TValue&gt;这个例子来探索一下泛型的真正含义。什么是T、TKey和Tvalue？为什么它们要被“&lt;&gt;”括起来？ 泛型机制的基础上一节演示了一个使用泛型的实际情景。但是泛型机制从无到有，这背后到底发生了一些什么事情呢？ 为了使泛型能够正常工作，C#语言的开发人员需要完成哪些工作呢？下面就简单列举一些为了实现泛型，而必须完成的一些工作。 需要创建新的CIL指令，在CIL的层面实现识别类型实参的功能。 修改引入泛型之前的元数据表的格式，使具有泛型参数的类型和方法能够正确表示。 修改具体的编程语言，例如C#，使之能够支持新的语法。 修改编译器（编程语言编译为CIL的编译器），使编程语言（C#）能够正确地被编译为对应的CIL代码。 修改JIT编译器（CIL代码编译为原生代码），使新创建的处理类型实参的CIL代码能够被正确地编译为对应平台的原生代码。 创建新的反射成员，使开发人员能够查询类型和成员，同时判断它们是否具有泛型参数。同时使开发人员能够在运行时创建泛型类型和泛型方法。 通过完成以上的工作，C#语言终于具备了泛型的机制。在Unity 3D的开发过程中，C#游戏脚本语言提供的泛型机制主要可以分为以下两种形式。 (1)泛型类型：包括类、接口、委托以及结构（值类型），但是需要注意的是并不包括泛型枚举。 (2)泛型方法。 泛型类型和类型参数泛型类型又可以细分成很多不同的种类，例如Dictionary&lt;TKey, TValue&gt;是泛型类，Dictionary&lt;TKey, TValue&gt;则是泛型接口。当然还有泛型委托和泛型结构。但泛型类型，同样还是一个表示一个API的基本形式，用一个类型参数来代表在使用时期望的类型。也就是说类型参数是真实类型（类型实参）的占位符。可以说类型参数实现了接受信息的功能，类型实参则提供实际的类型信息，这种关系和方法参数与方法实参的关系十分类似。只不过类型实参必须是类型，而不能是别的值。 可以看到在声明一个新的Dictionary&lt;TKey, TValue&gt;时，例如声明一个新的变量“Dictionary&lt;string, int&gt; counts = new Dictionary&lt;string, int&gt;();”也就是说要将类型参数放到一对尖括号(&lt;&gt;)内，并且在必要的时候使用逗号来间隔。而Dictionary&lt;TKey, TValue&gt;类的类型参数是Tkey，代表字典中键的类型；TValue代表字典中值的类型。当声明一个具体Dictionary&lt;TKey, TValue&gt;类的实例时，需要传入真实的类型，就像上面那行代码中的TKey是string型，TValue是int型。 但是需要注意的是，Mono运行时会为各种类型创建类型对象（即类型实例）的内部数据结构。拥有泛型类型参数的泛型类型同样是类型，因此Mono运行时同样会为它创建内部的类型对象。但是如果没有指定泛型类型中类型参数的具体类型，在这种情况下Mono运行时是禁止创建它的实例的，而这种情况下具有泛型类型参数的类型就被称为开放类型。例如要创建一个没有指定TKey和TValue具体类型的类Dictionarys&lt;,&gt;的实例是不会成功的，这里Dictionarys&lt;,&gt;便是一个开放类型。 与开放类型相反的是封闭类型，我们称为所有类型参数都传递了实际的数据类型的类型为封闭类型，例如Dictionary&lt;string, int&gt;便可以被称为封闭类型。如果不是所有的类型参数都被指定，而是有部分类型参数未被指定，那么也不是封闭类型，也不能创建该类型的实例。开放类型和封闭类型的各自特点，代码如下。 12 编译上面这段代码，并且运行生成的程序，可以看到在调试窗口输出的内容如下所示。 12 可以看到在Actiator类调用CreateInstance方法来试图创建新的实例时，分别抛出了两个ArgumentException异常。分别是“System.Collections.Generic.Dictionary’2[TKey,TValue] is an open generic type”以及“DictionaryOnePara’1[TValue] is an open generic type”，异常消息的内容翻译过来就是无法创建该类型实例，因为该类型是开放类型。而最后由于是创建封闭类型的实例，因此很正常地创建了出来。因此，了解泛型类型在使用过程中的开放类型和封闭类型的特点，也是十分重要的。 不过既然说泛型类型也是类型，那么泛型类型是否能够派生和继承呢？下面就介绍一下泛型类型和继承。 泛型类型和继承泛型类型仍然是类型，因此它能继承别的类型，也能派生出别的类型。当指定一个泛型类型的类型参数后，Mono运行时实际上会在幕后定义一个新的类型对象，而这个新的类型对象也从泛型类型继承的那个类型派生。 举一个例子，由于Dictionary&lt;TKey, TValue&gt;派生自Object类，因此Dictionary&lt;string， int也是从Object类派生的。同样在上面的例子中， DictionaryOnePara从Dictionary&lt;string， TValue&gt;类派生， 因此DictionaryOnePara-int&gt;也是从Dictionary&lt;string，TValue&gt;派生的。简单地说，指定类型实参后， Mono运行时虽然创建了一个新的类型，但是并不影响继承关系。 那么泛型类型的类型参数被指定后，到底是如何被编译成一个新的类型的呢?具体而言，对那些使用了泛型类型参数的代码进行JIT编译时， Mono运行时首先会获取其对应的CIL代码，并且用你指定的类型实参进行替换，最后将类型替换后的CIL代码编译为原生代码，因此指定了实参的泛型类型，实际上已经是一个新的类型了。但各位读者可能都能看到这种方式存在一个很大的隐患，那就是Mono运行时可能要为所有的“方法/实参类型”的组合生成一套原生代码，这样导致的后果就是代码编译后变得“臃肿不堪”。但是Mono运行时内部采用了一套优化机制来避免这种情况的发生，也就是使某个编译后的“方法实参类型”组合能够复用。假如某个特定的类型是某个泛型方法的类型实参，该“方法/实参类型”组合只需要被编译一次，之后再调用该方法就不需要再次编译了。例如一个Dictionary-string， int&gt;被编译一次，之后代码中再出现Dictionary&lt;string， inp就不需要编译了。除此之外， Mono运行时还有另一个优化，就是它认为所有的引用类型的实参都是完全相同的，这是因为所有的引用类型的实参，甚至是变量都是指向托管堆上某个对象的指针，因此可以采用统一的方式来处理。例如，List和List的代码编译之后都是相同的，因为它们的类型实参String和Stream都是引用类型。但是与此相反的是，如果类型实参是值类型，则必须单独编译成原生代码。 泛型接口和泛型委托提到泛型类型，人们大多想到的是类(引用类型)或者结构(值类型) ，但是还有一些也是属于泛型类型范畴的，例如泛型接口和泛型委托。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏实现中的设计模式]]></title>
    <url>%2F2019%2F08%2F09%2F%E6%B8%B8%E6%88%8F%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么要使用设计模式来进行游戏开发？ 设计模式非常重要的一点是把类作为方法的参数。一个类的构造函数里的参数是另一个类。 123456void Demo(Test test)&#123; test.testFunc();&#125;testInstance = new Test();Demo(testInstance); 设计模式的起源面向对象设计方法中强调的是，以类、对象、继承、组合来作为软件设计分析的方式（核心是类与对象，不像PHP，还有独立的函数参与其中）。所以，程序设计师在实现的过程中，必须将软件功能拆分成不同的类/组件，之后再将这些不同的类/组件加以组装、堆砌来最终完成软件的开发。 多样性的软件功能应用，使得程序设计师在使用面向对象程序设计语言时也增加了许多挑战，例如如何将软件功能进行切分、减少功能之间的重复、有效地链接不同功能都在不断地考验着程序设计师的系统分析及实现能力。 所以，通过引入“模式”的概念，让软件设计也能像建筑设计一样，以经验累积的方式，将一些经常用来解决特定情况的“类设计”“对象组装”加以整理并定义成为一种“设计模式”。而这些“软件的设计模式”，让开发者在以后遇到相同的问题时，可以从中找出对应的解决方法直接使用，不必再思考如何分析和设计。这样一来，除了能够减少不必要的时间花费之外，也能加强软件系统的“稳定性”和“可维护性”。 软件的设计模式是什么?我们可以将设计模式定义如下: 1每一种模式都在说明某种一再出现的问题，并描述解决方法的核心，之后让你能够据以变化出各种招式，来解决上万个类似的问题。 每一种设计模式除了按照“面向对象设计的原则”加以分析设计之外，它们还满足以下几项要求: 解决一再出现的问题解决问题的方案和问题核心的关键点可以重复使用的解决方案 面向对象设计中常见的设计原则单一职责原则(SRP: Single Responsibility Principle) 这个原则强调的是“当设计封装一个类时，该类应该只负责一件事”。当然，这与在类抽象化的过程中，对于该类应该负责哪些功能有关。一个类应该只负责系统中一个单独功能的实现，但是对于功能的切分和归属，通常也是开发过程中最困扰设计者的。程序设计师在一开始时不太容易遵循这个原则，会在项目开发过程中，不断地向同一类上增加功能，最后导致类过于庞大、接口过于复杂后才会发现问题:单个类负责太多的功能实现，会导致类难以维护，也不容易了解该类的主要功能，最后可能会让整个项目过度依赖于这个类，使得项目或这个类失去弹性。 但是，只要通过不断地进行“类重构”，将类中与实现相关功能的部分抽取出来，另外封装为新的类，之后再利用组合的方式将新增的类加入到原类中，慢慢地就能符合类单-职责化的要求一也就是项目中的每一个类只负责单一功能的实现。 开一闭原则(OCP: Open-Closed Principle) 一个类应该“对扩展开放、对修改关闭”。什么是对扩展开放，又如何对修改关闭呢?其实这里提到的类，指的是实现系统某项功能的类。而这个功能的类，除非是修正功能错误，否则，当软件的开发流程进入“完工测试期”或“上市维护期”时，对于已经测试完成或已经上线运行的功能，就应该“关闭对修改的需求”，也就是不能再修改这个类的任何接口或实现内容， 但是，当增加系统功能的需求发生时，又不能置之不理，所以也必须对“功能的增加保持开放”。为了满足这个原则的要求，系统分析时就要朝向“功能接口化”的方向进行设计，将系统功能的“操作方法”向上提升，抽象化为“接口”，将“功能的实现”向下移到子类中。因此，在面对增加系统功能的需求时，就可以使用“增加子类”的方式来满足。具体的实现方式是:重新实现一个新的子类，或者继承旧的实现类，并在新的子类中实现新增的系统功能。这样，对于旧的功能实现就可以保持不变(关闭)，同时又能够对功能新增的需求保持开放。 里氏替换原则(LSP: Liskov Substitution Principle) 这个原则指的是“子类必须能够替换父类”。如果按照这个设计原则去实现一个有多层继承的类群组，那么其中的父类通常是“接口类”或“可被继承的类”。父类中一定包含了可被子类重新实现的方法，而客户端使用的操作接口也是由父类来定义的。客户端在使用的过程中，必须不能使用到“对象强制转型为子类”的语句，客户端也不应该知道，目前使用的对象是哪一个子类实现的。至于使用哪个子类的对象来替代父类对象，则是由类本身的对象产生机制来决定，外界无法得知。里氏替换原则基本上也是对于开一闭原则提供了一个实现的法则，说明如何设计才能保持正确的需求开放 依赖倒置原则(DIP: Dependence Inversion Principle) 这个原则包含了两个主题:高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念;抽象接口不应该依赖于实现，而实现应该依赖于抽象接口。 从生活中举例来解释第一个原则主题(高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念)，可能会比单纯使用软件设计来解释更为容易，所以下面就以汽车为例进行说明。 汽车与汽车的引擎就是一个很明显违反这个原则的例子:汽车就是所谓的高层模块，当要组装一台汽车时，需要有不同的低层模块进行配合才能完成，如引擎系统、传动系统、悬吊系统、车身骨架系统、电装系统等，有了这些低层模块的相互配合才能完成一辆汽车。但汽车却很容易被引擎系统给限定，也就是说，装载无铅汽油引擎的汽车不能使用柴油作为燃料;装载柴油引擎的汽车不能使用无铅汽油作为燃料。每当汽车要加油时，都必须按照引擎的种类选择对应的加油车道，这就是“高级模块依赖于低层模块”的例子，这个高级模块现在有了限制-汽车因为引擎而被限制!了加油的品项。虽然这是一个很难去改变的例子，但是在软件系统的设计上，反倒有很多方法可以解除这个“高层依赖于低层”的问题，也就是将它们之间的关系反转，让低层模块按高层模块所定义的接口去实现 以个人计算机(PC)的组成为例，位于高层的个人计算机中定义了USB接口，而这个接口定义了硬件所需的规格及软件驱动程序的编写规则。只要任何低层模块，如存储卡、U盘、读卡器、相机、手机等符合USB接口规范的，都能加入个人计算机的模块中，成为计算机功能的一环共同为用户提供服务。 上述个人计算机的例子足以说明如何由“高层模块定义接口”再由“低层模块遵循这个接口实现”的过程，这个过程可以让它们之间的依赖关系反转。同时，这个反转的过程也说明了第二项原则主题的含义: “抽象接口不应该依赖于实现，而实现应该依赖于抽象接口”。当高层模块定义了沟通接口之后，与低层模块的沟通就应该只通过接口来进行，在具体实现上，这个接口可能是以一个类的变量或对象引用来表示的。请注意，在使用这个变量或对象引用的过程中，不能做任何的类型转换，因为这样就限定了高层模块只能使用某一个低层模块的特定实现。而且，子类在重新实现时，都要按照接口类所定义的方法进行实现，不应该再新增其他方法，让高层模块有利用类型转换的方式去调用的机会。 接口隔离原则(ISP: Interface Segregation Principle) “客户端不应该被迫使用它们用不到的接口方法”，这个问题一般会随着项目开发的进行而越来越明显。当项目中出现了一个负责主要功能的类，而且这个类还必须负责跟其他子系统进行沟通时，针对每一个子系统的需求，主要类就必须增加对应的方式。但是，增加越多的方法就等同于增加类的接口复杂度。因此，每当要使用这个类的方法时，就要小心地从中选择正确的方法，无形之中增加了开发和维护的困难度。通过“功能的切分”和“接口的简化”可以减少这类问题的发生，或者运用设计模式来重新规划类，也可以减少不必要的操作接口出现在类中。 除了上述5个原则外，还有一些常被使用的设计原则，简介如下: 最知识原则(LKP: Least Knowledge Principle) 当设计实现一个类时，这个类应该越少使用到其他类提供的功能越好。意思是，当这个类能够只靠其本身的“知识”去完成功能的话，那么就相对地减少与其他对象“知识”的依赖度。这样的好处是减少了这个类与其他类的耦合度(即依赖度)，换个角度来看，就是增加了这个类被不同项目共享的可能性，这将会提高类的重用性。 少用继承多用组合原则 当子类继承一个“接口类”后，新的子类就要负责重新实现接口类中所定义的方法，而且不该额外扩充接口，以符合上述多个设计原则的要求。但是，当系统想要扩充或增加某一项功能时，让子类继承原有的实现类，却也是最容易实现的方式之一。新增的子类在继承父类后，在子类内增加想要扩充的“功能方法”并加以实现，客户端之后就能直接利用子类对象进行新增功能的调用。但对于客户端或程序设计师而言，当下可能只是需要子类所提供的功能，并不想额外知道父类的功能，因为这样会增加程序设计师挑选方法时的难度。例如， “闹钟类”可以利用继承“时钟类”的方式，取得“时间功能”的实现，只要子类本身再另外加上“定时提醒”的功能，就能实现“闹钟功能”的目标。当客户端使用“闹钟类”时，可能期待的只不过是设定闹钟时间的方法而已，对于取得当前时间的功能并没有迫切的需求。因此，从“时钟父类”继承而来的方法，对于闹钟的用户来说，可能是多余的。 如果将设计改为在闹钟的类定义中，声明一个类型为时钟类的“类成员”，那么就可以减少不必要的方法出现在闹钟接口上，也可以减少“闹钟类”的客户端对“时钟类”的依赖性。另外，在无法使用多重继承的程序设计语言(如Java)中，使用组合的方式会比层层继承来得明白及容易维护，并且对于类的封装也有比较好的表现方式。 在了解了上述几个面向对象设计的原则之后，可以知道，面向对象设计的原则强调的是，在进行软件分析时所必须遵循的指导原则，而设计模式基本上都会秉持着这些原则来进行设计。也可以这样说， “设计模式”是在符合“面向对象设计原则”的前提下，解决软件设计问题的实践成果。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式与游戏完美开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Transform API]]></title>
    <url>%2F2019%2F08%2F08%2FTransform-API%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Transform组件是Unity中最常用的组件，因为每个GameObject都会有Transform组件。物体最基本的位置、旋转、缩放都是由这个组件提供的。物体的父子关系也是由这个组件提供的。 Transform组件的文档位于：https://docs.unity3d.com/ScriptReference/Transform.html 如何修改物体的位置/旋转/缩放？ 要想知道如何修改物体的位置/旋转/缩放，首先要知道如何获取，这时就要用到transform组件。 我们之前知道获取物体上的组件组要通过GetComponent获取，那么获取Transform组件就是GetComponent()。 其实在Unity中还有更简单的写法，就是直接使用transform。比如下面的代码： 123456789101112using UnityEngine;public class Test : MonoBehaviour&#123; private GameObject other; void Start () &#123; Debug.Log(transform.position); // 获取脚本所在物体的位置 Debug.Log(other.transform.position); // 获取其他物体的位置 &#125;&#125; 在脚本中可以直接使用transform成员，获得当前脚本所在物体的Transform组件。 对于其他物体，可以直接通过gameObject.transform来获取这一物体的transform组件。 世界坐标位置：position世界坐标旋转：rotation自身缩放（缩放不区分世界或本地坐标系）：localScale本地坐标位置（相对于父物体，即Inspector中看到的position）：localPosition本地坐标旋转：localRotation 上面提到的两个旋转，类型都是Quaternion（四元数），此外还有两种分别是eulerAngles和localEulerAngles分别代表世界坐标欧拉角和本地坐标欧拉角（Vector3类型）。 什么是四元数和欧拉角？ 四元数和欧拉角是两种表示旋转的表示方法。欧拉角比较直观，使用三维向量分别代表三个轴的旋转，但是存在万向锁的问题，所以引入了四元数的表示方法。Inspector面板中显示的旋转是欧拉角。后面也会详细解释。获取这些属性后，如何修改呢？除了rotation和localRotation的类型是Quaterniion，上述提到的其他属性，类型都是Vector3。 修改Transform组件中的属性例如： 1transform.position = new Vector3(0, 10, 0); 一定要注意Vector3类型在创建的时候，也需要通过new关键字来创建。 Vector3类型 Vector3是三维向量，分别用x、y、z三个float值来代表在x、y、z轴上的值。完整文档请见：https://docs.unity3d.com/ScriptReference/Vector3.html 如何修改物体的父子关系？ 修改物体的父子关系也是非常常见的一种操作。比如我们动态生成一个盒子，需要跟随一辆货车一起移动，最简单的办法就是将盒子变成货车的子物体。 设置物体的父物体是通过Transform中下面这个API： 12public void SetParent(Transform p);public void SetParent(Transform parent, bool worldPositionStays); 注意传入的参数时Transform类型，不是GameObject类型。默认情况下，使用第一种SetParent会保留物体的世界坐标、旋转、缩放，和在Hierarchy中直接调整父子关系类似。但是某些情况下我们想让物体的位置、旋转、缩放变成相对于父物体的位置、旋转、缩放。这时候就需要用到第二种形式，并且第二个参数worldPositionStays传入false。 调整父子关系，保留世界坐标 如上图中就是保留世界位置，Cube2的世界坐标位置没有变，但是相对于父物体的位置会发生变化。 如果使用下面的代码改变Cube2的父子关系，我们来看一下： 1234567891011using UnityEngine;public class Test : MonoBehaviour&#123; public Transform cube1; void Start () &#123; transform.SetParent(cube1, false); &#125;&#125; 不保留世界位置的SetParent.gif 执行的效果如上图，cube2的位置发生了变化。这是为什么呢？因为Cube2在设置父物体时不保留世界坐标的位置，原来世界坐标(3,0,0)会变成相对父物体的坐标，而父物体的位置是(1,0,0)，实际上Cube2最终的世界坐标会变成(4,0,0)，所以位置发生了变化。大多数需要worldPositionStays为false的情况都是在动态生成UI的时候。 如何获取物体的所有子物体？ 可以通过foreach循环遍历一个物体的所有子Transform组件。 123456789public Transform cube1;void Start ()&#123; foreach (Transform tran in cube1) &#123; Debug.Log(tran.gameObject.name); &#125;&#125; 当然也可以通过for循环来获取一个物体的所有子物体： 123456789public Transform cube1;void Start ()&#123; for (int i = 0; i ‹ cube1.childCount; i++) &#123; Debug.Log(cube1.GetChild(i).name); &#125;&#125; childCount可以获取子物体的个数，GetChild(index)方法可以获取第index个子物体。 如何查找子物体？ 有些情况我们需要在一个物体的子物体中按名称查找物体，这时候可以用到Transform组件中的Find方法。 public Transform Find(string n);查找时也可以使用/类似路径来使用。比如下面特别注意1中的例子。 特别注意1Transform的Find方法只能查找第一层的子物体。 比如这个图中查找GameObject的子物体，就只能查找sphere1和sphere2，无法找到sphere3，如果想找sphere3，就必须使用’sphere2/sphere3’作为参数比如这个图中查找GameObject的子物体，就只能查找sphere1和sphere2，无法找到sphere3，如果想找sphere3，就必须使用’sphere2/sphere3’作为参数 特别注意2这个方法可以找到active是false的物体。（与GameObject.Find的区别） 如何旋转一个物体？ 旋转物体通常是新手的一个难点。 最开始我们需求最多的可能是物体自身旋转x度。这时候需要用到的API是： 1public void Rotate(Vector3 eulers, Space relativeTo = Space.Self); 这个API的第一个参数是在x、y、z轴上旋转的度数。比如只沿y轴旋转30度，需要传入new Vector3(0, 30, 0)。第二个参数是相对的坐标空间。枚举中有两个值可以选择：Space.World和Space.Self。 选择Space.World时，物体是沿着世界坐标轴的方向进行旋转。绿色的线是沿Y轴旋转。 SpaceWorld.gif 选择Space.Self时，物体是沿着自身坐标轴的方向进行旋转。绿色的线是沿Y轴旋转。 SpaceSelf.gif 还有一个API是RotateAround，这个旋转可以让物体围绕一个物体旋转，比如地球绕太阳公转。 1public void RotateAround(Vector3 point, Vector3 axis, float angle); 在世界坐标系统，围绕一个点point的axis轴旋转angle度。 比如下面的例子： 1234567891011using UnityEngine;public class Test : MonoBehaviour&#123; public Transform sun; void Update() &#123; transform.RotateAround(sun.position, sun.up, 1); &#125;&#125; 围绕太阳的位置的up方向，也就是物体本地坐标轴绿色轴的方向，每帧旋转1度（这种方式实际不太合理，我们明天会仔细讲）。 地球围绕太阳旋转.gif 官方Transformclass in UnityEngine/Inherits from:Component/Implemented in:UnityEngine.CoreModuleLeave feedbackSWITCH TO MANUALDescriptionPosition, rotation and scale of an object. Every object in a Scene has a Transform. It’s used to store and manipulate the position, rotation and scale of the object. Every Transform can have a parent, which allows you to apply position, rotation and scale hierarchically. This is the hierarchy seen in the Hierarchy pane. They also support enumerators so you can loop through children using: using UnityEngine; public class Example : MonoBehaviour{ // Moves all transform children 10 units upwards! void Start() { foreach (Transform child in transform) { child.position += Vector3.up * 10.0f; } }}See Also: The component reference, Physics class. PropertieschildCount The number of children the parent Transform has.eulerAngles The rotation as Euler angles in degrees.forward The blue axis of the transform in world space.hasChanged Has the transform changed since the last time the flag was set to ‘false’?hierarchyCapacity The transform capacity of the transform’s hierarchy data structure.hierarchyCount The number of transforms in the transform’s hierarchy data structure.localEulerAngles The rotation as Euler angles in degrees relative to the parent transform’s rotation.localPosition Position of the transform relative to the parent transform.localRotation The rotation of the transform relative to the transform rotation of the parent.localScale The scale of the transform relative to the parent.localToWorldMatrix Matrix that transforms a point from local space into world space (Read Only).lossyScale The global scale of the object (Read Only).parent The parent of the transform.position The world space position of the Transform.right The red axis of the transform in world space.root Returns the topmost transform in the hierarchy.rotation A quaternion that stores the rotation of the Transform in world space.up The green axis of the transform in world space.worldToLocalMatrix Matrix that transforms a point from world space into local space (Read Only).Public MethodsDetachChildren Unparents all children.Find Finds a child by n and returns it.GetChild Returns a transform child by index.GetSiblingIndex Gets the sibling index.InverseTransformDirection Transforms a direction from world space to local space. The opposite of Transform.TransformDirection.InverseTransformPoint Transforms position from world space to local space.InverseTransformVector Transforms a vector from world space to local space. The opposite of Transform.TransformVector.IsChildOf Is this transform a child of parent?LookAt Rotates the transform so the forward vector points at /target/‘s current position.Rotate Use Transform.Rotate to rotate GameObjects in a variety of ways. The rotation is often provided as a Euler angle and not a Quaternion.RotateAround Rotates the transform about axis passing through point in world coordinates by angle degrees.SetAsFirstSibling Move the transform to the start of the local transform list.SetAsLastSibling Move the transform to the end of the local transform list.SetParent Set the parent of the transform.SetPositionAndRotation Sets the world space position and rotation of the Transform component.SetSiblingIndex Sets the sibling index.TransformDirection Transforms direction from local space to world space.TransformPoint Transforms position from local space to world space.TransformVector Transforms vector from local space to world space.Translate Moves the transform in the direction and distance of translation.Inherited MembersPropertiesgameObject The game object this component is attached to. A component is always attached to a game object.tag The tag of this game object.transform The Transform attached to this GameObject.hideFlags Should the object be hidden, saved with the Scene or modifiable by the user?name The name of the object.Public MethodsBroadcastMessage Calls the method named methodName on every MonoBehaviour in this game object or any of its children.CompareTag Is this game object tagged with tag ?GetComponent Returns the component of Type type if the game object has one attached, null if it doesn’t.GetComponentInChildren Returns the component of Type type in the GameObject or any of its children using depth first search.GetComponentInParent Returns the component of Type type in the GameObject or any of its parents.GetComponents Returns all components of Type type in the GameObject.GetComponentsInChildren Returns all components of Type type in the GameObject or any of its children.GetComponentsInParent Returns all components of Type type in the GameObject or any of its parents.SendMessage Calls the method named methodName on every MonoBehaviour in this game object.SendMessageUpwards Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.TryGetComponent Gets the component of the specified type, if it exists.GetInstanceID Returns the instance id of the object.ToString Returns the name of the GameObject.Static MethodsDestroy Removes a gameobject, component or asset.DestroyImmediate Destroys the object obj immediately. You are strongly recommended to use Destroy instead.DontDestroyOnLoad Do not destroy the target Object when loading a new Scene.FindObjectOfType Returns the first active loaded object of Type type.FindObjectsOfType Returns a list of all active loaded objects of Type type.Instantiate Clones the object original and returns the clone.Operatorsbool Does the object exist?operator != Compares if two objects refer to a different object.operator == Compares two object references to see if they refer to the same object.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GameObject API]]></title>
    <url>%2F2019%2F08%2F08%2FGameObject-API%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 如何在脚本中获取自身所在的GameObject？ Debug.Log的二个参数形式有什么作用？ 如何通过物体名字查找物体？ GameObject.Find()有什么缺点？如何解决？ 如何修改物体的active状态？ activeInHierarchy和active有什么区别？ 如何用代码创建空物体？ 如何用代码创建内置几何体？ 怎么得到游戏对象的layer，tag和所在场景名？ 如何给游戏对象添加组件？ GameObject本身没有功能，它是组件的容器，很多时候我们需要在脚本中操作GameObject。 如何在脚本中获取自身所在的GameObject？我们知道脚本必须挂在一个GameObject上面才能执行，那么如何知道当前脚本所挂载的GameObject是哪一个呢？ 这就需要用到gameObject属性了。 gameObject属性可以在所有继承MonoBehaviour的类中获取到，因为脚本必须要挂载到一个物体上才能执行，这个gameObject就是脚本挂到的物体。 123456789using UnityEngine;public class Test : MonoBehaviour&#123; void Start () &#123; Debug.Log(gameObject.name, gameObject); &#125;&#125; 上面的代码就会打印出脚本所挂物体的名字。 注意这里Debug.Log传入了两个参数，这是为什么呢？ 遇到这种问题，我们首先查一下Unity的文档。 为什么要查Unity的文档呢？ 从图中可以看到，将光标移到Debug上面时，显示Debug类是属于UnityEngine这个命名空间的，也就是Unity提供的API。 Debug.Log有两种形式： 12public static void Log(object message);public static void Log(object message, Object context); 第二种形式中可以传入一个Object类型的参数，传入这个参数时，在Console中显示的log会与脚本所在的物体关联。点击Console中这条信息时，会在Hierarchy中高亮这一个物体。 Log关联GameObject 如何通过物体名字查找物体？GameObject类中有一个静态（static）方法Find，用于通过名字查找场景中的物体。 什么是静态方法？ 静态方法是标记为static的方法。静态方法独立于实例对象存在。即使没有类的实例，仍然可以通过类名.静态方法调用。静态方法中不能访问实例成员，可以访问其他静态成员。 静态方法在定义时需要在返回值类型前面加上static修饰符，比如： 1234static void Walk()&#123; Debug.Log("Walking");&#125; 访问时，可以直接通过类名.方法名调用。比如查找物体的方法就是GameObject.Find(“cat”)。 查找的名称字符串中可以包含“/”，比如GameObject.Find(“animals/cat”）就只会查到父物体名字为animals的cat物体。如果“/”字符在字符串中最开始的位置，那么会在根节点开始找，比如GameObject.Find(“/animals/cat”)就只会查到根节点为animals物体的子物体cat。 查找过后，一定要判断一下是否为空，因为Find有可能找不到你想找的物体。 特别注意1 这个方法的效率比较低，不要在Update中调用此方法，否则可能会造成游戏卡顿。一般的做法是，在Awake或Start方法中通过Find找到，然后保存到成员变量中。 比如： 12345678910111213using UnityEngine;public class Test : MonoBehaviour&#123; private GameObject cat; void Start() &#123; cat = GameObject.Find("cat"); if(cat != null) Debug.Log("找到了cat物体", cat); &#125;&#125; 特别注意2 这个方法无法找到active为false的物体。 那么如何查找active为false的物体呢？ 1、不要使用Find，直接在代码中通过public的变量关联物体。 2、不要设置物体的active为false，先在游戏最开始时通过代码找到物体，然后通过代码设为false。 3、通过transform.Find。 如何修改物体的active状态？修改物体的active状态是一个快速隐藏/显示物体的方法。物体的active是false时，物体上所有的组件都不会执行，相当于将物体隐藏了。 1gameObject.SetActive(false); 特别注意 这个方法只会改变物体自身的active属性。如果该物体有子物体，那么子物体也会被隐藏，但是active属性不会变。如果该物体的父物体的active是false，即使将该物体的active设置为true，该物体也不会显示出来。 物体的active可以通过两个属性来判断： activeInHierarchy 物体是否在Hierarchy中是激活状态。这个属性为true时，则可知该物体及其所有父物体的active都为true。 activeSelf 物体自身的active属性是否为true，即使该物体的父物体的active可能为false。 如何通过tag查找物体？除了通过物体的name查找物体，通过物体的tag也可以查找。Tag即在Inspector上设置的一个标签，如下图所示： 一个物体只能有一个Tag，但是一个Tag可以被多个物体使用。 通过tag查找有两个方法： 1public static GameObject FindWithTag(string tag); 返回第一个查找到的标签为tag的active为true的物体（以字母排序），如果没有找到则返回null。 tag必须在TagManager中设置过，否则会抛出异常。异常内容是：UnityException: Tag: cat is not defined.含义是：标签：cat 没有定义。 1public static GameObject[] FindGameObjectsWithTag(string tag); 由于一个Tag可以被多个物体使用，所以这个方法可以找到所有使用该标签的active为true的物体，并返回对应的数组。如果没有找到，会返回一个空数组（长度为0的数组）。 tag必须在TagManager中设置过，否则会抛出异常。异常内容是：UnityException: Tag: xxx is not defined.含义是：标签：xxx 没有定义。 如何用代码创建空物体？有时候为了组织Hierarchy的结构，需要动态创建空物体作为文件夹使用。 创建空物体可以使用如下代码： 123GameObject go = new GameObject();go.name = "EmptyGameObject";GameObject dog = new GameObject("Puppy"); new的时候可以传入一个字符串作为GameObject的名字。也可以不传，默认名字是New Game Object。也可以创建后再修改空物体的名字。 如何用代码创建内置几何体？通过代码也很容易创建Unity中的几种默认几何体。 1public static GameObject CreatePrimitive(PrimitiveType type); 其中PrimitiveType是一个枚举（enum）类型，包括的类型有：Sphere、Capsule、Cylinder、Cube、Plane、Quad。 具体的用法如下： 1GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube); 上面的代码可以创建一个Cube，和通过菜单栏GameObject › 3D Object › Cube创建出来的Cube一致。 什么是枚举？ 枚举是一组命名整型常量。枚举类型是使用enum关键字声明的。 C#枚举是值类型。换句话说，枚举包含自己的值，且不能继承或传递继承。 声明枚举的一般语法： 1234enum ‹enum_name›&#123; enumeration list &#125;; 其中， enum_name 指定枚举的类型名称。 enumeration list 是一个用逗号分隔的标识符列表。 枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。默认情况下，第一个枚举符号的值是0。例如： 1enum Days &#123; Sun, Mon, tue, Wed, thu, Fri, Sat &#125;; 使用时，可以使用Days.Sun来表示星期日。 官方文档class in UnityEngine / Inherits from:Object / Implemented in:UnityEngine.CoreModule DescriptionBase class for all entities（实体） in Unity Scenes. Properties 属性 作用 activeInHierarchy Defines whether the GameObject is active in the Scene. activeSelf The local active state of this GameObject. (Read Only) isStatic Editor only API that specifies if a game object is static. layer The layer the game object is in. 返回数字 scene Scene that the GameObject is part of.返回UnityEngine.SceneManagement.Scene,obj.scene.name可得到场景名 tag The tag of this game object. transform The Transform attached to this GameObject. Constructors 名称 作用 GameObject Creates a new game object, named name. Public Methods 名称 作用 AddComponent Adds a component class named className to the game object. BroadcastMessage Calls the method named methodName on every MonoBehaviour in this game object or any of its children. CompareTag Is this game object tagged with tag ? GetComponent Returns the component of Type type if the game object has one attached, null if it doesn’t. GetComponentInChildren Returns the component of Type type in the GameObject or any of its children using depth first search. GetComponentInParent Returns the component of Type type in the GameObject or any of its parents. GetComponents Returns all components of Type type in the GameObject. GetComponentsInChildren Returns all components of Type type in the GameObject or any of its children. GetComponentsInParent Returns all components of Type type in the GameObject or any of its parents. SendMessage Calls the method named methodName on every MonoBehaviour in this game object. SendMessageUpwards Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor（祖先） of the behaviour. SetActive Activates/Deactivates the GameObject, depending on the given true or false value. Static Methods 名称 作用 CreatePrimitive Creates a game object with a primitive mesh renderer and appropriate collider. Find Finds a GameObject by name and returns it. FindGameObjectsWithTag Returns a list of active GameObjects tagged tag. Returns empty array if no GameObject was found. FindWithTag Returns one active GameObject tagged tag. Returns null if no GameObject was found. Inherited Members Properties 名称 作用 hideFlags Should the object be hidden, saved with the Scene or modifiable by the user? name The name of the object. Public Methods 名称 作用 GetInstanceID Returns the instance id of the object. ToString Returns the name of the GameObject. Static Methods 名称 作用 Destroy Removes a gameobject, component or asset. DestroyImmediate Destroys the object obj immediately. You are strongly recommended to use Destroy instead. DontDestroyOnLoad Do not destroy the target Object when loading a new Scene. FindObjectOfType Returns the first active loaded object of Type type. FindObjectsOfType Returns a list of all active loaded objects of Type type. Instantiate Clones the object original and returns the clone. Operators 名称 作用 bool Does the object exist? operator!= Compares if two objects refer to a different object. operator== Compares two object references to see if they refer to the same object.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取游戏服务的唯一对象--单例模式]]></title>
    <url>%2F2019%2F08%2F07%2F%E8%8E%B7%E5%8F%96%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%94%AF%E4%B8%80%E5%AF%B9%E8%B1%A1--%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 游戏实现中的唯一对象生活中的许多物品都是唯一的，地球是唯一的、太阳是唯一的等。软件设计上也会有唯一对象的需求，例如：服务器端的程序只能连接到一个数据库、只能有一个日志产生器；游戏世界也是一样的，同时间只能有一个关卡正在进行、只能连线到一台游戏服务器、只能同时操作一个角色等。 在《P级阵地》中，也存在唯一的对象，例如上一章提到的，用来包含所有游戏子系统的PBaseDefenseGame类，它负责游戏中几个主要功能之间的串接，外界通过它的接口就能存取《P级阵地》的主要游戏服务，可以称这个PBaseDefenseGame类为“游戏服务”的提供者。因为它提供了运行这个游戏所需要的功能，所以PBaseDefenseGame类的对象只需要一个，并且由这个唯一的对象来负责游戏的运行。另外，PBaseDefenseGame类实现了外观模式（Facade），包含了游戏中大部分的操作接口。因此，在实际应用上，会希望有一种方法能够快速获取这个唯一的对象。在实现上，程序设计师会希望这个PBaseDefenseGame类具备两项特质： （1）同时间只存在一个对象； （2）提供一个快速获取这个对象的方法。 如果使用比较直接的方式来实现，可能会使用程序设计语言中的“全局静态变量”功能来满足上述两项需求。若以C#来编写的话，可能会是如下这样： Listing 5-1 使用全局静态对象的实现方式 12345public static class GlobalObject&#123; public static PBaseDefenseGame GameInstance = new PBaseDefenseGame();&#125;GlobalObject.GameInstance.Update(); // 使用方法 在一个静态类中，声明类对象为一个静态成员，这样实现的方式虽然可以满足“容易获取对象”的需求，但无法避免刻意或无意地产生第二个对象，而且像这种使用全局变量的实现方式，也容易产生全局变量命名重复的问题。 所以，最好的实现方式是，让PBaseDefenseGame类只产生一个对象，并提供便利的方法来获取这唯一的对象。GoF中的单例模式（Singleton）讲述的就是如何满足上述需求的模式。 单例模式单例模式是笔者过去常使用的设计模式，单例模式确实令人“着迷”，因为它能够让程序设计师快速获取提供某项服务或功能的对象，可以省去层层传递对象的困扰。 单例模式的定义单例模式在GoF中的定义是： “确认类只有一个对象，并提供一个全局的方法来获取这个对象”。 单例模式在实现时，需要程序设计语言的支持。只要具有静态类属性、静态类方法和重新定义类建造者存取层级。 3项语句功能的程序设计语言，就可以实现出单例模式。本书使用的C#具备这3项条件，可以用来实现单例模式。 不过单例模式也是许多设计模式推广人士不建议大量使用的模式，详细的原因会在本章后面加以说明。 单例模式的说明单例模式的结构如图5-1所示。 单例模式的结构示意图 Singleton参与的角色说明如下： 能产生唯一对象的类，并且提供“全局方法”让外界可以方便获取唯一的对象。 通常会把唯一的类对象设置为“静态类属性”。 习惯上会使用Instance作为全局静态方法的名称，通过这个静态函数可能获取“静态类属性”。 单例模式的实现范例C#支持实现单例模式（Singleton Pattern）的特性，以下是使用C#实现的方式之一： Listing 5-2 单例模式的实现范例（Singleton.cs） 12345678910111213141516171819public class Singleton&#123; public string Name &#123;get; set;&#125; private static Singleton _instance; public static Singleton Instance &#123; get &#123; if (_instance == null) &#123; Debug.Log("产生Singleton"); _instance = new Singleton(); &#125; return _instance; &#125; &#125; private Singleton()&#123;&#125;&#125; 在类内定义一个Singleton类的“静态属性成员”_instance，并定义一个“静态成员方法”Instance，用来获取_instance属性。这里也应用了C#的getter存取运算符功能来实现Instance方法，让原本Singleton.Instance()的调用方式可以改为Singleton.Instance方式，虽然只是少了对小括号()，但以笔者的开发经验来说，少打一对小括号对于程序编写及后续维护上仍有不少的帮助。 Instance的getter存取运算符中，先判断_instance是否已被产生过，如果没有，才继续下面的new Singleton()，之后再返回_instance。 最后，将建造者Singleton()声明为私有成员，这个声明主要是让建造者Singletion()无法被外界调用。一般来说，有了这个声明就可以确保该类只能产生一个对象，因为建造者是私有成员无法被调用，因此可以防止其他客户端有意或无意地产生其他类对象。 打开测试类SingletonTest，测试程序代码如下： Listing 5-3 单例模式测试方法（SingletonTest.cs） 12345678910void UnitTest()&#123; Singleton.Instance.Name = "Hello"; Singleton.Instance.Name = "World"; Debug.Log(Singleton.Instance.Name); //Singleton TempSingleton = new Singleton(); /*错误error CS0122: `DesignPattern_Singleton.Singleton.Singleton()` is inaccessible due to its protection level */&#125; 在范例中，分别使用Singleton.Instance来获取类属性Name，从输出信息中可以看到： 执行结果：产生Singleton测试范例产生的信息World 使用两次Singleton.Instance只会产生一个对象，从Name属性最后显示的是World也可以证实存取的是同一个对象。 测试程序代码，最后试着再产生另一个Singleton对象： 执行结果 再产生另一个Singleton对象时，产生的错误信息error CS0122: ‘DesignPattern_Singleton.Singleton.Singleton()’ is inaccessible due to its protection level. 但从C#编译报错的信息可以看出，构建式Singleton()是在保护阶段，无法被调用，所以无法产生对象。 使用单例模式获取唯一的游戏服务对象游戏系统中哪些类适合以单例模式实现，必须经过挑选，至少要确认的是，它只能产生一个对象且不能够被继承。笔者过去的许多经验中，都会遇到必须将原本是单例模式的类改回非单例模式，而且还必须开放继承的情况。强制修改之下会使得程序代码变得不易维护，所以分析上需要多加注意。 游戏服务类的单例模式实现在《P级阵地》中，因为PBaseDefenseGame类包含了游戏大部分的功能和操作，因此希望只产生一个对象，并提供方便的方法来取用PBaseDefenseGame功能，所以将该类运用单例模式，设计如图5-2所示。 图5-2 游戏服务类的单例模式实现示例 参与者的说明如下： PBaseDefenseGame 游戏主程序，内部包含了类型为PBaseDefenseGame的静态成员属性instance，作为该类唯一的对象。 提供使用C# getter实现的静态成员方法Instance，用它来获取唯一的静态成员属性_instance。 BattleState PBaseDefenseGame类的客户端，使用PBaseDefenseGame.Instance来获取唯一的对象。 实现说明在《P级阵地》范例中，只针对PBaseDefenseGame类运用单例模式，实现方式如下： Listing 5-4 将游戏服务类以单例模式实现（PBaseDefenseGame.cs） 1234567891011121314151617public class PBaseDefenseGame&#123; // Singleton模式 private static PBaseDefenseGame _instance; public static PBaseDefenseGame Instance &#123; get &#123; if(_instance == null) _instance = new PBaseDefenseGame(); return _instance; &#125; &#125; ... private PBaseDefenseGame() &#123;&#125;&#125; 按照之前说明的步骤，实现时先声明一个PBaseDefenseGame类的静态成员属性_instance，同时提供一个用来存取这个静态成员属性的“静态成员方法”Instance。在静态成员方法中，实现时必须确保只会有一个PBaseDefenseGame类对象被产生出来。最后，将建造者PBaseDefenseGame()设置为私有成员。 在实际应用中，直接通过PBaseDefenseGame.Instance获取对象，立即可以使用类功能： Listing 5-5 战斗状态中以单例的方式使用PBaseDefenseGame对象（BatleState.cs） 123456789public class BattleState : ISceneState&#123; // 开始 public override void StateBegin() &#123; PBaseDefenseGame.Instance.Initinal(); &#125; ...&#125; 在《P级阵地》中，除了BattleState类会使用到PBaseDefenseGame对象之外，在后续的说明中也会看到其他类的使用情况。以下是另一个使用的例子： Listing 5-6 兵营用户界面中以单例的方式使用PBaseDefenseGame对象（SoldierClickScript.cs） 123456789public class SoldierOnclick: MonoBehaviour&#123; ... public void OnClick() &#123; // Debug.Log("CharacterOnClick.OnClick:" + gameObject.name); PBaseDefenseGame.Instance.ShowSoldierInfo(Soldier); &#125;&#125; 在SoliderOnClick中完全不需要设置PBaseDefenseGame对象的引用来源，直接调用PBaseDefenseGame.Instance就可以马上获取对象并调用类方法。 使用单例模式后的比较对于需要特别注意“对象产生数量”的类，单例模式通过将“类建造者私有化”，让类对象只能在“类成员方法”中产生，再配合“静态成员属性”，在每一个类中只会存在一个的限制，让系统可以有效地限制产生数量（有需要时可以放宽一个的限制），在两者配合下，单例模式可以有效地限制类对象产生的地点和时间，也可以防止类对象被任意产生而造成系统错误。 反对使用单例模式的原因按照笔者过去的开发经验，单例模式好用的原因之一是：可以马上获取类对象，不必为了“安排对象传递”或“设置引用”而伤脑筋，想使用类对象时，调用类的Instance方法就可以马上获取对象，非常方便。 如果不想使用单例模式或全局变量，最简单的对象引用方式就是：将对象当成“方法参数”，一路传递到最后需要使用该对象的方法中。但此时若存在设计不当的程序代码，那么方法的参数数量就会容易失控而变多，造成难以维护的情况。 而程序设计师一旦发现这个“马上获取”的好处时，就很容易在整个项目中看到许多单例模式的应用（包含实现与调用），这种情况使开发者过于沉迷于使用单例模式。 很不幸，笔者在过去的开发经验中也有过这个“症状”，大多是为了想“省略参数传递”及“能够快速获取唯一对象”等原因。所以在实现上，只要发现“游戏子系统类”或“用户界面类”的对象，在整个游戏运行中是唯一时，就会将单例模式运用在该类上，因此项目内处处可见标示为Singleton的类。 单例模式之所以被滥用，是开发时过度使用“全局变量”及不仔细思考对象的“适当可视性”所造成的产物，因此这是可以避免的。提供了另一种模型来避开使用单例模式。 归咎滥用单例模式的主要原因，多数还是认为是在设计上出现了问题。大多数情况是不需要使用单例模式的，开发者只需要再多花点时间重新思考、更改设计，就可避免使用。 再深入探讨的话，单例模式还违反了“开—闭原则（OCP）”，因为，通过Instance方法获取对象是“实现类”而不是“接口类”，该方法返回的对象包含了实现细节的实体类。因此，当设计变更或需求增加时，程序设计师无法将其替代为其他类，只能更改原有实现类内的程序代码，所以无法满足“对修改关闭”的要求。 当然，如果真的要让单例模式返回接口类——即父类为单例模式类型，并让子类继承实现，并不是没有办法，有以下两种方式可以实现： 子类向父类注册实体对象，让父类的Instance方法返回对象时，按条件查表返回对应的子类对象。 每个子类都实现单例模式，再由父类的Instance去获取这些子类。（《P级阵地》采用类似的方式来实现）。 不过“返回子类的单例模式的对象”有时会引发“白马非马”的逻辑诡辩问题——返回的对象是否就能代表父类呢？举一个实例来说明会发生逻辑诡辩的设计方式： 今天服务器端的系统有项设计需求，需要连线到某一个数据库服务，并要求同时只能存在个连接。程序设计师们经过设计分析后，决定使用单例模式只能产生唯一对象的特性，来满足只能存在一条连接的需求。接着定义数据库连接操作的接口，并运用单例模式，如图5-3所示。 图5-4 实现“子类向父类注册实体对象”的方式 客户端现在可以按当前的设计结果，获取某一种数据库的连接对象，并同时确保只存在一条连接。 经过多次需求追加后，服务器数据库功能的操作需求也增加了，这次希望的需求是：每次的数据库操作能够被记录下来，即当数据库完成操作后必须将操作记录写入“日志数据库”中。但由于“日志数据库”具有“只写不读”的特性，在实现上会选择再启用另一条连接，连接到另一组数据库（有针对“只写不读”特性进行优化的数据库），这样除了可以减少每次操作记录写入时的延迟,也不会增加主数据库的负担。 所以，如果要在不更改原有接口的要求下实现新的功能，最简单的方式就是再从MySQLConnect和OracleConnect各自继承一个子类，并在子类中增加另一条“日志数据连接”和日志操作方法，类结构如图5-5所示。 图5-5 从MySQLConnect和OracleConnect各自继承一个子类后的类结构图 现在获取的MySQLConnectWithLog或OracleConnectWithLog对象，是否还是IDBConnect对象？从IDBConnect的设计需求来看： 数据库连接——有； 只能有一个对象——有； 一个对象代表一条连接——没有。 因为有两条连接存在…，所以MySQLConnectWithLog还是IDBConnect对象吗？ 赞同方会说：“因为单例模式负责产生的对象只有一个，不会去管数据库的连接数量，所以还是单例对象”；反对方则会说：“当初就是希望利用单例模式只能产生唯一对象的特性，来限制数据库的同时连接数，现在子类却有两条连接，所以当然不是”…，白马是不是马的辩论就这样产生了。而笔者认为，花点时间修改原有的设计，让这种辩论消失才是真正解决的方式。 少用单例模式时如何方便地引用到单一对象单例模式包含两个重要特性：唯一的对象和容易获取对象。那么要如何减少单例模式的使用呢？可以从分析类的“使用需求”开始，先确认程序设计师在使用这个类时，是希望同时获得上述两个好处还是只需要其中一个。若是只需要其中一个，那么下面几种方式可以用来设计系统。 让类具有计数功能来限制对象数量 在有数量限制的类中加上“计数器”（静态成员属性）。每当类建造者被调用时，就让计数器增加1，然后判断有没有超过限制的数量，如果超过使用上限，那么该对象就会被标记为无法使用，后续的对象功能也不可以被执行。适当地在类建造者中加入警告或Assert，也有助于调试分析，范例程序如下: Listing 5-7 有计数功能的类（ClassWithCounter.cs） 1234567891011121314151617181920212223public class ClassWithCounter&#123; protected static int m_ObjCounter = 0; protected bool m bEnable = false; public ClassWithCounter() &#123; m_Objcounter++; m_bEnable= (m Obicounter=1 )? true: false ; if( m_bEnable==false) &#123; Debug.LogError("当前对象数["+m objCounter+"]超过1个!!"); &#125; &#125; public void Operator() &#123; if( m bEnable ==false) return ; Debug. Log ("可以执行"); &#125;&#125; Listing 5-8 有计数功能类的测试方法(SingletonTest.cs) 12345678void UnitTest classwithcounter() &#123; //有计数功能的类 ClassWithCounter pobj1 = new ClassWithcounter(); pobj1.operator(); ClassWithcounter pobj2 = new classWithcounter(); pobj2.Operator(); pobj1.Operator();&#125; 设置成为类的引用，让对象可以被取用 某个类的功能被大量使用时，可以将这个类对象设置为其他类中的成员，方便直接引用这些类。而这种实现方法是“依赖性注入”的方式之一，可以让被引用的对象不必通过参数传递的方式,就能被类的其他方法引用。按照设置的方式又可以分为“分别设置”和“指定类静态成员”两种。 1.分别设置 在《P级阵地》中，PBaseDefenseGame是最常被引用的。虽然已经运用了单例模式，但笔者还是以此来示范如何通过设置它成为其他类引用的方式，来减少对单例模式的使用。 由于在《P级阵地》中，每个游戏子系统都会使用PBaseDefenseGame类的功能，所以在各个游戏系统初始化设置时，就将PBaseDefenseGame对象指定给每一个游戏系统，并让游戏系统设置为类成员。那么，后面若有游戏系统的方法需要使用PBaseDefenseGame的功能时，就可以直接使用这个类成员来调用PBaseDefenseGame的方法; Listing 5-9 将PBaseDefenseGame设置为其他类中的对象引用 12345678910111213141516171819202122public class PBaseDefenseGame.../1初始化P-BaseDefense游戏相关设置public void Initinal() t//游戏系统m GameEventSystem = new GameEventSystem (this); //游戏事件系统:m CampSystem-new CampSystem (this): //兵营系统m stagesyatem-hew stagesystem (this); //关卡系统// PbaseDefenseGame.cs//游戏子系统共享接口public abstract class IGameSystemprotected PBasepefenseGame m PBDGame nul1: -public IGameSystem ( PBaseDefenseGame PBDGame) t m PBDGame s PBDGame:public virtual void Initialize()0)public virtual void Release()t)public virtual void Update ()11 // IGameSystem.cs//兵营系统public class CampSystem: IGameSystempublic CampSystem (PBaseDefenseGame PBDGame) :base (PBDGame) Initialize ();//显示场景中的俘兵营public void ShowCaptivecamp ().m CaptiveCamps [ENUM Enemy.E1f).SetVisible (true);m PBDGame . ShowGameMsg ("获得俘兵营");F// CampSystem.cs 在上面的范例中，兵营系统的建造者将传入的PBaseDefenseGame对象设置类成员mPBDGame，并在有需求时(ShowCaptiveCamp)通过m-PBDGame来调用PBaseDefenseGame的方法。 2,指定类的静态成员 A类的功能中若需要使用到B类的方法，并且A类在产生其对象时具有下列几种情况:产生对象的位置不确定;有多个地方可以产生对象；生成的位置无法引用到;有众多子类。 当满足上述情况之一时，可以直接将B类对象设置为A类中的“静态成员属性”，让该类的对象都可以直接使用: Listing 5-10将PBaseDefenseGame设置为类的静态引用成员 1234567public class PBaseDefenseGame//初始P-BaseDefense游戏相关设置public void Initinal() f m StageSystem=new StageSystem (this) ;//关卡系统//注入其他系统EnemyAI.SetstageSystem ( m stageSystem);&#125;// PBaseDefenseGame.cs 举例来说，敌方单位AI类(EnemyAl)，在运行时需要使用关卡系统(StageSystem )的信息，但EnemyA1对象产生的位置是在敌方单位建造者(EnemyBuilder)之下: Listing 5-11 Enemy各部位的建立 123456public class EnemyBuilder: TCharacterBuilder//加入A1public override void AddAI() tEnemyAI theAI = new EnemyAI( n BuildParam. NewCharacter, m BuildParam. AttackPosition).m BuildParam.NewCharacter. SetAI ( theAl);// EnemyBuilder.cs 按照“最少知识原则（LKP）”，会希望敌方单位的建造者（EnemyBuilder）减少对其他无关类的引用。因此，在产生敌方单位AI(EnemyAl)对象时，敌方单位建造者(EnemyBuilder)无法将关卡系统(Stagesystem)对象设置给敌方单位AI，这是属于上述“生成的位置无法引用到”的情况。所以,可以在敌方单位Al (EnemyAl)类中，提供一个静态成员属性和静态方法，让关卡系统(StageSystem)对象产生的当下，就设置给敌方单位Al (EnemyAl)类: Listing 5-12 敌方Al的类(EnemyAl.cs) 12345678public class EnemyAI: ICharacterAlprivate static stageSystem m StageSystem =null;//将关卡系统直接注入给EnemyAI类使用public static void SetstageSystem (StageSystem stageSystem) m StageSystem = stageSystem,/1是否可以攻击Heartpublic override bool CanAttackHeart() (//通知少一个Heartm StageSystem. LoseHeart ().return true; 使用类的静态方法 每当增加一个类名称就等同于又少了一个可以使用的全局名称,但如果是在类下增加“静态方法”就不会减少可使用的全局名称数量,而且还能马上增加这个静态类方法的“可视性”-也就是全局都可以引用这个静态类方法。如果在项目开发时,不存在限制全局引用的规则,或者已经没有更好的设计方法时,使用“类静态方法”来获取某一系统功能的接口,应该就是最佳的方式了。它有着单例模式(Singleton)的第二个特性:方便获取对象。 举例来说,在《P级阵地》中,有一个静态类PBDFactory就是按照这个概念去设计的。由于它在《P级阵地》中负责的是所有资源的产生,所以将其定义为“全局引用的类”并不违反这个游戏项目的设计原则。它的每一个静态方法都负责返回一个“资源生成工厂接口”,注意,是“接口”,所以在以后的系统维护更新中,是可以按照需求的改变来替换子类而不影响其他客户端: Listing 5-13 获取P-BaseDefenseGame中所使用的工厂(PBDFactory.cs) 123456789public static class PBDFactoryprivate static IAssetFactory m AssetFactory - null;//获取将Unity Asset实现化的工厂public static IAssetFactory GetAssetFactory() t if( m AssetFactory = nul1)if ( m bLoadFromResourcem AssetFactory = new ResourceAssetFactory();elsem AssetFactory new RemoteAssetFactory();return m AssetFactory; 但如果在系统设计的需求上,又要求每个游戏资源工厂都“必须是唯一的”,那么此时可以在各个子类中运用单例模式(Singleton),或者采取前面提到的“让类具有计数功能来限制对象数量”的方式来满足需求。 结论单例模式的优点是：可以限制对象的产生数量；提供方便获取唯一对象的方法。单例模式的缺点是容易造成设计思考不周和过度使用的问题，但并不是要求设计者完全不使用这个模式，而是应该在仔细设计和特定的前提之下，适当地采用单例模式。 在《P级阵地》中，只有少数地方引用到单例类PBaseDefenseGame，而引用点可以视为单例模式优点的呈现。 其他应用方式 网络在线游戏的客户端，可以使用单例模式来限制连接数，以预防误用而产生过多连接，避免服务器端因此失效。 日志工具是比较不受项目类型影响的功能之一，所以可以设计为跨项目共享使用。此外，日志工具大多使用在调试或重要信息的输出上，而单例模式能让程序设计师方便快速地获取日志工具，所以是个不错的设计方式。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式与游戏完美开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏主要类--外观模式]]></title>
    <url>%2F2019%2F08%2F07%2F%E6%B8%B8%E6%88%8F%E4%B8%BB%E8%A6%81%E7%B1%BB--%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 游戏场景 场景的转换 游戏场景可能的实现方式白 状态模式（State） 状态模式的定义 状态模式的说明 状态模式的实现范例 使用状态模式实现游戏场景的转换 SceneState的实现 实现说明 使用状态模式的优点 游戏执行流程及场景转换说明 状态模式面对变化时 结论 游戏子功能的整合一款游戏要能顺利运行，必须同时由内部数个不同的子系统一起合作完成。在这些子系统中，有些是在早期游戏分析时规划出来的，有些则是实现过程中，将相同功能重构整合之后才完成的。以《P级阵地》为例，它是由下列游戏系统所组成： 游戏事件系统（GameEventSystem）； 兵营系统（CampSystem）； 关卡系统（StageSystem）； 角色管理系统（CharacterSystem）； 行动力系统（APSystem）； 成就系统（AchievementSystem）； 这些系统在游戏运行时会彼此使用对方的功能，并且通知相关信息或传送玩家的指令。另外，有些子系统必须在游戏开始运行前，按照一定的步骤将它们初始化并设置参数，或者游戏在完成一个关卡时，也要按照一定的流程替它们释放资源。 可以理解的是，上面这些子系统的沟通及初始化过程都发生在“内部”会比较恰当，因为对于外界或客户端来说，大可不必去了解它们之间的相关运行过程。如果客户端了解太多系统内部的沟通方式及流程，那么对于客户端来说，就必须与每一个游戏系统绑定，并且调用每一个游戏系统的功能。这样的做法对客户端来说并不是一件好事，因为客户端可能只是单纯地想使用某一项游戏功能而已，但它却必须经过一连串的子系统调用之后才能使用，对于客户端来说，压力太大，并且让客户端与每个子系统都产生了依赖性，增加了游戏系统与客户端的耦合度。 如果要在我们的游戏范例中举一个例子，那么上一章所提到的“战斗状态类（BattleState）”就是一个必须使用到游戏系统功能的客户端。 根据上一章的说明，战斗状态类（BattleState）主要负责游戏战斗的运行，而《P级阵地》在进行一场战斗时，需要大部分的子系统一起合作完成。在实现时，可以先把这些子系统及相关的执行流程全都放在BattleState类之中一起完成： Listing 4-1 在战斗状态类中实现所有子系统相关的操作 12345678910111213141516171819202122232425262728293031323334353637public class BattleState : ISceneState&#123; // 游戏系统 private GameEventSystem m_GameEventSystem = null; // 游戏事件系统 private CampSystem m_CampSystem = null; // 兵营系统 private StageSystem m_StageSystem = null; // 关卡系统 private CharacterSystem m_CharacterSystem = null; // 角色管理系统 private APSystem m_ApSystem = null; // 行动力系统 private AchievementSystem m_AchievementSystem = null; // 成就系统 public GameState (SceneStateController Controller): base(Controller) &#123; this.StateName-"GameState"; // 初始化游戏子系统 InitGameSystem(); &#125; // 初始化游戏子系统 private void InitGameSystem() &#123; m_GameEventSystem = new GameEventSystem(); m_CampSystem = new CampSystem(); ... m_GameEventSystem.Init(); m_CampSystem.Init(); &#125; //更新游戏子系统， private void UpdateGameSystem() &#123; m_GameEventSystem.Update(); m_CampSystem.Update (); m_CharacterSystem.Update(); ... &#125;&#125; 虽然这样的实现方式很简单，但就如本章一开始所说明的，让战斗状态类（BatleState）这个客户端去负责调用所有与游戏玩法相关的系统功能，是不好的实现方式，原因是： 从让事情单一化（单一职责原则）这一点来看，BattleState类负责的是游戏在“战斗状态”下的功能执行及状态切换，所以不应该负责游戏子系统的初始化、执行操作及相关的整合工作。 以“可重用性”来看，这种设计方式会使得BattleState类不容易转换给其他项目使用，因为BattleState类与太多特定的子系统类产生关联，必须将它们删除才能转换给其他项目，因此丧失可重用性。 综合上述两个原因，将这些子系统从BattleState类中移出，整合在单一类之下，会是比较好的做法。所以，在《P级阵地》中应用了外观模式来整合这些子系统，使它们成为单一界面并提供外界使用。 外观模式（Facade）其实，外观模式是在生活中最容易碰到的模式。当我们能够利用简单的行为来操作一个复杂的系统时，当下所使用的接口，就是以外观模式来定义的高级接口。 外观模式的定义外观模式在GoF的解释是： 1为子系统定义一组统一的接口，这个高级的接口会让子系统更容易被使用。 以驾驶汽车为例，当驾驶者能够开着一辆汽车在路上行走，汽车内部还必须由许多的子系统一起配合才能完成汽车行走这项功能，这些子系统包含引擎系统、传动系统、悬吊系统、车身骨架系统、电装系统等。但对客户端（驾驶者）而言，并不需要了解这些子系统是如何协调工作的，驾驶者只需要通过高级接口（方向盘、踏板、仪表盘）就可以轻易操控汽车。 再以生活中常用的微波炉为例，微波炉内部包含了电源供应系统、微波加热系统、冷却系统、外装防护等。当我们想要使用微波炉加热食物时，只需要使用微波炉上的面板调整火力和时间，按下启动键后，微波炉的子系统就会立即交互合作将食物加热。 所以，外观模式的重点在于，它能将系统内部的互动细节隐藏起来，并提供一个简单方便的接口。之后客户端只需要通过这个接口，就可以操作一个复杂系统并让它们顺利运行。 外观模式的说明整合子系统并提供一个高级的界面让客户端使用，可以由图1表示。 参与者的说明如下: client（客户端、用户）从原本需要操作多个子系统的情况，改为只需要面对一个整合后的界面。 subSystem（子系统）原本会由不同的客户端（非同一系统相关）来操作，改为只会由内部系统之间交互使用。 Facade（统一对外的界面） 整合所有子系统的接口及功能，并提供高级界面（或接口）供客户端使用。 接收客户端的信息后，将信息传送给负责的子系统。 外观模式的实现说明从之前提到的一些实例来看，驾驶座位前的方向盘、仪表板，以及微波炉上的面板，都是制造商提供给用户使用的Facade界面。 外观模式可以让客户端使用简单的界面来操作一个复杂的系统，并且减少客户端要与之互动的系统数量，让客户端能够专心处理与本身有关的事情。所以，驾驶员不需要了解汽车引擎系统是否已完成调校，只需要注意行车速度及仪表板上是否有红灯亮起；用户在使用微波炉时，也不用了解此时的微波功率是多少瓦，只需要知道放入的容器是否正确、食物是否过熟即可。 使用外观模式实现游戏主程序游戏开始实现时，就如同本章第一节中的范例一样，先将几个游戏系统写在一个直接使用它们的类中，但随着游戏系统越加越多，会发现这些游戏系统的程序代码占据了整个类。这些游戏系统的初始化设置和流程串接，与使用它们的类完全没有关系，此时就需要将它们移出，并以一个类重新组织。 游戏主程序架构设计在《P级阵地》中， PBaseDefenseGame就是“整合所有子系统，并提供高级界面的外观模式类”。重新规划后的类结构图如图4-6所示。 图2 外观模式类的结构图 参与者的说明如下: GameEventSystem、CampSystem、…：分别为游戏的子系统，每个系统负责各自应该实现的功能并提供接口. PBaseDefenseGame：包含了和游戏相关的子系统对象，并提供了界面让客户端使用。 BatleState：战斗状态类，即是《P级阵地》中与PBaseDefenseGame互动的客户端之一。 实现说明在PBaseDefenseGame类中，将子系统定义为类的私有成员，如下： Listing 4-2 游戏主要类的实现，将子系统定义为类成员（PBaseDefenseGame.cs） 12345678910public class PBaseDefenseGame&#123; // 游戏系统 private GameEventSystem m_GameEventSystem = null; // 游戏事件系统 private CampSystem m_CampSystem = null; // 兵营系统 private StageSystem m_StageSystem = null; // 关卡系统 private CharacterSystem m_CharacterSystem = null; // 角色管理系统 private APSystem m_ApSystem = null; // 行动力系统 private AchievementSystem m_AchievementSystem = null; // 成就系统&#125; 并提供初始化方法，供游戏开始时调用。初始化方法被调用时，各个子系统的对象才会被产生出来: Listing 4-3 初始化PBaseDefense游戏相关设置（PBaseDefenseGame.cs） 12345678910111213public void Initinal()&#123; // 场景状态控制 m_bGameover = false; // 游戏系统 m_GameEventSystem = new GameEventSystem(this); // 游戏事件系统 m_CampSystem = new CampSystem(this); // 兵营系统 m_StageSystem = new stageSystem(this); // 关卡系统 m_CharacterSystem= new CharacterSystem(this); // 角色管理系统 m_ApSystem = new APSystem(this); m_AchievementSystem = new AchievementSystem(this); // 成就系统 ...&#125; 再定义出相关的高级界面供客户端使用。而这些PBaseDefenseGame类方法，多数会把接收到的信息或请求转发给相对应的子系统负责。 Listing 4-4 PBaseDefense更新（PBaseDefenseGame.cs） 1234567891011121314151617181920212223242526272829303132333435public void Update()&#123; //游戏系统更新 m_GameEventSystem.Update(); m_CampSystem.Update(); m_StageSystem.Update(); m_CharacterSystem.Update(); m_ApSystem.Update(); m_AchievementSystem.Update(); ...&#125;// 游戏状态public bool ThisGameIsOver()&#123; return m_bGameover;&#125;...// 当前敌人数量public int GetEnemyCount()&#123; if(m_CharacterSystem != null) return m_CharacterSystem.GetEnemyCount(); return 0;&#125;...// 获取各单位数量public int GetUnitCount(ENUM_Soldier emSolider)&#123; return m_CharacterSystem.GetUnitCount(emSolider);&#125;public int GetUnitCount(ENUM_Enemy emEnemy)&#123; return m_CharacterSystem.GetUnitCount(emEnemy);&#125; 在战斗状态类（BattleState）中，通过PBaseDefenseGame类提供的界面来操作《P级阵地》的系统运行： Listing 4-5 使用PBaseDefenseGame Facade界面沟通的战斗状态类（BattleState.cs） 123456789101112131415161718192021222324252627public class BattleState : ISceneState&#123; ... // 开始 public override void StateBegin() &#123; PBaseDefenseGame.Instance.Initinal(); &#125; // 结束 public override void StateEnd() &#123; PBaseDefenseGame.Instance.Release(); &#125; // 更新 public override void StateUpdate() &#123; ... // 游戏逻辑 PBaseDefenseGame.Instance.Update(); ... // 游戏是否结束 if(PBaseDefenseGame.Instance.ThisGameIsOver()) m_Controller.SetState(new MainMenuState(m_Controller), "MainMenuState"); &#125;&#125; 使用外观模式的优点将游戏相关的系统整合在一个类下，并提供单一操作界面供客户端使用，与当初将所有功能都直接实现在BattleState类中的方式相比，具有以下几项优点： 使用外观模式可将战斗状态类BattleState单一化，让该类只负责游戏在“战斗状态”下的功能执行及状态切换，不用负责串接各个游戏系统的初始化和功能调用。 使用外观模式使得战斗状态类BattleState减少了不必要的类引用及功能整合，因此增加了BattleState类被重复使用的机会。 除了上述优点之外，外观模式如果应用得当，还具有下列优点： 节省时间 对某些程序设计语言而言，减少系统之间的耦合度，有助于减少系统构建的时间。以C/C++为例，头文件（.h）代表了某一个类所提供的接口，当接口中的方法有所改变时，任何引用到的该头文件（.h）的单元都必须重新编译。以笔者过去的开发经验来说，即便现代的计算机设备越来越进步，仍须花费许多时间在等待编译程序进行编译。 虽然使用C#在Unity3D开发上，不至于发生修改一个文件就让系统重建时间变长的情况，但良好的设计习惯还是有助于其他程序设计语言的使用。 事实上，Unity3D本身提供了不少系统的Facade接口，例如物理引擎、渲染系统、动作系统、粒子系统等。当在Unity3D中使用物理引擎时，只需要在GameObject挂上碰撞组件（Collider）或刚体组件（Rigidbody），并在面板上设置好相关参数之后，GameObject即可与其他物理组件产生反应。另外，通过面板上的材质设置及相关参数调整，也可以轻易得到Unity3D渲染系统反馈的效果。所以，开发者只需要专心在游戏效果和可玩性上，不必再自行开发对象引擎及渲染功能。 易于分工开发 对于一个既庞大又复杂的子系统而言，若应用外观模式，即可成为另一个Facade接口。所以，在工作的分工配合上，开发者只需要了解对方负责系统的Facade接口类，不必深入了解其中的运行方式。例如，今天有一位程序员A告诉你，要使用他写的“关卡系统”时，必须：①先初始化一个关卡数据List；②将关卡信息加入；③设置排序规则；④最后才能获得关卡信息。 但另一位程序员B也告诉你，使用他写的“关卡系统”时，只要初始化关卡系统后，就可以马上获得关卡信息 。自然，与程序员B合作时是比较愉快的，因为在使用程序员B的关卡系统时，不必了解每一步的流程是什么，而且也不必编写太多的程序代码与对方的系统连接，进而也会让自已编写的功能更容易维护。所以，为了让系统能够顺利分工开发，将单一系统功能内部所需要的操作流程全部隐藏，不让客户端去操作，可协助开发团队在分工上的任务划分。 增加系统的安全性 隔离客户端对子系统的接触，除了能减少耦合度之外，安全性也是重点之一。这里所说的安全性，指的是系统执行时“意外宕机或出错”的情况。因为有时候子系统之间的沟通和构建程序上会有一定的步骤，例如：某一个功能一定要先通知子系统A将内部功能设置完成后，才能通知子系统B接手完成后续的设置，顺序的错误会让系统初始化失败或导致宕机，所以像这样的程序构建顺序，应该由Facade接口类来完成，而不应该由客户端去实现。 实现外观模式时的注意事项由于将所有子系统集中在Facade接口类中，最终会导致Facade接口类过于庞大且难以维护。当发生这种情况时，可以重构Facade接口类，将功能相近的子系统进行整合，以减少内部系统的依赖性，或是整合其他设计模式来减少Facade接口类过度膨胀。 例如在本章的实现上，PBaseDefenseGame类虽然隔离了战斗状态类（BattleState）和各游戏子系统之间的操作，但还需要注意的是，PBaseDefenseGame内部子系统之间要如何减少耦合度的问题，在下一章（第5章）中，将说明如何减少子系统之间的耦合度。 外观模式面对变化时随着开发需求的变更，任何游戏子系统的修改及更换，都被限制在PBaseDefenseGame这个Facade接口类内。所以，当有新的系统需要增加时，也只会影响PBaseDefenseGame类的定义及增加对外开放的方法，这样就能使项目的变动范围减到最小。 结论将复杂的子系统沟通交给单一的一个类负责，并提供单一界面给客户端使用，使客户减少对系统的耦合度是外观模式的优点。在本章中，我们利用外观模式实现了PBaseDefenseGame类，所以战斗状态类（BattleState）与各游戏子系统被隔离开了，这样做的好处是显而易见的。除此之外，本章所实现的设计还有哪些应该注意的地方，以及还可以将外观模式应用在游戏设计的哪些地方，分述如下。 与其他模式的合作 在《P级阵地》中，PBaseDefenseGame类使用单例模式（Singleton）来产生唯一的类对象，内部子系统之间则使用中介者模式（Mediator）作为互相沟通的方式，而游戏事件系统（GameEventSystem)是观察者模式（Observer）的实现，主要目的就是要减少PBaseDefenseGame类接口过于庞大而加入的设计。 其他应用方式 网络引擎：网络通信是一项复杂的工作，通常包含连线管理系统、信息事件系统、网络数据封包管理系统等，所以一般会用外观模式将上述子系统整合为一个系统。 数据库引擎：在游戏服务器的实现中，可以将与“关系数据库”（MySQL、MSSQL等）相关的操作，以一种较为高级的接口隔离，这个接口可以将数据库系统中所需的连线、数据表修改、新增、删除、更新、查询等的操作加以封装，让不是很了解关系数据库原理的设计人员也能使用。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式与游戏完美开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态配置图片]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 如果使用本地的图片，看看需要做哪些改变呢？ 怎么最大程度提高程序的扩展性呢？最好图片和文字说明是可以动态替换的。 这个问题用我们这两周学的配置文件和读取文件的知识，串起来就可以搞定这个问题了！ 基本思路是这样的： 使用json配置图片的路径和文字说明动态获取外部的图片，这样图片可以在外面替换，不用重新发布程序 创建场景 1、先创建一个虚拟展厅的场景，我这里偷懒就使用一个3D Object-&gt;Quad创建了一面墙，然后调整物体的Scale。2、由于主要是展示图片和文字，在这里就用3D UI进行搭建，这里面有几点需要注意。 注意图片选择Raw Image组件。RawImage可以直接显示Texture类型的贴图，而不用转换为Sprite。 Canvas设置为World Space，然后设置位置和Scale，符合三维场景中墙壁的尺寸。 这里我将Text作为了图片的子物体（如果你的层级结构不同，下面获取图片对应的代码需要做相应的修改） 创建完成大致的结构如下 配置图片和说明 配置的json文件如下： 1234567891011121314151617[ &#123; "Id": 1, "Url": "http://www.zyzw.com/sjmhxs/sjmhxst/sjmhxst003.jpg", "Name": "蒙娜丽莎" &#125;, &#123; "Id": 2, "Url": "http://www.zyzw.com/sjmhxs/sjmhxst/sjmhxst003.jpg", "Name": "蒙娜丽莎" &#125;, &#123; "Id": 3, "Url": "http://www.zyzw.com/sjmhxs/sjmhxst/sjmhxst003.jpg", "Name": "蒙娜丽莎" &#125;] 一定要注意保存的文件不要有BOM头。 这里面你会注意到我加了一个Id，这个Id是用来和场景中的物体进行对应，便于修改与调试。否则我们就只能通过数组的索引来访问，很不方便。 不知道你还记不记得，Unity自带的JsonUtility无法解析最外层是数组的JSON字符串，如果你像我上面那样写，需要导入LitJson。ConfigManager 由于我们很多对象中都需要获取这个配置信息，所以我们通过一个通用的管理类来获取配置的数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;using System.Collections;using System.IO;using System.Linq;using LitJson;using UnityEngine;using UnityEngine.Networking;// 图片信息public class PicData&#123; public int Id; public string Url; public string Name;&#125;public class ConfigManager : MonoBehaviour&#123; // 设置为静态，方便在其他地方访问 public static PicData[] Data; IEnumerator Start() &#123; var uri = new Uri(Path.Combine(Application.streamingAssetsPath, "data.json")); var request = UnityWebRequest.Get(uri); yield return request.SendWebRequest(); if (request.isHttpError || request.isNetworkError) Debug.Log(request.error); else ParseJsonStr(request.downloadHandler.text); &#125; // 解析获取到的JSON字符串 private void ParseJsonStr(string json) &#123; Data = JsonMapper.ToObject‹PicData[]›(json); Debug.Log(Data.Length); &#125; // 使用Linq获取第一个符合Id的数据 public static PicData GetData(int id) &#123; return Data.First(t =› t.Id == id); &#125;&#125; 记得把LitJson导入到工程中，如果忘了回去看看195节哦。 创建一个Manager空物体，将这个脚本挂到Manager空物体上。 针对每个图片物体的脚本 下面的代码用于从配置类中获取信息，然后去下载对应的图片。 12345678910111213141516171819202122232425262728293031323334using System;using System.Collections;using UnityEngine;using UnityEngine.Networking;using UnityEngine.UI;public class Picture : MonoBehaviour&#123; public int Id; IEnumerator Start() &#123; // 防止配置文件还没读取完毕 while (ConfigManager.Data == null) yield return null; var data = ConfigManager.GetData(Id); // 如果Id有误，没有对应的数据则退出此协程 if (data == null) yield break; var uri = new Uri(data.Url); // 使用UnityWebRequestTexture类来获取图片 var request = UnityWebRequestTexture.GetTexture(uri); yield return request.SendWebRequest(); if (request.isHttpError || request.isNetworkError) Debug.Log(request.error); else GetComponent‹RawImage›().texture = DownloadHandlerTexture.GetContent(request); GetComponentInChildren‹Text›().text = data.Name; &#125;&#125; 将这个脚本挂在Pic1、Pic2、Pic3物体上并设置相应的Id即可。 总结最后的结果如下： 如果你想改变墙上的图片和内容，即使发布出来以后，也只需要修改json文件即可，不需要重新发布。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读写文件]]></title>
    <url>%2F2019%2F08%2F07%2F%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 用Unity读取外部的txt文件，把里面的内容显示在UI上 Unity项目中经常需要读写外部文件，比如配置文件、外部的图片、音频、模型等等。今天我们来看一下在Unity中如何使用C#读写文件。 读写文件读写文件在C#中有多种不同的方法，我们先来看一段简单的代码，这段代码加载了一个text.txt文件，可以读到文件中的文本内容。 1234567891011using System.IO;using UnityEngine;public class LearnFile : MonoBehaviour&#123; void Start() &#123; var str = File.ReadAllText("text.txt"); Debug.Log(str); &#125;&#125; 这个txt文件需要放到和Assets文件夹同级的位置。 上面是一段非常简单的读取文件的代码，但是里面涉及到了几个知识点： C#读写文件的类是什么？怎么使用？ 文件的路径在哪？ 文件没有读到如何处理？ C#读写文件的类C#中有多种方法来读写文件，上面用到的是一种最简单的方式。也就是C#中的File类。 File类File类在读取文件时会一次性读取文件的所有内容，在写文件时也会一次性将所有内容写入文件。 此外File类还是一个同步操作，也就是执行完才会执行下一条语句。如果文件比较大，可能会阻塞程序。所以一般建议对小文件使用这个类来读取会比较合适。 常用的File类中的方法有： 12345678// 读取文件中的所有字节，常用于二进制文件public static byte[] ReadAllBytes(string path);// 读取文件中所有文本内容，常用于文本文件public static string ReadAllText(string path);// 一次性将字节数组写入文件public static void WriteAllBytes(string path, byte[] bytes);// 一次性将文本写入文件public static void WriteAllText(string path, string contents); 要注意引用File类的命名空间System.IO： 1using System.IO; Unity相关路径文件读写里面还有非常重要的一环，那就是文件的路径问题。如果文件读写的路径不对，那一切都是枉然。 Unity的API提供了几种常用的路径： 1234Application.dataPathApplication.persistentDataPathApplication.streamingAssetsPathApplication.temporaryCachePath 下面我们来分别看看每个路径的用途。 Application.dataPath这个路径指向了游戏的数据文件夹。在不同的运行环境中所返回的结果不尽相同： Unity Editor: &lt;工程路径&gt;/AssetsMac player: /ContentsiOS player: &lt;app bundle路径&gt;/Data (只读）Win/Linux player: (Linux路径区分大小写)WebGL: 数据目录的绝对路径url (不包含数据文件名)Android: 一般是APK安装路径，如果是分包会指向 OBB 路径 这个路径一般只在Editor和Standalone的player中使用，一般用于配置文件等外部文件的读取。 Application.persistentDataPath永久保存文件的路径用于玩家存档，外部数据等，可以在程序之间共用一般我们不用关心具体存在哪里App升级时，这个路径内的文件不会删掉路径基于Bundle Identifier，如果Bundle Identifier不修改，那么app升级后还能访问到相同的路径 Application.streamingAssetsPath将一些配置文件、可以在外部替换的文件放到工程Assets目录下StreamingAssets目录后，这个目录中的数据，在打包时不会编译转码，会原封不动拷贝到对应位置。 在Win/Linux/Mac平台上，build之后可以修改这个目录中的文件，可用来放置配置文件等。Android上会被打包到Apk中，该路径只读，需要使用UnityWebRequest来获取在WebGL中该路径只读，不能使用File操作，需要使用UnityWebRequest来获取 Application.temporaryCachePath临时路径，可用于临时文件的中转可能被各种XX管家视为垃圾文件，不要用于存储 不需要死记硬背这么多路径在不同平台上的路径都不相同，不需要死记硬背，只需要了解每个路径应该什么时候使用即可，因为我们可以在程序中打印出来对应项目的实际路径。 那你可能会说，在Editor中我们可以使用log输出，那发布出来以后怎么办呢？ 其实发布出来以后也还有对应的log，只不过查看起来不太方便。 这时候可以使用一个LogViewer的插件。可以从Github或者Assetstore上免费下载安装： https://github.com/aliessmael/Unity-Logs-Viewerhttps://www.assetstore.unity3d.com/en/#!/content/12047（版本更新可能有些滞后） 使用方法： 在buildsettings的第一个场景中使用菜单 (Reporter-&gt;Create) 创建Reporter。将Reporter.cs的“Scrip execution order ” (Edit -&gt; Project Settings )设置为最高（最小值）。运行时在屏幕上画一个圆，即可调出这个插件，看到运行的log了。 读写文件的一些坑读写文件的时候也有一些常见的容易犯的错误。 路径拼接读写文件经常会涉及到路径拼接的问题，比如将目录的路径和文件名进行拼接类似的操作。经常需要判断有没有加分隔符/，或者不同平台的分割符还不同，如果使用string的加法操作可能很容易出错。 拼接的时候建议使用Path.Combine(path1, path2)这个C#的API，他会帮你拼接两个路径。 只读目录上面我们看到有一些只读的目录，需要使用UnityWebRequest读取（也就是之前的WWW类），后面我们会学到。 总结如果读写文件不成功，首先要确认路径是否正确，充分利用插件的调试能力。然后再确认路径的权限，是否可以读写，如果是只读路径，需要用到后面学习的UnityWebRequest的方式读取。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏场景的转换--状态模式]]></title>
    <url>%2F2019%2F08%2F06%2F%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF%E7%9A%84%E8%BD%AC%E6%8D%A2--%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 你会画游戏场景的状态图吗？ 为什么要做登录场景的通用？ 用一个场景类来管理所有场景有什么问题？ 如何用德鲁伊来描述状态模式？ 本章涵盖： 游戏场景 场景的转换 游戏场景可能的实现方式白 状态模式（State） 状态模式的定义 状态模式的说明 状态模式的实现范例 使用状态模式实现游戏场景的转换 SceneState的实现 实现说明 使用状态模式的优点 游戏执行流程及场景转换说明 状态模式面对变化时 结论 游戏场景场景的转换当游戏比较复杂时，通常会设计成多个场景，让玩家在几个场景之间转换。 我们可规划出数个场景，每个场景分别负责多项功能的执行。 登录场景：负责游戏片头、加载游戏数据、出现游戏主画面、等待玩家登录游戏。 主画面场景：负责进入游戏画面、玩家在主城/主画面中的操作、在地图上打怪打宝… 战斗场景：负责与玩家组队之后进入副本关卡、挑战王怪… 在游戏场景规划完成后，就可以利用“状态图”将各场景的关系连接起来，并且说明它们之间的转换条件以及状态转换的流程，如图1所示。 图1 各场景转换条件以及状态转换的“状态图” 切分场景的好处 将游戏中不同的功能分类在不同的场景中来执行，除了可以将游戏功能执行时需要的环境明确分类之外，“重复使用”也是使用场景转换的好处之一。 从上面几个例子中可以看出，“登录场景”几乎是每款游戏必备的场景之一。而一般在登录场景中，会实现游戏初始化功能或玩家登录游戏时需要执行的功能，例如： 单机游戏：登录场景可以有加载游戏数据、让玩家选择存盘、进入游戏等步骤。 在线游戏：登录场景包含了许多复杂的在线登录流程，比如使用第三方认证系统、使用玩家自定义账号、与服务器连接、数据验证… 对于大多数的游戏开发公司来说，登录场景实现的功能，会希望通用于不同的游戏开发项目，使其保持流程的一致性。尤其对于在线游戏这种类型的项目而言，由于登录流程较为复杂，若能将各项目共同的部分（场景）独立出来，由专人负责开发维护并同步更新给各个项目，那么效率就能获得提升，也是比较安全的方式。在项目开发时，若是能重复使用这些已经设计良好的场景，将会减少许多开发时间。 《P级阵地》规划了3个场景，如图2所示。 图2 《P级阵地》规划的3个场景 开始场景（StartScene）：GameLoop游戏对象的所在，游戏启动及相关游戏设置的加载。 主画面场景（MainMenuScene）：显示游戏名称和“开始”按钮。 战斗场景（BattleScene）：游戏主要执行的场景。 游戏场景可能的实现方式实现Unity3D的场景转换较为直接的方式如下: Listing 1 一般场景控制的写法 123456789101112131415161718192021222324252627282930313233343536373839404142434445using UnityEngine;using System.Collections;using UnityEngine.UI;using UnityEngine.SceneManagement;public class SceneMgr : MonoBehaviour&#123; private string m_state ="开始"; // 改换场景 public void ChangeScene(string StateName) &#123; m_state = StateName; switch (m_state) &#123; case "菜单": SceneManager.LoadScene("MainMenuScene"); break; case "主场景": SceneManager.LoadScene("GameScene"); break; &#125; &#125; // Update is called once per frame void Update() &#123; switch (m_state) &#123; case "开始": Debug.Log("现在在开始场景"); break; case "菜单": Debug.Log("现在在菜单场景"); break; case "主场景": Debug.Log("现在在主场景"); break; &#125; &#125;&#125; 123456789101112131415161718192021222324252627using UnityEngine;using System.Collections;public class GameMgr : MonoBehaviour &#123; private SceneMgr scene_mgr; // Use this for initialization void Start () &#123; scene_mgr = gameObject.GetComponent&lt;SceneMgr&gt;(); scene_mgr.ChangeScene("菜单"); DontDestroyOnLoad(this.gameObject); &#125; // Update is called once per frame void Update () &#123; if (Input.GetMouseButtonDown(0)) &#123; scene_mgr.ChangeScene("主场景"); &#125; if (Input.GetMouseButtonDown(1)) &#123; scene_mgr.ChangeScene("开始"); &#125; &#125;&#125; 上述的实现方式会有以下缺点： 只要增加一个状态，则所有switch(m_state)的程序代码都需要增加对应的程序代码。 与每一个状态有关的对象，都必须在SceneManager类中被保留，当这些对象被多个状态共享时，可能会产生混淆，不太容易识别是由哪个状态设置的，造成游戏程序调试上的困难。 每一个状态可能使用不同的类对象，容易造成SceneManager类过度依赖其他类，让SceneManager类不容易移植到其他项目中。 为了避免出现上述缺点，修正的目标会希望使用一个“场景类”来负责维护一个场景，让与此场景相关的程序代码和对象能整合在一起。这个负责维护的“场景类”，其主要工作如下: 场景初始化； 场景结束后，负责清除资源； 定时更新游戏逻辑单元； 转换到其他场景； 其他与该场景有关的游戏实现。 由于在范例程序中我们规划了3个场景，所以会产生对应的3个“场景类”，但如何让这3个“场景类”相互合作、彼此转换呢？我们可以使用GoF的状态模式（State）来解决这些问题。 状态模式状态模式（State），在多数的设计模式书籍中都会提及，它也是游戏程序设计中应用最频繁的一种模式。主要是因为“状态”经常被应用在游戏设计的许多环节中，包含AI人工智能状态、账号登录状态、角色状态。 状态模式的定义状态模式，在GoF中的解释是: 1让一个对象的行为随着内部状态的改变而变化，而该对象也像是换了类一样。 如果将GoF对状态模式的定义改以游戏的方式来解释，就会像下面这样: “当德鲁伊（对象）由人形变化为兽形状态（内部状态改变）时，他所施展的技能（对象的行为）也会有所变化，玩家此时就像是在操作另一个不同的角色（像是换了类）”。 “德鲁伊”是一种经常出现在角色扮演游戏（RPG）中的角色名称。变化外形是他们常使用的能力，通过外形的变化，使德鲁伊具备了转换为其他形体的能力，而变化为“兽形”是比较常见的游戏设计。当玩家决定施展外形转换能力时，德鲁伊会进入“兽形状态”，这时候的德鲁伊会以“兽形”来表现其行为，包含移动和攻击施展的方式；当玩家决定转换回人形时，德鲁伊会复原为一般形态，继续与游戏世界互动。 所以，变化外形的能力可以看成是德鲁伊的一种“内部状态的转换”。通过变化外形的结果，角色表现出另外一种行为模式，而这一切的转化过程都可以由德鲁伊的内部控制功能来完成，玩家不必理解这个转化过程。但无论怎么变化，玩家操作的角色都是德鲁伊，并不会因为他内部状态的转变而有所差异。 当某个对象状态改变时，虽然它“表现的行为”会有所变化，但是对于客户端来说，并不会因为这样的变化，而改变对它的“操作方法”或“信息沟通”的方式。也就是说，这个对象与外界的对应方式不会有任何改变。但是，对象的内部确实是会通过“更换状态类对象”的方式来进行状态的转换。当状态对象更换到另一个类时，对象就会通过新的状态类，表现出它在这个状态下该有的行为。但这一切只会发生在对象内部，对客户端来说，完全不需要了解这些状态转换的过程及对应的方式。 状态模式的说明状态模式的结构如图3所示。 图3 状态模式的结构图 参与者的说明如下： Context（状态拥有者） 是一个具有“状态”属性的类，可以制定相关的接口，让外界能够得知状态的改变或通过操作让状态改变。 有状态属性的类，例如：游戏角色有潜行、攻击、施法等状态；好友上线、脱机、忙碌等状态；GoF使用TCP联网为例，有已连接、等待连接、断线等状态。这些类中会有一个ConcreteState[X]子类的对象为其成员，用来代表当前的状态。 State（状态接口类）：制定状态的接口，负责规范Context （状态拥有者）在特定状态下要表现的行为。 ConcreteState（具体状态类） 继承自State（状态接口类）。 实现Context（状态拥有者）在特定状态下该有的行为。例如，实现角色在潜行状态时该有的行动变缓、3D模型变半透明、不能被敌方角色察觉等行为。 状态模式的实现范例首先定义Context类： Listing 2 定义Context类（State.cs） 123456789101112131415public class Context&#123; State m_State = null; public void Request(int Value) &#123; m_State.Handle(Value); &#125; public void SetState(State theState) &#123; Debug.Log("Context.SetState:"+ theState); m_State = theState; &#125; &#125; Context类中，拥有一个State属性用来代表当前的状态，外界可以通过Request方法，让Context类呈现当前状态下的行为。SetState方法可以指定Context类当前的状态，而State状态接口类则用来定义每一个状态该有的行为： Listing 3 State类（State.cs） 12345678910public abstract class State&#123; protected Context m_Context = null; public State(Context theContext) &#123; m_Context = theContext; &#125; public abstract void Handle(int Value); &#125; 在产生State类对象时，可以传入Context类对象，并将其指定给State的类成员m_Context，让State类在后续的操作中，可以获取Context对象的信息或操作Context对象。然后定义Handle抽象方法，让继承的子类可以重新定义该方法，来呈现各自不同的状态行为。 最后定义3个继承自State类的子类： Listing 4 定义3个状态（State.cs） 12345678910111213141516171819202122232425262728293031323334353637383940//状态Apublic class ConcreteStateA : State&#123; public ConcreteStateA(Context theContext) : base(theContext)&#123;&#125; public override void Handle(int Value) &#123; Debug.Log("ConcreteStateA.Handle"); if( Value &gt; 10) m_Context.SetState( new ConcreteStateB(m_Context)); &#125;&#125;//状态Bpublic class ConcreteStateB : State&#123; public ConcreteStateB(Context theContext) : base(theContext)&#123;&#125; public override void Handle(int Value) &#123; Debug.Log("ConcreteStateB.Handle"); if( Value &gt; 20) m_Context.SetState( new ConcreteStateC(m_Context)) ; &#125;&#125;// 状态Cpublic class ConcreteStateC : State&#123; public ConcreteStateC(Context theContext) : base(theContext)&#123;&#125; public override void Handle(int Value) &#123; Debug.Log("ConcreteStateC.Handle"); if( Value &gt; 30) m_Context.SetState( new ConcreteStateA(m_Context)); &#125;&#125; 上述3个子类，都要重新定义父类State的Handle抽象方法，用来表示在各自状态下的行为。在范例中，我们先让它们各自显示不同的信息（代表当前的状态行为），再按照本身状态的行为定义来判断是否要通知Context对象转换到另一个状态。 Context类中提供了一个SetState方法，让外界能够设置Context对象当前的状态，而所谓的“外界”，也可以是由另一个State状态来调用。所以实现上，状态的转换可以有下列两种方式： 交由Context类本身，按条件在各状态之间转换； 产生Context类对象时，马上指定初始状态给Context对象，而在后续执行过程中的状态转换则交由State对象负责，Context对象不再介入。 笔者在实现时，大部分情况下会选择第2种方式，原因在于： 状态对象本身比较清楚“在什么条件下，可以让Context对象转移到另一个State状态”，所以在每个ConcreteState类的程序代码中，可以看到“状态转换条件”的判断，以及设置哪一个ConcreteState对象成为新的状态。 每个ConcreteState状态都可以保持自己的属性值，作为状态转换或展现状态行为的依据，不会与其他的ConcreteState状态混用，在维护时比较容易理解。 因为判断条件及状态属性都被转换到ConcreteState类中，故而可缩减Context类的大小。 4个类定义好之后，我们可以通过测试范例来看看客户端程序会怎样利用这个设计： Listing 5 State的测试范例（StateTest.cs） 123456789void UnitTest()&#123; Context theContext = new Context(); theContext.SetState(new ConcreteStateA(theContext)); theContext.Request(5); theContext.Request(15); theContext.Request(25); theContext.Request(35);&#125; 首先产生Context对象theContext，并立即设置为ConcreteStateA状态；然后调用Context类的Request方法，并传入作为“状态转换判断”用途的参数，让当前状态（ConcreteStateA）判断是否要转移到ConcreteStateB；最后调用几次Request方法，并传入不同的参数。 从输出的信息中可以看到，Context对象的状态由ConcreteStateA按序转换到ConcreteStateB.ConcreteStateC状态，最后回到ConcreteStateA状态。 执行结果 State测试范例产生的信息 123456Context.SetState:DesignPattern_State.ConcreteStateAConcreteStateA.HandleConcreteStateA.HandleContext.SetState:DesignPattern_State.ConcreteStateBContext.SetState:DesignPattern_State.ConcreteStateCContext.SetState:DesignPattern_State.ConcreteStateA 使用状态模式实现游戏场景的转换在Unity3D的环境中，游戏只会在一个场景中运行，所以我们可以让每个场景都由一个“场景类”来负责维护。此时，如果将场景类当成“状态”来比喻的话，那么就可以利用状态模式的转换原理，来完成场景转换的功能。 由于每个场景所负责执行的功能不同，通过状态模式的状态转移，除了可以实现游戏内部功能的转换外，对于客户端来说，也不必根据不同的游戏状态来编写不同的程代码，同时也减少了外界对于不同游戏状态的依赖性。 而原本的Unity3D场景转换判断功能，可以在各自的场景类中完成，并且状态模式同时间也只会让一个状态存在（同时间只会有一个状态在运行），因此可以满足Unity3D执行时只能有一个场景（状态）存在的要求。 SceneState的实现《P级阵地》的场景分成3个：开始场景（StarScene）、主画面场景（MainMenuScene）和战斗场景（BattleScene），所以声明3个场景类负责对应这3个场景。这3个场景类都继承自ISceneState而SceneStateController则是作为这些状态的拥有者（Context），最后将SceneStateController对象放入GameLoop类下，作为与Unity3D运行的互动接口，上述结构如图4所示。 图4 3个场景类的结构图 其中的参与者如下说明： ISceneState：场景类的接口，定义《P级阵地》中场景转换和执行时需要调用的方法。 StartState、MainMenuState、BattleState：分别对应范例中的开始场景（StarScene），主画面场景（MainMenuScene）及战斗场景（BattleScene），作为这些场景执行时的操作类。 SceneStateController：场景状态的拥有者（Context），保持当前游戏场景状态，并作为与GameLoop类互动的接口。除此之外，也是执行“Unity3D场景转换”的地方。 GameLoop：游戏主循环类。作为Unity3D与《P级阵地》的互动接口，包含了初始化游戏和定期调用更新操作。 实现说明首先，定义ISceneState接口如下: Listing 6 定义ISceneState类（ISceneState.cs） 12345678910111213141516171819202122232425262728293031323334353637383940using UnityEngine;using System.Collections;// 场景状态public class ISceneState&#123; // 状态名称 private string m_StateName = "ISceneState"; public string StateName &#123; get&#123; return m_StateName; &#125; set&#123; m_StateName = value; &#125; &#125; // 控制者 protected SceneStateController m_Controller = null; // 建造者 public ISceneState(SceneStateController Controller) &#123; m_Controller = Controller; &#125; // 开始 public virtual void StateBegin() &#123;&#125; // 结束 public virtual void StateEnd() &#123;&#125; // 更新 public virtual void StateUpdate() &#123;&#125; public override string ToString () &#123; return string.Format("[I_SceneState: StateName=&#123;0&#125;]", StateName); &#125;&#125; ISceneState定义了在《P级阵地》中，场景转换执行时需要被Unity3D通知的操作，包含： StateBegin方法：场景转换成功后会利用这个方法通知类对象。其中可以实现在该场景执行时需要加载的资源及游戏参数的设置。SceneStateController在此时才传入（不像前一节范例那样在建造者中传入），因为Unity3D在转换场景时会花费一些时间，所以必须先等到场景完全加载成功后才能继续执行。 StateEnd方法：场景将要被释放时会利用这个方法通知类对象。其中可以释放游戏不再使用的资源，或者重新设置游戏场景状态。 StateUpdate方法：“游戏定时更新”时会利用这个方法通知类对象。该方法可以让Unity3D的“定时更新功能”被调用，并通过这个方法让其他游戏系统也定期更新。这个方法可以让游戏系统类不必继承Unity3D的MonoBehaviour类，也可以拥有定时更新功能，第7章会对此进行更详细地说明。 m_StateName属性：可以在调试（Debug）时使用。 StateBegin、StateEnd及StateUpdate这3个方法，虽然是定义为IScenesState中的接口方法，但是由于不强迫子类重新实现它，所以并没有被定义为抽象方法。 共有3个子类继承自ISceneState，分别用来负责各Unity3D Scene的运行和转换。首先是负责开始场景（StartScene）的类，程序代码如下： Listing 7 定义开始状态类（StartState.cs） 12345678910111213141516171819202122232425using UnityEngine;using UnityEngine.UI;using System.Collections;// 开始状态public class StartState : ISceneState&#123; public StartState(SceneStateController Controller) : base(Controller) &#123; this.StateName = "StartState"; &#125; // 开始 public override void StateBegin() &#123; // 可在此进行游戏数据加载和初始化等 &#125; // 更新 public override void StateUpdate() &#123; // 更换为 m_Controller.SetState(new MainMenuState(m_Controller), "MainMenuScene"); &#125; &#125; 《P级阵地》的运行，必须在开始场景（StartScene）中单击“开始”按钮才能运行，所以游戏最开始的场景状态会被设置为StartState。因此在实现上，可在StateBegin方法中，将游戏启动时所需要的资源加载，这些资源可以是游戏属性数据、角色组件预载、游戏系统初始化、版本信息等。当StartState的StateUpdate第一次被调用时，会马上将游戏场景状态转换为MainMenuState，完成StartState/StartScene初始化游戏的任务。 主画面场景（MainMenuScene）负责显示游戏的开始画面，并且提供简单的界面让玩家可以开始进入游戏，程序代码如下： Listing 8 定义主菜单状态（MainMenuState.cs） 12345678910111213141516171819202122232425262728using UnityEngine;using UnityEngine.UI;using System.Collections;// 主菜单状态public class MainMenuState : ISceneState&#123; public MainMenuState(SceneStateController Controller) : base(Controller) &#123; this.StateName = "MainMenuState"; &#125; // 开始 public override void StateBegin() &#123; // 取得开始按钮 Button tmpBtn = UITool.GetUIComponent&lt;Button&gt;("StartGameBtn"); if(tmpBtn != null) tmpBtn.onClick.AddListener( ()=&gt; OnStartGameBtnClick(tmpBtn) ); &#125; // 开始战斗 private void OnStartGameBtnClick(Button theButton) &#123; //Debug.Log ("OnStartBtnClick:"+theButton.gameObject.name); m_Controller.SetState(new BattleState(m_Controller), "BattleScene" ); &#125;&#125; 《P级阵地》的开始画面上只有一个“开始”按钮，这个按钮是使用Unity3D的UI工具增加的。从原本Unity3D的UI设置界面上，可直接设置当按钮被鼠标单击时，需要由哪一个脚本组件的方法来执行；这个设置动作也可以改由程序代码来指定。至于《P级阵地》与Unity3D的UI设计工具的整合，在第17章中有进一步的说明。 因此，在MainMenuState的StateBegin方法中，获取MainMenuScene的“开始”按钮（StartGameBtn）后，将其OnClick事件的监听者设置为OnStartGameBtnClick方法，而该方法也将直接实现在MainMenuState类中。所以，当玩家单击“开始”按钮时， OnStartGameBtnClick会被调用，并将游戏场景状态通过SceneStateController转换到战斗场景（BattleScene）。 战斗场景为《P级阵地》真正游戏玩法（阵地防守）场景，程序代码如下: Listing 9 定义战斗状态（BattleState.cs） 123456789101112131415161718192021222324252627282930313233343536using UnityEngine;using UnityEngine.UI;using System.Collections;// 战斗状态public class BattleState : ISceneState&#123; public BattleState(SceneStateController Controller) : base(Controller) &#123; this.StateName = "BattleState"; &#125; // 开始 public override void StateBegin() &#123; PBaseDefenseGame.Instance.Initinal(); &#125; // 结束 public override void StateEnd() &#123; PBaseDefenseGame.Instance.Release(); &#125; // 更新 public override void StateUpdate() &#123; // 游戏逻辑 PBaseDefenseGame.Instance.Update(); // Render由Unity负责 // 游戏是否结束 if( PBaseDefenseGame.Instance.ThisGameIsOver()) m_Controller.SetState(new MainMenuState(m_Controller), "MainMenuScene" ); &#125;&#125; 负责战斗场景（BattleScene）的BattleState状态类在StateBegin方法中，首先调用了游戏主程序PBaseDefenseGame的初始化方法： 1234public override void StateBegin()&#123; PBaseDefenseGame.Instance.Initinal();&#125; 当《P级阵地》在一场战斗结束或放弃战斗时，玩家可以回到主菜单场景（MainMenuState）。所以，当战斗场景即将结束时，StateEnd方法就会被调用，实现上，会在此调用释放游戏主程序的操作： 1234public override void StateEnd()&#123; PBaseDefenseGame.Instance.Release();&#125; BattleState的StateUpdate方法扮演着“游戏循环”的角色（GameLoop将在第7章中说明）。先获取玩家的“输入操作”后，再执行“游戏逻辑” （调用PBaseDefenseGame的Update方法），并且不断地定时重复调用，直到游戏结束转换为主菜单场景（MainMenuState）为止： 123456789101112public override void StateUpdate()&#123; // 输入 InputProcess(); // 游戏逻辑 PBaseDefenseGame.Instance.Update(); // Render由Unity负责 // 游戏是否结束 if( PBaseDefenseGame.Instance.ThisGameIsOver()) m_Controller.SetState(new MainMenuState(m_Controller), "MainMenuScene" );&#125; 3个主要的游戏状态类都定义完成后，接下来就是实现这些场景转换和控制的功能： Listing 10 定义场景状态控制者（SceneStateController.cs） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using UnityEngine;using System.Collections;using UnityEngine.SceneManagement;// 场景状态控制者public class SceneStateController&#123; private ISceneState m_State; private bool m_bRunBegin = false; public SceneStateController() &#123;&#125; // 设定状态 public void SetState(ISceneState State, string LoadSceneName) &#123; //Debug.Log ("SetState:"+State.ToString()); m_bRunBegin = false; // 载入场景 LoadScene( LoadSceneName ); // 通知前一个State结束 if( m_State != null ) m_State.StateEnd(); // 设定 m_State=State; &#125; // 载入场景 private void LoadScene(string LoadSceneName) &#123; if( LoadSceneName==null || LoadSceneName.Length == 0 ) return ; SceneManager.LoadLevel( LoadSceneName ); &#125; // 更新 public void StateUpdate() &#123; // 是否还在载入 if( Application.isLoadingLevel) return ; // 通知新的State开始 if( m_State != null &amp;&amp; m_bRunBegin==false) &#123; m_State.StateBegin(); m_bRunBegin = true; &#125; if( m_State != null) m_State.StateUpdate(); &#125;&#125; SceneStateController类中有一个ISceneState成员，用来代表当前的游戏场景状态。在SetState方法中，实现了转换场景状态的功能，该方法先使用SceneManager.LoadLevel方法来加载场景；然后通知前一个状态的StateEnd方法来释放前一个状态；最后将传入的参数设置为当前状态。 至于SceneUpdate方法，则是会先判断场景是否载入成功，成功之后才会调用当前游戏场景状态的StateBegin方法来初始化游戏场景状态。 最后，将SceneStateController与GameLoop脚本组件结合如下： Listing 11 与游戏主循环的结合（GameLoop.cs） 1234567891011121314151617181920212223242526272829303132using UnityEngine;using System;using System.Collections;// 游戏主循环public class GameLoop : MonoBehaviour &#123; // 场景状态 SceneStateController m_SceneStateController = new SceneStateController(); void Awake() &#123; // 转换场景不会被删除 GameObject.DontDestroyOnLoad( this.gameObject ); // 随机数种子 UnityEngine.Random.seed = (int)DateTime.Now.Ticks; &#125; // Use this for initialization void Start() &#123; // 设置起始的场景 m_SceneStateController.SetState(new StartState(m_SceneStateController), ""); &#125; // Update is called once per frame void Update() &#123; m_SceneStateController.StateUpdate(); &#125;&#125; 在GameLoop脚本组件中，定义并初始化SceneStateController类对象，并在Start方法中设置第一个游戏场景状态：StartState。之后在GameLoop脚本组件每次的Update更新方法中，调用SceneStateController对象的StateUpdate方法，让当前的场景状态类能够被定时更新。 使用状态模式的优点使用状态模式来实现游戏场景转换，有下列优点: 减少错误的发生并降低维护难度 不再使用switch(m_state)来判断当前的状态，这样可以减少新增游戏状态时，因未能检查到所有switch(m_state)程序代码而造成的错误。 状态执行环境单一化 与每一个状态有关的对象及操作都被实现在一个场景状态类下，这样可以清楚地了解每一个状态执行时所需要的对象及配合的类。 项目之间可以共享场景 本章开始时就提到，有些场景可以在不同项目之间共享。以当前《P级阵地》使用的3个场景及状态类为例，其中的开始场景（StartScene）和开始状态类（StartState）都可以在不同项目之间共享。例如：可以在开始状态类（StartState）的StateBegin方法中，明确定义出游戏初始化时的步骤，并将这些步骤搭配“模版方法模式（Template Method）”或“策略模式（Strategy）”，就能让各项目自行定义符合各个游戏需求的具体实现，达到各项目共享场景的目的。 这种做法对于网络在线型的游戏项目特别有用，在此类型的项目中，玩家的上线、登录、验证、数据同步等过程，实现上存在一定的复杂度。若将这些复杂的操作放在共享的场景中，共享使用与维护，就可以节省许多的开发时间及成本。 游戏执行流程及场景转换说明从Unity游戏开始执行的流程来看，《P级阵地》通过StartScene场景中唯一的GameLoop游戏对象，以及挂在其上的GameLoop脚本组件，将整个游戏运行起来。所以，在GameLoop的Start方法中设置好第一个游戏场景状态后， GameLoop的Update方法就将游戏的控制权交给SceneStateController。而SceneStateController内部则会记录当前的游戏场景状态类，之后再通过调用游戏场景状态的StateUpdate方法，就能够完成更新当前游戏场景状态的需求。上述流程可以参考下面的流程图，如图5所示。 图5 流程图 状态模式面对变化时随着项目开发进度进入中后期，游戏企划可能会提出新的系统功能来增加游戏内容。这些提案可能是增加小游戏关卡、提供查看角色信息图鉴、玩家排行等功能。当程序人员在分析这些新增的系统需求后，如果觉得无法在现有的场景下实现，就必须使用新的场景来完成。而在现有的架构下，程序人员只需要完成下列几项工作： 在Unity3D编辑模式下新增场景。 加入一个新的场景状态类对应到新的场景，并在其中实现相关功能。 决定要从哪个现有场景转换到新的场景。 决定新的场景结束后要转换到哪一个场景。 上述流程，就程序代码的修改而言，只会新增一个程序文件（.cs）用来实现新的场景状态类，并修改一个现有的游戏状态，让游戏能按照需求转换到新的场景状态。除此之外，不需要修改其他任何的程序代码。 结论在本章中，我们利用状态模式实现了游戏场景的切换，这种做法并非全然都是优点，但与传统的switch(state_code)相比，已经算是更好的设计。此外，正如前面章节所介绍的，设计模式并非只能单独使用，在实际开发中，若多种设计模式搭配得宜，将会是更好的设计。因此，本章结尾，我们将讨论，本章所做的设计还有哪些应该注意的地方，以及还可以将状态模式应用在游戏设计的哪些地方。 状态模式的优缺点 使用状态模式可以清楚地了解某个场景状态执行时所需要配合使用的类对象，并且减少因新增状态而需要大量修改现有程序代码的维护成本。 《P级阵地》只规划了3个场景来完成整个游戏，算是“产出较少状态类”的应用。但如果状态模式是应用在有大量状态的系统时，就会遇到“产生过多状态类”的情况，此时会伴随着类爆炸的问题，这算是一个缺点。不过与传统使用switch(state_code)的实现方式相比，使用状态模式对于项目后续的长期维护效益上，仍然具有优势。 在本书后面（第12章）讲解到AI实现时，还会再次使用状态模式来实现，届时，读者可看到其他利用状态模式的应用。 与其他模式的合作 在《P级阵地》的BattleState类实现中，分别调用了PBaseDefenseGame类的不同方法，此时的PBaseDefenseGame使用的是“单例模式”，这是一种让BattleState类方法中的程序代码，可以取得唯一对象的方式。而PBaseDefenseGame也使用了“外观模式”来整合PBaseDefenseGame内部的复杂系统，因此BattleState类不必了解太多关于PBaseDefenseGame内部的实现方式。 状态模式的其他应用方式： 角色AI：使用状态模式来控制角色在不同状态下的AI行为。 游戏服务器连线状态：网络游戏的客户端，需要处理与游戏服务器的连线状态，一般包含开始连线、连线中、断线等状态，而在不同的状态下，会有不同的封包信息处理方式，需要分别实现。 关卡进行状态：如果是通关型游戏，进入关卡时通常会分成不同的阶段，包含加载数据、显示关卡信息、倒数通知开始、关卡进行、关卡结束和分数计算，这些不同的阶段可以使用不同的状态类来负责实现。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式与游戏完美开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity资产，特殊文件夹以及重要路径]]></title>
    <url>%2F2019%2F08%2F06%2FUnity%E8%B5%84%E4%BA%A7%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E9%87%8D%E8%A6%81%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本文将介绍Unity中的资产，Unity中的特殊文件夹，Unity的一些路径对应各个平台上的具体路径。 第一部分就是介绍资产Assets——哪些是Assets，Assets类型具体有哪些，如何在编辑器中搜索特定的Assets，与Assets息息相关的meta文件，对于从外界导入的Assets怎么进行流程化处理，如何设置对于一些二进制的资产进行序列化。 第二部分是Unity工程目录下的一些有特定用处特殊命名的文件夹。 第三部分介绍 Application.dataPath，Application.streamingAssetsPath，Application.persistentDataPath，Application.temporaryCachePath这四个接口在IOS，Android和Windows下具体的路径在哪里。 第四部分是Unity自带的工具。目录 一：资产类型 1.资产(Asset)和资源(Resource)的区别： 2.资产类型（通过扩展名识别）： 3.搜索资产和加载资产 4.资产meta文件 5.资产导入 6.资产序列化 二：特殊文件夹 1.Assets文件夹下的特殊文件夹 2.Library文件夹 1）ScriptAssemblies文件夹 2）metadata文件夹 3）AtlasCache 和 ShaderCache 3.ProjectSettings文件夹 4.Temp 三：重要路径 iOS 1.四个路径对应的平台下的路径 2.app的独立数据存储目录 3.各路径对应的OC访问方法 Android 1.四个路径对应的平台下的路径 2.重要目录 Windows: 四：Unity工具 1.查看unity里的二进制文件 参考： 一：资产类型1.资产(Asset)和资源(Resource)的区别：资产：Assets目录下的所有文件和文件夹 资源：Resources特殊目录下的文件 2.资产类型（通过扩展名识别）：•场景(.unity) •预置体(.prefab) •模型(.fbx) •贴图(.jpeg/.png/.tga/…) •脚本(.cs/.js) •文本(.txt/.bytes/.json/…) •声音等… 特别的，对于Lua脚本 因为扩展名是.lua不能被Unity识别为TextAsset 所以打包lua时候：先改扩展名 .bytes–》再打包AssetBundle–》最后再改回来 3.搜索资产和加载资产1.Project 视图： 搜索框输入比如 t:Prefab t:Mesh t:Scene t:Model t:ScriptableObject （等价于点击搜索框右边的 SearchByType） 2.代码中使用搜索：接口 AssetDatabase.FindAssets string[] guids = AssetDatabase.FindAssets(“t:Mesh”, searchFolder);3.代码中加载资产，使用对应的类：接口 AssetDatabase.LoadAssetAtPath AudioClip audioClip = AssetDatabase.LoadAssetAtPath(“XXXX路径下音频名.wav”,typeof(AudioClip)) as AudioClip; 4.资产meta文件Asset中的所有文件、文件夹，经过unity的导入过程后，会为每个都生成一个.meta文件，这个文件是unity内部管理文件的重要内容，包含： 1）GUID（标识资产的唯一编号）。 优点之一是对象之间的引用不是通过资产路径来引用，而是通过GUID来引用。所以改变资产路径不会使得引用失效。所以一旦Meta中的GUID变更了，就要注意，它很可能引起一场引用丢失的灾难。编辑器中使用AssetDatabase.GUIDToAssetPath和AssetDatabase.AssetPathToGUID中可以进行互转。 GUID保持不变的情况：移动、重命名、改动资源文件，都对GUID没有影响，GUID还是指向这个资源文件。 GUID改变的情况：注意不要随意删除资源文件相关的meta文件。如果删除了meta文件，unity会认为原始的资源文件被删除了，并给此资源重新生成一个新的GUID。（为什么有时候场景中资源的引用会突然断开）2）导入设置（default import setting）：可以在meta文件中找一下在导入设置中的对应项目。 根据不同的文件类型，它的数据是不同的ImportSetting数据，比如上面的NativeFormatImporter、ModelImporter、AudioImporter等等。只要对照Inspector面板中的条目，都可以看懂每一行的意义。所以假如我们把一个文件和这个文件的Meta文件从一个Unity工程复制到另一个Unity工程中，它的配置是不会变的 关于meta文件 1. 新增资产文件或文件夹，一定要连同生成的meta文件一同提交。 2. 重命名和移动要在Unity内进行，这样可以保证相应的meta文件自动完成相应操作。 3. 复制资产时尽量在Unity内用Ctrl+D进行，这样会生成GUID不同的meta文件。 4. 用脚本操作资产时要注意meta文件的同步，尽量用AssetDatabase类的API而非文件I/O。 5. AssetDatabase.Refresh() 何时使用：当你使用System.IO 的东西去增删文件的时候，需要调用这个函数把修改的东西导入一遍，防止 Unity 继续使用缓存内容。如果使用 AssetDatabase 的方法来增删文件，是不需要调用这个函数。5.资产导入导入单个资产可能要花费好几秒。以贴图为例，需要做的一些事情： 生成必要的压缩图片以用于目标平台 生成预览用的小图 生成GUID …… 使用 脚本 将导入流程自动化 AssetPostprocessor 类。 待看： https://blogs.unity3d.com/cn/2012/10/26/in-depth-cache-server/ https://blogs.unity3d.com/cn/2012/10/26/in-depth-cache-server/ 6.资产序列化 二：特殊文件夹1.Assets文件夹下的特殊文件夹Editor1.不会被打包。 2.放一些编辑器脚本，插件的安装包，以及不需要打进包的工具的资源。 Plugins1.会被打包。可以不放在根目录下。 2.用来放插件，jar包，第三方SDK等。 Resources1.资源会被压缩，转化成二进制。会被加密。 2.使用Resources.Load加载 3.不应放太多资源，以及配置文件等资源。Resources 目录大小和启动速度的关系https://blog.uwa4d.com/archives/QA_Loading_1.html 1.该文件夹下的资源无论使用与否都会被打包。 2.打包后文件夹下的资源只读。 3.无法做热更新。 Streaming Assets1.打包时候资源不压缩不加密。所以此文件夹一定要注意大小，打包前多大，就会多大打到包中。 2.加载路径：Android平台上的特殊性——不能直接用文件I/O，即不能用Application.streamingAssetsPath 应该用：”jar:file://“+Application.dataPath+”!/assets” 3.在这个文件夹下主要存放一些二进制文件。 2.Library文件夹此放的是程序集和库的缓存文件。 1）ScriptAssemblies文件夹存放的是当前工程的程序集： 其依赖关系，分成运行时程序集和编辑器程序集（各自都要依赖于firstpass，所以取名叫first） 编辑器程序集：是在 Editor 目录里的代码构成的。 运行时程序集：打包的时候只会构建运行时的程序集。 2）metadata文件夹存放的是 unity导入的原始资源（存放Assets文件夹下）生成了unity内部特定的格式（unity可识别）文件在游戏中使用的文件。 每次修改了原始资源文件，就需要重新导入，生成unity可识别的文件格式。即每次删除此文件夹，再次打开unity，也就是重新导入一次，重新生成这个文件夹的那些文件。 文件夹都是两个字符，取自文件的GUID的前两个字符，文件名即是GUID。（meta文件） 如果把Assets文件夹下的原始资源删除了，Unity会自动删除其meta文件，以及 metadata文件夹下相关的文件。 3）AtlasCache文件夹 和 ShaderCache文件夹 atlas和shader的缓存。 4）assetDatabase3类AssetDatabase的数据支撑。 保证了mete被删除后，仍能创建回拥有相同guid的meta文件。 而删除了整个Library，当Library再次重建回来，被删的meta创建出来的guid就不再一样了。 3.ProjectSettings文件夹此文件夹下是很多 .asset 文件，可以以文本的方式打开查看。 各个文件对应与工程中的 Project Settings 中的各个项。在Unity编辑器中设置了这些项目属性以后，其实都是存储在了这个文件夹下的.asset文件中。 ps：如果想查看Unity工程是用哪个版本打开的，除了直接用Unity打开查看以外，还可以看这个目录下的 ProjectVersion.txt 这个文件。 4.TempLibrary 和 Temp 都是缓存，可以删除，因此也不应该在版本控制之下。 三：重要路径iOS1.四个路径对应的平台下的路径Application.dataPath/var/containers/Bundle/Application/app sandbox/xxx.app/Data 也就是app安装路径，app本身就在这里，此目录是只读的。 Application.streamingAssetsPath/var/containers/Bundle/Application/app sandbox/xxx.app/Data/Raw streamingAssetsPath是dataPath下的Raw目录。 Application.persistentDataPath/var/mobile/Containers/Data/Application/app sandbox/Documents 下面介绍独立数据存储目录的 Documents目录 Application.temporaryCachePath/var/mobile/Containers/Data/Application/app sandbox/Library/Caches 下面介绍独立数据存储目录的 Library下的Caches子目录 2.app的独立数据存储目录Documents文件夹 这个目录用于存储需要长期保存的数据，比如我们的热更新内容就写在这里。需要注意的是，iCloud会自动备份此目录，如果此目录下写入的内容较多，审核的可能会被苹果拒掉。Library文件夹 Caches子目录一个相对临时的目录，适合存放下载缓存的临时文件，空间不足时可能会被系统清除。 我把热更新的临时文件写在这里，等一个版本的所有内容更新完全后，再把内容转移到Documents目录 Preferences子目录 用于应用存储偏好设置，用NSUserDefaults读取或设置。tmp文件夹 临时目录，存放应用运行时临时使用的数据3.各路径对应的OC访问方法app安装路径 [[NSBundle mainBundle] resourcePath]app数据沙盒存储根目录 NSHomeDirectory()Documents NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)Library NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES)Caches NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)tmp NSTemporaryDirectory() Android1.四个路径对应的平台下的路径Application.dataPath /data/app/package name-n/base.apk 也就是apk安装路径 Application.streamingAssetsPath jar:file:///data/app/package name-1/base.apk!/assetsApplication.persistentDataPath/storage/emulated/0/Android/data/package name/files 外部存储路径-私有目录-files目录 Application.temporaryCachePath/storage/emulated/0/Android/data/package name/cache 外部存储路径-私有目录-cache目录 2.重要目录 各路径对应的Java访问方法 apk安装路径/data/app/package name-n/base.apk 就是上面的dataPath返回的目录 AssetManager.open(String filename)内存存储路径(InternalStorage)/data/data/package name-n/，用户或其它app都不能访问。 打开会发现里面有4个目录（需要root） cache 缓存目录，类似于iOS的Cache目录context.getFilesDir().getPath() 或者 context.getCacheDir().getPath() databases 数据库文件目录files 文件目录，类似于iOS的Documents目录shared_prefs，类似于iOS的Preferences目录，用于存放常用设置，比如Unity3D的PlayerPrefs就存放于此外部存储路径(ExternalStorage)在内置或外插的sd上，用户或其它app都可以访问。 外部存储目录又分私有和公有目录 公有目录 有DCIM、Music、Movies、Download这样系统创建的公共目录， 也有各自app创建的文件夹（在sd卡根目录下），卸载app数据依旧存在。 context.getExternalFilesDir().getPath() 或者 context.getExternalCacheDir().getPath() 私有目录 /storage/emulated/n/Android/data/package name/ 打开可以看到里面有两个文件夹cache和files。 为什么跟内部存储目录重复了？ 这是为了更大的存储空间，以防内存存储空间较小。 推荐把不需要隐私的、较大的数据存在这里，而需要隐私的或较小的数据存在内部存储空间。 Windows:Application.dataPath 应用的appname_Data/Application.streamingAssetsPath应用的appname_Data/StreamingAssets Application.persistentDataPathC:\Users\username\AppData\LocalLow\company name\product name Application.temporaryCachePathC:\Users\username\AppData\Local\Temp\company name\product name 四：Unity工具1.查看unity里的二进制文件.prefab .anim .mat .assets 以及 metadata下的文件 用 Unity\Editor\Data\Tools 安装路径下的 binary2text.exe 进行转化 2.查看Editor的日志\AppData\Local\Unity\Editor 版权声明：本文为CSDN博主「ivy_0709」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/u012138730/article/details/81143413]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第15章 提升游戏真实感]]></title>
    <url>%2F2019%2F08%2F06%2F%E7%AC%AC15%E7%AB%A0-%E6%8F%90%E5%8D%87%E6%B8%B8%E6%88%8F%E7%9C%9F%E5%AE%9E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第14章 使用Photon Cloud制作网络游戏]]></title>
    <url>%2F2019%2F08%2F06%2F%E7%AC%AC14%E7%AB%A0-%E4%BD%BF%E7%94%A8Photon-Cloud%E5%88%B6%E4%BD%9C%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第13章 Unity内置网络游戏]]></title>
    <url>%2F2019%2F08%2F06%2F%E7%AC%AC13%E7%AB%A0-Unity%E5%86%85%E7%BD%AE%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解PHP数组的底层实现：HashTable]]></title>
    <url>%2F2019%2F08%2F06%2F%E8%AF%A6%E8%A7%A3PHP%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9AHashTable%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言PHP中的数组是一种强大且灵活的数据类型。在讲解它的底层实现之前，让我们先来看看它在实际使用中都有哪些重要的特性： 12345678910111213141516171819202122// 可以使用数字下标的形式定义数组$arr= ['Mike', 2 =&gt; 'JoJo'];echo $arr[0], $arr[2];// 也可以使用字符串下标定义数组$arr = ['name' =&gt; 'Mike', 'age' =&gt; 22];// 可以顺序读取数组中的数据foreach ($arr as $key =&gt; $value) &#123; // Do Something&#125;echo current($arr);echo next($arr);// 也可以随机读取数组中的数据$arr = ['name' =&gt; 'Mike', 'age' =&gt; 22];echo $arr['name'];// 数组的长度是可变的$arr = [1, 2, 3];$arr[] = 4;array_push($arr, 5); 基于这些特性，我们可以很轻易的使用PHP中的数组实现集合、栈、列表、字典等多种数据结构。那么这些特性在底层是如何实现的呢？且听我细细道来。 数据结构PHP中的数组实际上是一个有序映射。映射是一种把values关联到keys的类型。—— PHP手册 在 PHP 中，这种映射关系是使用散列表（HashTable）实现的，在C语言中，只能通过数字下标访问数组元素，而通过 HashTable，我们可以使用 String Key 作为下标来访问数组元素。简单地说，HashTable 通过映射函数将一个Strring Key转化为一个普通的数字下标，并将对应的 Value 值储存到下标对应的数组元素中。 PHP 中的HashTable由zend_array定义，它的数据结构如下： 123456789101112131415161718192021struct _zend_array &#123; zend_refcounted_h gc; union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar flags, zend_uchar nApplyCount, zend_uchar nIteratorsCount, zend_uchar reserve) &#125; v; uint32_t flags; /* 通过 32 个可用标识，设置散列表的属性 */ &#125; u; uint32_t nTableMask; /* 值为 nTableSize 的负数 */ Bucket *arData; /* 用来储存数据 */ uint32_t nNumUsed; /* arData 中的已用空间大小 */ uint32_t nNumOfElements; /* 数组中的元素个数 */ uint32_t nTableSize; /* 数组大小，总是 2 幂次方 */ uint32_t nInternalPointer; /* 下一个数据元素的指针，用于迭代（foreach） */ zend_long nNextFreeElement; /* 下一个可用的数值索引 */ dtor_func_t pDestructor; /* 数据析构函数（句柄） */&#125;; 该结构中的 Bucket 即储存元素的数组，arData 指向数组的起始位置，使用映射函数对 key 值进行映射后可以得到偏移值，通过内存起始位置 + 偏移值即可在散列表中进行寻址操作。Bucket 的数据结构如下： 12345typedef struct _Bucket &#123; zval val; /* 值 */ zend_ulong h; /* 使用 time 33 算法对 key 进行计算后得到的哈希值（或为数字索引） */ zend_string *key; /* 当 key 值为字符串时，指向该字符串对应的 zend_string（使用数字索引时该值为 NULL） */&#125; Bucket; 基本实现散列表主要由储存元素的数组（Bucket）和散列函数两部分构成。 随机读当指定一个 Key-Value 映射关系时，如果 Key 为 String 类型，则先通过 Time 33 算法将其转换为一个 Int 类型的整数，然后再先通过 PHP 中某种特定的散列算法将该 Int 映射为 Bucket 数组中的一个下标，最终将 Value 储存到该下标对应的元素中。通过 Key 访问数组时，只需要使用相同的算法计算出对应下标，然后取出对应元素中的 Value 值，即可实现随机读取。 顺序读由上面所讲可知，储存在HashTable中的元素是无序的，而PHP中的数组是有序的，PHP是如何解决这个问题的呢？ 为了实现HashTable的有序性，PHP为其增加了一张中间映射表，该表是一个大小与 Bucket 相同的数组，数组中储存整形数据，用于保存元素实际储存的 Value 在 Bucekt中的下标。注意，加入了中间映射表后，Bucekt 中的数据是有序的，而中间映射表中的数据是无序的。这样顺序读取时只需要访问 Bucket 中的数据即可。 zend_array 中并没有单独定义中间映射表，而是将其与 arData 放在一起，数组初始化时并不只分配 Bucket 大小的内存，同时还会分配相同大小空间的数据来作为中间映射表，其实现方式如图： 散列函数由上一节可知，散列函数实际上是先将 hash code 映射到中间映射表中，再由中间映射表指向实际存储 Value 的元素。PHP 中采用如下方式对 hash code 进行散列：nIndex = key-&gt;h | nTableMask;复制代码因为散列表的大小恒为 2 的幂次方，所以散列后的值会位于 [nTableMask, -1] 之间，即中间映射表之中。 Hash冲突任何散列函数都会出现哈希冲突的问题，常见的解决哈希冲突的方法有以下几种： 开放定址法链地址法重哈希法 PHP 采用的是其中的链地址法，将冲突的 Bucket 串成链表，这样中间映射表映射出的就不是某一个元素，而是一个 Bucket 链表，通过散列函数定位到对应的 Bucket 链表时，需要遍历链表，逐个对比 Key 值，继而找到目标元素。新元素 Hash 冲突时的插入分为以下两步： 将旧元素的下标储存到新元素的 next 中将新元素的下标储存到中间映射表中 可以看出，PHP 在 Bucket 原有的数组结构上，实现了静态链表，从而解决了哈希冲突的问题。 查找HashTable中的查找过程其实已经在上面说完了： 使用 time 33 算法对 key 值计算得到 hash code使用散列函数计算hash code得到散列值nIndex，即元素在中间映射表的下标通过nIndex从中间映射表中取出元素在 Bucket 中的下标idx通过 idx 访问 Bucket 中对应的数组元素，该元素同时也是一个静态链表的头结点遍历链表，分别判断每个元素中的key值是否与我们要查找的key值相同 如果相同，终止遍历 扩容在 C 语言中，数组的长度是定长的，那么如果空间已满还需继续插入的时候怎么办呢？PHP 的数组在底层实现了自动扩容机制，当插入一个元素且没有空闲空间时，就会触发自动扩容机制，扩容后再执行插入。需要提出的一点是，当删除某一个数组元素时，会先使用标志位对该元素进行逻辑删除，而不会立即删除该元素所在的 Bucket，因为后者在每次删除时进行一次排列操作，从而造成不必要的性能开销。扩容的过程为： 如果已删除元素所占比例达到阈值，则会移除已被逻辑删除的 Bucket，然后将后面的 Bucket 向前补上空缺的 Bucket，因为 Bucket 的下标发生了变动，所以还需要更改每个元素在中间映射表中储存的实际下标值。如果未达到阈值，PHP 则会申请一个大小是原数组两倍的新数组，并将旧数组中的数据复制到新数组中，因为数组长度发生了改变，所以 key-value 的映射关系需要重新计算，这个步骤为重建索引。 注：因为在重建索引时需要重新计算映射关系，所以将旧数组复制到新数组中时，中间映射表的数据是无需复制的。总结 PHP 中的数组是使用 HashTable 实现的HashTable 的占用空间是 2 的幂次方HashTable 通过 Key-Value 映射关系实现随机读取HashTable 通过中间映射表实现顺序读取，中间映射表和元素数组（Bucket）使用连续的内存空间PHP 通过链地址法解决 HashTable 中的哈希冲突在空间已满时，会触发自动扩容机制，导致重建索引]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章-递归]]></title>
    <url>%2F2019%2F08%2F03%2F%E7%AC%AC3%E7%AB%A0-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 学习递归。递归是很多算法都使用的一种编程方法。 学习如何将问题分成基线条件和递归条件。第4章将介绍的分而治之策略使用这种简单的概念来解决棘手的问题。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#遍历指定文件夹下的所有文件和所有子目录]]></title>
    <url>%2F2019%2F08%2F03%2FC-%E9%81%8D%E5%8E%86%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%92%8C%E6%89%80%E6%9C%89%E5%AD%90%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 如何获得子目录？ 如何获得目录下的文件？ 怎么把结果写入txt？ 递归怎么使用？ 程序使用Directory、DirectoryInfo类 1234567Directory.GetCurrentDirectory()获得当前运行程序的路径DirectoryInfo对象.GetDirectories()获得该文件夹下的子目录，返回类型为DirectoryInfoDirectoryInfo对象.GetFiles()获得该文件夹下的文件，返回类型为FileInfoDirectoryInfo对象.Name获得文件夹名DirectoryInfo对象.FullName获得文件夹完整的路径名FileInfo对象.Name和FileInfo对象.FullName 同理 程序使用以上方法，递归地输出当前运行程序所在的磁盘下的所有文件名和子目录名，并将结果保存在指定的txt文件中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980using System;using System.IO;namespace GetAllFiles&#123; class Program &#123; static void Main(string[] args) &#123; // 获取当前程序所在的文件路径 string cwd = Directory.GetCurrentDirectory(); string drive = cwd.Substring(0, 3); // 取盘符 D:\ StreamWriter sw = null; try &#123; // 创建输出流，将得到文件名子目录名保存到txt中 sw = new StreamWriter(new FileStream("files.txt", FileMode.Append)); sw.WriteLine("根目录：" + drive); FindDirectories(sw, drive, 2); &#125; catch (IOException e) &#123; Console.WriteLine(e.Message); &#125; finally &#123; if (sw != null) &#123; sw.Close(); Console.WriteLine("完成"); &#125; &#125; Console.ReadKey(); &#125; /// &lt;summary&gt; /// 获得指定路径下所有文件名 /// &lt;/summary&gt; /// &lt;param name="sw"&gt;写入流&lt;/param&gt; /// &lt;param name="path"&gt;目录路径&lt;/param&gt; /// &lt;param name="indent"&gt;缩进&lt;/param&gt; public static void GetFileName(StreamWriter sw, string path, int indent) &#123; DirectoryInfo root = new DirectoryInfo(path); foreach (FileInfo f in root.GetFiles()) &#123; for (int i = 0; i &lt; indent; i++) &#123; sw.Write(" "); &#125; sw.WriteLine(f.Name); &#125; &#125; /// &lt;summary&gt; /// 打印某目录下所有子目录名字并存入txt 递归 /// &lt;/summary&gt; /// &lt;param name="directory"&gt;&lt;/param&gt; /// &lt;param name="directory"&gt;&lt;/param&gt; /// &lt;param name="directory"&gt;&lt;/param&gt; static void FindDirectories(StreamWriter sw, string directory, int indent) &#123; GetFileName(sw, directory, indent); DirectoryInfo dirInfo = new DirectoryInfo(directory); foreach (DirectoryInfo d in dirInfo.GetDirectories()) &#123; for (int i = 0; i &lt; indent; i++) &#123; sw.Write(" "); &#125; sw.WriteLine("文件夹：" + d.Name); FindDirectories(sw, d.FullName, indent + 2); sw.WriteLine(); &#125; &#125; &#125;&#125; 执行结果：files.txt和此程序的exe在同一个目录下。]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI界面开发技术]]></title>
    <url>%2F2019%2F08%2F02%2FUGUI%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 哪个是锚点？作用是什么？ 哪个是中心点？作用是什么？ 本章涵盖： Anchor锚点与屏幕自适应本节我们学习“锚点”（Anchor）与“中心点”的概念及具体应用。锚点是相对于父容器的一种相对定位技术，是屏幕自适应的一种解决方案；中心点则是控件本身进行各种旋转的位置依据。 如图1所示，我们新建一个场景，在层级视图中添加一个Button控件。仔细观察Button，在其中心点的位置处会发现个小符号，一个类似雪花样子的是“锚点”符号，另外一个样子形如蓝色圆圈的是“中心点”，如图1所示。 我们先来研究锚点。如果把锚点移到画布的右边沿，此时我们缩小与放大窗体，我们会发现Button控件与锚点的距离似乎永远是相同的[注：如果屏幕缩小过大则会失效]，如图2所示。 锚点的定位如果仅仅使用鼠标拖曳的方式，其操作是非常原始与效率低下的，官方给我们提供了使用编辑器的快捷方式，分别对应于16种常见的锚点定位方式，如 仔细观察属性窗口，我们会发现如图23.36所示的两个重要参数”Pos X”和”Pos Y”。这两个参数表示当前控件的中心点与当前控件的锚点之间的偏移量，这为我们使用脚本的方式对控件的位置做进一步设定提供了基础参数支持 控件的“中心点”应用比“锚点”比例要小一些，我们一般可以使用中心点配合Animation动画工具制作一些基于U的旋转特效等应用。值得一提的是，如果想修改控件中心点的位置，必须先确保快捷工具栏中相关按钮的正确设置，如图23.37所示，中心被锁定为控件居中，不能移动中心点了。 图23.36控件偏移量参数 图23.37 “Center”表示中心点被锁定 当我们解锁中心点后(把“Center”单击后改为”Pivot”) ，把鼠标慢慢移动到控件的四周时，会发现出现一个圆圈标记，然后单击鼠标左键不动，拖动鼠标后，我们就可以得到一个依据中心点进行旋转倾斜的控件模式了，如图23.38所示。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D/2D游戏开发从0到1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章-选择排序]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%AC%AC2%E7%AB%A0-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 学习两种最基本的数据结构——数组和链表，它们无处不在。数组是个重要的主题，一定要高度重视！但在有些情况下，使用链表比使用数组更合适。本章阐述数组和链表的优缺点，让你能够根据要实现的算法选择合适的一个。 学习第一种排序算法。很多算法仅在数据经过排序后才管用。还记得二分查找吗？它只能用于有序元素列表。本章将介绍选择排序。很多语言都内置了排序算法，因此你基本上不用从头开始编写自己的版本。但选择排序是下一章将介绍的快速排序的基石。快速排序是一种重要的算法，如果你熟悉其他排序算法，理解起来将更容易。 内存的工作原理 数组和链表 选择排序 小结 内存的工作原理假设你去看演出，需要将东西寄存。寄存处有一个柜子，柜子有很多抽屉。 每个抽屉可放一样东西，你有两样东西要寄存，因此要了两个抽屉。 你将两样东西存放在这里。 现在你可以去看演出了！这大致就是计算机内存的工作原理。计算机就像是很多抽屉的集合体，每个抽屉都有地址。 fe0ffeeb是一个内存单元的地址。 需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。但它们并非都适用于所有的情形，因此知道它们的差别很重要。接下来介绍数组和链表以及它们的优缺点。 数组和链表有时候，需要在内存中存储一系列元素。假设你要编写一个管理待办事项的应用程序，为此需要将这些待办事项存储在内存中。 应使用数组还是链表呢？鉴于数组更容易掌握，我们先将待办事项存储在数组中。使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。 现在假设你要添加第四个待办事项，但后面的那个抽屉放着别人的东西！ 这就像你与朋友去看电影，找到地方就坐后又来了一位朋友，但原来坐的地方没有空位置，只得再找一个可坐下所有人的地方。在这种情况下，你需要请求计算机重新分配一块可容纳4个待办事项的内存，再将所有待办事项都移到那里。 如果又来了一位朋友，而当前坐的地方也没有空位，你们就得再次转移！真是太麻烦了。同样，在数组中添加新元素也可能很麻烦。如果没有了空间，就得移到内存的其他地方，因此添加新元素的速度会很慢。一种解决之道是“预留座位”：即便当前只有3个待办事项，也请计算机提供10个位置，以防需要添加待办事项。这样，只要待办事项不超过10个，就无需转移。这是一个不错的权变措施，但你应该明白，它存在如下两个缺点。 你额外请求的位置可能根本用不上，这将浪费内存。你没有使用，别人也用不了。 待办事项超过10个后，你还得转移。 因此，这种权宜措施虽然不错，但绝非完美的解决方案。对于这种问题，可使用链表来解决。 链表链表中的元素可存储在内存的任何地方。 链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。 串在一起的内存地址 这犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因此，你前往地址123，那里又有一张纸条，写着“下一个元素的地址为847”，以此类推。在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。 使用链表时，根本就不需要移动元素。这还可避免另一个问题。假设你与五位朋友去看一部很火的电影。你们六人想坐在一起，但看电影的人较多，没有六个在一起的座位。使用数组时有时就会遇到这样的情况。假设你要为数组分配10 000个位置，内存中有10 000个位置，但不都靠在一起。在这种情况下，你将无法为该数组分配内存！链表相当于说“我们分开来坐”，因此，只要有足够的内存空间，就能为链表分配内存。 链表的优势在插入元素方面，那数组的优势又是什么呢？ 数组排行榜网站使用卑鄙的手段来增加页面浏览量。它们不在一个页面中显示整个排行榜，而将排行榜的每项内容都放在一个页面中，并让你单击Next来查看下一项内容。例如，显示十大电视反派时，不在一个页面中显示整个排行榜，而是先显示第十大反派。你必须在每个页面中单击Next，才能看到第一大反派。这让网站能够在10个页面中显示广告，但用户需要单击Next九次才能看到第一个，真的是很烦。如果整个排行榜都显示在一个页面中，将方便得多。这样，用户可单击排行榜中的人名来获得更详细的信息。 链表存在类似的问题。在需要读取链表的最后一个元素时，你不能直接读取，因为你不知道它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3的地址，以此类推，直到访问最后一个元素。需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低。 数组与此不同：你知道其中每个元素的地址。例如，假设有一个数组，它包含五个元素，起始地址为00，那么元素#5的地址是多少呢？ 只需执行简单的数学运算就知道：04。需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素的地址，以此类推，直到访问第五个元素。 术语数组的元素带编号，编号从0而不是1开始。例如，在下面的数组中，元素20的位置为1。 而元素10的位置为0。这通常会让新手晕头转向。从0开始让基于数组的代码编写起来更容易，因此程序员始终坚持这样做。几乎所有的编程语言都从0开始对数组元素进行编号。你很快就会习惯这种做法。 元素的位置称为索引 。因此，不说“元素20的位置为1”，而说“元素20位于索引1处”。本书将使用索引来表示位置。 下面列出了常见的数组和链表操作的运行时间。 问题：在数组中插入元素时，为何运行时间为O(n)呢？假设要在数组开头插入一个元素，你将如何做？这需要多长时间？请阅读下一节，找出这些问题的答案！ 练习 假设你要编写一个记账的应用程序。 你每天都将所有的支出记录下来，并在月底统计支出，算算当月花了多少钱。因此，你执行的插入操作很多，但读取操作很少。该使用数组还是链表呢？ 在中间插入假设你要让待办事项按日期排列。之前，你在清单末尾添加了待办事项。 但现在你要根据新增待办事项的日期将其插入到正确的位置。 需要在中间插入元素时，数组和链表哪个更好呢？使用链表时，插入元素很简单，只需修改它前面的那个元素指向的地址。 而使用数组时，则必须将后面的元素都向后移。 如果没有足够的空间，可能还得将整个数组复制到其他地方！因此，当需要在中间插入元素时，链表是更好的选择。 删除如果你要删除元素呢？链表也是更好的选择，因为只需修改前一个元素指向的地址即可。而使用数组时，删除元素后，必须将后面的元素都向前移。 不同于插入，删除元素总能成功。如果内存中没有足够的空间，插入操作可能失败，但在任何情况下都能够将元素删除。 下面是常见数组和链表操作的运行时间。 需要指出的是，仅当能够立即访问要删除的元素时，删除操作的运行时间才为O (1)。通常我们都记录了链表的第一个元素和最后一个元素，因此删除这些元素时运行时间为O (1)。 数组和链表哪个用得更多呢？显然要看情况。但数组用得很多，因为它支持随机访问。有两种访问方式：随机访问 和顺序访问 。顺序访问意味着从第一个元素开始逐个地读取元素。链表只能顺序访问：要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。随机访问意味着可直接跳到第十个元素。本书经常说数组的读取速度更快，这是因为它们支持随机访问。很多情况都要求能够随机访问，因此数组用得很多。数组和链表还被用来实现其他数据结构，这将在本书后面介绍。 练习 2.2 假设你要为饭店创建一个接受顾客点菜单的应用程序。这个应用程序存储一系列点菜单。服务员添加点菜单，而厨师取出点菜单并制作菜肴。这是一个点菜单队列：服务员在队尾添加点菜单，厨师取出队列开头的点菜单并制作菜肴。 你使用数组还是链表来实现这个队列呢？（提示：链表擅长插入和删除，而数组擅长随机访问。在这个应用程序中，你要执行的是哪些操作呢？） 2.3 我们来做一个思考实验。假设Facebook记录一系列用户名，每当有用户试图登录Facebook时，都查找其用户名，如果找到就允许用户登录。由于经常有用户登录Facebook，因此需要执行大量的用户名查找操作。假设Facebook使用二分查找算法，而这种算法要求能够随机访问——立即获取中间的用户名。考虑到这一点，应使用数组还是链表来存储用户名呢？ 2.4 经常有用户在Facebook注册。假设你已决定使用数组来存储用户名，在插入方面数组有何缺点呢？具体地说，在数组中添加新用户将出现什么情况？ 2.5 实际上，Facebook存储用户信息时使用的既不是数组也不是链表。假设Facebook使用的是一种混合数据：链表数组。这个数组包含26个元素，每个元素都指向一个链表。例如，该数组的第一个元素指向的链表包含所有以A打头的用户名，第二个元素指向的链表包含所有以B打头的用户名，以此类推。 假设Adit B在Facebook注册，而你需要将其加入前述数据结构中。因此，你访问数组的第一个元素，再访问该元素指向的链表，并将Adit B添加到这个链表末尾。现在假设你要查找Zakhir H。因此你访问第26个元素，再在它指向的链表（该链表包含所有以z打头的用户名）中查找Zakhir H。 请问，相比于数组和链表，这种混合数据结构的查找和插入速度更慢还是更快？你不必给出大O运行时间，只需指出这种新数据结构的查找和插入速度更快还是更慢。 选择排序有了前面的知识，你就可以学习第二种算法——选择排序了。要理解本节的内容，你必须熟悉数组、链表和大O表示法。 假设你的计算机存储了很多乐曲。对于每个乐队，你都记录了其作品被播放的次数。 你要将这个列表按播放次数从多到少的顺序排列，从而将你喜欢的乐队排序。该如何做呢？ 一种办法是遍历这个列表，找出作品播放次数最多的乐队，并将该乐队添加到一个新列表中。 再次这样做，找出播放次数第二多的乐队。 继续这样做，你将得到一个有序列表。 下面从计算机科学的角度出发，看看这需要多长时间。别忘了，O(n)时间意味着查看列表中的每个元素一次。例如，对乐队列表进行简单查找时，意味着每个乐队都要查看一次。 要找出播放次数最多的乐队，必须检查列表中的每个元素。正如你刚才看到的，这需要的时间为O(n)。因此对于这种时间为O(n)的操作，你需要执行n次。 需要的总时间为 O (n × n )，即O (n 2 )。 排序算法很有用。你现在可以对如下内容进行排序： 电话簿中的人名 旅行日期 电子邮件（从新到旧） 需要检查的元素数越来越少 随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一个。既然如此，运行时间怎么还是O (n 2 )呢？这个问题问得好，这与大O表示法中的常数相关。第4章将详细解释，这里只简单地说一说。 你说得没错，并非每次都需要检查n 个元素。第一次需要检查n 个元素，但随后检查的元素数依次为n - 1, n – 2, …, 2和1。平均每次检查的元素数为1/2 × n ，因此运行时间为O (n × 1/2 × n )。但大O表示法省略诸如1/2这样的常数（有关这方面的完整讨论，请参阅第4章），因此简单地写作O (n × n )或O (n 2 )。 选择排序是一种灵巧的算法，但其速度不是很快。快速排序是一种更快的排序算法，其运行时间为O (n log n )，这将在下一章介绍。 示例代码前面没有列出对乐队进行排序的代码，但下述代码提供了类似的功能：将数组元素按从小到大的顺序排列。先编写一个用于找出数组中最小元素的函数。 12345678def findSmallest(arr): smallest = arr[0] ←------存储最小的值 smallest_index = 0 ←------存储最小元素的索引 for i in range(1, len(arr)): if arr[i] &lt; smallest: smallest = arr[i] smallest_index = i return smallest_index 现在可以使用这个函数来编写选择排序算法了。 12345678def selectionSort(arr): ←------对数组进行排序 newArr = [] for i in range(len(arr)): smallest = findSmallest(arr) ←------找出数组中最小的元素，并将其加入到新数组中 newArr.append(arr.pop(smallest)) return newArrprint selectionSort([5, 3, 6, 2, 10]) selection_sort.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define SIZE 5// Finds the smallest value in an arrayint findSmallest(int *arr) &#123; // Stores the smallest value int smallest = arr[0]; // Stores the index of the smallest value int smallest_index = 0; for (int i = 1; i &lt; SIZE; i++) &#123; if (arr[i] &lt; smallest) &#123; smallest = arr[i]; smallest_index = i; &#125; &#125; return smallest_index;&#125;int *selectionSort(int *arr) &#123; // Create new Array int *newArr = (int *)malloc(SIZE * sizeof(int)); for (int i = 0; i &lt; SIZE; i++) &#123; int smallest = findSmallest(arr); newArr[i] = arr[smallest]; // same as deleted by changing to the largest value arr[smallest] = INT_MAX; &#125; return newArr;&#125;int main(void) &#123; int arr[SIZE] = &#123;5, 3, 6, 2, 10&#125;; int *sortarr = selectionSort(arr); // print result for (int i = 0; i &lt; SIZE; i++) &#123; printf("%d ", sortarr[i]); &#125; return 0;&#125;``` &gt; selection_sort.lua```luafunction binary_search(array, value) -- Lua arrays start with 1 local low, high = 1, #array while low &lt;= high do local mid = math.floor((low + high) / 2) local guess = array[mid] if guess == value then return mid elseif guess &gt; value then high = mid - 1 else low = mid + 1 end end return nilendlocal my_array = &#123;1, 3, 5, 7, 9&#125;print(binary_search(my_array, 3)) -- =&gt; 2print(binary_search(my_array, -1)) -- =&gt; nil 小结 计算机内存犹如一大堆抽屉。 需要存储多个元素时，可使用数组或链表。 数组的元素都在一起。 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。 数组的读取速度很快。 链表的插入和删除速度很快。 在同一个数组中，所有元素的类型都必须相同（都为int、double等）。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章-算法简介]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%AC%AC1%E7%AB%A0-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 编写第一种查找算法——二分查找。 学习如何谈论算法的运行时间——大O表示法。 了解一种常用的算法设计方法——递归。 引言算法是一组完成任务的指令。 将讨论二分查找，并演示算法如何能够提高代码的速度。在一个示例中，算法将需要执行的步骤从40亿个减少到了32个！ GPS设备使用图算法来计算前往目的地的最短路径。 可使用动态规划来编写下国际跳棋的AI算法。 对于每种算法，都将首先进行描述并提供示例，再使用大O表示法讨论其运行时间，最后探索它可以解决的其他问题。 性能方面将学习比较不同算法的优缺点：该使用合并排序算法还是快速排序算法，或者该使用数组还是链表。仅仅改用不同的数据结构就可能让结果大不相同。 问题解决技巧 开发电子游戏，可使用图算法编写跟踪用户的AI系统； 使用K最近邻算法编写推荐系统； 有些问题在有限的时间内是不可解的！讨论NP完全问题的部分将告诉你，如何识别这样的问题以及如何设计找到近似答案的算法。 二分查找 binary_search.c 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int binarySearch(int[], int, int);int main()&#123; int myList[] = &#123;1, 3, 5, 7, 9&#125;; int len = sizeof(myList) / sizeof(myList[0]); printf("%d\n", binarySearch(myList, 3, len)); // 1 printf("%d\n", binarySearch(myList, -1, len)); //-1 return 0;&#125;int binarySearch(int list[], int item, int len)&#123; int low = 0; int high = len; while (low &lt;= high) &#123; int mid = (low + high)/2; int guess = list[mid]; if (guess == item) &#123; return mid; &#125; else if (guess &gt; item) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return -1; //number not found&#125; 123456789101112131415161718192021222324252627282930313233343536373839using System;using System.Collections.Generic;using System.Linq;namespace ConsoleApplication&#123; public class Program &#123; public static void Main(string[] args) &#123; var myList = new List&lt;int&gt; &#123; 1, 3, 5, 7, 9 &#125;; Console.WriteLine(BinarySearch(myList, 3)); // =&gt; 1 Console.WriteLine(BinarySearch(myList, -1)); // =&gt; null gets printed as an empty string &#125; private static int? BinarySearch(IList&lt;int&gt; list, int item) &#123; var low = 0; var high = list.Count() - 1; while (low &lt;= high) &#123; var mid = (low + high) / 2; var guess = list[mid]; if (guess == item) return mid; if (guess &gt; item) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return null; &#125; &#125;&#125; binary_search.lua 123456789101112131415161718192021222324function binary_search(array, value) -- Lua arrays start with 1 local low, high = 1, #array while low &lt;= high do local mid = math.floor((low + high) / 2) local guess = array[mid] if guess == value then return mid elseif guess &gt; value then high = mid - 1 else low = mid + 1 end end return nilendlocal my_array = &#123;1, 3, 5, 7, 9&#125;print(binary_search(my_array, 3)) -- =&gt; 2print(binary_search(my_array, -1)) -- =&gt; nil 大O表示法大O表示法是一种特殊的表示法，指出了算法的速度有多快。 算法的运行时间以不同的速度增加Bob要为NASA编写一个查找算法，这个算法在火箭即将登陆月球前开始执行，帮助计算着陆地点。 简单查找和二分查找，两种算法的运行时间呈现不同的增速。Bob需要做出决定，是使用简单查找还是二分查找。使用的算法必须快速而准确。一方面，二分查找的速度更快。Bob必须在10秒钟内找出着陆地点，否则火箭将偏离方向。另一方面，简单查找算法编写起来更容易，因此出现bug的可能性更小。Bob可不希望引导火箭着陆的代码中有bug！为确保万无一失，Bob决定计算两种算法在列表包含100个元素的情况下需要的时间。 假设检查一个元素需要1毫秒。使用简单查找时，Bob必须检查100个元素，因此需要100毫秒才能查找完毕。而使用二分查找时，只需检查7个元素（log2 100大约为7），因此需要7毫秒就能查找完毕。然而，实际要查找的列表可能包含10亿个元素，在这种情况下，简单查找需要多长时间呢？二分查找又需要多长时间呢？请务必找出这两个问题的答案，再接着往下读。 Bob使用包含10亿个元素的列表运行二分查找，运行时间为30毫秒（log2 1 000 000 000大约为30）。他心里想，二分查找的速度大约为简单查找的15倍，因为列表包含100个元素时，简单查找需要100毫秒，而二分查找需要7毫秒。因此，列表包含10亿个元素时，简单查找需要30 ×15 = 450毫秒，完全符合在10秒内查找完毕的要求。Bob决定使用简单查找。这是正确的选择吗？ 不是。实际上，Bob错了，而且错得离谱。列表包含10亿个元素时，简单查找需要10亿毫秒，相当于11天！为什么会这样呢？因为二分查找和简单查找的运行时间的增速不同。 也就是说，随着元素数量的增加，二分查找需要的额外时间并不多，而简单查找需要的额外时间却很多。因此，随着列表的增长，二分查找的速度比简单查找快得多。Bob以为二分查找速度为简单查找的15倍，这不对：列表包含10亿个元素时，为3300万倍。有鉴于此，仅知道算法需要多长时间才能运行完毕还不够，还需知道运行时间如何随列表增长而增加。这正是大O表示法的用武之地。 大O表示法指出了算法有多快。例如，假设列表包含n个元素。简单查找需要检查每个元素，因此需要执行n次操作。使用大O表示法，这个运行时间为O(n)。单位秒呢？没有——大O表示法指的并非以秒为单位的速度。大O表示法让你能够比较操作数，它指出了算法运行时间的增速 。 再来看一个例子。为检查长度为n的列表，二分查找需要执行log n次操作。使用大O表示法，这个运行时间怎么表示呢？O(log n)。一般而言，大O表示法像下面这样。 这指出了算法需要执行的操作数。之所以称为大O表示法，是因为操作数前有个大O。这听起来像笑话，但事实如此！ 下面来看一些例子，看看你能否确定这些算法的运行时间。 理解不同的大O运行时间下面的示例，你在家里使用纸和笔就能完成。假设你要画一个网格，它包含16个格子。 算法1 一种方法是以每次画一个的方式画16个格子。记住，大O表示法计算的是操作数。在这个示例中，画一个格子是一次操作，需要画16个格子。如果每次画一个格子，需要执行多少次操作呢？ 画16个格子需要16步。这种算法的运行时间是多少？ 算法2 请尝试这种算法——将纸折起来。 在这个示例中，将纸对折一次就是一次操作。第一次对折相当于画了两个格子！ 再折，再折，再折。 折4次后再打开，便得到了漂亮的网格！每折一次，格子数就翻倍，折4次就能得到16个格子！ 你每折一次，绘制出的格子数都翻倍，因此4步就能“绘制”出16个格子。这种算法的运行时间是多少呢？请搞清楚这两种算法的运行时间之后，再接着往下读。 答案如下：算法1的运行时间为O (n )，算法2的运行时间为O (log n )。 大O表示法指出了最糟情况下的运行时间假设你使用简单查找在电话簿中找人。你知道，简单查找的运行时间为O (n )，这意味着在最糟情况下，必须查看电话簿中的每个条目。如果要查找的是Adit——电话簿中的第一个人，一次就能找到，无需查看每个条目。考虑到一次就找到了Adit，请问这种算法的运行时间是O (n )还是O (1)呢？ 简单查找的运行时间总是为O (n )。查找Adit时，一次就找到了，这是最佳的情形，但大O表示法说的是最糟的情形。因此，你可以说，在最糟情况下，必须查看电话簿中的每个条目，对应的运行时间为O (n )。这是一个保证——你知道简单查找的运行时间不可能超过O (n )。 说明 除最糟情况下的运行时间外，还应考虑平均情况的运行时间，这很重要。最糟情况和平均情况将在第4章讨论。 一些常见的大O运行时间下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。 O(log n)，也叫对数时间 ，这样的算法包括二分查找。 O(n)，也叫线性时间 ，这样的算法包括简单查找。 O(n * log n )，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。 O(n2)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。 O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。 假设你要绘制一个包含16格的网格，且有5种不同的算法可供选择，这些算法的运行时间如上所示。如果你选择第一种算法，绘制该网格所需的操作数将为4（log 16 = 4）。假设你每秒可执行10次操作，那么绘制该网格需要0.4秒。如果要绘制一个包含1024格的网格呢？这需要执行10（log 1024 = 10）次操作，换言之，绘制这样的网格需要1秒。这是使用第一种算法的情况。 第二种算法更慢，其运行时间为O(n)。即要绘制16个格子，需要执行16次操作；要绘制1024个格子，需要执行1024次操作。执行这些操作需要多少秒呢？ 下面按从快到慢的顺序列出了使用这些算法绘制网格所需的时间： 还有其他的运行时间，但这5种是最常见的。 这里做了简化，实际上，并不能如此干净利索地将大O运行时间转换为操作数，但就目前而言，这种准确度足够了。等你学习其他一些算法后，第4章将回过头来再次讨论大O表示法。当前，我们获得的主要启示如下。 算法的速度指的并非时间，而是操作数的增速。 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。 算法的运行时间用大O表示法表示。 O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。 旅行商阅读前一节时，你可能认为根本就没有运行时间为O (n !)的算法。让我来证明你错了！下面就是一个运行时间极长的算法。这个算法要解决的是计算机科学领域非常著名的旅行商问题，其计算时间增加得非常快，而有些非常聪明的人都认为没有改进空间。 有一位旅行商。 他需要前往5个城市。 这位旅行商（姑且称之为Opus吧）要前往这5个城市，同时要确保旅程最短。为此，可考虑前往这些城市的各种可能顺序。 对于每种顺序，他都计算总旅程，再挑选出旅程最短的路线。5个城市有120种不同的排列方式。因此，在涉及5个城市时，解决这个问题需要执行120次操作。涉及6个城市时，需要执行720次操作（有720种不同的排列方式）。涉及7个城市时，需要执行5040次操作！ 推而广之，涉及n 个城市时，需要执行n !（n 的阶乘）次操作才能计算出结果。因此运行时间为O (n !)，即阶乘时间。除非涉及的城市数很少，否则需要执行非常多的操作。如果涉及的城市数超过100，根本就不能在合理的时间内计算出结果——等你计算出结果，太阳都没了。 这种算法很糟糕！Opus应使用别的算法，可他别无选择。这是计算机科学领域待解的问题之一。对于这个问题，目前还没有找到更快的算法，有些很聪明的人认为这个问题根本就没有更巧妙的算法。面对这个问题，我们能做的只是去找出近似答案，更详细的信息请参阅第10章。 最后需要指出的一点是，高水平的读者可研究一下二叉树，这在最后一章做了简要的介绍。 小结二分查找的速度比简单查找快得多。 O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。 算法运行时间并不以秒为单位。 算法运行时间是从其增速的角度度量的。 算法运行时间用大O表示法表示。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FSM有限状态机在游戏中的运用]]></title>
    <url>%2F2019%2F08%2F01%2FFSM%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E5%9C%A8%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖：]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity 3D实战核心技术详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏开发经验分享]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 消息类型定义和封装 关于游戏开发经验，网上资料很多，在这里总结的是我在实际项目开发中遇到的问题以及在开发中使用的一些核心技术，学习编程首先要从程序调试开始，不会调试的程序员永远学不好编程，只要是人为的因素都会有Bug出现，程序员只有通过调试才能解决这些Bug，下面先从调试开始讲起。 关于调试经验分享不论开发什么样的程序，首要的是开发者必须会调试，这也是作为程序开发者必备的技能，不会调试的程序员，就不是一个好程序员。任何人写程序都会出现Bug，遇到问题要学会解决问题。在使用Unity开发程序时，经常会遇到在PC端运行程序没有问题，但是将程序打包成Android包安装在手机上时出现各种莫名其妙的Bug，为了解决移动端的Bug，开发者也要知道如何在移动端调试程序。在使用mono编辑器或者Visual Studio编辑器调试移动端程序时，需要在手机端安装一个Unity官方提供的软件Unity Remote，在手机端安装好了后，在编译Unity的Android包时要进行如图14-1所示的设置。 图14-1 Unity移动端调试设置界面 这样编译的apk包在安装到手机端时，运行手机端程序可以在mono编辑器中查看到硬件的名字，如图14-2所示。 图14-2 编辑器与移动端硬件绑定界面 设置好了以上信息后，运行手机端的程序，就可以在mono编辑器或者Visual Studio编辑器中断点调试了。也可以连接Profiler调试工具，查看程序内存分配和CPU的占用情况，操作界面如图14-3所示，它可以查看手机运行的情况，这是一种在移动端调试的方式。 图14-3 Profiler调试界面 第二种调试方式，Android SDK的调试。它可以通过Eclipse编辑器的DDMS查看手机运行的报错问题，在Eclipse开发工具的右上角可以轻松查看到DDMS。大家可以自行下载Eclipse体验一下，它可以查看到游戏运行时的空对象错误，非常实用。 第三种调试方式是通过adb logcat命令行查看Unity的日志信息，打开“运行”，在其中输入“cmd”打开dos的操作界面，然后输入adb logcat-s Unity命令，操作方式如图14-4所示。 图14-4 命令行调试 如果不知道如何使用，可以通过命令查看帮助说明，如果要把日志信息保存到手机卡上，可以输入命令adb logcat-f/sdcard/log.txt，这样log.txt就被保存到手机卡上了，可以查看或者导出，当然也可以保存到电脑上。掌握了以上三种调试方式，就可以解决任何在移动端运行无法解决的问题，接下来介绍移动端游戏防破解技术。 移动端游戏防破解技术现在用Unity引擎开发的游戏产品越来越多，很多上线的游戏被破解了。游戏被破解的方式分两种：一种是游戏代码的破解，另一种是游戏计费文件的破解。关于代码的破解网上有很多相关的资料，这里就不一一介绍了。防代码破解一般采用的技术是代码混淆的方式。其实对于游戏公司来说最重要的是关于游戏数据的修改，以及关于计费文件的修改，这二者关乎公司的直接利益。游戏的基础数据通常都会放到本地，这样就会被一些玩家通过修改本地文件的方式去改写数据，防止本地数据文件的修改，采用的是服务器验证的方式，服务器数据库只保存变化的数据，如果一定要放在本地需要将本地的数据文件进行加密处理。通常采用的是SHA512算法或者是MD5加密方式。本节的加密方式是对项目的基础数据文件采用SHA512算法加密方式处理的，核心代码如下所示。 1234567891011121314 //加密算法public static string GetSHA512Password(string password)&#123; byte[] bytes = Encoding.UTF7.GetBytes(password); byte[] result; SHA512 shaM = new SHA512Managed(); result = shaM.ComputeHash(bytes); StringBuilder sb = new StringBuilder(); foreach (byte num in result) &#123; sb.AppendFormat("&#123;0:x2&#125;", num); &#125; return sb.ToString(); &#125; 函数的参数是开发者自己定义的数据串，经过函数的处理后被称为加密的密码，然后将生成的密码字符串作为输入文本文件zip压缩的密码，压缩zip文件函数代码如下所示。 123456789101112protected void SaveConfigXMLToZip()&#123; using (ZipFile zipFile = new ZipFile(Encoding.UTF8)) &#123; zipFile.Password = configurationZipPwd; zipFile.AddEntry(configurationFile, configuration.bytes); zipFile.AddEntry(localizationFile, localization.bytes); stringzipPath=Path.Combine(Application.persistentDataPath, configurationZipFile); LogTool.Log("Saving configuration in \"" + zipPath + "\""); zipFile.Save(zipPath); &#125;&#125; 程序的压缩是在PC端的编译模式下运行时压缩的，压缩完成后可以将其上传到资源服务器，程序运行时下载该文件然后读取其压缩格式，压缩文件的格式是xml文本文件格式。所以核心代码里面有对XML文件的解释，如果你使用的是Json文件可以更改成Json文件的解析函数，函数如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940protected void TryLoadingXMLsFromZip()&#123; string zipPath = Path.Combine(Application.persistentDataPath, configurationZipFile); if (!File.Exists(zipPath)) &#123; LogTool.Log("Configuration not found!"); this.ParseConfigXML(configuration.text, false); this.ParseLocalizationXML(localization.text, false); return; &#125; using (ZipFile zipFile = new ZipFile(zipPath, Encoding.UTF8)) &#123; zipFile.Password = configurationZipPwd; ZipEntry xmlConfEntry = zipFile[configurationFile], xmlLocaleEntry = zipFile[localizationFile]; if (null == xmlConfEntry || null == xmlLocaleEntry) &#123; LogTool.Log("Downloaded configuration INVALID!"); this.ParseConfigXML(configuration.text, false); this.ParseLocalizationXML(localization.text, false); return; &#125; using (MemoryStream ms = new MemoryStream()) &#123; xmlConfEntry.Extract(ms); string xmlText = Encoding.UTF8.GetString(ms.GetBuffer(), 0, ms.GetBuffer().Length); this.ParseConfigXML(xmlText, true); ms.Seek(0, SeekOrigin.Begin); xmlLocaleEntry.Extract(ms); xmlText = Encoding.UTF8.GetString(ms.GetBuffer(), 0, ms.GetBuffer().Length); this.ParseLocalizationXML(xmlText, true); &#125; &#125;&#125; 以上是关于文件的加密方式，需要在Unity中加入zip压缩库。下面介绍关于计费文件的破解，原理就是绕过计费文件，屏蔽计费，这样的破解对公司造成的损失是很大的。为了预防此类方式的破解，很多知名IT公司给开发者提供了防破解软件，常用的有360防破解、腾讯防破解以及爱游戏防破解等。这些防破解软件就是把Android包用该软件进行加固处理，这样不论什么软件都无法修改计费文件，效果如图14-5所示。 图14-5 360防破解软件界面 经过该软件处理的包，极大的预防了游戏包体的破解。该软件还有签名功能，使用它能有效地防止计费文件被破解。下面介绍另一个让程序员头疼的问题——减小包体的大小。 14.3 减小包体的大小游戏包体的大小一直是影响游戏玩家体验的重要因素。不论做什么类型的游戏，首要的任务就是把包体大小缩减到一定范围内，对于玩家来说40M是一道坎，游戏都要朝着这个目标努力。包体的大小主要包括美术资源和代码，代码占用量非常小，可以忽略。美术资源的大小直接决定了包体的大小，所以要减小包体必须从美术资源入手。美术资源主要包含两部分：模型和材质贴图，模型的面数要适当控制，这取决于美术的品质要求。 下面介绍一下如何减小贴图的大小。减小贴图的大小常用的处理方式是将不带Alpha通道的贴图存为jpg格式，而将带有Alpha通道的贴图存成png格式。针对UI和3D场景美术建立通用的材质库，这样可以规范和节省美术资源。由于Unity打包图集固有的缺陷，可以采用Texture Packer工具打包解决其带来的问题。Unity图集打包存在主要的问题是，如果定义好了图集大小，那么这个图集不论是否满了，其在内存中占有的大小都是4M。Texture Packer工具会根据贴图的数量自动打成适当大小的图集供程序使用，从而避免这个问题。 另一个辅助检查图片大小的工具是BuildReport，在程序编译成Android的apk包时，要进行设置，效果如图14-6所示。通过图14-6可以看到包体的总量大小以及哪些资源占用量比较大。可以针对性的修改，帮助我们压缩图片的大小。 图14-6 BuildReport工具运行界面 BuildReport资源分布的运行效果如图14-7所示。 图14-7 BuildReport资源分布的运行界面 减小包体需要程序和美术的共同努力，找到问题所在。这就要求在游戏开发初期定义好规范，这样在程序优化后期可以减少很多麻烦。对于使用的库文件dll，可以在Assets目录下建一个link.xml文件，减少不需要的dll文件也可以减小包体，link文件内容样例如下所示。 12345678910111213141516171819202122&lt;linker&gt;&lt;assembly fullname="System.Web.Services"&gt;&lt;type fullname="System.Web.Services.Protocols.SoapTypeStubInfo" preserve="all"/&gt;&lt;type fullname="System.Web.Services.Configuration.WebServicesConfigurationSectionHandler" preserve="all"/&gt;&lt;/assembly&gt;&lt;assembly fullname="System"&gt;&lt;type fullname="System.Net.Configuration.WebRequestModuleHandler" preserve="all"/&gt;&lt;type fullname="System.Net.HttpRequestCreator" preserve="all"/&gt;&lt;type fullname="System.Net.FileWebRequestCreator" preserve="all"/&gt;&lt;/assembly&gt;&lt;assembly fullname="mscorlib"&gt;&lt;type fullname="System.AppDomain" preserve="fields"/&gt;&lt;type fullname="System.InvalidOperationException" preserve="fields"&gt;&lt;method signature="System.Void .ctor()"/&gt;&lt;/type&gt;&lt;type fullname="System.Object" preserve="nothing"&gt;&lt;method name="Finalize"/&gt;&lt;/type&gt;&lt;/assembly&gt;&lt;/linker&gt; 其中，参数all表示保留所有类型与该库相关的库，fields仅保留该类型相关的库，nothing仅保留该类型库，这个可根据需求对不需要的dll进行设置。 总之，优化的方式很多，比如对资源本身的优化，包括顶点数量和材质数量。开发项目时需要对项目进行优化，这个优化包括很多方面，在这里给大家介绍一下：首先要考虑的问题是资源的优化，资源优化包括模型的顶点数量、材质数量、NGUI使用的图集大小、粒子特效数量。这些决定了包的大小，这是要优先要考虑的。其次要考虑的问题是程序的编写是否合理，资源是不是及时的删除或者清空，Shader渲染的运用是不是对于显卡要求比较高。优化程序伴随着游戏开发的始终。代码方面的优化建议开发者读一读《代码重构》一书。 14.4 动态对象资源的优化不论手游开发还是端游开发，优化自始至终伴随着游戏产品的开发。Unity引擎对于资源优化处理的并不是很好，引擎内部只处理了静态对象的优化，对于动态对象并没有去处理，这需要开发者通过编程去实现动态优化的处理。程序优化主要涉及程序运行的效率，游戏运行出现卡顿以及内存溢出，编写代码要注意内存是否及时的释放掉了，影响游戏内存的因素很多，比如代码中打印的Log是否过多，是否有死循环的代码，以及程序切换场景时是否及时释放内存等。 优化的事情并不只是程序的任务，也需要美术协助。例如，遇到游戏运行出现卡帧现象时，借助Unity的Profiler工具查看内存占用情况，如图14-8所示。单击CPU Usage内存中的曲线可以帮助判断程序出现卡帧，下方的Camera.Render目录下对应的是Unity代码中的具体函数，从而帮助开发者非常方便地找到问题的所在，然后根据找到的问题检查程序逻辑是否有问题。单击Memory可以查看资源在内存中的占用情况，可以针对性的对资源进行处理，如图14-9所示。首先要检查美术资源包括面片数量、材质大小，最后检查一下运用在物体上的Shader，是否有比较好的Shader运用，比如后处理效果Bloom、Blur等。下面主要是针对游戏中使用的资源进行的优化，同时结合案例讲解如何降低DrawCall的数量，达到优化的目的。程序方面要具体问题具体分析，在这里就不一一列举了。 图14-8 查看CPU函数运行界面 图14-9 查看内存占用界面 由于策划需求，美术经常会在游戏场景中摆放一些具有骨骼动画的物件道具用于场景装饰，如果这些场景物件多了，DrawCall会增长的很快，严重影响程序运行效率。不论你是动态实例化生成还是直接拖放到场景中，DrawCall都会增长。面对这样的需求该如何处理呢？因为Unity只提供了静态对象的优化，我们可以直接勾选Static选项，而对动态对象的优化只能自己想办法解决，读者可以先做个实验，只在场景中放一个具有骨骼动画的物体，观察一下它的DrawCall和FPS运行帧率各是多少。场景中是一艘带有骨骼动画的船，程序运行时的DrawCall是10，FPS是76.8，如图14-10所示。 接下来增加两艘同样的船，如图14-11所示，此时，DrawCall是25，FPS是76.8，虽然DrawCall不是成倍增长，但是明显增加了一倍多。通过这个案例可以想象如果这些装饰物过多，对程序还是有影响的。面对这种类型的问题，先说一下解决问题的思路，首先分析一下：这些物体的共同点是带有相同的骨骼动画，而且材质也是一样的。 图14-10 单个带有骨骼动画的物体展示 图14-11 多个带有骨骼动画的物体展示 说一下解决问题的思路，如果把这些船的Mesh和Skeleton合并成一个物体，会出现什么情况呢？对于合并成的物体需要自己创建一个新的Mesh，然后对Mesh进行填充。下面先把代码分享一下，后面会给大家讲案例，完整的优化代码如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using UnityEngine;using System.Collections.Generic;public class CombineDrawCall : MonoBehaviour &#123; //用于初始化 void Start () &#123; CombineToOne(this.gameObject);//调用函数接口 &#125; //合并网格和动作 public static void CombineToOne(GameObject _go) &#123; SkinnedMeshRenderer[] _smr = _go.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;(); List&lt;CombineInstance&gt; lcom = new List&lt;CombineInstance&gt;(); List&lt;Material&gt; lmat = new List&lt;Material&gt;(); List&lt;Transform&gt; ltra = new List&lt;Transform&gt;(); for(int i = 0;i &lt; _smr.Length; i++) &#123; lmat.AddRange(_smr[i].materials); ltra.AddRange(_smr[i].bones); for(int sub = 0; sub &lt; _smr[i].sharedMesh.subMeshCount; sub++) &#123; CombineInstance ci = new CombineInstance(); ci.mesh = _smr[i].sharedMesh; ci.subMeshIndex = sub; lcom.Add(ci); &#125; Destroy(_smr[i].gameObject); &#125; SkinnedMeshRenderer _r = _go.GetComponent&lt;SkinnedMeshRenderer&gt;(); if (_r == null) _r = _go.AddComponent&lt;SkinnedMeshRenderer&gt;(); _r.sharedMesh = new Mesh(); _r.bones = ltra.ToArray(); _r.materials = new Material[] &#123; lmat[0] &#125;; _r.rootBone = _go.transform; _r.sharedMesh.CombineMeshes(lcom.ToArray(), true, false); &#125;&#125; 以上代码实现了动态对象的优化处理，在使用代码时，首先要建立一个空对象作为父类，把要优化的动态对象放到父类下面作为子类，当然你也可以用一个动态对象作为父类，其他动态对象挂到它的下面。优化的动态对象需要带有自己的骨骼动画，材质最好只有一张贴图，当然多张也是可以的。优化的对象是同一个对象，这一般适用于装饰场景的物件，有的人可能将其应用到游戏中动态生成的怪物，这是不可以的，因为优化的本质是将所有要优化的动态对象组合成一个大的对象，所以不适合怪物的生成。下面将其应用到Unity中给大家展示一下运行效果。直接在场景中放了五艘船，同时把上面写好的代码CombineDrawCall.cs直接挂到GameObject对象上，如图14-12所示。 图14-12 优化代码挂接 它的运行效果如图14-13所示，DrawCall和FPS都有所优化，DrawCall是13，与放置一个物体的DrawCall结果类似，FPS是81.6略有提高，达到了优化的目的。 图14-13 优化运行效果 多线程资源下载技术在游戏开发中经常会使用多线程去处理，比如在3D游戏开发中，对于大地形的加载，通常是使用分块的方式。用于加载魔兽世界地图场景的3D游戏引擎使用的技术就是多线程加载，在内存里放置9块地形，在缓存里面放置16块地形用于与内存进行地形块的交换。以前开发过端游，主线程负责地形的加载，单独开一个线程用于地形的卸载。在开发中，Unity只有一个主线程运行，也就是单线程，但是可以在Unity中使用多线程加载资源。当我们同时要处理很多事情并且与Unity的对象没有交互时，可以用thread多线程，否则只能使用协成coroutine。在多处理器的计算机上可以做到多个线程的真正同步，在Unity中，你仅能从主线程中访问Unity的组件对象和Unity系统调用，任何企图访问这些对象的第二个线程都将失败并引发错误，这是一个需要我们重视的限制。下面介绍一下实现多线程的思路，以及对资源的断点续传。 本节使用的多线程是用于处理游戏资源的下载，意思是在程序运行时，在用户不知情的情况下在后台开启一个线程下载游戏资源。首先将需要下载的资源打包用zip压缩，主要目的是减少资源包体的大小，然后借助工具生成md5的加密文件，名字为VersionMD5.xml，如果游戏资源有所改变，要重新命名生成的加密文件为VersionMD5_1.0.xml，并将其放到FTP资源服务器上。 游戏启动时，首先判断是否已连接WiFi。如果已开启，则自动启动资源下载。程序会在游戏后台打开线程去下载资源，先从服务器上下载版本控制文件VersionMD5_1.0.xml通过文件名和版本号，对比本地文件的VersionMD5.xml，确定是否需要更新资源，如有不同，则加入下载列表。如果没有打开WiFi，要保证游戏在一定时间内能正常运行，等运行到游戏需要加载的服务器资源时，如果本地无资源加载，就开启数据流量使用提醒强制下载，下载结束后游戏就可以继续运行了。多线程断点续传下载流程如图14-14所示。 图14-14 多线程断点续传下载流程 根据上面的流程图，我们把完整的代码展示一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357using UnityEngine;using System.Collections;using System.Collections.Generic;using System.Xml;using System.IO;using System.Net;using System.Threading;using System;public class ResUpdate &#123; public static ResUpdate Instance; static public string MAIN_VERSION_FILE = "VersionMd5.xml"; static string SERVER_RES_URL; static string LOCAL_RES_OUT_PATH = ""; public static string LOCAL_DECOMPRESS_RES = ""; public static Dictionary&lt;string , ResReference&gt; LocalResOutVersion = new Dictionary&lt;string , ResReference&gt;();//本地包外资源 static Dictionary&lt;string , int&gt; ServerResVersion = new Dictionary&lt;string , int&gt;();//服务器资源版本号 static List&lt;string&gt; NeedDownFiles = new List&lt;string&gt;(); //本地资源包信息 public struct ResReference &#123; public bool isFinish;//是否存在包外 public bool isUnZip;//是否解压DownFile public int version; public ResReference (bool isFinish , int version , bool isUnZip) &#123; this.isFinish = isFinish; this.version = version; this.isUnZip = isUnZip; &#125; &#125; public int updatedNum = 0; public int totalNeedUpdateNum = 0; public long curFileTotalNum = 0; public long curFileNum = 0; public Thread downloadThread; static ResUpdate () &#123; Instance = new ResUpdate();#if UNITY_ANDROID SERVER_RES_URL="http://127.0.0.1/AssetBundle/Android/";#elif UNITY_IPHONE SERVER_RES_URL="http://127.0.0.1/AssetBundle/IOS/";#elif UNITY_EDITOR || UNITY_STANDALONE_WIN SERVER_RES_URL="http://127.0.0.1/AssetBundle/Windows32/";#endif System.Net.ServicePointManager.DefaultConnectionLimit = 512;// LOCAL_RES_OUT_PATH = Application.persistentDataPath + "/AssetBundle/"; LOCAL_DECOMPRESS_RES = LOCAL_RES_OUT_PATH + "/DeCompress/"; SERVER_RES_URL += SGConstant.mSTR_CURVERSION + "/"; &#125; private static bool isDownload = false; /// &lt;summary&gt; /// 启动下载程序 /// &lt;/summary&gt; /// &lt;param name="isAuto"&gt;是否自动（自动只允许Wi-Fi下载）&lt;/param&gt; public static void StartDownLoad (bool isAuto = true) &#123; if ( isAuto ) &#123; if ( AndroidSDKTool.GetNetWorkType() == NetworkType.WIFI ) &#123; Debug.Log("start download resource"); if ( !isDownload ) &#123; CoroutineManager.DoCoroutine(Instance.LoadVersion()); &#125; &#125; else &#123; Debug.Log("no wifi"); &#125; &#125; else &#123; if ( !isDownload ) &#123; CoroutineManager.DoCoroutine(Instance.LoadVersion()); &#125; &#125; &#125; //加载版本文件 IEnumerator LoadVersion () &#123; isDownload = true; //清空变量 //LocalResOutVersion.Clear(); ServerResVersion.Clear(); NeedDownFiles.Clear(); string serverMainVersion = ""; //读取本地配置文件 string localVersion = System.IO.Path.Combine(LOCAL_RES_OUT_PATH , MAIN_VERSION_FILE); if ( File.Exists(localVersion) ) Instance.ParseLocalVersionFile(localVersion , LocalResOutVersion); //取得服务器版本 string versionUrl = SERVER_RES_URL + "VersionMd5_1.0/" + MAIN_VERSION_FILE; WWW sw = new WWW(versionUrl); yield return sw; if ( !string.IsNullOrEmpty(sw.error) ) Debug.LogError("Server Version ..." + sw.error); else &#123; serverMainVersion = sw.text; Debug.Log(serverMainVersion); ParseVersionFile(serverMainVersion , ServerResVersion); &#125; if ( string.IsNullOrEmpty(sw.text) ) &#123; Debug.LogError("无法连接服务器"); //加载下一个场景 &#125; else//可以连接服务器 &#123; //对比本地和服务器的配置 CompareServerVersion(); //开启下载 DownLoadResByThread(); &#125; &#125; public delegate void HandleFinishDownload (WWW www); //在多线程环境中只要我们用下面的方式实例化HashTable就可以了 Hashtable ht = Hashtable.Synchronized(new Hashtable()); public void DownLoadResByThread () &#123; downloadThread = new Thread(new ThreadStart(DownFile)); downloadThread.Start(); &#125; //更新本地的version配置 private void UpdateLocalVersionFile () &#123; XmlDocument xmldoc = new XmlDocument(); XmlElement xmlelem; //加入一个根元素 xmlelem = xmldoc.CreateElement("" , "VersionNum" , ""); xmldoc.AppendChild(xmlelem); foreach ( KeyValuePair&lt;string , ResReference&gt; kvp in LocalResOutVersion ) &#123; XmlElement xe1 = xmldoc.CreateElement("File");//创建一个&lt;Node&gt;节点 xe1.SetAttribute("FileName" , kvp.Key);//设置该节点FileName属性 xe1.SetAttribute("Num" , kvp.Value.version.ToString());//设置该节点Num属性 xe1.SetAttribute("isFinish" , kvp.Value.isFinish.ToString());//设置该节点isFinish属性 xe1.SetAttribute("isUnZip" , kvp.Value.isUnZip.ToString());//设置该节点isUnZip属性 xmlelem.AppendChild(xe1);//添加到&lt;Employees&gt;节点中 &#125; xmldoc.Save(LOCAL_RES_OUT_PATH + MAIN_VERSION_FILE); &#125; //与服务器版本比较 private void CompareServerVersion () &#123; foreach ( var version in ServerResVersion ) &#123; //Debug.Log(version.Key); string fileName = version.Key; int serverVersion = version.Value; //if ( IsResOut(fileName) ) &#123; //如果本地配置表中无资源、版本号不匹配，或者未下载完，就下载 if ( ( LocalResOutVersion.ContainsKey(fileName) &amp;&amp; LocalResOutVersion[fileName].version != ServerResVersion[fileName] ) || !LocalResOutVersion.ContainsKey(fileName) || ( LocalResOutVersion.ContainsKey(fileName) &amp;&amp; LocalResOutVersion[fileName].version == ServerResVersion[fileName] &amp;&amp; !LocalResOutVersion[fileName].isFinish ) ) &#123; NeedDownFiles.Add(fileName); &#125; //AllResDic.Add(fileName , new ResReference(true , serverVersion)); &#125; totalNeedUpdateNum = NeedDownFiles.Count; updatedNum = 0; Debug.Log(string.Format("需下载资源数量：&#123;0&#125;" , totalNeedUpdateNum)); //删除旧资源 foreach ( string fileName in NeedDownFiles ) &#123; string localPath = LOCAL_RES_OUT_PATH + fileName;//下载文件 string localUnZipPath = string.Format("&#123;0&#125;&#123;1&#125;.&#123;2&#125;" , LOCAL_DECOMPRESS_RES , fileName.Substring(0 , fileName.IndexOf(".")) , "assetbundle");//解压文件 if ( File.Exists(localPath) ) File.Delete(localPath); if ( File.Exists(localUnZipPath) ) File.Delete(localUnZipPath); &#125; &#125; /// &lt;summary&gt; /// 检查包外资源是否比包内资源新 /// &lt;summary&gt; /// 将xml版本号转换为字典数据 /// &lt;/summary&gt; /// &lt;param name="content"&gt;&lt;/param&gt; /// &lt;param name="dict"&gt;&lt;/param&gt; private void ParseVersionFile (string content , Dictionary&lt;string , int&gt; dict) &#123; if ( content == null || content.Length == 0 ) &#123; return; &#125; XmlDocument doc = new XmlDocument(); doc.LoadXml(content); XmlNodeList nodes = doc.GetElementsByTagName("File"); for ( int i = 0 ; i &lt; nodes.Count ; i++ ) &#123; XmlAttribute att = nodes[i].Attributes["FileName"]; if ( !dict.ContainsKey(att.Value) ) &#123; dict.Add(att.Value , int.Parse(nodes[i].Attributes["Num"].Value)); &#125; else &#123; Debug.Log("Dict has same key -----&gt;" + att.Value); &#125; &#125; &#125; /// &lt;summary&gt; /// 将xml版本号转换为字典数据 /// &lt;/summary&gt; /// &lt;param name="filename"&gt;&lt;/param&gt; /// &lt;param name="dict"&gt;&lt;/param&gt; private void ParseLocalVersionFile (string filename , Dictionary&lt;string , ResReference&gt; dict) &#123; if ( filename == null || filename.Length == 0 ) &#123; return; &#125; XmlDocument doc = new XmlDocument(); doc.Load(filename); XmlNodeList nodes = doc.GetElementsByTagName("File"); for ( int i = 0 ; i &lt; nodes.Count ; i++ ) &#123; XmlAttribute att = nodes[i].Attributes["FileName"]; if ( !dict.ContainsKey(att.Value) ) &#123; dict.Add(att.Value , new ResReference(bool.Parse(nodes[i].Attributes["isFinish"].Value) , int.Parse(nodes[i].Attributes["Num"].Value) , bool.Parse(nodes[i].Attributes["isUnZip"].Value))); &#125; else &#123; Debug.Log("Dict has same key -----&gt;" + att.Value); &#125; &#125; &#125; //支持断点续传的下载 private void DownFile () &#123; if ( updatedNum &gt;= NeedDownFiles.Count ) &#123; UpdateLocalVersionFile(); return; &#125; string fileName = NeedDownFiles[updatedNum]; string serverPath = SERVER_RES_URL + fileName; //判断目录 string[] fileNameArr = fileName.Split('/'); string filePath = ""; for ( int i = 0 ; i &lt; fileNameArr.Length - 1 ; i++ ) &#123; filePath += fileNameArr[i] + "/"; &#125; filePath = LOCAL_RES_OUT_PATH + filePath;//下载文件目录 string localPath = LOCAL_RES_OUT_PATH + fileName;//下载文件 string localUnZipPath = string.Format("&#123;0&#125;&#123;1&#125;.&#123;2&#125;" , LOCAL_DECOMPRESS_RES , fileName.Substring(0 , fileName.IndexOf(".")) , "assetbundle");//解压文件 if ( !Directory.Exists(filePath) ) Directory.CreateDirectory(filePath); if ( !Directory.Exists(LOCAL_DECOMPRESS_RES) ) Directory.CreateDirectory(LOCAL_DECOMPRESS_RES); bool isRight = false;//是否下载好 //上个版本先删除（并删除解压好的文件） if(LocalResOutVersion.ContainsKey(fileName)&amp;&amp; ( LocalResOutVersion[fileName].version &lt; ServerResVersion[fileName] ) ) &#123; File.Delete(localPath); File.Delete(localUnZipPath); &#125; FileStream fs = null; HttpWebRequest requestGetCount = null; HttpWebResponse responseGetCount = null; try &#123; requestGetCount = (System.Net.HttpWebRequest)System.Net.HttpWebRequest.Create(serverPath); responseGetCount = (HttpWebResponse)requestGetCount.GetResponse(); curFileTotalNum = responseGetCount.ContentLength; if ( File.Exists(localPath) ) &#123; fs = File.OpenWrite(localPath);//打开流 curFileNum = fs.Length;//通过字节流的长度确定当前的下载位置 if ( curFileTotalNum - curFileNum &lt;= 0 ) &#123; isRight = true; &#125; fs.Seek(curFileNum , SeekOrigin.Current); //移动文件流中的当前指针 &#125; else &#123; fs = new FileStream(localPath , FileMode.CreateNew); curFileNum = 0; &#125; &#125; catch ( Exception ex ) &#123; if ( fs != null ) fs.Close(); UpdateLocalVersionTemp(fileName , false , false); UpdateLocalVersionFile(); isRight = false; Debug.Log(ex.ToString()); &#125; finally &#123; if ( responseGetCount != null ) &#123; responseGetCount.Close(); responseGetCount = null; &#125; if ( requestGetCount != null ) &#123; requestGetCount.Abort(); requestGetCount = null; &#125; &#125; HttpWebRequest request = null; HttpWebResponse response = null; Stream ns = null; string test = ""; try &#123; //本地未下载完成 if ( !isRight ) &#123; request = (HttpWebRequest)HttpWebRequest.Create(serverPath); if ( curFileNum &gt; 0 ) request.AddRange((int)curFileNum); //设置Range值 response = (HttpWebResponse)request.GetResponse(); //向服务器请求，获得服务器回应数据流 ns = response.GetResponseStream(); byte[] nbytes = new byte[1024]; int nReadSize = 0; nReadSize = ns.Read(nbytes , 0 , 1024); while ( nReadSize &gt; 0 ) &#123; fs.Write(nbytes , 0 , nReadSize); nReadSize = ns.Read(nbytes , 0 , 1024); curFileNum += nReadSize; //Debug.Log(DownloadByte); &#125; isRight = true; fs.Flush(); fs.Close(); ns.Close(); request.Abort(); &#125; UpdateLocalVersionTemp(fileName , true , false); //解压(防止更新下载不全，解压报错的文件占坑) if ( File.Exists(localUnZipPath) ) &#123; File.Delete(localUnZipPath); &#125; CompressUtil.DeCompress(localPath , localUnZipPath , null); UpdateLocalVersionTemp(fileName , true , true); updatedNum++; Debug.Log("down " + updatedNum + "/" + totalNeedUpdateNum + "," + fileName + "Loading complete"); &#125; catch ( Exception ex ) &#123; if ( fs != null ) fs.Close(); UpdateLocalVersionTemp(fileName , false , false); isRight = false; Debug.Log(ex.ToString()); //解压出错，删除下载文件 if ( File.Exists(localPath) ) &#123; File.Delete(localPath); &#125; //StartDownLoad(); &#125; finally &#123; if ( ns != null ) &#123; ns.Close(); ns = null; &#125; if ( response != null ) &#123; response.Close(); response = null; &#125; if ( request != null ) &#123; request.Abort(); request = null; &#125; //下载下一个 //if ( isRight ) &#123; DownFile(); &#125; &#125; //下载结束 isDownload = false; &#125; private string UrlNoCache (string url) &#123; return url + "?date=" + DateTime.Now.Ticks; &#125; private void UpdateLocalVersionTemp (string fileName , bool isFinish , bool isUnZip) &#123; //下载更新版本号 if ( LocalResOutVersion.ContainsKey(fileName) ) &#123; LocalResOutVersion[fileName] = new ResReference(isFinish , ServerResVersion[fileName] , isUnZip); &#125; else &#123; LocalResOutVersion.Add(fileName,newResReference(isFinish , ServerResVersion[fileName] , isUnZip)); &#125; UpdateLocalVersionFile(); &#125;&#125; 下面介绍一下代码，在该代码中首先声明两个变量，用于存储包体外的资源和服务器资源，包体外的资源主要是考虑到从服务器下载的资源不可能加载到包体里面，只能放到指定的文件夹下面，声明的变量是用字典Dictionary存放的。 12public static Dictionary&lt;string , ResReference&gt; LocalResOutVersion = new Dictionary&lt;string , ResReference&gt;();//本地保外资源static Dictionary&lt;string , int&gt; ServerResVersion = new Dictionary&lt;string , int&gt;();//服务器资源版本号 在声明的变量中有ResReference，它表示的是资源信息，在这里用结构体定义本地资源包信息，结构体表示如下。 123456789101112//本地资源包信息public struct ResReference &#123; public bool isFinish;//是否存在包外 public bool isUnZip;//是否解压DownFile public int version; public ResReference (bool isFinish , int version , bool isUnZip) &#123; this.isFinish = isFinish; this.version = version; this.isUnZip = isUnZip; &#125;&#125; 前期准备工作完成后，开始进入资源下载阶段，使用函数StartDownLoad开始启动资源下载。首先下载配置文件，本地的配置文件会与服务器的配置文件做对比决定下载哪个资源文件，在该函数中调用了函数LoadVersion，处理版本配置文件。 12345678910111213141516171819202122232425262728293031323334353637IEnumerator LoadVersion () &#123; isDownload = true; //清空变量 //LocalResOutVersion.Clear(); ServerResVersion.Clear(); NeedDownFiles.Clear(); string serverMainVersion = ""; //读取本地配置文件 string localVersion = System.IO.Path.Combine(LOCAL_RES_OUT_PATH , MAIN_VERSION_FILE); if ( File.Exists(localVersion) ) Instance.ParseLocalVersionFile(localVersion , LocalResOutVersion); //取得服务器版本 string versionUrl = SERVER_RES_URL + "VersionNum/" + MAIN_VERSION_FILE; WWW sw = new WWW(versionUrl); yield return sw; if ( !string.IsNullOrEmpty(sw.error) ) Debug.LogError("Server Version ..." + sw.error); else &#123; serverMainVersion = sw.text; Debug.Log(serverMainVersion); //serverVersionByte = sw.bytes; ParseVersionFile(serverMainVersion , ServerResVersion); &#125; if ( string.IsNullOrEmpty(sw.text) ) &#123; Debug.LogError("无法连接服务器"); //CompareLoacalVersion(); //加载下一个场景 &#125; else//可以连接服务器 &#123; //对比本地和服务器的配置 CompareServerVersion(); //开启下载 //CoroutineManager.DoCoroutine(DownLoadResByWWW()); DownLoadResByThread(); &#125;&#125; 配置文件对比完成后，确定开始启动线程下载资源，调用函数DownLoadResByThread下载，代码如下所示。 1234public void DownLoadResByThread () &#123; downloadThread = new Thread(new ThreadStart(DownFile)); downloadThread.Start();&#125; 该函数起动了一个线程，在这个线程里面调用函数DownFile去下载资源并且它具有断点续传功能，函数中都有注释，读者可以自行查看。下面把断点续传内容的重点解释一下：它的HttpWebRequest和HttpWebResponse作为资源请求来使用，获取到服务器请求后，可以拿到资源流，根据流的大小判断是否下载完整，如果不完整可以做个记录，继续下载，在最后又调用了一次函数DownFile（），函数迭代进行直到资源下载完成，以下是处理断点续传的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364HttpWebRequest request = null;HttpWebResponse response = null;Stream ns = null;string test = "";try &#123; //本地未下载完成 if ( !isRight ) &#123; request = (HttpWebRequest)HttpWebRequest.Create(serverPath); if ( curFileNum &gt; 0 ) request.AddRange((int)curFileNum); //设置Range值 response = (HttpWebResponse)request.GetResponse(); //向服务器请求，获得服务器回应数据流 ns = response.GetResponseStream(); byte[] nbytes = new byte[1024]; int nReadSize = 0; nReadSize = ns.Read(nbytes , 0 , 1024); while ( nReadSize &gt; 0 ) &#123; fs.Write(nbytes , 0 , nReadSize); nReadSize = ns.Read(nbytes , 0 , 1024); curFileNum += nReadSize; //Debug.Log(DownloadByte); &#125; isRight = true; fs.Flush(); fs.Close(); ns.Close(); request.Abort(); &#125; UpdateLocalVersionTemp(fileName , true , false); //解压（防止更新下载不全，解压报错的文件占坑） if ( File.Exists(localUnZipPath) ) &#123; File.Delete(localUnZipPath); &#125; CompressUtil.DeCompress(localPath , localUnZipPath , null); UpdateLocalVersionTemp(fileName , true , true); updatedNum++; Debug.Log("down " + updatedNum + "/" + totalNeedUpdateNum + "," + fileName + "Loading complete");&#125; catch ( Exception ex ) &#123; if ( fs != null ) fs.Close(); UpdateLocalVersionTemp(fileName , false , false); isRight = false; Debug.Log(ex.ToString()); //解压出错，删除下载文件 if ( File.Exists(localPath) ) &#123; File.Delete(localPath); &#125; //StartDownLoad();&#125; finally &#123; if ( ns != null ) &#123; ns.Close(); ns = null; &#125; if ( response != null ) &#123; response.Close(); response = null; &#125; if ( request != null ) &#123; request.Abort(); request = null; &#125; DownFile();&#125; 该代码脚本可以直接挂到对象上，完成资源的断点续传，断点续传主要是用于减小包体的，可以在玩家玩游戏的过程中，在后台开启一个线程来完成后续资源的下载。采用了断点续传技术也可以避免在下载的过程中由于网络不好，出现资源下载不完整的情况，在玩家不知情的情况下就完成了游戏资源的下载。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity 3D实战核心技术详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8章-贪婪算法]]></title>
    <url>%2F2019%2F08%2F01%2F%E7%AC%AC8%E7%AB%A0-%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 学习如何处理不可能完成的任务：没有快速算法的问题（NP完全问题）。 学习识别NP完全问题，以免浪费时间去寻找解决它们的快速算法。 学习近似算法，使用它们可快速找到NP完全问题的近似解。 学习贪婪策略——一种非常简单的问题解决策略。 教室调度问题假设有如下课程表，你希望将尽可能多的课程安排在某间教室上。 你没法让这些课都在这间教室上，因为有些课的上课时间有冲突。 你希望在这间教室上尽可能多的课。如何选出尽可能多且时间不冲突的课程呢？ 这个问题好像很难，不是吗？实际上，算法可能简单得让你大吃一惊。具体做法如下。 (1) 选出结束最早的课，它就是要在这间教室上的第一堂课。 (2) 接下来，必须选择第一堂课结束后才开始的课。同样，你选择结束最早的课，这将是要在这间教室上的第二堂课。 重复这样做就能找出答案！下面来试一试。美术课的结束时间最早，为10:00 a.m.，因此它就是第一堂课。 接下来的课必须在10:00 a.m.后开始，且结束得最早。 英语课不行，因为它的时间与美术课冲突，但数学课满足条件。最后，计算机课与数学课的时间是冲突的，但音乐课可以。 因此将在这间教室上如下三堂课。 很多人都跟我说，这个算法太容易、太显而易见，肯定不对。但这正是贪婪算法的优点——简单易行！贪婪算法很简单：每步都采取最优的做法。在这个示例中，你每次都选择结束最早的课。用专业术语说，就是你每步都选择局部最优解 ，最终得到的就是全局最优解。信不信由你，对于这个调度问题，上述简单算法找到的就是最优解！ 显然，贪婪算法并非在任何情况下都行之有效，但它易于实现！下面再来看一个例子。 8.2 背包问题假设你是个贪婪的小偷，背着可装35磅（1磅≈0.45千克）重东西的背包，在商场伺机盗窃各种可装入背包的商品。 你力图往背包中装入价值最高的商品，你会使用哪种算法呢？ 同样，你采取贪婪策略，这非常简单。 (1) 盗窃可装入背包的最贵商品。 (2) 再盗窃还可装入背包的最贵商品，以此类推。 只是这次这种贪婪策略不好使了！例如，你可盗窃的商品有下面三种。 你的背包可装35磅的东西。音响最贵，你把它给偷了，但背包没有空间装其他东西了。 你偷到了价值3000美元的东西。且慢！如果不是偷音响，而是偷笔记本电脑和吉他，总价将为3500美元！ 在这里，贪婪策略显然不能获得最优解，但非常接近。下一章将介绍如何找出最优解。不过小偷去购物中心行窃时，不会强求所偷东西的总价最高，只要差不多就行了。 从这个示例你得到了如下启示：在有些情况下，完美是优秀的敌人。有时候，你只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的结果又与正确结果相当接近。 练习 8.1 你在一家家具公司工作，需要将家具发往全国各地，为此你需要将箱子装上卡车。每个箱子的尺寸各不相同，你需要尽可能利用每辆卡车的空间，为此你将如何选择要装上卡车的箱子呢？请设计一种贪婪算法。使用这种算法能得到最优解吗？ 8.2 你要去欧洲旅行，总行程为7天。对于每个旅游胜地，你都给它分配一个价值——表 示你有多想去那里看看，并估算出需要多长时间。你如何将这次旅行的价值最大化？请设计一种贪婪算法。使用这种算法能得到最优解吗？ 下面来看最后一个例子。在这个例子中，你别无选择，只能使用贪婪算法。 8.3 集合覆盖问题 假设你办了个广播节目，要让全美50个州的听众都收听得到。为此，你需要决定在哪些广播台播出。在每个广播台播出都需要支付费用，因此你力图在尽可能少的广播台播出。现有广播台名单如下。 每个广播台都覆盖特定的区域，不同广播台的覆盖区域可能重叠。 如何找出覆盖全美50个州的最小广播台集合呢？听起来很容易，但其实非常难。具体方法如下。 (1) 列出每个可能的广播台集合，这被称为幂集 （power set）。可能的子集有2 n 个。 (2) 在这些集合中，选出覆盖全美50个州的最小集合。 问题是计算每个可能的广播台子集需要很长时间。由于可能的集合有2 n 个，因此运行时间为O (2 n )。如果广播台不多，只有5～10个，这是可行的。但如果广播台很多，结果将如何呢？随着广播台的增多，需要的时间将激增。假设你每秒可计算10个子集，所需的时间将如下。 没有任何算法可以足够快地解决这个问题 ！怎么办呢？ 近似算法贪婪算法可化解危机！使用下面的贪婪算法可得到非常接近的解。 (1) 选出这样一个广播台，即它覆盖了最多的未覆盖州。即便这个广播台覆盖了一些已覆盖的州，也没有关系。 (2) 重复第一步，直到覆盖了所有的州。 这是一种近似算法 （approximation algorithm）。在获得精确解需要的时间太长时，可使用近似算法。判断近似算法优劣的标准如下： 速度有多快； 得到的近似解与最优解的接近程度。 贪婪算法是不错的选择，它们不仅简单，而且通常运行速度很快。在这个例子中，贪婪算法的运行时间为O (n 2 )，其中n 为广播台数量。 下面来看看解决这个问题的代码。 准备工作 出于简化考虑，这里假设要覆盖的州没有那么多，广播台也没有那么多。 首先，创建一个列表，其中包含要覆盖的州。 states_needed = set([“mt”, “wa”, “or”, “id”, “nv”, “ut”,“ca”, “az”]) ←——你传入一个数组，它被转换为集合 我使用集合来表示要覆盖的州。集合类似于列表，只是同样的元素只能出现一次，即集合不能包含重复的元素 。例如，假设你有如下列表。 arr = [1, 2, 2, 3, 3, 3] 并且你将其转换为集合。 set(arr)set([1, 2, 3]) 在这个集合中，1、2和3都只出现一次。 还需要有可供选择的广播台清单，我选择使用散列表来表示它。 stations = {}stations[“kone”] = set([“id”, “nv”, “ut”])stations[“ktwo”] = set([“wa”, “id”, “mt”])stations[“kthree”] = set([“or”, “nv”, “ca”])stations[“kfour”] = set([“nv”, “ut”])stations[“kfive”] = set([“ca”, “az”]) 其中的键为广播台的名称，值为广播台覆盖的州。在该示例中，广播台kone覆盖了爱达荷州、内达华州和犹他州。所有的值都是集合。你马上将看到，使用集合来表示一切可以简化工作。 最后，需要使用一个集合来存储最终选择的广播台。 final_stations = set() 计算答案 接下来需要计算要使用哪些广播台。根据下边的示意图，你能确定应使用哪些广播台吗？ 正确的解可能有多个。你需要遍历所有的广播台，从中选择覆盖了最多的未覆盖州的广播台。我将这个广播台存储在best_station 中。 best_station = Nonestates_covered = set()for station, states_for_station in stations.items(): states_covered 是一个集合，包含该广播台覆盖的所有未覆盖的州。for 循环迭代每个广播台，并确定它是否是最佳的广播台。下面来看看这个for 循环的循环体。 covered = states_needed &amp; states_for_station ←——你没见过的语法！它计算交集if len(covered) &gt; len(states_covered): best_station = station states_covered = covered 其中有一行代码看起来很有趣。 covered = states_needed &amp; states_for_station 它是做什么的呢？ 集合 假设你有一个水果集合。 还有一个蔬菜集合。 有这两个集合后，你就可以使用它们来做些有趣的事情。 下面是你可以对集合执行的一些操作。 并集意味着将集合合并。 交集意味着找出两个集合中都有的元素（在这里，只有西红柿符合条件）。 差集意味着将从一个集合中剔除出现在另一个集合中的元素。 下面是一个例子。 fruits = set([“avocado”, “tomato”, “banana”])vegetables = set([“beets”, “carrots”, “tomato”])fruits | vegetables ←——并集set([“avocado”, “beets”, “carrots”, “tomato”, “banana”])fruits &amp; vegetables ←——交集set([“tomato”])fruits – vegetables ←——差集set([“avocado”, “banana”])vegetables – fruits ←——你觉得这行代码是做什么的呢？ 这里小结一下： 集合类似于列表，只是不能包含重复的元素； 你可执行一些有趣的集合运算，如并集、交集和差集。 回到代码 回到前面的示例。 下面的代码计算交集。 covered = states_needed &amp; states_for_station covered 是一个集合，包含同时出现在states_needed 和states_for_station 中的州；换言之，它包含当前广播台覆盖的一系列还未覆盖的州！接下来，你检查该广播台覆盖的州是否比best_station 多。 if len(covered) &gt; len(states_covered): best_station = station states_covered = covered 如果是这样的，就将best_station 设置为当前广播台。最后，你在for 循环结束后将best_station 添加到最终的广播台列表中。 final_stations.add(best_station) 你还需更新states_needed 。由于该广播台覆盖了一些州，因此不用再覆盖这些州。 states_needed -= states_covered 你不断地循环，直到states_needed 为空。这个循环的完整代码如下。 while states_needed: best_station = None states_covered = set() for station, states in stations.items(): covered = states_needed &amp; states if len(covered) &gt; len(states_covered): best_station = station states_covered = covered states_needed -= states_covered final_stations.add(best_station)最后，你打印final_stations ，结果类似于下面这样。 print final_stationsset([‘ktwo’, ‘kthree’, ‘kone’, ‘kfive’]) 结果符合你的预期吗？选择的广播台可能是2、3、4和5，而不是预期的1、2、3和5。下面来比较一下贪婪算法和精确算法的运行时间。 练习 下面各种算法是否是贪婪算法。 8.3 快速排序。 8.4 广度优先搜索。 8.5 狄克斯特拉算法。 8.4 NP完全问题为解决集合覆盖问题，你必须计算每个可能的集合。 这可能让你想起了第1章介绍的旅行商问题。在这个问题中，旅行商需要前往5个不同的城市。 他需要找出前往这5个城市的最短路径，为此，必须计算每条可能的路径。 前往5个城市时，可能的路径有多少条呢？ 8.4.1 旅行商问题详解我们从城市数较少的情况着手。假设只涉及两个城市，因此可供选择的路线有两条。 这两条路线相同还是不同 你可能认为这两条路线相同，难道从旧金山到马林的距离与从马林到旧金山的距离不同吗？不一定。有些城市（如旧金山）有很多单行线，因此你无法按原路返回。你可能需要离开原路行驶一两英里才能找到上高速的匝道。因此，这两条路线不一定相同。 你可能心存疑惑：在旅行商问题中，必须从特定的城市出发吗？例如，假设我是旅行商。我居住在旧金山，需要前往其他4个城市，因此我将从旧金山出发。 但有时候，不确定要从哪个城市出发。假设联邦快递将包裹从芝加哥发往湾区，包裹将通过航运发送到联邦快递在湾区的50个集散点之一，再装上经过不同配送点的卡车。该通过航运发送到哪个集散点呢？在这个例子中，起点就是未知的。因此，你需要通过计算为旅行商找出起点和最佳路线。 在这两种情况下，运行时间是相同的。但出发城市未定时更容易处理，因此这里以这种情况为例。 涉及两个城市时，可能的路线有两条。 3个城市 现在假设再增加一个城市，可能的路线有多少条呢？ 如果从伯克利出发，就需前往另外两个城市。 从每个城市出发时，都有两条不同的路线，因此总共有6条路线。 因此涉及3个城市时，可能的路线有6条。 4个城市 我们再增加一个城市——弗里蒙特。现在假设从弗里蒙特出发。 从弗里蒙特出发时，有6条可能的路线。这些路线与前面只有3个城市时计算的6条路线很像，只是现在所有的路线都多了一个城市——弗里蒙特！这里有一个规律。假设有4个城市，你选择一个出发城市——弗里蒙特后，还余下3个城市。而你知道，涉及3个城市时，可能的路线有6条。从弗里蒙特出发时，有6条可能的路线，但还可以从其他任何一个城市出发。 可能的出发城市有4个，从每个城市出发时都有6条可能的路线，因此可能的路线有4 × 6 = 24条。 你看出规律了吗？每增加一个城市，需要计算的路线数都将增加。 涉及6个城市时，可能的路线有多少条呢？如果你说720条，那就对了。7个城市为5040条，8个城市为40 320条。 这被称为阶乘函数 （factorial function），第3章介绍过。5! = 120。假设有10个城市，可能的路线有多少条呢？10! = 3 628 800。换句话说，涉及10个城市时，需要计算的可能路线超过300万条。正如你看到的，可能的路线数增加得非常快！因此，如果涉及的城市很多，根本就无法找出旅行商问题的正确解。 旅行商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。 近似求解 对旅行商问题来说，什么样的近似算法不错呢？能找到较短路径的算法就算不错。在继续往下阅读前，看看你能设计出这样的算法吗？ 我会采取这样的做法：随便选择出发城市，然后每次选择要去的下一个城市时，都选择还没去的最近的城市。假设旅行商从马林出发。 总旅程为71英里。这条路径可能不是最短的，但也相当短了。 NP完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。 8.4.2 如何识别NP完全问题 Jonah正为其虚构的橄榄球队挑选队员。他列了一个清单，指出了对球队的要求：优秀的四分卫，优秀的跑卫，擅长雨中作战，以及能承受压力等。他有一个候选球员名单，其中每个球员都满足某些要求。 Jonah需要组建一个满足所有这些要求的球队，可名额有限。等等，Jonah突然间意识到，这不就是一个集合覆盖问题吗！ Jonah可使用前面介绍的近似算法来组建球队。 (1) 找出符合最多要求的球员。 (2) 不断重复这个过程，直到球队满足要求（或球队名额已满）。 NP完全问题无处不在！如果能够判断出要解决的问题属于NP完全问题就好了，这样就不用去寻找完美的解决方案，而是使用近似算法即可。但要判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小。例如，前一章深入讨论了最短路径，你知道如何找出从A点到B点的最短路径。 但如果要找出经由指定几个点的的最短路径，就是旅行商问题——NP完全问题。简言之，没办法判断问题是不是NP完全问题，但还是有一些蛛丝马迹可循的。 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。 涉及“所有组合”的问题通常是NP完全问题。 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。 练习 8.6 有个邮递员负责给20个家庭送信，需要找出经过这20个家庭的最短路径。请问这是一个NP完全问题吗？ 8.7 在一堆人中找出最大的朋友圈（即其中任何两个人都相识）是NP完全问题吗？ 8.8 你要制作美国地图，需要用不同的颜色标出相邻的州。为此，你需要确定最少需要使用多少种颜色，才能确保任何两个相邻州的颜色都不同。请问这是NP完全问题吗？ 8.5 小结贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。 对于NP完全问题，还没有找到快速解决方案。 面临NP完全问题时，最佳的做法是使用近似算法。 贪婪算法易于实现、运行速度快，是不错的近似算法。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章-散列表]]></title>
    <url>%2F2019%2F08%2F01%2F%E7%AC%AC5%E7%AB%A0-%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是散列函数？ 什么是散列表？散列表的优势在哪里？ 散列表的应用场景是哪些？ 本章涵盖： 学习散列表——最有用的基本数据结构之一。散列表用途广泛，本章 将介绍其常见的用途。 学习散列表的内部机制：实现、冲突和散列函数。这将帮助你理解如何分析散列表的性能。 假设你在一家杂货店上班。有顾客来买东西时，你得在一个本子中查找价格。如果本子的内容不是按字母顺序排列的，你可能为查找苹果（apple）的价格而浏览每一行，这需要很长的时间。此时你使用的是第1章介绍的简单查找，需要浏览每一行。还记得这需要多长时间吗？O(n)。如果本子的内容是按字母顺序排列的，可使用二分查找来找出苹果的价格，这需要的时间更短，为O(log n)。 需要提醒你的是，运行时间O(n)和O(log n)之间有天壤之别！假设你每秒能够看10行，使用简单查找和二分查找所需的时间将如下。 你知道，二分查找的速度非常快。但作为收银员，在本子中查找价格是件很痛苦的事情，哪怕本子的内容是有序的。在查找价格时，你都能感觉到顾客的怒气。看来真的需要一名能够记住所有商品价格的雇员，这样你就不用查找了：问她就能马上知道答案。 不管商品有多少，这位雇员（假设她的名字为Maggie）报出任何商品的价格的时间都为O(1)，速度比二分查找都快。 真是太厉害了！如何聘到这样的雇员呢？ 下面从数据结构的角度来看看。前面介绍了两种数据结构：数组和链表（其实还有栈，但栈并不能用于查找）。你可使用数组来实现记录商品价格的本子。 这种数组的每个元素包含两项内容：商品名和价格。如果将这个数组按商品名排序，就可使用二分查找在其中查找商品的价格。这样查找价格的时间将为O(log n)。然而，你希望查找商品价格的时间为O(1)，即你希望查找速度像Maggie那么快，这是散列函数的用武之地。 散列函数散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。 如果用专业术语来表达的话，我们会说，散列函数“将输入映射到数字”。你可能认为散列函数输出的数字没什么规律，但其实散列函数必须满足一些要求。 它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。 它应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入是什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。 散列函数将输入映射为数字，这有何用途呢？你可使用它来打造你的“Maggie”！ 为此，首先创建一个空数组。 你将在这个数组中存储商品的价格。下面来将苹果的价格加入到这个数组中。为此，将apple作为输入交给散列函数。 散列函数的输出为3，因此我们将苹果的价格存储到数组的索引3处。 下面将牛奶（milk）的价格存储到数组中。为此，将milk作为散列函数的输入。 散列函数的输出为0，因此我们将牛奶的价格存储在索引0处。 不断地重复这个过程，最终整个数组将填满价格。 现在假设需要知道鳄梨（avocado）的价格。你无需在数组中查找，只需将avocado作为输入交给散列函数。 它将告诉你鳄梨的价格存储在索引4处。果然，你在那里找到了。 散列函数准确地指出了价格的存储位置，你根本不用查找！之所以能够这样，具体原因如下。 散列函数总是将同样的输入映射到相同的索引。每次你输入avocado，得到的都是同一个数字。因此，你可首先使用它来确定将鳄梨的价格存储在什么地方，并在以后使用它来确定鳄梨的价格存储在什么地方。 散列函数将不同的输入映射到不同的索引。avocado映射到索引4，milk映射到索引0。每种商品都映射到数组的不同位置，让你能够将其价格存储到这里。 散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。 刚才你就打造了一个“Maggie”！你结合使用散列函数和数组创建了一种被称为散列表（hash table）的数据结构。散列表是你学习的第一种包含额外逻辑的数据结构。数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。 在你将学习的复杂数据结构中，散列表可能是最有用的，也被称为散列映射、映射、字典和关联数组。散列表的速度很快！还记得第2章关于数组和链表的讨论吗？你可以立即获取数组中的元素，而散列表也使用数组来存储数据，因此其获取元素的速度与数组一样快。 你可能根本不需要自己去实现散列表，任一优秀的语言都提供了散列表实现。Python提供的散列表实现为字典，你可使用函数dict来创建散列表。 book = dict() 创建散列表book后，在其中添加一些商品的价格。 book[“apple”] = 0.67 ←——一个苹果的价格为67美分book[“milk”] = 1.49 ←——牛奶的价格为1.49美元book[“avocado”] = 1.49print book{‘avocado’: 1.49, ‘apple’: 0.67, ‘milk’: 1.49} 非常简单！我们来查询鳄梨的价格。 print book[“avocado”]1.49 ←——鳄梨的价格 散列表由键和值组成。在前面的散列表book 中，键为商品名，值为商品价格。散列表将键映射到值。 在下一节中，你将看到一些散列表使用示例。 练习 对于同样的输入，散列表必须返回同样的输出，这一点很重要。如果不是这样的，就无法找到你在散列表中添加的元素！ 请问下面哪些散列函数是一致的？ 5.1 f(x) = 1 ←——无论输入是什么，都返回1 5.2 f(x) = rand() ←——每次都返回一个随机数 5.3 f(x) = next_empty_slot() ←——返回散列表中下一个空位置的索引 5.4 f(x) = len(x) ←——将字符串的长度用作索引 应用案例散列表用途广泛，本节将介绍几个应用案例。 将散列表用于查找手机都内置了方便的电话簿，其中每个姓名都有对应的电话号码。 假设你要创建一个类似这样的电话簿，将姓名映射到电话号码。该电话簿需要提供如下功能。 添加联系人及其电话号码。 通过输入联系人来获悉其电话号码。 这非常适合使用散列表来实现！在下述情况下，使用散列表是很不错的选择。 创建映射。 查找。 创建电话簿非常容易。首先，新建一个散列表。 phone_book = dict() 顺便说一句，Python提供了一种创建散列表的快捷方式——使用一对大括号。 phone_book = {} ←——与phone_book = dict()等效 下面在这个电话簿中添加一些联系人的电话号码。 phone_book[“jenny”] = 8675309phone_book[“emergency”] = 911 这就成了！现在，假设你要查找Jenny的电话号码，为此只需向散列表传入相应的键。 print phone_book[“jenny”]8675309 ←——Jenny的电话号码 如果要求你使用数组来创建电话簿，你将如何做呢？散列表让你能够轻松地模拟映射关系。 散列表被用于大海捞针式的查找。例如，你在访问像http://adit.io 这样的网站时，计算机必须将adit.io转换为IP地址。 无论你访问哪个网站，其网址都必须转换为IP地址。 这不是将网址映射到IP地址吗？好像非常适合使用散列表啰！这个过程被称为DNS解析 （DNS resolution），散列表是提供这种功能的方式之一。 防止重复假设你负责管理一个投票站。显然，每人只能投一票，但如何避免重复投票呢？有人来投票时，你询问他的全名，并将其与已投票者名单进行比对。 如果名字在名单中，就说明这个人投过票了，因此将他拒之门外！否则，就将他的姓名加入到名单中，并让他投票。现在假设有很多人来投过了票，因此名单非常长。 每次有人来投票时，你都得浏览这个长长的名单，以确定他是否投过票。但有一种更好的办法，那就是使用散列表！ 为此，首先创建一个散列表，用于记录已投票的人。 voted = {} 有人来投票时，检查他是否在散列表中。 value = voted.get(“tom”) 如果“tom”在散列表中，函数get 将返回它；否则返回None 。你可使用这个函数检查来投票的人是否投过票！ 代码如下。 12345678voted = &#123;&#125;def check_voter(name): if voted.get(name): print "kick them out!" else: voted[name] = True print "let them vote!" 我们来测试几次。 123456&gt;&gt;&gt; check_voter("tom")let them vote!&gt;&gt;&gt; check_voter("mike")let them vote!&gt;&gt;&gt; check_voter("mike")kick them out! 首先来投票的是Tom，上述代码打印let them vote! 。接着Mike来投票，打印的也是let them vote! 。然后，Mike又来投票，于是打印的就是kick them out! 。 别忘了，如果你将已投票者的姓名存储在列表中，这个函数的速度终将变得非常慢，因为它必须使用简单查找搜索整个列表。但这里将它们存储在了散列表中，而散列表让你能够迅速知道来投票的人是否投过票。使用散列表来检查是否重复，速度非常快。 将散列表用作缓存来看最后一个应用案例：缓存。如果你在网站工作，可能听说过进行缓存是一种不错的做法。下面简要地介绍其中的原理。假设你访问网站facebook.com。 (1) 你向Facebook的服务器发出请求。 (2) 服务器做些处理，生成一个网页并将其发送给你。 (3) 你获得一个网页。 例如，Facebook的服务器可能搜集你朋友的最近活动，以便向你显示这些信息，这需要几秒钟的时间。作为用户的你，可能感觉这几秒钟很久，进而可能认为Facebook怎么这么慢！另一方面，Facebook的服务器必须为数以百万的用户提供服务，每个人的几秒钟累积起来就相当多了。为服务好所有用户，Facebook的服务器实际上在很努力地工作。有没有办法让Facebook的服务器少做些工作，从而提高Facebook网站的访问速度呢？ 假设你有个侄女，总是没完没了地问你有关星球的问题。火星离地球多远？月球呢？木星呢？每次你都得在Google搜索，再告诉她答案。这需要几分钟。现在假设她老问你月球离地球多远，很快你就记住了月球离地球238 900英里。因此不必再去Google搜索，你就可以直接告诉她答案。这就是缓存的工作原理：网站将数据记住，而不再重新计算。 如果你登录了Facebook，你看到的所有内容都是为你定制的。你每次访问facebook.com，其服务器都需考虑你感兴趣的是什么内容。但如果你没有登录，看到的将是登录页面。每个人看到的登录页面都相同。Facebook被反复要求做同样的事情：“当我注销时，请向我显示主页。”有鉴于此，它不让服务器去生成主页，而是将主页存储起来，并在需要时将其直接发送给用户。 这就是缓存 ，具有如下两个优点。 用户能够更快地看到网页，就像你记住了月球与地球之间的距离时一样。下次你侄女再问你时，你就不用再使用Google搜索，立刻就可以告诉她答案。 Facebook需要做的工作更少。 缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中！ Facebook不仅缓存主页，还缓存About页面、Contact页面、Terms and Conditions页面等众多其他的页面。因此，它需要将页面URL映射到页面数据。 当你访问Facebook的页面时，它首先检查散列表中是否存储了该页面。 具体的代码如下。 123456789cache = &#123;&#125;def get_page(url): if cache.get(url): return cache[url] ←------返回缓存的数据 else: data = get_data_from_server(url) cache[url] = data ←------先将数据保存到缓存中 return data 仅当URL不在缓存中时，你才让服务器做些处理，并将处理生成的数据存储到缓存中，再返回它。这样，当下次有人请求该URL时，你就可以直接发送缓存中的数据，而不用再让服务器进行处理了。 小结这里总结一下，散列表适合用于： 模拟映射关系； 防止重复； 缓存/记住数据，以免服务器再通过处理来生成它们。 冲突前面说过，大多数语言都提供了散列表实现，你不用知道如何实现它们。有鉴于此，我就不再过多地讨论散列表的内部原理，但你依然需要考虑性能！要明白散列表的性能，你得先搞清楚什么是冲突。本节和下一节将分别介绍冲突和性能。 首先，我撒了一个善意的谎。我之前告诉你的是，散列函数总是将不同的键映射到数组的不同位置。 实际上，几乎不可能编写出这样的散列函数。我们来看一个简单的示例。假设你有一个数组，它包含26个位置。 而你使用的散列函数非常简单，它按字母表顺序分配数组的位置。 你可能已经看出了问题。如果你要将苹果的价格存储到散列表中，分配给你的是第一个位置。 接下来，你要将香蕉的价格存储到散列表中，分配给你的是第二个位置。 一切顺利！但现在你要将鳄梨的价格存储到散列表中，分配给你的又是第一个位置。 不好，这个位置已经存储了苹果的价格！怎么办？这种情况被称为冲突 （collision）：给两个键分配的位置相同。这是个问题。如果你将鳄梨的价格存储到这个位置，将覆盖苹果的价格，以后再查询苹果的价格时，得到的将是鳄梨的价格！冲突很糟糕，必须要避免。处理冲突的方式很多，最简单的办法如下：如果两个键映射到了同一个位置，就在这个位置存储一个链表。 在这个例子中，apple和avocado映射到了同一个位置，因此在这个位置存储一个链表。在需要查询香蕉的价格时，速度依然很快。但在需要查询苹果的价格时，速度要慢些：你必须在相应的链表中找到apple。如果这个链表很短，也没什么大不了——只需搜索三四个元素。但是，假设你工作的杂货店只销售名称以字母A打头的商品。 等等！除第一个位置外，整个散列表都是空的，而第一个位置包含一个很长的列表！换言之，这个散列表中的所有元素都在这个链表中，这与一开始就将所有元素存储到一个链表中一样糟糕：散列表的速度会很慢。 这里的经验教训有两个。 散列函数很重要 。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。 如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好 ，这些链表就不会很长！ 散列函数很重要，好的散列函数很少导致冲突。那么，如何选择好的散列函数呢？这将在下一节介绍！ 性能本章开头是假设你在杂货店工作。你想打造一个让你能够迅速获悉商品价格的工具，而散列表的速度确实很快。 在平均情况下，散列表执行各种操作的时间都为O (1)。O (1)被称为常量时间 。你以前没有见过常量时间，它并不意味着马上，而是说不管散列表多大，所需的时间都相同。例如，你知道的，简单查找的运行时间为线性时间。 二分查找的速度更快，所需时间为对数时间。 在散列表中查找所花费的时间为常量时间。 一条水平线，看到了吧？这意味着无论散列表包含一个元素还是10亿个元素，从其中获取数据所需的时间都相同。实际上，你以前见过常量时间——从数组中获取一个元素所需的时间就是固定的：不管数组多大，从中获取一个元素所需的时间都是相同的。在平均情况下，散列表的速度确实很快。 在最糟情况下，散列表所有操作的运行时间都为O(n)——线性时间，这真的很慢。我们来将散列表同数组和链表比较一下。 在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。因此，在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有： 较低的填装因子； 良好的散列函数。 说明 接下来的内容并非必读的，我将讨论如何实现散列表，但你根本就不需要这样做。不管你使用的是哪种编程语言，其中都内置了散列表实现。你可使用内置的散列表，并假定其性能良好。下面带你去看看幕后的情况。 填装因子散列表的填装因子很容易计算。 散列表使用数组来存储数据，因此你需要计算数组中被占用的位置数。例如，下述散列表的填装因子为2/5，即0.4。 下面这个散列表的填装因子为多少呢？ 如果你的答案为1/3，那就对了。填装因子度量的是散列表中有多少位置是空的。 假设你要在散列表中存储100种商品的价格，而该散列表包含100个位置。那么在最佳情况下，每个商品都将有自己的位置。 这个散列表的填装因子为1。如果这个散列表只有50个位置呢？填充因子将为2。不可能让每种商品都有自己的位置，因为没有足够的位置！填装因子大于1意味着商品数量超过了数组的位置数。一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度 （resizing）。例如，假设有一个像下面这样相当满的散列表。 你就需要调整它的长度。为此，你首先创建一个更长的新数组：通常将数组增长一倍。 接下来，你需要使用函数hash 将所有的元素都插入到这个新的散列表中。 这个新散列表的填装因子为3/8，比原来低多了！填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。 你可能在想，调整散列表长度的工作需要很长时间！你说得没错，调整长度的开销很大，因此你不会希望频繁地这样做。但平均而言，即便考虑到调整长度所需的时间，散列表操作所需的时间也为O (1)。 良好的散列函数良好的散列函数让数组中的值呈均匀分布。 糟糕的散列函数让值扎堆，导致大量的冲突。 什么样的散列函数是良好的呢？你根本不用操心——天塌下来有高个子顶着。如果你好奇，可研究一下SHA函数（本书最后一章做了简要的介绍）。你可将它用作散列函数。 练习 散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置。 假设你有四个处理字符串的散列函数。 A. 不管输入是什么，都返回1。 B. 将字符串的长度用作索引。 C. 将字符串的第一个字符用作索引。即将所有以a打头的字符串都映射到散列表的同一个位置，以此类推。 D. 将每个字符都映射到一个素数：a = 2，b = 3，c = 5，d = 7，e = 11，等等。对于给定的字符串，这个散列函数将其中每个字符对应的素数相加，再计算结果除以散列表长度的余数。例如，如果散列表的长度为10，字符串为bag ，则索引为(3 + 2 + 17) % 10 = 22 % 10 = 2。 在下面的每个示例中，上述哪个散列函数可实现均匀分布？假设散列表的长度为10。 5.5 将姓名和电话号码分别作为键和值的电话簿，其中联系人姓名为Esther、Ben、Bob和Dan。 5.6 电池尺寸到功率的映射，其中电池尺寸为A、AA、AAA和AAAA。 5.7 书名到作者的映射，其中书名分别为Maus 、Fun Home 和Watchmen 。 小结你几乎根本不用自己去实现散列表，因为你使用的编程语言提供了散列表实现。你可使用Python提供的散列表，并假定能够获得平均情况下的性能：常量时间。 散列表是一种功能强大的数据结构，其操作速度快，还能让你以不同的方式建立数据模型。你可能很快会发现自己经常在使用它。 你可以结合散列函数和数组来创建散列表。 冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。 散列表的查找、插入和删除速度都非常快。 散列表适合用于模拟映射关系。 一旦填装因子超过0.7，就该调整散列表的长度。 散列表可用于缓存数据（例如，在Web服务器上）。 散列表非常适合用于防止重复。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级函数：发挥函数的极限]]></title>
    <url>%2F2019%2F08%2F01%2F%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%EF%BC%9A%E5%8F%91%E6%8C%A5%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Unity的C#知识点之Default的三种常用法实例]]></title>
    <url>%2F2019%2F08%2F01%2FUnity%E7%9A%84C-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8BDefault%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%B3%95%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Unity中的泛型单例的使用]]></title>
    <url>%2F2019%2F08%2F01%2FUnity%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%8D%95%E4%BE%8B%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 通常情况下，在没有泛型单例这个概念之前，我们如果需要使一个形成一个单例，通常情况下就会有以下代码： public class SceneStateManager{ private static SceneStateManager _Instance; //私有化构造器 public static SceneStateManager GetInstance（） //能被类调用并且返回类类型的方法GetInstance（） { if（_Instance == null） { _Instance = new SceneStateManager( ); } return _Instance; } } 然后我们在另外的类中通过SceneStateManager.GetInstance（）就得到了SceneStateManager这样一个类中唯一的对象—对象_Instance。如果是这样，在开发过程中，每次你想生成单例，都需要重复以上代码过程，这样很麻烦。我们引入泛型的概念，写一个抽象类的脚本。当其他的类只要继承这个类，就可以自动形成一个单例。既然这样，我们反过来彻底研究一下泛型以及泛型的具体应用 我们都知道在ArrayList这样的集合中，是对类型Object进行操作的，也就是说任何数据类型被添加到ArrayList中都会变成Object类型，这就是我们之所以能再ArrayList进行任何数据类型添加的原因。如下图： 但是，当我们进行运用的时候会遇到一些问题，如有以下情况： 出现上面的原因是向集合中添加元素之后，string类型会自动提升为object，而Object类型中是没有Length这样的属性的。遇到这样的情况，就需要强制转换了。如下： 但是上面的例子当中如果我们用泛型List就会不一样了 以上我们就是使用泛型，在定义LIst的时候，其中T表示泛型。 常见的集合一般分为泛型集合和非泛型集合。 其中System.Collections命名空间中的集合都是非泛型的，但是S有System.Collections.Generic命名空间中，这个命名空间里面的都是泛型集合。泛型是.Net Framework 2.0后出现的一种类型安全的机制。泛型出现的问题转移到编译时期。避免了装箱拆箱的麻烦。 泛型接口的使用 泛型参数的约束 在定义泛型类时，可以对客户端代码能够在实例化类时用于类型参数的类型种类施加限制。如果客户端代码尝试使用某个约束所不允许的类型来实例化类，则会产生编译时错误。这些限制称为约束。约束是使用 where 上下文关键字指定的。下表列出了六种类型的约束： where T: struct类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型。有关更多信息，请参见使用可以为 null 的类型（C# 编程指南）。where T : class类型参数必须是引用类型；这一点也适用于任何类、接口、委托或数组类型。where T：new()类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new() 约束必须最后指定。where T：&lt;基类名&gt;类型参数必须是指定的基类或派生自指定的基类。where T：&lt;接口名称&gt;类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。where T：U为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数。 到这里，基本的泛型概念和基本运用讲完了，接下来是重点：泛型单例的使用，在这里，我还是采取脚本代码逐条分析的方法进行介绍何为泛型单例： 这样ControlUIManager就可以成为一个单例作者：Rocky man来源：CSDN原文：https://blog.csdn.net/qq_38651460/article/details/79569487版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unity3D内存优化（一）对象池]]></title>
    <url>%2F2019%2F08%2F01%2FUnity3D%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%AF%B9%E8%B1%A1%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 一、定义： 关于U3D内存优化，一直是游戏开发者头疼的事情，由于在项目中我们会频繁地创建和销毁一些对象，例如：怪物模型或者是UI预设体，但是，部分对象在游戏中是会频繁出现的，例如战斗中的小怪物，假如每次都在使用的时候创建新对象，使用完毕后又直接销毁，这样对于游戏的内存消耗是很巨大的。 设想一下，我们是否能做一个池子，将一些常用的对象在创建之后放入池中，每次使用都直接从池子中查找获取，这样在提高对象利用率降低重复创建对象时的内存消耗的同时，对于性能提高有很大的帮助，这样的池子就是我们所要说的——对象池。 对象池——就是将对象存储在一个池子中，当需要时再次使用，而不是每次都实例化一个新的对象。 二、使用对象池有几个注意点： 1.虽然对象池可以优化对象利用率，但是对象池也不能无限地存储对象，这样对于内存占用也是急剧增加，应该通过限制池子上限，并通过统计获取使用频率较低的对象并剔除，从而动态地收缩对象池； 2.对于重复使用的对象，在对象池中应该处理好对象重置（reset）的操作； 3.假如在多个线程中同时访问统一对象池，要处理好线程安全的问题。 三、实践： 关于对象池的内存优化，我们可以参考内存池的设计模式：内存池设计与实现 具体如何设计对象池，我们可以通过从AssetStore获取成熟的插件，例如： PoolManager,具体使用方法：Unity3D研究院之初探PoolManager插件（七十四） 当然我们也可以设计自己的对象池框架：Unity3D内存管理——对象池(Object Pool) 具体步骤： 1.将插件.unitypackage包导入工程中； 2.在Hierachy中新建一个Empty对象，选中该Empty对象，然后选择菜单栏的Component—&gt;Path-o-logical—&gt;Pool Manager—&gt;Spawn Pool： 3.完成上述步骤后，在Empty对象下会绑定一个Spawn Pool组件，接下来我们就需要进行基本的信息设置： 同一个对象池可以存放不同预设体，每个预设体我们都可以为其创建一个类型栏，同一预设体创建出来的对象归属于同一栏。 4.Spawn中各个属性的作用： PoolName：缓存池的唯一名称。 MatchPoolScale：勾选后实例化的游戏对象的缩放比例将全是1，不勾选择用Prefab默认的。 MachPool Layer：勾选后实例化的游戏对象的Layer将用Prefab默认的。 Don’t Reparent：勾选后实例化的对象将没有父节点，通通在最上层，建议不要勾选。 Don’t Destroy On Load：这个就不用我解释了吧？切换场景不释放。 Log Messages： 是否打印日志信息 Pre-Prefab Pool Options ：缓存池列表，意思就是缓存列表里面可以放各种类型的Prefab。右边有个 “+”按钮点击就添加每个类型的Prefab了 prefab：可以直接把工程里的Prefab直接拖进来。 preloadAmount:缓存池这个Prefab的预加载数量。意思为一开始加载的数量！ preloadTime：如果勾选表示缓存池所有的gameobject可以“异步”加载。 preloadFrames：每几帧加载一个。 preloadDelay：延迟多久开始加载。 limitInstance：是否开启对象实例化的限制功能。 limit Amount：限制实例化Prefab的数量，也就是限制缓冲池的数量，它和上面的preloadAmount是有冲突的，如果同时开启则以limitAmout为准。 limitFIFO：如果我们限制了缓存池里面只能有10个Prefab，如果不勾选它，那么你拿第11个的时候就会返回null。如果勾选它在取第11个的时候他会返回给你前10个里最不常用的那个。 cullDespawend：是否开启缓存池智能自动清理模式。 cull Above：缓存池自动清理，但是始终保留几个对象不清理。 cull Delay：每过多久执行一遍自动清理，单位是秒。从上一次清理过后开始计时 cullMaxPerPass：每次自动清理几个游戏对象。 自动清理：就是当池子里面的对象setActive(false)也就是目前不用的时候，poolManager会根据上述参数自动清理这些对象，清理也就是Destroy()掉。 active变为true或false是由Spawn和Despawn方法决定的！ limitInstance是否开启（打钩）的区别： 不开启情况：假如此时preloadAmount为1，如果用户想要每隔5秒去Spawn一个缓冲池中的对象，那么当加载第二个prefab对象的时候，缓冲池会再创建一个此对象，如果程序再Spawn，那么还会在产生一个这样的对象，就这样一直产生下去，Spawn几次就产生几个对象！ （粒子系统：循环时：Spawn几次，就会产生几个对象，不循环时（循环结束状态为false）：会再产生一个对象，如果此时的Spawn速度特别快，并且检测不到前面的对象状态为false，那么可能会产生多个对象，直到检测到前面的几个对象有false状态，那么产生对象到此为止，程序在此几个对象之间来回Spawn！） 开启情况： 此时Limit Amount为1 limitFIFO勾选：那么程序永远使用的是预加载对象，而不会再产生其他对象！当加载第二次的时候，即使第一个对象处于true状态，也使用它，即操作第一个对象！（粒子系统为循环或者不循环时，效果和这一样） limitFIFO不勾选：那么程序永远使用的是预加载对象，而不会再产生其他对象！当加载第二次的时候，那么必须等第一个对象变为false状态，才能使用它！如果过了5s，第一个对象还没变为false状态，那么程序会报错！（粒子系统为循环：会循环下去，只有一个预加载对象，不报错，不循环时：等上一个变为false才能进行第二次，只有一个预加载对象，不报错！） 如果limit Amount数量大于1，为10的话 limitFIFO勾选：永远只有10个对象产生，当加载第11个对象时，如果前十个对象没有一个active为false状态，那么程序会选择不常用的那个，从而避免报错！ limitFIFO不勾选：永远只有10个对象产生，但是当加载第11个对象时，如果前十个对象没有一个active为false状态，那么程序会报错！ （粒子系统，永远只有10个对象，不报错！） 5.设置完以上参数之后，我们开始在代码中进行对象添加到对象池和从对象池中取出对象的操作： a. 获取对象池：123private SpawnPool mActors_Pool;mActors_Pool = PoolManager.Pools["ActorsAndBullets"]; b.获取对象池中对象的方法：12Transform bulletPrefab = mActors_Pool.prefabs["Bullet"];Transform bullet = mActors_Pool.Spawn(bulletPrefab); c.销毁对象池中对象的方法：1mActors_Pool.Despawn(bullet); d.全部销毁的方法:1mActors_Pool.DespawnAll();]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之树形结构]]></title>
    <url>%2F2019%2F08%2F01%2F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： C#实现的树形结构。树的遍历使用的先序遍历，两个类，一个是节点结构，一个是管理节点的树。采用链式存储。直接上代码。 123456789101112131415161718192021222324252627using UnityEngine;using System.Collections;using System.Collections.Generic;/// &lt;summary&gt;/// 文件夹树目录的节点基类,这应该写成接口的，类似树节点已经集成其他基类的结构可以实现这个接口，便于ListTree类对节点实现多态/// &lt;/summary&gt;public class ListTreeNode &lt;T&gt; &#123; public ListTreeNode &lt;T&gt; parent; //父节点 public List&lt;ListTreeNode &lt;T&gt;&gt; children; //子节点集合 public T data; //存放信息 public ListTreeNode () &#123; &#125; public ListTreeNode (T data) &#123; this.data = data; this.children = new List&lt;ListTreeNode&lt;T&gt;&gt;(); &#125; public ListTreeNode (T data, List &lt;ListTreeNode &lt;T&gt;&gt; list) &#123; this.data = data; this.children = list; &#125; public ListTreeNode (T data, List &lt;ListTreeNode &lt;T&gt;&gt; list, ListTreeNode &lt;T&gt; parent) &#123; this.data = data; this.children = list; this.parent = parent; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161using UnityEngine;using System.Collections;using System.Collections.Generic;/// &lt;summary&gt;/// 存放ListTreeNode的容器基类，对于节点的操作节点一定要从树中取得，我没有封装在一起，这写的不好/// &lt;/summary&gt;public class ListTree &lt;T&gt; &#123; #region 变量 private ListTreeNode &lt;T&gt; mRoot; //树的头节点 #endregion #region 属性 public ListTreeNode &lt;T&gt; Root &#123; get &#123; return mRoot; &#125; set &#123; mRoot = value; &#125; &#125; #endregion #region 构造方法 public ListTree () &#123; &#125; public ListTree (ListTreeNode &lt;T&gt; root) &#123; mRoot = root; &#125; #endregion #region 方法 //判断树是否为空 public bool IsEmpty () &#123; return null == mRoot ? true : false; &#125; //获取节点，使用树的非递归先序遍历 public ListTreeNode &lt;T&gt; GetNode (T nodeData) &#123; if (null == mRoot) &#123; return null; &#125; ListTreeNode &lt;T&gt; temp = null; Stack &lt;ListTreeNode &lt;T&gt;&gt; stack = new Stack&lt;ListTreeNode &lt;T&gt;&gt; (); stack.Push (mRoot); while (stack.Count != 0) &#123; temp = stack.Pop (); if (nodeData.Equals (temp.data)) &#123; return temp; &#125; for (int i = temp.children.Count - 1; i &gt;= 0; i--) &#123; stack.Push (temp.children [i]); &#125; &#125; return null; &#125; //获取节点的路径信息集合 public List&lt;T&gt; GetNodeDataArray(ListTreeNode &lt;T&gt; node) &#123; List&lt;T&gt; list = new List&lt;T&gt;(); Stack&lt;T&gt; stack = new Stack&lt;T&gt;(); while (node.parent != null) &#123; stack.Push(node.data); node = node.parent; &#125; stack.Push(mRoot.data); while (stack.Count != 0) &#123; list.Add(stack.Pop ()); &#125; return list; &#125; //获取节点路径上的所有节点集合 public List&lt;ListTreeNode&lt;T&gt;&gt; GetNodeArray(ListTreeNode &lt;T&gt; node) &#123; List&lt;ListTreeNode&lt;T&gt;&gt; list = new List&lt;ListTreeNode&lt;T&gt;&gt;(); Stack&lt;ListTreeNode &lt;T&gt;&gt; stack = new Stack&lt;ListTreeNode&lt;T&gt;&gt;(); while (node.parent != null) &#123; stack.Push(node); node = node.parent; &#125; stack.Push(mRoot); while (stack.Count != 0) &#123; list.Add(stack.Pop()); &#125; return list; &#125; //判断一个节点是否存在 public bool HaveNode (T nodeData) &#123; ListTreeNode &lt;T&gt; temp = null; Stack &lt;ListTreeNode &lt;T&gt;&gt; stack = new Stack&lt;ListTreeNode &lt;T&gt;&gt; (); stack.Push (mRoot); while (stack.Count != 0) &#123; temp = stack.Pop (); if (nodeData.Equals (temp.data)) &#123; return true; &#125; for (int i = temp.children.Count - 1; i &gt;= 0; i--) &#123; stack.Push (temp.children [i]); &#125; &#125; return false; &#125; //插入节点，注意节点要通过GetNode方法从树中获取(用于插入一层结构) public bool InsertNode (ListTreeNode &lt;T&gt; parent, T nodeData) &#123; if (null == parent) &#123; return false; &#125; ListTreeNode &lt;T&gt; node = new ListTreeNode&lt;T&gt; (nodeData); node.children = parent.children; node.parent = parent; parent.children.Add (node); return true; &#125; //删除节点，注意节点要通过GetNode方法从树中获取 public bool DeleteNode (ListTreeNode &lt;T&gt; parent, T nodeData) &#123; if (null == parent) &#123; return false;; &#125; for (int i = 0; i &lt; parent.children.Count; i++) &#123; if (nodeData.Equals (parent.children [i].data)) &#123; parent.children.RemoveAt (i); &#125; &#125; return true; &#125; //添加叶子节点。注意节点要通过GetNode方法从树中获取，若返回值为假说明传入的父亲节点是空或者该父节点下的孩子节点存在此信息的节点 public bool AddLeave (ListTreeNode &lt;T&gt; parent, T nodeData) &#123; if (null == parent) &#123; return false; &#125; for (int i = 0; i &lt; parent.children.Count; i++) &#123; if (parent.children [i].data.Equals (nodeData)) &#123; return false; &#125; &#125; ListTreeNode &lt;T&gt; node = new ListTreeNode&lt;T&gt; (nodeData); parent.children.Add (node); return true; &#125; //添加叶子节点，并可回调该叶子节点 public bool AddLeave(ListTreeNode&lt;T&gt; parent, T nodeData, out ListTreeNode &lt;T&gt; node) &#123; node = new ListTreeNode&lt;T&gt;(nodeData); if (null == parent) &#123; return false; &#125; for (int i = 0; i &lt; parent.children.Count; i++) &#123; if (parent.children[i].data.Equals(nodeData)) &#123; node = parent.children[i]; return false; &#125; &#125; parent.children.Add(node); node.parent = parent; return true; &#125; //判断一个节点是否为叶子节点，注意节点要通过GetNode方法从树中获取 public bool IsLeave (ListTreeNode &lt;T&gt; node) &#123; return node.children.Count == 0 ? true : false; &#125; #endregion&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序的递归和非递归实现]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 对于一个游戏爱好者和游戏开发者，数据结构和算法显得极为重要，这些可以体现一个开发者的逻辑能力。而作为一个游戏开发小白，要争取每天一个算法，游戏之路漫漫而其修远兮，吾将上下而求索。 这次写个快排的递归非递归算法，小白一个，有误之处多多见谅。废话不多说直接上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System.Collections.Generic;/// &lt;summary&gt;/// QuickSort/// 主要思路，不停找中间数并将数组一分为二，分治法思想，时间复杂度为n*logn/// 递归比非递归的效率高，以这个数组为例大约快6倍，原因在于递归算法只有一个pivot的变量，栈很小/// &lt;/summary&gt;namespace test&#123; class MainClass &#123; public static void Main (string[] args) &#123; int [] arr = new int[] &#123;3, 1, 5, 6, 8, 2, 4, 11, 0&#125;; long t1 = DateTime.Now.Ticks; QuickSortRecursion (0, arr.Length - 1, arr); //QuickSortWithoutRecursion (0, arr.Length - 1, arr); long t2 = DateTime.Now.Ticks; //输出 foreach (int i in arr) &#123; Console.WriteLine (i); &#125; Console.WriteLine ("DelaTime : " + (t2 - t1)); &#125; //分治法分开的部分的算法 private static int Partition (int low, int high, int [] arr) &#123; int left = low; int right = high; int pivot = arr [low]; //用于对比的关键点 //实现比pivot大的数放后面，比pivot小的数放前面，复杂度为n while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr [right] &gt;= pivot) &#123; right--; &#125; arr [left] = arr [right]; //比pivot大的数扔前面 while (left &lt; right &amp;&amp; arr [left] &lt;= pivot) &#123; left++; &#125; arr [right] = arr [left]; //pivot小的数扔后面 &#125; arr [left] = pivot; //对关键点移动后的索引位置赋值 return left; //此时左右标志位索引一致，返回任一即可 &#125; //快速排序调用递归的方法 private static void QuickSortRecursion (int low, int high, int [] arr) &#123; int pivot; if (low &lt; high) &#123; pivot = Partition (low, high, arr); //获取新的关键点的索引位置 QuickSortRecursion (low, pivot - 1, arr); QuickSortRecursion (pivot + 1, high, arr); &#125; &#125; //非递归快速排序,使用栈的思路，将每次需要 private static void QuickSortWithoutRecursion (int low, int high, int [] arr) &#123; Stack &lt;int&gt; stack = new Stack&lt;int&gt; (); stack.Push (low); //现在栈中放入数组的首尾位置 stack.Push (high); while (stack.Count != 0) &#123; //当栈为空，说明所有元素已经遍历完，数组已经排好 int q = stack.Pop (); int p = stack.Pop (); int pivot = Partition (p, q, arr); //每次从栈中取出一对首尾值并获取此部分数组的关键值 if (p &lt; pivot - 1) &#123; stack.Push (p); stack.Push (pivot - 1); &#125; if (pivot + 1 &lt; q) &#123; //两个判断表示当关键值符合大于首小于尾的条件时将其 stack.Push (pivot + 1); //和首尾放入栈以便下次排序 stack.Push (q); &#125; &#125; &#125; &#125;&#125; 最后给下两种算法运行分别所消耗的时间：递归算法：10001，非递归算法：60003，可见递归算法效率高于非递归算法，原因应该是递归算法中只有一个pivot的变量，所占栈的内存很小。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unity之对象池（单例对象池和泛型对象池）]]></title>
    <url>%2F2019%2F08%2F01%2FUnity%E4%B9%8B%E5%AF%B9%E8%B1%A1%E6%B1%A0%EF%BC%88%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%92%8C%E6%B3%9B%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%B1%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： https://blog.csdn.net/u012614432/article/details/49097315 众所周知，游戏开发中内存和性能一直是影响用户游戏体验的至关重要的两个因素，这次说一说对象池的概念。 对象池意义是将游戏中反复创建销毁的对象进行多次利用，从而避免大量对象的销毁与创建而造成CPU的负担。缺点是占用了更多的内存，但凡事都没有最好的解决办法，在移动平台上针对游戏的优化基本偏向于牺牲空间换取时间，所以以下两种对象池从本质上是为了回收对象服务的，废话不多说，直接上代码。 using UnityEngine;using System.Collections;using System;using System.Collections.Generic;/// /// 泛型非单例池，代码简洁，通用性广泛/// public class MyPool where T : class { private Action mReset; //重置对象的委托 private Func mNew; //创建新对象的委托 private Stack stack; //存放对象的池子，用List等动态数组也可以，推荐泛型数组 public MyPool (Func mNew, Action mReset = null) { this.mNew = mNew; this.mReset = mReset; stack = new Stack (); } //从池子中获取对象的方法，思路是若池子的数量为0，则调用创建新对象委托创建一个对象返回 //否则从池子中拿出一个对象并返回 public T New () { if (stack.Count == 0) { T t = mNew (); return t; } else { T t = stack.Pop (); if (mReset != null) mReset (t); return t; } } //此方法用于将销毁的对象存入池子 public void Store (T t) { stack.Push (t); } //清空池子 public void Clear () { stack.Clear (); }} 此处推荐一个链接，这个对象池的写法很大程度参照这篇文章的，是一位代码节俭主义牛人写的非常好的文章。点击打开链接 而他的使用方式如下： using UnityEngine;using System.Collections;/// /// 使用池子的测试类/// public class Test : MonoBehaviour { public GameObject ballet; //子弹的预设体，在unity引擎中引用 private MyPool pool; void Start () { pool = new MyPool (NewBallet, Reset); } //实例化新子弹的方法 private GameObject NewBallet () { GameObject g = Instantiate (ballet) as GameObject; //实例化新子弹，实例化过程中需要设置子弹的位置等初始化操作写在这 return g; } //重置对象的方法， private void Reset (GameObject g) { g.transform.position = Vector3.zero; g.transform.rotation = Quaternion.identity; g.SetActive (true); //从池子中取后将物体设为可见，也可用其他方法代替 //...... } //销毁对象的方法 private void Destroy (GameObject g) { g.SetActive (false); //放入池子前将物体设为不可见 pool.Store (g); }}对于使用池子的类我只是写了最基本的应用，推荐将池子放在一个对象类型的控制类中。至于方法里的扩展根据各位看官的项目内容而定。 using UnityEngine;using System.Collections;using System.Collections.Generic;using System;/// /// 单例对象池，思路是为每种GameObject建立一个新的池子，并给他/// 一个字符串存在字典中。/// public class SinglePool { #region 单例，此处使类继承MonoBehavior并写成继承MonoBehavior的单例也可以 private static SinglePool instance = null; private SinglePool () { } public static SinglePool GetInstance () { if (instance == null) { instance = new SinglePool (); } return instance; } #endregion #region 变量 private Dictionary &lt;string, List &gt; poolDic; //存放池子的字典，池子用泛型List private Action mReset; //重置对象的委托 private Func mNew; //创建新对象的委托 #endregion #region 方法 //可以让字典存放Object而不是GameObject，适用性更广 //从对应字符串池子中取出对象的方法 public GameObject New (string str, Func mNew, Action mReset = null) { if (poolDic.ContainsKey (str)) { //如果字典存在该字符串，取出该池子 if (poolDic [str].Count &gt; 0) { //如果池子里有对象则取出一个对象并返回 GameObject g = poolDic [str] [0]; poolDic [str].Remove (g); if (mReset != null) mReset (g); return g; } else { //如果池子没有对象则返回一个创建的新对象 return mNew (); } } else { //如果字典不存在该字符串则新创建一个池子，并返回一个创建的新对象 poolDic.Add (str, new List ()); return mNew (); } } //销毁的对象存入池子的方法 public void Store (string str, GameObject g) { if (poolDic.ContainsKey (str)) { poolDic [str].Add (g); } } //销毁对象池的方法 public void DestroyPool (string str) { if (poolDic.ContainsKey (str)) { poolDic.Remove (str); } } #endregion }单例池子的使用方式我就不写了，和上面大同小异，只需多传一个池子对应的string值存在字典即可。晚上继续第二天的一天一算法~]]></content>
  </entry>
  <entry>
    <title><![CDATA[第11章-泛型]]></title>
    <url>%2F2019%2F08%2F01%2F%E7%AC%AC11%E7%AB%A0-%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 泛型可以促进算法的重用怎么理解？ 为什么可以使用Stack类型的集合来实现多次撤销（undo）操作？ 本章涵盖： 如果C#没有泛型 泛型类型概述 约束 泛型方法 随着项目日趋复杂，需要用更好的方式重用和定制现有软件。C#通过泛型来促进代码重用，尤其是算法的重用。方法因为能获取参数而强大；类似地，类型和方法也会因为能获取类型参数而变得强大。 泛型在词义上等价于Java中的泛型类型和C++中的模板。在这三种语言中，该功能都使算法和模式只需实现一次，而不必为每个类型都实现一次。然而，与Java中的泛型和C++中的模板相比，C#中的泛型在实现细节和对类型系统的影响方面差异甚大。 注意，泛型是自C#2.0起引入才添加到“运行时”和C#中的。 如果C#没有泛型开始讨论泛型之前，先看看一个没有使用泛型的类。这个类是System.Collections.Stack，用于表示一个对象集合，使加入集合的最后一项是从集合中获取的第一项（称为后进先出或LIFO）。Push()和Pop()是Stack类的两个主要方法，分别用于在栈中添加和移除数据项。代码清单1展示了Stack类的Pop()和Push()方法的声明。 代码清单1 System.Collections.Stack类的方法签名 12345public class Stack&#123; public virtual object Pop() &#123; ..&#125; public virtual void Push(object obj) &#123;...&#125;&#125; 程序经常使用Stack类型的集合来实现多次撤销（undo）操作。例如，代码清单2利用Stack类在像素绘画游戏程序中执行撤销操作。 代码清单2的结果如输出1所示。 输出1 代码清单2 在类似像素绘画游戏的程序中模拟撤销操作 12 path是声明为System.Collections.Stack的一个变量。为了利用path来保存上一次移动，只需使用path.Push(currentPosition)方法，将一个自定义类型Cell传入Stack.Push()方法。如果用户输入Z（或者Ctrl+Z），表明需要撤销上一次移动。为此，程序使用一个Pop()方法获取上一次移动，将光标位置设为上一个位置，然后调用Undo()。虽然代码能够正常工作，但System.Collections.Stack类存在重大缺陷。如代码清单1所示，Stack类收集object类型的变量。由于CLR的每个对象都从object派生，所以Stack无法验证放到其中的元素是不是希望的类型。例如，传递的可能不是currentPosition而是string。在这个string中，X和Y坐标通过小数点拼接到一起。不过，编译器必须允许不一致的数据类型。因为Stack类被设计成获取任意对象，其中包括较具体类型的对象。 此外，使用Pop()方法从栈中获取数据时，必须将返回值转型为Cell。但是，假如Pop()返回的不是Ce1l，就会引发异常。通过强制类型转换将类型检查推迟到运行时进行（程序运行起来才检查，编辑的时候编辑器不会提示错误），程序变得更加脆弱。在不用泛型的情况下创建支持多种数据类型的类，根本的问题在于它们必须支持一个公共基类（或接口），通常是object。 为使用object的方法使用struct或整数这样的值类型，问题会变得更糟。将值类型的实例传给Stack.Push()方法，“运行时”将自动对它进行装箱。类似地，获取值类型的实例时需要显式对数据进行拆箱，将从Pop()获取的object引用转型为值类型。引用类型转换为基类或接口对性能的影响可忽略不计，但值类型装箱的开销较大，因为必须分配内存、复制值以及进行垃圾回收。 C#鼓励“类型安全”。许多类型错误（比如将整数赋值给string变量）能在编译时捕捉到。目前的根本问题是Stack类不是类型安全的。为了修改Stack类来确保类型安全，强迫它存储特定的数据类型，在不使用泛型的前提下，只能创建一个特殊的Stack类，如代码清单3所示。 代码清单3 定义特殊Stack类 123456public class CellStack()&#123; public virtual Cell Pop(); public virtual void Push(Cell cell); // ...&#125; 由于CellStack只能存储Cell类型的对象，所以这个解决方案要求对栈的各个方法进行自定义的实现，所以并不是理想的解决方案。例如，为了实现类型安全的整数栈，就需要另一个自定义实现。每一个实现看起来都差不多。最终将产生大量重复的、冗余的代码。 初学者主题：另一个例子——可空值类型 在声明值类型的变量时，可以使用可空修饰符?声明允许包含null值的变量。C#从2.0开始支持这个功能，它需要泛型才能正确实现。在引入泛型之前，程序员主要有两个选择。 第一个选择是为需要处理null值的每个值类型都声明可空数据类型，如代码清单4所示。 代码清单4 为各个值类型声明可以存储null的版本 12 代码清单4只显示了NullableInt和NullableGuid的实现。如果程序需要更多的可空值类型，就不得不创建更多的结构，并修改属性来使用所需的值类型。如果可空值类型的实现发生了改变（例如，为了支持一个用户定义的从基础类型向可空类型的隐式转换），就不得不修改所有可空类型声明。 第二个选择是声明可空类型，在其中包含object类型的Value属性，如代码清单5所示。 代码清单5 声明可空类型，其中包含object类型的Value属性 12 虽然这个方案只需可空类型的一个实现，但“运行时”在设置Value属性时总是对值类型进行装箱。此外，从Value属性获取基础值需要进行一次强制类型转换，而这个操作在运行时可能无效。 以上两种方案都不理想。为了解决这个问题，C#2.0引入了泛型的概念。事实上，可空类型是作为泛型类型Nullable实现的。 泛型类型概述可利用泛型创建一个数据结构，该数据结构能进行特化以处理特定的类型。程序员定义这种参数化类型，使泛型类型的每个变量都具有相同的内部算法，但数据类型和方法签名可随类型参数而变。 为了减轻开发者的学习负担，C#的设计者选择了与C++模板相似的语法。所以， C#中的泛型类和结构要求使用尖括号声明泛型类型参数以及指定泛型类型实参。 泛型类的使用代码清单6展示了如何指定泛型类使用的实际类型。为了指示path变量使用Cell类型，在实例化和声明语句中都要用尖括号表示法指定Cell。换言之，使用泛型数据类型声明变量（本例是path）时， C#要求指定泛型类型使用的类型实参。代码清单6展示了新的泛型Stack类。 代码清单6 使用泛型Stack类实现撤销 12 代码清单6的结果如输出2所示 输出2 代码清单6中将path声明为System.Collections.Generic.Stack类的变量，并用新实例初始化它。尖括号中指定栈中的元素类型为Cell。结果是添加到path以及从path取回的每个对象都是Cell类型。所以，不再需要对path.Pop()的返回值进行转型，也不需要在Push()方法中确保只有Cell类型的对象才能添加到path中。 简单泛型类的定义泛型允许开发人员把精力放在创建算法和模式上，并确保代码能由不同数据类型重用。代码清单7创建了泛型Stack&lt;T&gt;类，它与代码清单6使用的System.Collections.Generic.Stack&lt;T&gt;类相似。在类名之后，需要在一对尖括号中指定类型参数（本例是T）。然后，可以向泛型Stack提供类型实参，它将“替换”类中出现的每个T。这样，栈就可以存储指定的任何类型的数据项，不需要重复代码，也不需要将数据项转换成object。在代码清单7中可以看到将类型参数T用于内部Items数组、Push()方法的参数类型以及Pop()方法的返回类型。 代码清单7 声明泛型类Stack&lt;T&gt; 12 泛型的优点使用泛型类而不是非泛型版本（比如使用System.Collections.Generic.Stack&lt;T&gt;类而不是原始的System.Collections.Stack类型）有以下几个方面的优点。 (1)泛型促进了类型安全。它确保在参数化的类中，只有成员明确希望的数据类型才可使用。在代码清单7中，参数化栈类限制为Stack&lt;Cell&gt;的所有实例使用Cell数据类型。例如，执行path.Push(“garbage”)会造成编译时错误，指出没有System.Collections.Generic.Stacks&lt;T&gt;.Push(T)方法的哪一个重载版本可以处理字符串“garbage”，因为它不能被转换成Cell。 (2)编译时类型检查减小了在运行时发生InvalidCastException异常的几率。 (3)为泛型类成员使用值类型，不再造成到object的装箱转换。例如，path.Pop()和path.Push()不需要在添加一个项时装箱，或者在删除一个项时拆箱。 (4)C#泛型缓解了代码膨胀的情况。泛型类型保持了具体类版本的优势，但没有具体类版本的开销（例如，没有必要定义像CellStack这样的一个类）。 (5)性能得到了提高。一个原因是不再需要从object的强制类型转换，从而避免了类型检查。另一个原因是不再需要为值类型执行装箱。 (6)泛型减小了内存消耗。由于避免了装箱，因此减少了堆上的内存的消耗。 (7)代码的可读性更好。一个原因是转型检查次数变少了。另一个原因是现在需要较少的类型特定的实现。 (8)支持IntelliSense的代码编辑器现在能直接处理来自泛型类的返回参数。没有必要为了使IntelliSense工作起来，而对返回数据执行转型。 最核心的是，泛型允许写代码来实现模式，并在以后出现这种模式的时候重用那个实现。模式描述了在代码中反复出现的问题，而泛型类型为这些反复出现的模式提供了单一的实现。 类型参数命名规范和方法参数的命名相似，类型参数的命名应该尽量具有描述性。除此之外，为了强调它是类型参数，名称应包含T前缀。例如，在定义诸如EntityCollection&lt;TEntity&gt;的类时，使用的类型参数名称是TEntity。 唯一不需要使用描述性类型参数名称的时候是描述没有意义的时候。例如，在Stack&lt;T&gt;中使用T就够了，因为以说明问题——适合任意类型。 之后会介绍约束。使用约束描述类型名称是一种良好的编程习惯。例如，假定类型参数必须实现IComponent，则类型名称可以是“TComponent”。 规范要为类型参数选择有意义的名称，并为名称附加“T”前缀。考虑在类型名称中指明约束。 泛型接口和结构C#支持在语言中全面地使用泛型，其中包括接口和结构。语法和类的语法完全相同。要声明包含类型参数的接口，将类型参数放到接口名称后面的一对尖括号中即可，比如代码清单8中的IPair&lt;T&gt;。 代码清单8声明泛型接口 12345interface IPair&lt;T&gt;&#123; T First &#123;get; set; &#125; T Second &#123;get; set; &#125;&#125; 该接口代表一对相似对象，比如一个点的平面坐标、一个人的生身父母，或者一个二叉树的节点，等等。pair中的两个数据项具有相同类型。 实现接口的语法与非泛型类的语法相同。注意，一个泛型的类型实参可以成为另一个泛型类型的类型参数。这既合法又普遍，如代码清单9所示。接口的类型实参是类声明的类型参数。除此之外，这个例子使用了结构而不是类，表明C#支持自定义的泛型值类型。 代码清单9 实现泛型接口 12 对泛型接口的支持对于集合类尤其重要。使用泛型最多的地方就是集合类。假如没有泛型，开发者就要依赖于System.Collections命名空间中的一系列接口。和它们的实现类一样，这些接口只能使用object类型，因此，此接口要求进出这些集合类的所有访问都要执行转型。使用类型安全的泛型接口，就可以避免执行转型。 高级主题：在类中多次实现同一个接口 相同泛型接口的不同构造被看成是不同的类型，所以类或结构能多次实现“同一”泛型接口。来看看代码清单10的例子。 代码清单10 在类中重复一个接口实现 12 在这个例子中，Items属性通过显式的接口实现多次出现，每次类型参数都有所不同。没有泛型这是不可能的。在没有泛型的情况下，编译器只允许一个显式的IContainer.Items属性。 然而，像这样实现“同一个”接口的多个版本不是好的编码风格，因为它会造成混淆（尤其是在接口允许协变或逆变转换的情况下）此外，Person类的设计似乎也有问题，因为一般不会认为人是“能提供一组电子邮件地址”的东西。与其实现同一个接口的三个版本，不如实现3个属性：EmailAddresses、PhoneNumbers和MailingAddresses，每个属性都返回泛型接口的相应构造。 规范避免在类型中实现同一个泛型接口的多个构造。 构造器和终结器的定义令人惊讶的是，泛型类或结构的构造器（和终结器）不要求类型参数。换言之，不要求写成Pairs&lt;T&gt;(){…}这样的形式。在代码清单11的数对例子中，构造器声明为public Pair(T first, T second)。 代码清单11 声明泛型类型的构造器 12 默认值的指定在代码清单11中，构造器获取First和Second的初始值，并把它们赋给_First和_Second。由于Pairs&lt;T&gt;是结构，因此提供的任何构造器都必须对全部字段进行初始化。但这会带来一个问题。假定有一个Pairs&lt;T&gt;的构造器，它在实例化的时候，只对数对（pair）的一半进行初始化。 如代码清单12所示，定义这样的构造器会造成编译错误，因为在构造结束的时候，字段_Second仍然处于未初始化的状态。对_Second进行初始化有一个问题，因为不知道T的数据类型。如果是引用类型，那么可以使用null来初始化。然而，假如是非空值类型，使用null进行初始化就行不通了。 代码清单12 不初始化所有字段，造成编译错误 12 为了应对这样的局面，C#提供了default操作符，这个操作符最早是在讨论的。可以使用default(int)指定int的默认值。对于T，可以使用default(T)来初始化Second，如代码清单13所示。 代码清单13 用default操作符初始化字段 12 default操作符可提供任意类型的默认值，包括类型参数。 多个类型参数泛型类型可以使用任意数量的类型参数。在前面的Pairs&lt;T&gt;例子中，只包含一个类型参数。为了存储不同类型的两个对象，比如一个“名称/值”对，可以创建类型的新版本来声明两个类型参数，如代码清单14所示。 代码清单14 使用多个类型参数声明泛型 12 小结从C# 2.0开始引入的泛型类型和泛型方法从根本上改变了C#开发人员的编码风格。在C# 1.0代码中，凡是使用了object的地方，在C# 2.0和更高的版本中都最好用泛型来代替。至少，集合问题应考虑用泛型来解决。避免转型对类型安全性的提升、避免装箱对性能的促进以及重复代码的减少为泛型赋予了无穷的魅力。 第16章将讨论最常用的泛型命名空间之一System.Collections.Generic。该命名空间几乎完全由泛型类型构成。它清晰地演示了如何将最初使用object的类型转换为使用泛型。但在深入接触这些主题之前，我们先来探讨一下Lambda表达式。作为C# 3.0（和以后版本）最引人注目的一项增强，它极大地改进了操作集合的方式。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#本质论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity核心类与脚本生命周期]]></title>
    <url>%2F2019%2F08%2F01%2FUnity%E6%A0%B8%E5%BF%83%E7%B1%BB%E4%B8%8E%E8%84%9A%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 概述 GameObject核心类 Transform核心类 Time核心类 MonoBehaviour核心类 Unity脚本生命周期 Unity伪多线程揭秘 Unity重要应用类 Unity输入管理器 本章练习与总结 案例开发任务 概述在开发任何项目前如果感觉有一定技术难度,应该先要想到去查询Unity的“类库”,查询Unity是否对于此类问题提供了较好的解决方案,否则开发就会陷入“事倍功半”的低效开发怪圈中。 GameObject核心类CameObject类重要字段与方法如表1所示。 表1 GameObject类重要字段与方法 属性与方法含义字段:rigidbodyrendererLayeractionSelltag附属于这个游戏物体上的刚体(只读)附属于这个游戏物体上的渲染器(只读)游戏物体所在的层,一个层的范围是在0~32之间表示特定对象是否为激活与禁用状态游戏物体的标签实例方法:* AddComponent()AddComponent &lt;T&gt;* GetComponent().GetComponent &lt;‘T&gt;静态方法:CreatePrimitive()Find()FindCameObjectsWithTag( )增加组件方法增加制定类型的组件方法获得组件方法获得指定类型的组件方法,创建原始类型游戏对象查找游戏对象,游戏对象标签查找(返回多个游戏对象) 属性与方法静态方法 FindWithTag( )Set Active().继承的静态方法:Destroy()Destroylmmediate()DontDestroyOnload().Instantiate()游戏对象标签查找(返回单个游戏对象)设置激活状态销毁游戏对象立即销毁物体obj,建议使用Destroy代替加载新场景的时候使目标物体不被自动销毁,克隆游戏对象@温馨提示:表14.1中带星号的部分是7.3节中已经讲过的部分(下面的表格同理)。 14.3 Transform該u类Transform类重要字段与方法如表14.2所示。表14.2 Transform类重要字段与方法 属性与方社含义字段: positionlocealPosition* eulerAngleslocalEulerAngles* localScalelocalRotation位置相对父级的变换位置rightupforward实例方法:欧拉角旋转,作为欧拉角度,相对父级的变换旋转角度相对于父级物体变换的缩放物体变换的旋转角度,相对父级物体变换的旋转角度在世界空间坐标变换的红色轴,也就是X轴在世界空间坐标变换的绿色轴,也就是Y轴在世界空间坐标变换的蓝色轴,也就是Z轴Rotate() RotateAround().Translate( )LookAl()TransformDirection()InverseT’ransform Direction( )TransformPoint()旋转游戏对象环绕旋转游戏对象使游戏对象位移旋转物体,向前向量指向target的当前位置从自身坐标到世界坐标变换方向变换方向从世界坐标到自身坐标与Transform. TransformDirection相反变换位置从自身坐标到世界坐标 属性与方法含义实例方法:InverseTransformlPoint()DetachChildren()IsChildorc变换位置从世界坐标到自身坐标与Transform. TransformPoint相反所有子物体解除父子关系,这个变换是父级的子物体吗继承的方法:CompareTag()SendMessage ()Brosadeast Message ()SendMessagelipwards()Getllnstancell( )游戏物体有被标记标签吗数据传值技术中的常用技术,(注: 13.2节有详细讲解)向下广播(注: 13.3节有详细讲解)1上广播(注: 13.3节有详细讲解)返回物体的实例ID 4Time蔽u类Time类重要字段如表14.3所示。表14.3 Time类重要字段属性与方法含义字段: deltaTime间隔时间timetineScalerealtimeSinceStartup从游戏开始到现在所用的时间(只读)传递时间的缩放,这可用于减慢运动效果游戏中常用于“暂停游戏”的场合处理以秒计,自游戏开始的实时时间(只读,不被timeScale所影响 14.5MonoBehaviour該山类MonoBehaviour类重要字段与方法如表14.4所示。表14.4 MonoBehaviour类重要字段与方法属性与方法含义实例方法:* Invoke()调用函数]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D/2D游戏开发从0到1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程与调用函数]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%8D%8F%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖：]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D/2D游戏开发从0到1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[射线]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%B0%84%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是射线？射线技术应用在哪？ 射线的基本原理是什么？ Vector3.ClampMagnitude是干嘛用的？ 开发一个发射子弹击中墙壁的功能。 开发一个点击后走到目标点的功能。 本章涵盖： 射线概述 项目示例讲解 本章练习与总结]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D/2D游戏开发从0到1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#习题]]></title>
    <url>%2F2019%2F07%2F30%2FC-%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一些习题 3个可乐瓶可以换一瓶可乐，现在有364瓶可乐。问一共可以喝多少瓶可乐，剩下几个空瓶！ 思路：当可饮用的可乐 数量大于等于3的时候，每喝3瓶可乐（3个空瓶换得一瓶可乐），可饮用的可乐数量减少2 1234567891011int kola = 364;int count = 0;//喝的次数while (kola&gt;=3)&#123; kola -= 2;//喝三瓶换一瓶 count += 3;//记录喝的总数&#125;count = count + kola;//加上跳出循环后没有喝的可乐Console.WriteLine("一共可以喝&#123;0&#125;瓶可乐，剩下&#123;1&#125;个空瓶！",count,kola); 运行结果 1一共可以喝545瓶可乐，剩下2个空瓶！]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解类]]></title>
    <url>%2F2019%2F07%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 类的成员都有哪些？ 一个类的多个实例的成员数据在内存中是怎么存储的？ 静态成员的数据是怎么存储的？ 本章涵盖： 类成员 成员修饰符的顺序 实例类成员 静态字段 静态函数成员 其他静态类成员类型 成员常量 常量和静态 属性 实例构造函数 静态构造函数 对象初始化语句 析构函数 readonly修饰符 this关键字 索引 访问器的访问修饰符 分部类和分部类型 分部方法 类成员之前的两章阐述了9种类成员类型中的两种：字段和方法。在这一章中，我会介绍除事件和运算符之外的类型的类成员，并讨论其特征。 表1列出了类的成员类型。已经介绍过的类型用菱形标记。将在本章阐述的类型用勾号标记。将在以后的章节中阐述的类型用空的选择框标记。 表1 类成员的类型 成员修饰符的顺序在前面的内容中，你看到字段和方法的声明可以包括如public和private这样的修饰符。这一章会讨论许多其他的修饰符。多个修饰符可以在一起使用，自然就产生一个问题：它们需要按什么顺序排列呢？ 类成员声明语句由下列部分组成：核心声明、一组可选的修饰符和一组可选的特性（attribute），用于描述这个结构的语法如下。方括号表示方括号内的成分是可选的。 1[特性] [修饰符] 核心声明 修饰符 如果有修饰符，必须放在核心声明之前。 如果有多个修饰符，可以是任意顺序。 特性 如果有特性，必须放在修饰符和核心声明之前。 如果有多个特性，可以是任意顺序。 例如，public和static都是修饰符，可以用在一起修饰某个声明。因为它们都是修饰符，所以可以放置成任何顺序。下面两行代码是语义等价的: 12public static int MaxVal;static public int MaxVal; 图1阐明了声明中各成分的顺序，到目前为止，它们可用于两种成员类型：字段和方法。注意，字段的类型和方法的返回类型不是修饰符——它们是核心声明的一部分。 图1 类成员的类型 实例类成员类成员可以关联到类的一个实例，也可以关联到类的整体，即所有类的实例。默认情况下，成员被关联到一个实例。可以认为是类的每个实例拥有自己的各个类成员的副本，这些成员称为实例成员。 改变一个实例字段的值不会影响任何其他实例中成员的值。迄今为止，你所看到的字段和方法都是实例字段和实例方法。 例如，下面的代码声明了一个类D，它带有唯一整型字段Mem1， Main创建了该类的两个实例，每个实例都有自己的字段Mem1的副本，改变一个实例的字段副本的值不影响其他实例的副本的值。图6-2阐明了类D的两个实例。 1234567891011121314151617class D&#123; public int Mem1;&#125;class Program&#123; static void Main() &#123; D d1 = new D(); D d2 = new D(); d1.Meml = 10; d2.Mem1 = 28; Console.WriteLine("d1 = &#123;0&#125;, d2 = &#123;1&#125;", d1.Mem1, d2.Mem1); &#125;&#125; 这段代码产生如下输出： 1d1 = 10, d2 = 28 图2 类D的每个实例都有自己的字段Mem1的副本 静态字段除了实例字段，类还可以拥有静态字段。 静态字段被类的所有实例共享，所有实例都访问同一内存位置。因此，如果该内存位置的值被一个实例改变了，这种改变对所有的实例都可见。 可以使用static修饰符将字段声明为静态，如:12345678910111213141516class D&#123; int Mem1; // 实例字段 static int Mem2; // 静态字段 // ↑ 关键字&#125;class Program&#123; static void Main() &#123; D d1 = new D(); D d2 = new D(); ... &#125;&#125; 例如，图3左边的代码声明了类D，它含有静态字段Mem2和实例字段Mem1，Main定义了类D的两个实例。该图表明静态成员Mem2是与所有实例的存储分开保存的。实例中灰色的字段表明，从实例内部，访问或更新静态字段的语法和访问或更新其他成员字段一样。 因为Mem2是静态的，类D的两个实例共享单一的Mem2字段。如果Mem2被改变了，这个改变在两个实例中都能看到。 成员Mem1没有声明为static，所以每个实例都有自己的副本。 图3 静态和非静态数据成员 从类的外部访问静态成员在前一章中，我们看到使用点运算符可以从类的外部访问public实例成员。点运算符由实例名、点和成员名组成。 就像实例成员，静态成员也可以使用点运算符从类的外部访问。但因为没有实例，所以必须使用类名，如下面代码所示： 1D.Mem2 = 5; // 访问静态成员 ## 静态成员的生存期静态成员的生命期与实例成员的不同。 之前我们已经看到了，只有在实例创建之后才产生实例成员，在实例销毁之后实例成员也就不存在了。 但是即使类没有实例，也存在静态成员，并且可以访问。 图4阐述了类D，它带有一个静态字段Mem2。虽然Main没有定义类的任何实例，但它把值5赋给该静态字段并毫无问题地把它打印出来。 图4 没有类实例的静态成员仍然可以被赋值并读取，因为字段与类有关，而与实例无关 图4中的代码产生以下输出： 1Mem2 = 5 说明静态成员即使没有类的实例也存在。如果静态字段有初始化语句，那么会在使用该类的任何静态成员之前初始化该字段，但没必要在程序执行的开始就初始化。 静态函数成员除了静态字段，还有静态函数成员。 如同静态字段，静态函数成员独立于任何类实例。即使没有类的实例，仍然可以调用静态方法。 静态函数成员不能访问实例成员。然而，它们能访问其他静态成员。 例如，下面的类包含一个静态字段和一个静态方法。注意，静态方法的方法体访问静态字段，]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#图解教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Awake()和Start()有什么区别？Awake物体，Start脚本怎么理解？ FixedUpdate什么时候使用？怎么设置？ Start()和Update是有关系的怎么理解？ 融合术在于实现动画的自然过渡怎么理解？ 帧数：一秒内Update被调用的次数。性能高的电脑帧数大（例如60），性能低的电脑帧数小（30）。 Time.deltaTime 上一帧所消耗的时间，避免机器性能的影响。 Time.deltaTime也对每个电脑是不同的。Speed * Time.deltaTime只要保证一秒内移动相同的距离就可以。因为帧FPS是以秒为单位的。 坦克按住移动 1234567891011121314151617181920212223242526272829303132333435using UnityEngine;using System.Collections;public class Tank : MonoBehaviour &#123; public float speed = 2.5f; // Use this for initialization void Start () &#123; &#125; // Update is called once per frame void Update () &#123; if (Input.GetKey(KeyCode.W)) &#123; transform.Translate(new Vector3(0, 0, speed) * Time.deltaTime); &#125; if (Input.GetKey(KeyCode.S)) &#123; transform.Translate(new Vector3(0, 0, -speed) * Time.deltaTime); &#125; if (Input.GetKey(KeyCode.A)) &#123; transform.Rotate(new Vector3(0, 1, 0), -angleSpeed * Time.deltaTime); //transform.Translate(new Vector3(-speed, 0, 0) * Time.deltaTime); &#125; if (Input.GetKey(KeyCode.D)) &#123; transform.Rotate(new Vector3(0, 1, 0), angleSpeed * Time.deltaTime); // transform.Translate(new Vector3(speed, 0, 0) * Time.deltaTime); &#125; &#125;&#125; 有如下方法： 1this.transform.position += new Vector3(0, 0, 5); 但基本不用这种方法移动。使用TransLate。 轴Vector3表示轴的时候是没有大小的 1transform.Rotate(new Vector3(0, 1, 0), angleSpeed * Time.deltaTime); 原型如下： 123456789101112[ExcludeFromDocs]public void Rotate(Vector3 axis, float angle);//// 摘要: // Applies a rotation of eulerAngles.z degrees around the z axis, eulerAngles.x// degrees around the x axis, and eulerAngles.y degrees around the y axis (in// that order).//// 参数: // eulerAngles://// relativeTo: 此时写成100也不影响： 1transform.Rotate(new Vector3(0, 100, 0), angleSpeed * Time.deltaTime); 而如果想要用向量表示角度，需要Rotate的另一个重载方法，原型如下： 123456789101112[ExcludeFromDocs]public void Rotate(Vector3 eulerAngles);//// 摘要: // Rotates the transform around axis by angle degrees.//// 参数: // axis://// angle://// relativeTo: 1transform.Rotate(new Vector3(0, angleSpeed * Time.deltaTime, 0)); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Input.GetAxis 获取轴的数据 轴 水平轴 垂直轴float h = Input.GetAxis("Horizontal");float v = Input.GetAxis("Vertical");Vector3.forward = new Vector3(0,0,1);TransLate参数为1个时的含义//// 摘要: // Moves the transform in the direction（方向） and distance（距离） of translation.//// 参数: // translation://// relativeTo:// 这个距离和方向说的很对，因为向量就是表示的速度和方向。[ExcludeFromDocs]public void Translate(Vector3 translation);// 下面两个等价// 距离 = 速度 * 时间// new Vector3(0, 0, v * speed)是速度// Time.deltaTimes是时间// 向量的乘法this.transform.Translate(new Vector3(0, 0, v * speed) * Time.deltaTime);this.transform.Translate(Vector3.forward * v * speed * Time.deltaTime);// 两个参数的Rotate说明如下//// 摘要: // Rotates the transform around axis by angle degrees.//// 参数: // axis://// angle://// relativeTo:[ExcludeFromDocs]public void Rotate(Vector3 axis, float angle);//第一个参数明明白白说了是轴this.transform.Rotate(new Vector3(0, 1, 0), h * angleSpeed * Time.deltaTime);// 一个参数的说明如下//// 摘要: // Applies a rotation of eulerAngles.z degrees around the z axis, eulerAngles.x// degrees around the x axis, and eulerAngles.y degrees around the y axis (in// that order).//// 参数: // eulerAngles://// relativeTo:[ExcludeFromDocs]public void Rotate(Vector3 eulerAngles);唯一的参数指的是欧拉角，此时向量可以进行加减乘除。所以也可以这样旋转：Vector3.up = new Vector3(0,1,0);this.transform.Rotate(Vector3.up * h * angleSpeed * Time.deltaTime);Vactor3表示axis的时候，不需要乘以任何东西。就是一个轴，表示方向。Vector3(0,1,0)和Vector3(0,100,0)是一样的。上面的内容其实很重要，因为Vector3向量的各种概念很重要。 12345678910111213141516171819202122232425262728//Input GetKey GetKeyDown GetKeyUpif (Input.GetKeyDown("f")) //按下了指定键的那一刻返回一次true值&#123; Debug.Log("按下了f键");&#125;//参数 字符串必须要小写的if (Input.GetKey("f")) //按住指定键的时候，每一帧都会返回一次true值&#123; Debug.Log("按住了f键");&#125;if (Input.GetKeyUp("f")) //松开指定键的那一刻返回一次true值&#123; Debug.Log("松开了f键");&#125;if (Input.GetMouseButtonDown(0))&#123; Debug.Log("按下了左键");&#125;//参数 0代表左键，1代表右键if (Input.GetMouseButton(0))&#123; Debug.Log("按住了左键");&#125;if (Input.GetMouseButtonUp(0))&#123; Debug.Log("松开了左键");&#125; 天空盒两种方式1、是给摄像机单独添加天空盒。直接给摄像机添加一个“Skybox”组件。然后放置材质。2、是给整体添加一个天空盒。3步：①新建一个天空盒材质。②给天空盒材质添加天空盒。③把材质赋给环境中的材质。 相同点：①新建一个天空盒材质。②给天空盒材质添加天空盒。 不同点：赋材质的地点不同 天空盒图片又分：（1）Cubemap（2）六面 层次（Hierarchy）视图和项目（Project）视图Hierarchy里的都是游戏对象，Create出来的也是游戏对象。Project里的都是资源，物理资源，在电脑里可以打开的。 把Hierarchy里的东西拖进Project里，是序列化（持久化）的过程，是把对象变成物理存储。把Project里的东西拖进Hierarchy，是把物理资源变成游戏对象，是反序列化。 摄像机两个摄像机的深度值。大的显式。 小地图：两个摄像机的深度一样。调整另一个的Viewport Rect。 脚本脚本生命周期 OnEnable()在Awake()和Start()中间执行 Awake()物体初始化的时候被调用，这儿有个关键词，“物体”，不管脚本组件是否被选中。因为脚本组件绑不绑定都不影响物体的初始化。物体没选中的时候（没激活）不会调用，因为物体没有初始化进入内存。 初始化是加载到内存里。 Start()：Update()函数运行之前调用。脚本进入内存才启动Strat()。Start()和Update是有关系的。脚本选中激活后才会调用。这边也有个关键词：“脚本”。运行的过程中再次不选，选中脚本只会触发OnEnable()和OnDisable()，不会再触发Start()了。可知此时不选中时，脚本还是在内存里的，所以无需再次执行Start()。只有OnDestroy()才从内存里移除。 就像一个游戏对象绑定了很多组件，但是只有选中的组件，才会进入内存，不然都没选中，即不使用这些组件，那进入内存干什么？ OnDestroy()：从内存中移除。 多个脚本的执行顺序根据附加在GameObject上的顺序执行 这个所有脚本是一个对象上的所有脚本，还是所有对象上的所有脚本？ 所有对象上的所有脚本 所有对象上的所有脚本的Awake()执行完后才执行Start()所有对象上的所有脚本的Start()执行完后才执行Update()所有对象上的所有脚本的Start()执行完后才执行LateUpdate() 查找123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using UnityEngine;using System.Collections;//场景里面所有的物体都是GameObjectpublic class SearchObj : MonoBehaviour &#123; //1、查找物体的第一种方式（通过定义一个公有的GameObject变量，在属性面板里面把对应的物体拖拽上去），尽量少用 //public GameObject cube; //2、通过代码来查找（一般都是用这种方式） //-1、GameObject.Find("所要查找的物体的名称");或者GameObject.Find("查找路径") //只能查找显示中的物体，查找不到隐藏的物体 //属于全局查找，注意不要去频繁调用，会耗费很大的性能 //注意，如果场景里面有多个同名物体，那么就只能查找到一个 //-2、通过标签来查找（ 只能查找显示中的物体，查找不到隐藏的物体） //GameObject.FindGameObjectWithTag("所要查找的物体标签的名称");或者 GameObject.FindWithTag("所要查找的物体标签的名称"); //属于全局查找，注意不要去频繁调用，会耗费很大的性能 //注意，如果场景里面有多个同标签名物体，那么就只能查找到一个 //如何查找多个物体？？？ //GameObject.FindGameObjectsWithTag("所要查找物体的标签");，返回的是一个数组 //3.如何查找隐藏的物体？？？ //transform.FindChild("所要查找的物体的名称")或者transform.Find("所要查找的物体的名称")，支持路径查找transform.Find("查找路径") //既能查找显示的物体，也能查找隐藏的物体 //注意，只能查找子物体(缺点) private GameObject cube; private GameObject shpere; void Start () &#123; //cube = GameObject.Find("Cube"); //cube.GetComponent&lt;Renderer&gt;().material.color = Color.red; ////shpere = GameObject.Find("Sphere"); //shpere = GameObject.Find("Cube/Sphere"); //shpere.GetComponent&lt;Renderer&gt;().material.color = Color.red; //GameObject myCube = GameObject.FindWithTag("MyObj"); ////GameObject myCube= GameObject.FindGameObjectWithTag("MyObj"); //myCube.GetComponent&lt;Renderer&gt;().material.color = Color.yellow; //查找多个物体（通过标签） //GameObject[] arr= GameObject.FindGameObjectsWithTag("MyTag"); //for (int i = 0; i &lt; arr.Length; i++) //&#123; // arr[i].GetComponent&lt;Renderer&gt;().material.color = Color.green; //&#125; //查找隐藏的物体 GameObject myCapsule = this.transform.FindChild("MyCapsule").gameObject; myCapsule.GetComponent&lt;Renderer&gt;().material.color = Color.black; &#125;&#125; 拖曳的缺点：1、后期不好维护2、版本控制会丢失。 Find的缺点1、不显示的物体找不到2、全局查找，耗费性能 1234567891011121314151617181920private GameObject cube;private GameObject[] spheres;private GameObject cylinder;// Use this for initializationvoid Start () &#123; cube = GameObject.Find("Cube"); cube.GetComponent&lt;Renderer&gt;().material.color = Color.red; //sphere = GameObject.FindGameObjectWithTag("ball1"); spheres = GameObject.FindGameObjectsWithTag("ball1"); for (int i = 0; i &lt; spheres.Length; i++) &#123; spheres[i].GetComponent&lt;Renderer&gt;().material.color = Color.blue; &#125; cylinder = this.transform.FindChild("Cylinder").gameObject; cylinder.GetComponent&lt;Renderer&gt;().material.color = Color.yellow;&#125; 下面这句很重要： 1cylinder = this.transform.FindChild("Cylinder").gameObject; 因为 1The game object this component is attached to. A component is always attached to a game object. 即可以根据组件寻找到对象 1组件.gameObject 即可得到绑定此组件的对象 unity中查找游戏物体是很寻常的操作，有较多的方法，如下： unity中提供了获取对象的方法： 通过对象名称（Find方法）GameObject.Find 通过标签获取单个游戏对象（FindWithTag方法） 通过标签获取多个游戏对象（FindGameObjectsWithTags方法） 通过类型获取单个游戏对象（FindObjectOfType方法） 通过类型获取多个游戏对象（FindObjectsOfType方法） Find方法： static GameObject Find (string name) 传入的name可以是单个的对象的名字，也可以是hierarchy中的一个路径名，如果找到会返回该对象(活动的)，如果找不到就返回null。 注：无论传值是名字或则路径名，只有对象存在就能返回该对象。建议传具体的路径名，以防有多个相同名字的对象的情况。且当有多个相同名字的对象的时候，返回为查找到的第一个对象。另不建议在每一帧都执行的函数（如update，fixupdate…）中调用该函数， 可以在Start这种函数中定义变量获取返回值，在其他函数中使用。 注： 1.使用对象名的情况：可查找带不带脚本，不查找隐藏（隐藏为active=false)的物体对象，返回的不一定是要查找的对象（有多个名相同物体的情况下） 2.使用目录结构：可查找带不带脚本，能查隐藏，可以确定是要找的对象 注：如果路径查找中的任何一个父节点active=false，这个对象都将查找不到 对比： transform.Find() 1.对象名 只能查当前对象下一级子目录的对象，也基本确定，可查找隐藏对象，根节点需可见 2.目录结构 可查找带不带脚本对象，可以查隐藏物体，可以确定是要找的对象 脚本示例： 1 GameObject.Find(“GameObject”); 2 GameObject.Find(“GameObject/ChildGameObject); 总:使用目录结构进行查找较通过名字查询缩短了查询时间和范围，也更能确定对象，缺点是一旦路径或结构调整后，容易影响到程序。方便使用，但效率低下。 FindWithTag方法： static GameObject FindWithTag (string tag) 返回一个用tag做标识的活动的对象，如果没有找到则为null。 tag设置：在hierarchy中选择对象，右侧的Inspector面板上面的选择Tag（可添加自定义：利用下拉列表中的AddTag创建） FindGameObjectsWithTag方法： static GameObject[] FindGameObjectsWithTag (string tag) 返回一个用tag做标识的活动的游戏物体的列表，如果没有找到则为null。 FindObjectOfType方法： static Object FindObjectOfType(Type type) 返回类型为type的活动的第一个游戏对象 FindObjectsOfType方法： static Object FindObjectsOfType(Type type) 返回类型为type的所有的活动的游戏对象列表 注意：一定保证对象是active的才会找到 效率问题，建议在初始函数中进行初始化 对比： Transform.Find 1.可以查找隐藏对象 2.支持路径查找 3.查找隐藏对象的前提是transform所在的根节点必须可见，即active=true Resources.FindObjectsOfTypeAll 返回指定类型的对象列表。主要用于编辑器中，eg。检测内存泄露、批量查找的功能等 GameObject.Find(“a”); // 相对路径查找 GameObject.Find(“/a”); // 绝对路径查找 即使隐藏root节点gameObject也能进行查找: GetComponentsInChildren( typeof(Transform), true ); GetComponent(true); Resources1234567891011121314151617181920212223242526using UnityEngine;using System.Collections;//注意//并不是所有的资源都能放到Resources文件夹下面//因为打包项目的时候，会把Resources文件夹里面所有的资源全部打包进去//如果不需要动态加载的资源不要放在Resources文件夹下面，会增大包体的大小//放在Resources文件夹下面的资源，打包的时候都会被压缩并且加密public class TestLoad : MonoBehaviour &#123; //private GameObject myCube; private GameObject wall; void Start () &#123; //// myCube = Resources.Load("Cube") as GameObject; // myCube = Resources.Load&lt;GameObject&gt;("Cube"); // Instantiate(myCube); wall = Resources.Load&lt;GameObject&gt;("Wall"); for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; GameObject go=Instantiate(wall); go.transform.position = new Vector3(i,j+1,0); &#125; &#125; &#125;&#125; 打开项目能看见Assets文件夹的路径打开，尽量不要点击场景打开。 脚本挂载真正的开发中，除了游戏初始化脚本，脚本基本都是动态挂载的，不是最开始手动挂上去的。 添加组件：AddComponent&lt;脚本名&gt; 只要不是放在Editor下面就OK。获取组件：GetComponent&lt;脚本名&gt; 没有直接的移除组件的API，要先获取再Destroy()。 碰撞体Is Kinematic 取消物理效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748```csusing UnityEngine;using System.Collections;//碰撞的条件（需要同时满足一下条件）//1、两个物体都必须有碰撞体//2、两个物体都有刚体，或者至少有一个物体有刚体//一般情况下，都是有刚体的去碰撞没刚体的，或者两个都有刚体的相互碰撞//碰撞检测//触发检测public class TestCollider : MonoBehaviour&#123; //碰撞检测 //检测碰撞进入 void OnCollisionEnter(Collision other)//other就是碰撞到的物体 &#123; Debug.Log("碰撞进入"+other.gameObject.name); &#125; //检测碰撞停留// 只有至少一个物体在移动时才会一直触发// 如果两个物体都静止则不会触发 void OnCollisionStay(Collision other) &#123; Debug.Log("碰撞停留" + other.gameObject.name); &#125; //检测碰撞退出 void OnCollisionExit(Collision other) &#123; Debug.Log("碰撞退出" + other.gameObject.name); &#125; //触发检测(记得把该物体上面的碰撞体的IsTrigger勾选) //检测触发进入 void OnTriggerEnter(Collider other) &#123; Debug.Log("触发进入"+other.name); &#125; //检测触发停留 void OnTriggerStay(Collider other) &#123; Debug.Log("触发停留" + other.name); &#125; //检测触发退出 void OnTriggerExit(Collider other) &#123; Debug.Log("触发退出" + other.name); &#125;&#125; 坦克大战12345678910111213141516171819202122232425262728293031323334353637using UnityEngine;using System.Collections;public class BulletCtrl : MonoBehaviour &#123; private Rigidbody rd; private float speed = 10; private GameObject effect; void Start() &#123; rd = this.GetComponent&lt;Rigidbody&gt;(); Destroy(this.gameObject,3f); &#125; //一般对刚体进行操作（进行物理运算）都要放在FixedUpdate里面，固定时间调用 void FixedUpdate() &#123; //Vector3.forward是世界坐标的正方向（方向是不会改变的） // rd.AddForce(Vector3.forward); //子弹自身的正方向（跟随子弹变化的） rd.AddForce(this.transform.forward * speed); &#125; void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag=="Enemy") &#123; //effect = Resources.Load&lt;GameObject&gt;("Effect"); ////播放特效 //Instantiate(effect, other.transform.position,Quaternion.identity); PlayEffectMgr.PlayEffect("Effect", other.transform.position); //销毁物体 Destroy(other.gameObject); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using UnityEngine;using System.Collections;public class TankCtrl : MonoBehaviour&#123; //移动速度 private float moveSpeed = 30; //旋转速度 private float rotateSpeed = 200; //子弹的预制体 private GameObject bulletPrefab; //子弹生成的位置 public Transform bulletStartPs; void Start() &#123; bulletPrefab = Resources.Load&lt;GameObject&gt;("Bullet"); bulletStartPs = this.transform.FindChild("BulletStartPs"); &#125; void Update() &#123; Move(); Shoot(); &#125; //射击 private void Shoot() &#123; if (Input.GetMouseButtonDown(0)) &#123; //Debug.Log("发射子弹"); GameObject bullet = Instantiate(bulletPrefab, bulletStartPs.position, bulletStartPs.rotation) as GameObject; if (bullet.GetComponent&lt;BulletCtrl&gt;()==null) &#123; bullet.AddComponent&lt;BulletCtrl&gt;(); &#125; &#125; &#125; //控制移动和转向 private void Move() &#123; //水平方向的输入（-1~1） float inputHorizontal = Input.GetAxis("Horizontal"); //垂直方向的输入（-1~1） float inputVertical = Input.GetAxis("Vertical"); //控制坦克前后移动（Vector3.forward指坦克的正方向，Z轴方法） this.transform.Translate(Vector3.forward * inputVertical * moveSpeed * Time.deltaTime); //控制坦克转向 this.transform.Rotate(Vector3.up * inputHorizontal * rotateSpeed * Time.deltaTime); &#125;&#125; 12345678910111213141516171819202122using UnityEngine;using System.Collections;using System.Collections.Generic;//播放特效的管理类public class PlayEffectMgr : MonoBehaviour&#123; //缓存特效的字典&lt;特效名称，特效的预制体&gt; private static Dictionary&lt;string, GameObject&gt; dicEffect = new Dictionary&lt;string, GameObject&gt;(); public static void PlayEffect(string effectName,Vector3 ps) &#123; //判断将要播放的这个特效有没有缓存在字典里面 if (!dicEffect.ContainsKey(effectName)) &#123; //如果没有，就去加载，加载完以后，就缓存到字典里 GameObject effect = Resources.Load&lt;GameObject&gt;(effectName); dicEffect.Add(effectName, effect); &#125; Instantiate(dicEffect[effectName], ps, Quaternion.identity); &#125; &#125; 优化1GameObject effect = Resources.Load&lt;GameObject&gt;("Effect"); 电脑上的资源变成了游戏对象这个过程只要做一次。就在最开始的时候，所有Resources.Load只执行一次，然后把游戏对象存储进内存里。 把数据放进堆里面。 UGUIanchor 锚点presets 预调；预置Rect TransformAnchor Presets锚点在左上角，缩小放大的时候和锚点（左上角）保持固定距离。4个白色三角形不一定在一起。 压缩图片www.tinypng.com 包体很大时从图片入手。 UGUI打包图集 UGUI不需要亲自去管理图集的打包 什么时候需要手动去打包？ Draw Call和SetPass Calls是一个东西 一个Canvas只占一个Draw Call。 直接把图片拉到场景里，会产生一个Draw Call，但复制时不会新增。（做2D游戏时经常这样直接拖进来，3D基本都使用UI系统的Canvas。） 自己也会有一个，所以10张图片有11个SetPass Calls。 如何打包？ Window-&gt;Sprite Packer 动画bool 循环播放 走路trigger 一次性的动作 阻尼就是阻止物体继续运动 动画状态机可以很灵活地进行动画的复用，也就是说实现人物的换装系统？ “融合术”技术，可以实现不同状态下动画剪辑的自然过渡，使得游戏画面更具真实感。 动画是在模型里的，动画和模型的图标是不一样的。 自身坐标Inspector显示的是自身坐标。自身坐标没有父物体毫无意义。 Inspector的Rotation指的是eulerAngles。 移动肯定是在世界坐标中移动。无论什么坐标都要转成世界坐标才能正确移动。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[预加载与对象缓冲池技术]]></title>
    <url>%2F2019%2F07%2F29%2F%E9%A2%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%BC%93%E5%86%B2%E6%B1%A0%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是对象缓冲池技术？是为了解决什么问题？ 怎么使用缓冲池技术？ 本章涵盖： 简单对象缓冲池技术 高级对象缓冲池技术 对象缓冲池技术是游戏开发领域的一个高级知识点，它的出现主要解决游戏开发过程中由于大量游戏道具的生成与销毁而造成系统瓶颈的问题。关于游戏项目中的性能优化策略，我们使用了整整一章项目研发常用优化策略进行详细的讨论与论述，而本章所要讨论的问题其实就是Unity引擎中针对脚本性能优化而推荐的优秀解决方案。 预加载是整个对象缓冲池技术的实现原理与实现前提，本章使用两个优秀的示例，具体讲解两类对象缓冲池的实现原理与使用方法。 概述对象缓冲池技术不是Unity所专用的技术，它来自软件开发中对于数据库的优化方案，从“数据库连接缓冲池”经过改造与变化而来。由于在做CS/BS软件开发的过程中，我们写的软件系统都一定要与数据库打交道，而频繁地访问数据库又是一件非常消耗数据库资源的问题（数据库服务器能同时被“连接”访问的次数是有限的，而且系统申请连接数据库也是比较耗费时间的）。所以软件开发领域出现了“数据库连接缓冲池”技术，也就是系统中首先提前建立一个数据库连接访问“池”（本质就是一个“集合”，如List&lt;&gt;），“池”中预先存放了一定数量的连接数据库的实例，当我们在需要使用数据库连接的时候，首先查看“池”中是否有现成的“连接实例”，如果有，直接从“池”中获取即可，避免了反复申请连接与断连接等费事操作，大大提高了系统效率。 游戏开发项目中存在相同的问题，而且或许更加突出与严峻。我们的游戏项目如果要开发的“高大上”，则必然需要使用大量的“次时代”游戏道具与大量的游戏粒子特效等。但是大量的游戏道具与粒子系统的出现，必然会导致频繁的创建、克隆、销毁游戏对象，这就很大程度地消耗了大量的CPU资源，使得游戏出现明显的“卡顿”现象。 后来，聪明的游戏研发人员就考虑是否把需要销毁的游戏对象进行“隐藏”，也就是可以使用脚本“GameObject.SetActive(false)”禁用游戏对象，当我们再次需要使用此游戏对象的时候则进行启用即可（使用GameObjet.SetActive(true)），这就形成了一个优化的基本观点，使用“隐藏”代替“销毁”. 再后来，我们就考虑是否在真正的游戏场景开始之前就把需要用到的大量游戏对象与粒子系统等提前加载到一个“池”中，然后需要的时候再直接从“池”中取得，避免使用的时候进行大量“克隆”操作，影响系统效率，造成游戏操作过程中的“卡顿”现象。于是这就形成了“预加载”的概念。 把以上两种方式（“禁用”、“启用”脚本与“预加载”）结合起来，形成了我们今天要研究的“对象缓冲池”的基本原理。 简单对象缓冲池技术如图1所示，我们使用一个“射击木箱靶墙”的小场景，结合一个最简单的对象缓冲池脚本，演示与说明简单对象缓冲池的具体实现原理和基本应用方法。 首先我们研究与解释一个最简单的对象缓冲池脚本，如代码清单1所示。 代码清单1 ObjectPoolManager.cs 1234567891011121314151617181920212223242526272829303132/* * * Title:学习“对象缓冲池”管理 * * 对象缓冲池管理器 * * Description: * 基本原理： * 通过池管理思路，在游戏初始化的时候，生成一个初始的池，存放我们要复用的元素 * 当要用到游戏对象时，从池中取出；不再需要的时候，不直接删除对象，而是把对象重新回收到“池”中 * 这样就避免了对内存中大量对象的反复实例化与回收垃圾处理，提高了资源的利用率 * * Author: * * Date: * Version: * Modify Record: */using UnityEngine;using System.Collections;using System.Collections.Generic;public class ObjectPoolManager : MonoBehaviour &#123; public GameObject ObjPrefab; // 池中所使用的元素预设 public Transform TranObjPrefabParent; // 池中所使用的元素预设的父对象 public int InitialCapacity; // Capacity 容积，池 初始容量 private int _startCapacityIndex; // 初始下标 private List&lt;int&gt; _avaliableIndex; // 可用“池"游戏对象下标 private Dictionary&lt;int, GameObject&gt; _totalObjList; // 池中全部元素的容器&#125; 从ObjectPoolManager.cs脚本的头注释中可以清楚地查看到本脚本的基本原理说明：在游戏初始化的时候，生成一个初始的“池”，存放我们要复用的元素。当要用到游戏对象时，从池中取出。不再需要的时候不直接删除对象，而是把对象重新回收到“池”中，这样避免了对内存中大量对象的反复实例化与回收垃圾处理，提高了资源利用率。 脚本字段定义中比较重要的是“_totalObjList”，它是实际存储“池”元素的容器集合，而“_avaliableIndex”则是记录当前“池”中所有可以使用的“池”元素下标数值。 代码清单2 1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 初始化缓冲池/// &lt;/summary&gt;void Awake()&#123; _avaliableIndex = new List&lt;int&gt;(InitialCapacity); _totalObjList = new Dictionary&lt;int, GameObject&gt;(InitialCapacity); // 初始化池 expandPool();&#125;/// &lt;summary&gt;/// 取得游戏对象/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public KeyValuePair&lt;int, GameObject&gt; PickObj()&#123; // 容量不够，进行“池”扩展 if (_avaliableIndex.Count == 0) expandPool(); // 取得一个可用的池下标数值 int id = _avaliableIndex[0]; // “可用池下标”集合，删除对应下标 _avaliableIndex.Remove(id); // 设置“池”对象可用 _totalObjList[id].SetActive(true); // 从“池”中提取一个对象返回 return new KeyValuePair&lt;int, GameObject&gt;(id, _totalObjList[id]);&#125; 代码清单2中定义的Awake()事件函数的作用是初始化“池”容器集合和初始化“池”，即expandPool()方法实例化指定数量的被禁用的“游戏对象预设”，提前放入集合中。代码清单2中的PickObj()方法是从“池”中取得一个可用的游戏对象（预设）。其原理如代码清单2中的26行代码所示，把指定id序列号的游戏对象预设“激活”（使用“SetActive(true)”）。 代码清单3 1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt;/// 回收游戏对象/// &lt;/summary&gt;public void RecyleObj(int id)&#123; // 设置对应对象不可用（即：放回池操作） _totalObjList[id].SetActive(false); // 指定Id的游戏对象下标，重新进入可用“池”下标集合中 _avaliableIndex.Add(id);&#125;/// &lt;summary&gt;/// 扩展池/// &lt;/summary&gt;private void expandPool()&#123; int start = _startCapacityIndex; int end = _startCapacityIndex + InitialCapacity; for (int i = 0; i &lt; end; i++) &#123; // 加入验证判断，避免在多个请求同时触发扩展池需求 if (_totalObjList.ContainsKey(i)) continue; GameObject newObj = Instantiate(ObjPrefab) as GameObject; // 生成的池对象增加父对象，容易查看与检查 newObj.transform.parent = TranObjPrefabParent.transform; // 每一个生成的对象，设置暂时不可用 newObj.SetActive(false); // 下标记入“池”可用下标集合中 _avaliableIndex.Add(i); // 新产生的对象，并入本池容器集合中 _totalObjList.Add(i, newObj); &#125; // 扩展“初始下标” _startCapacityIndex = end;&#125; 代码清单3中的RecyleObj()方法回收指定id序列号的游戏对象重新回到“池”中，本质就是代码清单3中的第7行代码所示的，把指定序列号的游戏对象预设重新禁用。14-35行代码是expandPool()扩展池方法，其目的是当游戏刚开始或者“池”中的元素不够使用的时候，扩展容器类中元素的数量。23行代码使用Instantiate()方法通过复制“原型预设”（即变量“ObjPrefab”）的方法扩充新的游戏对象预设元素，加入到“_totalObjList”这个容器类集合中，其查找用的元素下标数值则存储在“_avaliableIndex”集合中。 这样，一个最简单的“对象缓冲池”脚本就解释完毕了，如何使用呢？需要读者在理解上述脚本的原理上，写其他的测试脚本，通过调用相关方法来使用。也就是说，核心的“对象缓冲池”脚本只是一个“中间件”，不能单独运行，需要我们写脚本来使用。如代码清单4所示，我们使用本书之前讲解的射击场景，运用和测试对象缓冲池的实际效用。 代码清单4 ShottingUseBufferPool.cs 12 代码清单4中的ShottingUseBufferPool.cs脚本是在本书之前提及的RayDemo.cs脚本基础上加入“对象缓冲池”技术改造升级之后的脚本。其中代码清单4中的24-27行代码是关于运用“对象缓冲池”新加入的字段。 代码清单5 12 代码清单5中，Start()事件函数的主要作用是建立“射击靶墙”，OnGUI()事件函数的作用是绘制射击光标。 代码清单6 12 代码清单6中的第73行代码取代原先的创建“子弹”，而是从“缓冲池”取得已经存在的“预设对象”，即调用PickObj，第76行代码SendMessage()函数的作用是传递子弹在缓冲池中的“序号”给“子弹”所在的对象脚本，目的是当子弹超出摄像机视野范围的时候主动“回收”子弹实例。 代码清单7 12 代码清单7中使用OnBecamelnvisible()方法实现当子弹离开摄像机视野范围时，子弹再次自动回收到“缓冲池”中的操作。代码清单7中的ReceiveBulletID()方法是接收ShottingUseBufferPool.cs脚本中用SendMessage()方法传来的子弹序号数据，用于回收子弹使用。 以上3个核心脚本介绍完毕，请读者查看随书第27章的示例项目，但程序运行之后，我们就会发现在正式开始射击之前，所有指定数量的“子弹预设”就已经创建完毕了，只不过是“禁用”状态。当开始射击的时候，会发现随着子弹的射击，其“子弹缓冲池”列表中的子弹预设对象其状态（“启用”或者“禁用”）也在不断的变化。 高级对象缓冲池技术上面我们介绍了简单对象缓冲池的实现原理与实验项目，读者能否发现有什么不方便使用的地方，或者功能需求上的缺失呢？ 之前介绍的对象缓冲池的不足之处，如下所示。 第1条：使用对象缓冲池的时候必须把一个名为“缓冲对象id号”传给“缓冲对象”所在的脚本，否则不能正确回收“对象”。 第2条：对象缓冲池不支持多“类”对象的缓冲池处理，即如果射击项目中增加“子弹”、“飞弹”、“炮弹”等不同种类的游戏对象，就不能直接应用了。 第3条：对象缓冲池中，对象必须明确回收的条件，不能自动按照时间进行“回收”处理。例如，跑酷游戏中，大量的“红宝石”等道具如果用缓冲池，就需要具备一定时间以后自动回收的功能实现。 为了解决以上简单对象缓冲池的不足，我们来研发更加高级的对象缓冲池， 目的就是既要使用简单，又要功能强大。 图27.10就是应用高级对象缓冲池的实验项目，从图中的方框中可以看出这个对象缓冲.池支持多类型对象缓冲处理，而且本实验项目中已经有了按照指定时间自动“回收”缓冲 现在就从代码的层级来介绍这个缓冲池的构成与基本原理。功能强大但脚本相对比较简单，核心仅2个脚本和4个类，结构如下。 1)脚本: “Pools. cs”包含以下3个类。类: Pools 作用:负责多个类型对象缓冲器的实现。类: PoolOption 作用:负责单类型对象缓冲器的实现。类: PoolTimeObject 作用:辅助功能，时间处理。 2)脚本: “Pool Manager. cs”类: PoolManager 作用:负责多个类型复合对象缓冲器，使用到前面3个类的方法调用。 图27.11给出了Pools， cs脚本完整的头注释，利于相互学习与借鉴。 图27.12给出了脚本中包含的3个类的简略定义。为了使读者更好地理解，我们先从类”PoolOption” (图27.12代码中的第178行)开始介绍，这个类是负责单个类型对象缓冲器的具体代码实现。 图27.13中定义了PoolOption类的字段与“预加载” (Preload)方法，图中183行与185行代码中的”ActiveCameObjectArray”、 “InactiveCameObjectArray”是核心容器类集合，分别存放“活动游戏对象(预设)”与“非活动游戏对象(预设)”。其中， “预加载”方法的作用是克隆指定游戏对象，然后重命名后对此对象做“禁用”处理(图中代码200行)，最后加入到“非活动游戏对象”集合中。 图27.14中的“激活游戏对象” (Active)是Pooloption类的重要方法。当我们需要从缓冲池中提取出一个游戏对象时，首先从“非活动游戏集合”容器中取出下标为0的游戏对象，然后经过方位调整后(即游戏对象应有的位置、旋转、缩放等信息)加入“活动池”容器中，且正式“启用”此对象(设置SetActive (true) )，然后返回。 图27. 15中的”Deactive”是“禁用游戏对象”方法，通过活动与非活动集合的操作，以及设置对象“禁用”来实现。图27. 15中的其他方法以统计集合中的数据为重点，这里为了突出基本原理，不做介绍。 关于PoolOption类的重要功能就介绍到这里。为了使此对象缓冲池可以容纳多种类型的游戏对象，我们在PoolOption类的基础上又“包裹”了一层代码，即Pools类，从而实现对多种游戏对象类型的支持，代码如图27.16所示。 图27.16中的第33行代码就是包含PoolOption类的泛型集合，从而实现多种类型对象缓冲的支持。图中第40行代码中的PeloadGameObjet()是预加载方法，即多种类游戏对象的预加载。 图27.17中的PreLoadGameObject ()与BirthGameObject()分别是Pools类中关于“多模”对象缓冲池中的“预加载”与“生成单个游戏对象”的方法，其基本原理是通过调用Pool-Option中的相关方法来实现的图27， 18中的RecoverGameObject ( )方法是“多模”状态下的“同收”缓冲池对象方法。下面我们来介绍Pools类中关于定时回收对象的基本原理，如图27.19所示。 图27. 19中的ProcessCameObject NameTime ( )是Pools类中的“时间截”方法，即系统根据开发人员的要求指定特定种类游戏对象的存活时间，到时间就会自动回收缓冲池对象的机制。 图27.21中的”PoolManager”与子对象”RedDiamend”、”_Tree”都是建立的空对象，”PoolManager”对象上赋值”PoolManager. cs”脚本，两个子空对象赋值”Pools. cs”脚本。 我们使用前面学习的“跑酷”项目作为测试实验项目，其调用方式如图27.22和图27.23所示。 图27.22中的第76行代码表明使用缓冲池的方法，首先确定缓冲池的类型名称，这里用”strPoolsTypeObjName”动态获得，然后调用(Pools类中) BirthGameObject ()方法生成缓冲池对象，当然，这是对应于初始缓冲池中的对象不够用时才进行调用的。 图27.23中，第51行代码定义了回收缓冲池游戏对象的方法，写法与生成游戏对象的写法类似。 本章练习与总结本章我们学习了对象缓冲池技术，此技术是基于Unity引擎中非常重要的性能优化手段。首先我们介绍了“预加载”的概念，然后介绍了对象缓冲池的来历与基本原理。在此基础上我们提供了两种截然不同、功能高、低搭配的两种缓冲池技术实现，使用两个不同的示例，演示了两种缓冲池在不同项目中的具体部署与代码使用方式。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D/2D游戏开发从0到1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目研发常用优化策略]]></title>
    <url>%2F2019%2F07%2F29%2F%E9%A1%B9%E7%9B%AE%E7%A0%94%E5%8F%91%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是Draw Call？为什么Draw Call那么重要？ 本章涵盖： 项目优化策略项目优化技能是优秀研发人员的基本素质，除了以上我们介绍的两种主要性能优化方式与性能检测工具，下面还有非常丰富的经验与优化建议与大家分享。现在针对这些优化建议，结合自身研发经验分以下6个方面进行归纳与总结。 Draw Call 模型/图像方面 光照与摄像机处理 程序优化方面 Unity系统设置 开发与使用习惯 项目优化之Draw Call对于Unity研发人员而言，系统的性能优化几乎等同于“Draw Call”的优化，其重要性可见一般。那么，对于初学者而言，究竟什么是Draw Call？为什么Draw Call那么重要？下面针对其概念与重要性进行探讨。 1.Draw Call概述与基本原理 一个模型的数据经过CPU传输到GPU，并命令GPU进行绘制，称为一个Draw Call。 Unity引擎准备数据并渲染游戏对象的过程是逐个游戏对象进行的，所以对于每个游戏对象，不仅GPU的渲染很耗时，引擎重设材质与Shader也是一项非常耗时的操作。因此每帧的Draw Call次数是一项非常重要的系统性能指标。 降低Draw Call的基本原理基于Draw Call是CPU调用底层图形接口，对于GPU来说，一个游戏对象与大量游戏对象，其图形处理的工作量是一样的。所以对Draw Call的优化，主要工作量就是为尽量减少CPU在调用图形接口上的开销而努力。针对Draw Call，我们的主要思路是，每个游戏对象尽量减少渲染次数，多个游戏对象尽量一起渲染。 2.降低Draw Call的主要途径 一般项目中，角色和场景是最消耗资源的两个方面，其中角色是CPU的瓶颈，场景是GPU的瓶颈。所以项目的优化就是降低Draw Call，其总体思路就是对美术资源进行梳理、大量合并Draw Call、人物角色减少材质与纹理的依赖、简化多余特效等。当然也可以允许玩家在部分低端设备平台上选择关闭某些功能与特效来换取更流畅的帧速率与性能。 以下分10个途径来进行详细讨论。 途径1：Draw Call批处理（Draw Call Batching）技术 Unity运行时可以将一些游戏对象进行合并，也就是把多个游戏对象打包，然后再使用一个Draw Call来渲染它们，这一操作被称为“批处理”（Draw Call Batching）。 Draw Call批处理技术的核心就是在可见性测试之后，检查所有要绘制的对象材质，把相同材质分为一组，然后把它们组合成一个对象，这样就可以在一个Draw Call中处理多个了（实际上是组合后的一个对象）。 Unity提供了“动态批处理”（Dynamic Batching）和“静态批处理”（Static Batching）两种方式。“动态批处理”是完全自动进行的，不需要也无法进行任何干预，对于顶点数在900以内的可移动物体，只要使用相同的材质，就会组成“批处理”（Batching）。“静态批处理”（Static Batching）则需要把静止的物体标记为“静态”（Static），然后无论大小，都会组成“批处理”（Batch）。 为了更好地使用静态批处理（Static Batching），需要明确指出哪些物体是静止的，并且在游戏中永远不会移动、旋转和缩放。在属性窗口中将“Static”复选框勾选即可。非运动物体尽量打上Static标签。Unity在运行时会对“Static”物体进行自动优化处理，所以应该尽可能将非运动游戏对象勾选静态”Static”标签，如图所示。 途径2：使用图集（Texture Packing或者Texture Allasing）减少材质的使用 Unity判断对哪些游戏对象进行批处理时，一般是根据这些对象是否具有共同的材质和贴图，也就是说拥有相同材质的对象才可以进行批处理。因此，如果想要得到更好的批处理效果，需要在场景中尽可能复用材质到不同的对象上。 有效利用Draw Call批处理，首先应尽量减少场景中使用的材质数量，即尽量共享材质，对于仅纹理不同的材质，可以把纹理组合到一张更大的纹理中（称为“图集”，TexturePacking或者TextureAllasing），然后把不会移动的物体标记为“Static”。 途径3：尽量少地使用反光、阴影，因为那会使物体多次渲染 途径4：视锥体合理裁剪（Frustum Culling） 视锥体合理裁剪（Frustum Culling）是Unity内建的功能，我们需要做的就是寻求一个合适的远裁剪平面。一般经验是，对于大型场景中的大量游戏对象进行合理分层（Layer），对于大型建筑物使用较大裁剪距离，而对于小游戏对象可以使用较小裁剪距离，场景中的粒子系统等可以使用更小的裁剪距离。 途径5：遮挡剔除方法（Occlusion Culling) 途径6：网格渲染器（Mesh Renderer）的控制 只有处于摄像机视锥体内，且添加了网格渲染器（Mesh Renderer）组件的对象才会产生渲染的开销，而空的游戏对象并不会产生渲染开销。根据这个原理，我们可以对暂时无须显示的游戏对象通过使用脚本的方式进行控制，不进行渲染，需要的时候再渲染即可。 途径7：减少游戏对象的缩放 分别拥有缩放大小(1, 1, 1)和(2, 2, 2)的两个对象将不会进行批处理，统一缩放的对象不会与非统一缩放的对象进行批处理 途径8：减少多通道Shader的使用 多通道的Shader会妨碍批处理操作。例如，几乎Unity中所有的着色器在前向渲染（Forward Rendering）中都支持多个光源，因此为它们开辟多个通道，所以对批处理有影响。 途径9：脚本访问材质方法 如果需要通过脚本访问复用材质属性，如使用Renderer.material改变贴图，则将会造成一份材质。因此一般使用Renderer.sharedMaterial来保证材质的共享状态。 途径10：尽量多使用“预设”（Prefab） 使用预设生成的对象会自动使用相同的网格模型和材质，因此会自动被批处理。 对于复杂的静态场景，还可以考虑自行设计遮挡剔除算法，尽量减少可见游戏对象数量，同时也可以减少Draw Call。总之理解Draw Call和Draw Call批处理的原理，根据场景的具体特点，设计相应的方案来尽量减少Draw Call，是项目性能优化策略中非常重要的一环。 项目优化之模型与图像方面“模型与图像方面”的优化分为以下6个途径进行探讨。 途径1：模型优化 (1)模型几何体的优化:图形渲染管线中模型的数据量越大，需要对这些数据进行处理的时间就会越长。当然，随着渲染技术的发展，处理模型数据的数量也在提升。但是毋庸置疑，经常使用经过优化的模型可以使游戏的运行更有效率。如何进行优化呢?对模型的优化主要是模型的顶点、三角形面片数目等不要太多。如果可能，把相邻的对象(网格)合并为一个，且只用一个材质的对象(网格)。例如，游戏场景中有一处森林，森林由大量树木与灌木组成，如果要进行优化，则完全可以在三维建模工具中将它们合并在一起，减少需要渲染的物体的数量，这样可极大地提高游戏性能。 (2)蒙皮动画模型优化:蒙皮动画主要针对添加骨骼的模型，对这些模型的优化，也对渲染效率起到不可低估的提升作用。建议在Unity中的每个角色仅使用一个蒙皮网格渲染器skinned mesh renderer)来绘制，这是因为当角色仅有一个蒙皮网格渲染器时， Unity会使用可见性裁剪和包围体更新的方法来优化角色的运动，而这种优化只有在角色仅含有一个蒙皮网格渲染器时才会启动。角色的面数一般不要超过15* * ，骨骼数量少于3* ，角色材质数量一般1-2个为最佳。 (3)压缩面片(Mesh): 3D模型导人Unity之后，在不影响显示效果的前提下，最好打开”Mesh Compression”、 “Off”、 “Low”、”Medium”、”High”这几项，具体分析，酌情选择。对于单个面片，最好仅使用一个材质，如图24所示。 (4)避免大量使用Unity自带的Sphere等内建游戏对象：Unity内建的部分游戏对象，其多边形的数量比较大，如果物体不要求特别圆滑，可导人其他的简单3D模型代替(见图25)。 途径2：贴图(纹理)优化 (1)使用贴图压缩优化：尺寸越小、压缩比率越高可以降低对它的渲染处理时间，同时也会减少游戏文件的体积。修改贴图的尺寸及压缩格式，可以通过贴图的属性面板来设置。最后在整个场景中尽量减少贴图的数量。在外观不变的前提下，贴图大小越小越好。 (2)贴图（纹理）压缩格式选择：纹理方面，建议使用压缩纹理。不透明贴图的压缩格式为ETC4bit，因为Android市场手机中的GPU有多种，每家的GPU支持不同的压缩格式，但它们都兼容ETC格式，如图26所示。对于透明贴图，我们只能选择RCBA 16bit或者RGBA 32hit。 关于贴图的格式，如果读者从事的是手游开发，则建议使用PNG或TGA格式。如果发布ios，则不用转成i* s硬件支持的PVRTC格式，因为Uniy在发布时会帮你自动转换。贴图的长宽尽量小于1* 24b，同时应该尽可能小，够用就好，以保证贴图对内存带宽的影响达到最小。 (3)选择支持“Mipmap”：建议生成Mipmap，虽然这种做法会增加一些应用程序的体积，但在游戏运行时，系统会根据需求应用Mipmap来渲染，从而减少内存带宽需求。 途径3：材质 尽量合并使用同贴图的材质球，合并使用相同材质球的对象。使用尽可能少的材质，尽可能减少网格所用材质的数量，除非想使用不同的着色器来实现不同部位的材质效果，这使得Unity更容易进行批处理。 建议使用纹理（贴图）图集（Texture Packing或者Texture Allasing）来代替一系列单独的小贴图，它们可以更快地被加载，具有很少的状态转换，而且批处理更友好。在手游开发中尽量减少AlphaTest和AlphaBlend材质的使用，因为这对系统效率会造成很大影响 途径4：(模型)碰撞体 如果可以，尽量不用Mesh Collider，以节省不必要的开销。如果不能避免，则尽量减少Mesh的面片数，或用较少面片的代理体来代替。网格碰撞盒比基本碰撞盒需要更高的性能开销，因此应该尽量少使用。类似问题还有车轮碰撞盒（Wheel Collider）与布料模拟，它们都会造成很高的CPU开销。 途径5：粒子系统 屏幕上的最大粒子数建议小于200，每个粒子发射器发射的最大粒子数建议不超过50个。如果可以，粒子的size应该尽可能小，因为Unity粒子系统的Shader，无论是AlphaTest还是AlphaBlending，都是一笔不小的开销。同时，对于非常小的粒子，建议粒子纹理去掉Alpha通道。另外，尽量不要开启粒子的碰撞功能，因为这一功能非常耗时。 途径6：其他 建议场景中尽可能多地使用“预设体”（Prefab）。尽可能多地使用“预设”的实例化对象，以降低内存带宽的负担。 非均匀缩放动画（Animation）在Unity中非常慢，建议将非均匀缩放都改为均匀缩放。不要在静态物体上附加Animation组件，虽然加了对结果没任何影响，但是会增加CPU开销。 项目优化之光照与摄像机方面“光照与摄像机”方面的优化分为以下3个途径进行探讨。 途径1:渲染途径(Rendering Path) 要想优化“渲染途径”，就必须先了解什么是渲染途径及其具体作用 Unity提供了不同的渲染途径(Rendering Path)，这些渲染途径用于决定灯光和阴影在场景中的计算方法，不同的渲染途径具有不同的性能特性和渲染效果。Unity中提供了3种渲染途径，分别是“顶点光照” ( Vertex Lit)、“前向渲染” ( Forward Rendering)和“延时光照” (Deferred Lighting)。 (1)延时光照:延时光照是具备最高的保真度与真实感的渲染途径。如果项目场景中需要开发绚丽多彩、具备较多实时灯光与阴影效果的场景时，最好使用延时光照。 延迟光照的主要优点是对于能影响物体的光线数量没有上限，全部采用以每像素的方式进行光线计算。所有光线都可以使用灯光Cookie、产生阴影，光照计算的开销与屏幕的光线尺寸成正比，与所照射的物品的数量没有直接关系。 延迟光照的缺点是需要消耗系统大量资源，需要较高水平的硬件支持。影响计算性能的因素分别是被照亮的物体在屏幕上的像素数量和投射阴影的灯光数量;延迟光照中实时光线的开销与光线照亮的像素数量成正比，但不取决于场景的复杂性。 (2)前向渲染:前向渲染途径(Forward Rendering Path)是基于着色器的渲染途径。它支持逐像素计算光照(包括法线贴图和灯光Cookies)及支持一个来自平行光的实时阴影(即除唯一一个平行光外，不支持其他实时阴影)，这也是系统的默认光照模式，是一种保持较高光照效果与较高系统性能的综合平衡选项 (3)顶点光照:顶点光照(Vertex Lit)是一种最低保真度光照，不支持实时阴影，只对所有对象渲染一遍，它是对硬件要求最低也是渲染速度最快的渲染途径。基于顶点光照的特点，所以它一般应用于发布到比较陈旧或者平台受限的设备上。 针对不同渲染途径的特点与系统消耗，大型项目中可以使用多个摄像机。每个摄像机针对不同的场景，使用不同的渲染途径，以有效地进行有针对性的性能优化。 图27中是摄像机关于渲染途径的选项，默认是“Use Player Setting”，如果没有更改，其实就是前向渲染路径。“Use Player Setting”可以在系统菜单”File””BuildingSetting”→”Player Setting” →”Other Setting”中进行设置，如图28所示。 途径2：光照与阴影方面 像素的动态光照将对顶点变换增加显著的开销，所以应该尽量避免任何给定的物体被多个光源同时照亮的情况。对于静态物体，可以采用“光照烘焙”方法，这是更为有效的方 关于“光照烘焙”的知识点，见本书第22章的详细讲解 光线性能的消耗占用顺序为“聚光灯” &gt; “点光源” &gt; “平行光”。所以一个好的点亮场景的方法就是先得到你想要的效果，然后看看哪些光更为重要，在保持光效的前提下去除多余光照。 点光源和聚光灯只影响它们范围内的网格，所以如果一个网格处于点光源或者聚光灯的照射范围之外，那么这个网格将不会被光源所影响，这样就可以节省性能开销。因此，从理论上来讲可以使用很多小的点光源，而且依然能有一个好的性能，因为这些光源只影响一小部分物体。 一个网格在有8个以上光源影响的时候，只响应前8个最亮的光源。 如果硬阴影可以解决问题，就不要用软阴影，并且使用不影响效果的低分辨率阴影。实时阴影很耗性能，尽量减小产生阴影的距离，允许的话应在大场景中使用线性雾，这样可以使远距离对象或阴影不易察觉，因此可以通过减小摄像机的远裁剪距离和阴影距离提高性能。 实时阴影一般开销较大，如果不正确使用，则可能造成大量的性能开销。在“质量设置” (Quality Settings)面板中的”Shadow Distance”属性上设置阴影的显示距离，该距离是根据当前摄像机作为参考的;当可以生成阴影的地方与当前摄像机之间的距离超过该值时，将不生成阴影，如图2* .29所示。 图2* .29中是阴影的显示距离设置，在系统菜单”Edit”→”Projeet Setting”→&gt; “Quality”中进行设置。 途径3:摄像机技巧 将远平面设置成合适的距离，远平面过大会将一些不必要的物体加入渲染，降低效率。我们可以根据不同的物体来设置摄像机的远裁剪平面。Unity提供了可以根据不同的“层”(Layer)来设置不同的显示距离(View Distance)，所以我们可以实现将游戏对象进行分层，大物体层设置的可视距离大些，而小物体层设置小此，一些开销比较大的实体(如粒子系统)可以设置更小此，如图所示。 项目优化之程序优化方面我们从“Draw Call”、“模型与图像”、“光照与摄像机”等方面讲解了性能优化策略，现在我们把重点放在脚本本身进行进一步探讨。 下面我们从以下4个方面进行讨论。 1.程序整体优化方面 (1)如果项目的性能瓶颈不在渲染方面，则一定在脚本代码。我们要删除脚本中为空或不需要的默认方法，尽量少在Update中做事情，脚本不用时把它禁用掉（Deactive）。 (2)尽量不使用原生的GUI方法，而是用UGUI代替（或者NGUI）。 (3)需要隐藏/显示或实例化来回切换的对象，尽量少用SetActiveRecursively或Active。而是改为将对象移出相机范围和移回原位的做法，这样性能更优一些；也可以选择使用脚本方式开启与关闭游戏对象的“Mesh Renderer”组件来进行优化。 (4)不要频繁地获取组件，将其声明为全局变量。 (5)脚本在不使用时禁用它，需要时再启用。 (6)尽量直接声明脚本变量，而不使用GetComponent来获取脚本。因为GetComponent或内置组件访问器会产生明显的开销;可以通过一次获取组件的引用来避免开销，并将该引用分配给一个变量。 (7)尽量少使用Update、LateUpdate、FixedUpdate等每帧处理的函数，这样也可以提升性能和节省电量。 (8)使用C#中的委托与事件的机制，比使用SendMessage机制效率更高。 2.事件函数方面 (1)按照脚本生命周期的原理，对于“协程”与“调用函数”，一般在脚本禁用的时候，“协程”与“调用函数”不会自动禁用，需要使用脚本写明标示禁用，否则会出现空转现象，耗费资源。 (2)同一脚本中频繁使用的变量，建议声明其为全局变量；脚本之间频繁调用的变量或方法，建议声明为全局静态变量或方法。 (3)尽量避免每帧处理，可以每隔几帧处理一次。 例如： 123456function Update () &#123; if(Time. frameCount % 100 == 0) DoSomeThing();&#125;// Time.frameCount表明为“帧数量” (4)可以使用“协同”（Coroutine）程序或者“调用函数“（InvokeRepeating）来代替不必每帧都执行的方法。 (5)避免在Update或FixedUpdate中使用搜索方法，如GameObject.Find()。良好的代替方案是把搜索方法放在单次执行的事件函数中，如Start()事件函数中。 3.数学计算方面 尽量使用int类型来代替float类型，尽量少用复杂的数学函数，如sin，cos等函数；改除法为乘法，尽量少用模运算和除法运算。 4.垃圾回收机制方面 (1)尽量主动回收垃圾。例如，给某个GameObject赋值以下代码: 12345function Update()&#123; if (Time.frameCount % 100 == 0 ) System.GC.Collect(); &#125; (2)垃圾回收的“时机”很重要，尽量放在游戏场景的加载与场景结束的时候，主动卸载资源；而在场景人员的战斗中尽量不要主动卸载，否则会造成非连续性卡顿等问题。 (3)避免频繁分配内存。应该避免分配新对象，除非你真的需要，因为它们不被使用时会增加垃圾回收系统的开销。您可以经常重复使用数组和其他对象，但不能分配新的数组或对象。这样做的好处是减少了垃圾的回收工作。这里可以采用“游戏对象缓存”的技术来提高系统效率，将在第27章详细论述。 (4)在较大场景中，距离摄像机较远的游戏对象可以将GameObject上不必要的脚本禁用（Disable）掉。如果需要启用，则再使用GameObject.setctive()启用等。这也可以配合事件函数中的OnBecameInvisible()（当变为不可见）和OnBecameVisible()（当变成可见），使得游戏对象在不可见的时候自动禁用掉，可见的时候再启用。 (5)善于使用OnBecameInVisible()和OnBecameVisible( )，控制物体Update()函数的执行，以减少开销。 6)资源预加载技术的运用。“资源预加载”技术就是以空间换时间的方法。正式进入战斗场景前，可以在关卡之间的“战绩统计场景”中进行“预加载”操作（一般常用“协程”进行加载），这样正式游戏时就不会出现卡顿等现象。 项目优化之Unity系统设置方面Unity游戏引擎的性能优化有很多内容值得讨论，现就典型内容列举如下。 1.限帧措施 在以手机为代表的移动设备上运行游戏，主动减少“帧速率”（FPS）可以显著地减少 具体方法:菜单”Elit”→”ProjectSetting”→”Qualit”中的”VSync Count”参数会影响你的FPS.Every Blank相当于”FPS =60， Every Second VBlank =30”，这两种情况如果都不符合游戏的FPS，我们则需要手动调整FPS，首先关闭垂直同步这个功能，然后在代码的Awake方法里手动设置FPS(Application.targetFramelate =45)，如图31所示。 2.物理性能优化 1)增加固定时间步长 对于台式机，稍微复杂一些的物理模拟运算是绰绰有余的，但是如果是开发移动终端的游戏，那么就需要更加注意物理性能的优化。当我们设置了FPS后，再调整一下Fixed Timestep这个参数，这个参数在”Edit”-，”ProjectSetting”-， “Time”中，目的是减少物理计算的次数，提高游戏性能。减少固定的增量时间，设置”Fixed Timestep”在0.04~0.0678之间(也就是每秒15-25顿之间，如图32所示)。这降低了FixedUpdate被调用与物理引擎执行碰撞检测和刚体更新的频率。 如果为主角添加了刚体，可以在刚体组件中启用“插值(Interpolate )来平滑降低固定增量时间步长，如图33所示。 2)设置“最大允许时钟步调” (Maximum Allowed Timestep) 物理计算和FixedUpdate( )执行不会超过该指定的时间。一般在0. 1~0.125范围之内设定，使得在最坏的情况下封顶物理花费的时间 3)设置“时间缩放因子” (Time Scale)图32中的最后一个属性“时间缩放因子” (Time Scale)，如果该值为1，则表示按照正常时钟运行游戏；当该值为0时，游戏暂停运行;如果设置为2，游戏运行时间将加快到两倍；当为0.5时，运行时间减慢到一半，以减少对物理更新所花费的时间。增加时间步长将减少CPU开销，但物理模拟的精度会下降。通常情况下，为增加速度而降低精度是可以接受的折中方案。 3.调整像素光数量 像素光可以让你的游戏看起来效果绚丽多彩，但是不要使用过多的像素光。在游戏中可以使用质量管理器来调节像素光的数量，从而取得性能和质量的一个均衡点，如图34所示。 项目优化之良好开发与使用习惯(1)养成良好的标签(Tags)、层次(Hieratchy)和图层(layer)的条理化习惯，将不同的对象置于不同的标签或图层，三者的有效结合将方便按名称、类别和属性进行查找。 (2)项目研发的过程中养成经常通过States和Profile查看对效率影响最大的方面或对象，或者使用禁用部分模型的方式查看问题到底在哪里，而不是项目发布后再进行这一步骤。 本章练习与总结对于游戏开发与虚拟现实领域有所作为的大家，本章所总结与探讨的领域是极其重要的。我们首先从Unity提供的两种大型优化手段（遮挡剔除、层级细节）与性能检测工具（Profiler）谈起，然后结合Unity官方文档与自身开发经验，分6个方面着重讨论了影响项目性能的方方面：“DrawCall”、“模型与图像”、“光照与摄像机”、“程序优化”、“系统设置”、“良好开发与使用习惯”等。 项目优化策略是一个涉及知识体系庞大、影响广泛、需要深入研究的领域，希望广大读者能够在此基础之上举一反三，不断深入研究，开发出更加优秀的项目产品。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D/2D游戏开发从0到1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展方法]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么说密封类和抽象类相反？密封类的应用场景是什么？ 什么是静态类？什么时候选择静态类而不是实例类？ 静态类可以被继承吗？为什么？ 什么是扩展方法？怎么使用？ 本章涵盖： 密封类 静态类 扩展方法 密封类抽象类必须用作基类，它不能像独立的类那样被实例化。密封类与它相反。 密封类只能被用作独立的类，它不能被用作基类。 密封类使用sealed修饰符标注。 例如，下面的类是一个密封类。将它用作其他类的基类会产生一个编译错误。 12345// ↓ 关键字sealed class MyClass&#123; ...&#125; 静态类静态类中所有成员都是静态的。静态类用于存放不受实例数据影响的数据和函数。静态类的一个常见的用途可能就是创建一个包含一组数学方法和值的数学库。 关于静态类需要了解的重要事情如下。 类本身必须标记为static. 类的所有成员必须是静态的。 类可以有一个静态构造函数，但不能有实例构造函数，不能创建该类的实例。 静态类是隐式密封的，也就是说，不能继承静态类。 可以使用类名和成员名，像访问其他静态成员那样访问它的成员。 下面的代码展示了一个静态类的示例: 1234567891011121314151617181920212223242526// ↓ 类必须标记为静态的static public class MyMath&#123; public static float PI = 3.14f; // 成员必须是静态的 public static bool IsOdd(int x) &#123; return x%2 == 1; &#125; // 成员必须是静态的 public static int Times2(int x) &#123; return 2 * x; &#125; &#125;class Program&#123; static void Main() &#123; int val =3; // 使用类名和成员名 Console.WriteLine("&#123;0&#125; is odd is &#123;1&#125;.", val, MyMath.IsOdd(val)); Console.WriteLine("&#123;0&#125; * 2 = &#123;1&#125;.", val, MyMath.Times2(val)); &#125;&#125; 这段代码产生以下输出: 123 is odd is True.3 * 2 = 6. 扩展方法在迄今为止的内容中，你看到的每个方法都和声明它的类关联。扩展方法特性扩展了这个边界，允许编写的方法和声明它的类之外的类关联。 想要知道可以如何使用这个特性，请看下面的代码。它包含类MyData，该类存储3个double类型的值，并含有一个构造函数和一个名称为Sum的方法，该方法返回3个存储值的和。 123456789101112131415161718192021class MyData&#123; // 字段 private double D1; private double D2; private double D3; // 构造函数 public MyData(double d1, double d2, double d3) &#123; D1 = d1; D2 = d2; D3 = d3; &#125; // 方法Sum public double Sum() &#123; return D1 + D2 + D3; &#125;&#125; 这是一个非常有限的类，但假设它还含有另外一个方法会更有用，该方法返回3个数据的平均值。使用已经了解的关于类的内容，有几种方法可以实现这个额外的功能。 如果你有源代码并可以修改这个类，当然，你只需要为这个类增加一个新方法。 然而，如果不能修改这个类（如这个类在一个第三方类库中），那么只要它不是密封的，你就能把它用作一个基类并在派生自它的类中实现这个额外的方法。 然而，如果不能访问代码，或该类是密封的，或有其他的设计原因使这些方法不能工作，就不得不在另一个类中使用该类的公有可用成员编写一个方法。 例如，可以编写一个下面这样的类。下面的代码包含一个名称为ExtendMyData的静态类，它含有一个名称为Average的静态方法，该方法实现了额外的功能。注意该方法接受MyData的实例作为参数。 123456789101112131415161718static class ExtendMyData&#123; // ↓ MyData类的实例 public static double Average(MyData md) &#123; return md.Sum() / 3; // 使用MyData的实例 &#125;&#125;class Program&#123; static void Main() &#123; MyData md = new MyData(3, 4, 5); // ExtendMyData.Average调用静态方法 ↓ MyData的实例 Console.WriteLine("Average: &#123;0&#125;", ExtendMyData.Average(md)); &#125;&#125; 这段代码产生以下输出： 1Average: 4 尽管这是非常好的解决方案，但如果能在类的实例自身上调用该方法，而不是创建另一个作用于它的类的实例，将会更优雅。下面两行代码阐明了它们的区别。第一行使用刚展示的方法：在另一个类的实例上调用静态方法。第二行展示了我们愿意使用的形式：在对象自身上调用实例方法。 扩展方法允许你使用第二种形式，即使第一种形式可能是编写这种调用的正常方法。 12ExtendMyData.Average(md); // 静态调用形式md.Average(); // 实例调用形式 通过对方法Average的声明做一个小小的改动，就可以使用实例调用形式。需要做的修改是在参数声明中的类型名前增加关键字this，如下面所示。把this关键字加到静态类的静态方法的第一个参数上，把该方法从类ExtendMyData的常规方法改变为类MyData的扩展方法。现在两种调用形式都可以使用。 123456789// 必须是一个静态类static class ExtendMyData&#123; // 必须是公有的和静态的 ↓ 关键字 ↓ 类型 public static double Average(this MyData md) &#123; ... &#125;&#125; 扩展方法的重要要求如下。 声明扩展方法的类必须声明为static. 扩展方法本身必须声明为static. 扩展方法必须包含关键字this作为它的第一个参数类型，并在后面跟着它所扩展的类的名称。 图1阐明了扩展方法的结构。 图1 扩展方法的结构 下面的代码展示了一个完整的程序，包括类MyData和声明在类ExtendMyData中的扩展方法Average。注意方法Average完全如同它是MyData的实例成员那样调用！图2阐明了这段代码。类MyData和ExtendMyData共同起到期望类的作用，带有3个方法。 12345678910111213141516171819202122232425262728293031323334namespace ExtensionMethods&#123; sealed class MyData &#123; private double D1, D2, D3; public MyData(double d1, double d2, double d3) &#123; D1 = d1; D2 = d2; D3 = d3; &#125; public double Sum() &#123; return D1 + D2 + D3; &#125; &#125; static class ExtendMyData &#123; // ↓ 关键字和类型 public static double Average(this MyData md) &#123; return md.Sum() / 3; &#125; &#125; class Program &#123; static void Main() &#123; MyData md = new MyData(3, 4, 5); Console.WriteLine("Sum: &#123;0&#125;", md.Sum()); // ↓ 当做类的实例成员来调用 Console.WriteLine("Average: &#123;0&#125;", md.Average()); &#125; &#125;&#125; 这段代码产生以下输出： 12Sum: 12Average: 4]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#图解教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QFramework简介与环境安装]]></title>
    <url>%2F2019%2F07%2F29%2FQFramework%E7%AE%80%E4%BB%8B%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是渐进式框架？ QFramework简介QFramework 是一套渐进式的快速开发框架。目标是作为无框架经验的公司、独立开发者、以及Unity3D初学者们的第一套框架。框架内部积累了多个项目在各个技术方向的解决方案。学习成本低，接入成本低，重构成本低，二次开发成本低，文档内容丰富（提供使用方式以及原理、开发文档）。 GitHub：https://github.com/liangxiegame/QFramework 快速开始QuickStart1.Action Kit chainning style(Driven by MonoBehaviour or Update) 12345this.Sequence() .Delay(1.0f) .Event(()=&gt;Log.I("Delayed 1 second")) .Until(()=&gt;something is done) .Begin(); object oriented style 123456var sequenceNode = new SequenceNode();sequenceNode.Append(DelayAction.Allocate(1.0f));sequenceNode.Append(EventAction.Allocate(()=&gt;Log.I("Delayed 1 second"));sequenceNode.Append(UntilAction.Allocate(()=&gt;something is true));this.ExecuteNode(sequenceNode); 2.Res Kit 123456789101112131415161718// allocate a loader when initialize a panel or a monobehavourvar loader = ResLoader.Allocate();// load someth in a panel or a monobehaviourloader.LoadSync&lt;GameObject&gt;("Resources/smobj");loader.LoadSync&lt;Texture2D&gt;("Resources/Bg");// load by asset bundle's assetNameloader.LoadSync&lt;Texture2D&gt;("HomeBg");// load by asset bundle name and assetNameloader.LoadSync&lt;Texture2D&gt;("home","HomeBg");// resycle this panel/monobehaivour's loaded res when destroyed loader.Recycle2Cache();loader = null; 3.UI Kit 12345678// open a panel from assetBundleUIMgr.OpenPanel&lt;UIMainPanel&gt;();// load a panel from specified ResourcesUIMgr.OpenPanel&lt;UIMainPanel&gt;(prefabName:"Resources/UIMainPanel");// load a panel from specield assetNameUIMgr.OpenPanel&lt;UIMainPanel&gt;(prefabName:"UIMainPanel1"); 技术支持 Tech Support：文档 Document:http://doc.qframework.io社区:http://community.qframework.io/ awesome_qframework下载地址 Download:最新版本:https://github.com/liangxiegame/QFramework/releases 运行环境Unity 5.6.x ~ 2018.x 包含项目 Include Projects:Catlib.CoreActionSequenceSystemStateManageEditorUniRxJson.netUnityEditorMemo 参考 Reference:BDFrameworkHGFramework: Unity3D客户端框架Qarth: Framework For Game Develop With Unity3dGameFramework:A game framework based on Unity 5.3 and later versionscocos2d/cocos2d-xResetCore.UnityUnityUGUIImageShaderPackFishManShaderTutorial 优秀的Unity库、框架xasset:xasset 致力于为 Unity 项目提供一套精简稳健的资源管理环境代码规范完全遵循:QCSharpStyleGuide 结构图 (v0.0.13) QFramework 功能列表; 约定还记得上版本的第二十四篇的约定嘛？现在出来履行啦~为什么要重制?之前写的专栏都是按照心情写的，在最初的时候笔者什么都不懂，而且文章的发布是按照很随性的一个顺序。结果就是说，大家都看完了，都还对框架没有一个感觉，感觉很乱。而现在，经过两年多的摸索，笔者已经对框架的体系有了一个了解，所以希望再版一次此系列的专栏。为什么不在原来的文章里直接修改呢?在上一轮的专栏第二十四篇里有讲过过:虽然以前的内容过时了，但是这些专栏对笔者有很重要的意义，它们记录了笔者成长的一个经历，在评论区有着大家的支持和鼓励也有一些很有意义的问答，所以笔者舍不得破坏掉这些宝贵的回忆。更新哪些内容?这次的重制更新的内容围绕如下几点: 在原有内容的基础上补充更多内容。语句不通顺、不太容易理解、有歧义的地方、不够严谨的地方进行修改优化。顺序调整：会按照从易到难、由浅入深、由常用到不常用这三个角度进行内容上的排版，以提高阅读体验，使只是掌握更容易更充分。QFramework 的介绍与原理，重点是 UI 和 资源管理两个模块的介绍与原理。 整理后的内容结构如下: 理论与方法论:包含架构与框架搭建、重构、命名、测试、设计模式等内容。资源管理神器: ResKit (重点)UI 框架: UIKit (重点)QFramework 最佳实践与 Demo归纳和总结。 希望这次可以大家展现一个比较清晰的框架知识体系。此次专栏重制的背景就写到这里。接下来开始正文。架构与框架初识什么是架构?架构是一个约定，一个规则，一个大家都懂得遵守的共识。那这是什么样的约定、什么样的规则、什么样的共识呢？我以包为例，我经常出差，双肩背包里装了不少东西。笔记本电脑、电源、2 个上网卡、鼠标、USB 线、一盒大的名片、一盒小的名片、口香糖、Mini-DisplayPort 转 VGA 接口、U 盘、几根笔、小螺丝刀、洗漱用品、干净衣服、袜子、香水、老婆给我带的抹脸膏（她嫌我最近累，脸有点黄）、钱包、Token 卡、耳机、纸巾、USB 线、U 盘等。这个包有很多格子，最外面的格子我放常用的，比如笔、纸、一盒小的名片等；中间的格子一般放的是衣服、袜子、洗漱用品、香水等；靠背的那个大格子放了笔记本电脑，和笔记本电脑相近的小格子放的是两个上网卡、Mini-DisplayPort 转 VGA 接口、大盒名片、记事本，和笔记本电脑相近的大格子放的是电源、鼠标、口香糖等。我闭着眼睛都可以将我的东西从包里掏出来，闭着眼睛都可以将东西塞到包里！但是，非常不幸的是，一旦我老婆整理过我的包，那我就很惨了，老是因为找不到东西而变得抓狂！更不幸的，要是我那个不到两岁的“小可爱”翻过，就更不得了了。这个包就是我放所有物品的“架构”，每一个东西放置的位置就是我的“约定、规则、共识”。倘若我老婆也知道我的“架构”、我的“约定、规则、共识”，那么不管她怎么动我的包，我都照样能够轻易的拿东西或者放东西。进一步，如果我的同事也知道我的“架构”，知道我的“约定、规则、共识”，那么他们什么时候动我的包，我也毫无所知！——道法自然 《10 年感触：架构是什么？——消灭架构！》什么是框架?框架（framework）是一个框子–指其约束性，也是一个架子–指其支撑性。——360 百科小结本小节对框架和架构概念做了简单的认识，得出了以下两个结论： 架构是“约定、规则、共识”框架具有约束性和支撑性 到这里，大家应该对这两个概念有点感觉了。但是还是会有很多疑问，比如“如何去做架构？”、“框架的约束性和支撑性分别指的什么怎么体现的？”等等。这些在后续的专栏中详细讲解。关于架构与框架的初识就介绍到这里。QFramework 简介两年前，笔者毕业半年，刚从 cocos2d 转 Unity 不到两个月，当时所在的公司有一套游戏开发框架。笔者用它做了两个月的项目，使用框架做项目的时候并没有去思考框架是什么，只是开始的时候觉得很新鲜，而且越用越顺手，尝到了它的甜头。后来笔者接到了一个跑酷游戏项目，于是就把工作辞掉了，决定出来全职做这个项目。辞职后，公司的框架由于保密协议就不可以用了。项目就只能从零开始开发，那么结果就是在跑酷项目的开发的过程中各种中水土不服。于是，笔者就开始了市面上开源框架的选型，折腾了几天，发现要么上手太难，要么学习成本很高文档不齐全，有的框架光是理解概念就要很久，对于像笔者一样刚毕业的初学者来说，市面上的开源框架真的很不友好。从那时候笔者就决定要 为自己，开发一套符合自己使用习惯的框架，也就是现在的 QFramework。为什么叫 QFramework笔者在做 cocos2dx 的时候，市面上有个叫 Quick-Cocos2d-x 的开源框架，用两个词形容就是简单、强大。而笔者一直坚信好的工具就应该简单。QFramework 的目标是要做到像 Quick-Cocos2d-x 一样 “简单、强大”。当时笔者纠结过很多名字，比如 QuickEngine，QuickUnity 等等。Q 代表 Quick，并且 Q 这个字母给人感觉灵活有弹性，所以最终确定为 QFramework。QFramework 的目标记得在此系列上一轮的第十篇中有如下一段话: 笔者意愿是想把 QFramework 打造成,让使用的人觉得所有框架中出现的概念要非常清晰,没有任何模糊的概念,出现的概念已经达成共识的概念,没有任何生僻概念,使用门槛尽很低:)。 这个 flag 是 2016 年立的，目前从用户的反馈来看完成得还不错。QFramework 群里有人形容 QFramework 三个词:简单、粗暴、还有点小精致，笔者觉得形容地非常地贴切。目前主要三个模块，UIKit,ResKit,ActionKit。目前还有一个模块 EditorKit 正在开发中。看到这里大家可能对 ActionKit 有些陌生，它的前身就是 QChain，负责所有的异步逻辑，包含 UniRx 和 Promise 还有一套轻量级的行为树。之后会用一个非常详细的文章介绍它。QFramework 快速入门:要介绍 QFramework 只要附上三段代码就够了:1.Action Kit 123456789101112131415161718chainning style(Driven by MonoBehaviour or Update)this.Sequence() .Delay(1.0f) .Event(()=&gt;Log.I("Delayed 1 second")) .Until(()=&gt;something is done) .Begin();object oriented stylevar sequenceNode = new SequenceNode();sequenceNode.Append(DelayAction.Allocate(1.0f));sequenceNode.Append(EventAction.Allocate(()=&gt;Log.I("Delayed 1 second"));sequenceNode.Append(UntilAction.Allocate(()=&gt;something is true));this.ExecuteNode(sequenceNode); 2.Res Kit 123456789101112131415161718// allocate a loader when initialize a panel or a monobehavourvar loader = ResLoader.Allocate&lt;ResLoader&gt;();// load someth in a panel or a monobehaviourloader.LoadSync&lt;GameObject&gt;("Resources/smobj");loader.LoadSync&lt;Texture2D&gt;("Resources/Bg");// load by asset bundle's assetNameloader.LoadSync&lt;Texture2D&gt;("HomeBg");// load by asset bundle name and assetNameloader.LoadSync&lt;Texture2D&gt;("home","HomeBg");// resycle this panel/monobehaivour's loaded res when destroyed loader.Recycle2Cache()loader = null 3.UI Kit 12345678// open a panel from assetBundleUIMgr.OpenPanel&lt;UIMainPanel&gt;();// load a panel from specified ResourcesUIMgr.OpenPanel&lt;UIMainPanel&gt;(prefabName:"Resources/UIMainPanel");// load a panel from specield assetNameUIMgr.OpenPanel&lt;UIMainPanel&gt;(prefabName:"UIMainPanel1"); QFramework 介绍到这里。Unity 里的常用架构一份六一礼物今天是六一，作为礼物先送上一段对笔者影响最大的一段话: 在写一个项目的时候，不要短视地说我就把这个项目做完了，就是交一个差上线了就完了，我们希望每写一个游戏的时候，我们都积累一些东西，把写的每一行代码，都当成是一个可以收藏的，甚至是可以传递下去的这样的一个资产。有了这样一个思想，可能我们在写代码的时候，整个的思维模式会完全不一样。——刘钢《Unity 项目架构和开发管理》 以上这段话来自刘钢老师的讲座《Unity项目架构设计与开发管理》 的结尾。Unity 项目架构设计与开发管理笔者比较幸运，在学习 Unity 之后不久就看了刘钢老师的这个视频，笔者当时很受启发。而视频中所提出的 Manager Of Managers 很好地为 QFramework 指明了方向。视频讲得通俗易懂，里边很多内容都值得反复咀嚼，笔者之后花了很长时间去消化里边的内容。直到今天，笔者再看一遍视频还是会有很多收获的，希望大家看完之后也有所收获有所启发。视频中比较精彩的部分是从一个什么架构都没有的项目一点一点演化到 MVVM 和 StrangeIOC 架构。关于Unity的架构有如下几种常用的方式简单总结如下:1.EmptyGO:在 Hierarchy 上创建一个空的 GameObject,然后挂上所有与 GameObject 无关的逻辑控制的脚本。使用GameObject.Find() 访问对象数据。缺点:逻辑代码散落在各处,不适合大型项目。2.Simple GameManager:所有与 GameObject 无关的逻辑都放在一个单例中。缺点:单一文件过于庞大。3.Manager Of Managers:将不同的功能单独管理。如下: MainManager: 作为入口管理器。EventManager: 消息管理。GUIManager: 图形视图管理。AudioManager: 音效管理。PoolManager: GameObject管理（减少动态开辟内存消耗,减少GC)。LevelManager: 关卡管理。GameManager: 游戏管理。SaveManager: 配置&amp;存储管理。MenuManager 菜单管理。 4.将 View 和 Model 之间增加一个媒介层。MVCS:StrangeIOC 插件。MVVM:uFrame 插件。 ECS (Entity Component Based System)Unity 是基于 ECS,比较适合 GamePlay 模块使用。还有比较有名的 Entitas-CSharp相关链接:我的框架地址:https://github.com/liangxiegame/QFramework教程源码:https://github.com/liangxiegame/QFramework/tree/master/Assets/HowToWriteUnityGameFramework/QFramework&amp;游戏框架搭建QQ交流群: 623597263转载请注明地址:凉鞋的笔记http://liangxiegame.com/微信公众号:liangxiegame image 如果有帮助到您:如果觉得本篇教程对您有帮助，不妨通过以下方式赞助笔者一下，鼓励笔者继续写出更多高质量的教程，也让更多的力量加入 QFramework 。 给 QFramework 一个 Star 地址: https://github.com/liangxiegame/QFramework 给 Asset Store 上的 QFramework 并给个五星(需要先下载) 地址: http://u3d.as/SJ9 购买 gitchat 话题《Unity 游戏框架搭建：我所理解的框架》 价格: 6 元，会员免费地址: http://gitbook.cn/gitchat/activity/5abc3f43bad4f418fb78ab77 购买 gitchat 话题《Unity 游戏框架搭建：资源管理神器 ResKit》 价格: 6 元，会员免费地址: http://gitbook.cn/gitchat/activity/5b29df073104f252297a779c 购买同名的蛮牛视频课程录播课程: 价格 19.2 元 29.8 元地址: http://edu.manew.com/course/431 购买同名电子书 :https://www.kancloud.cn/liangxiegame/unity_framework_design( 29.9 元，内容会在 2018 年 10 月份完结) 作者：凉鞋游戏链接：https://www.jianshu.com/p/85d3c4f8deaf来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 上手 QFramework 要想在项目中使用 QFramework，其实非常简单，QF 的链式扩展可以渗透到每一行代码上。 以下代码介绍了: GameObject、Transform、MonoBehaviour(Component) 提供的链式扩展支持。 123456789101112131415161718192021222324// traditional stylevar playerPrefab = Resources.Load‹GameObject›('no prefab don't run');var playerObj = Instantiate(playerPrefab);playerObj.transform.SetParent(null);playerObj.transform.localRotation = Quaternion.identity;playerObj.transform.localPosition = Vector3.left;playerObj.transform.localScale = Vector3.one;playerObj.layer = 1;playerObj.layer = LayerMask.GetMask('Default');Debug.Log('playerPrefab instantiated');// Extension's Style,same as above Resources.Load‹GameObject›('playerPrefab') .Instantiate() .transform .Parent(null) .LocalRotationIdentity() .LocalPosition(Vector3.left) .LocalScaleIdentity() .Layer(1) .Layer('Default') .ApplySelfTo(_ =› &#123; Debug.Log('playerPrefab instantiated'); &#125;); 看到这个有人会问，这样写有什么意义？ 答案是，这样做可以让我们从每一行代码上节省时间，从而提高效率，QFramework 就是这样的一个框架。 除此之外，链式结构让我们觉得编程是如此美好的事情。 如何掌握链式的 API？ QFramework 的链式扩展，除了支持 GameObject、Transform、Component 的 API 之外，还对数百个 Unity、.Net 最常用的 API 做了扩展支持。 不过，要是一一学习它们难免枯燥，笔者给的建议，就是在任何代码文件里，先引入 QFramework 命名空间，IDE 会在合适的时候提示我们某个对象提供了什么样的扩展，随缘就好。 为什么要先了解 QFramework 的链式扩展支持 因为链式扩展的学习性价比很高，可以很快在项目中得到实践，而且链式扩展奠定了 QFramework 的代码风格，是非常重要的一个元素。 在上一篇，我们介绍了 QFramework 的链式扩展功能。 在这一篇，简单介绍一下资源管理模块 ResKit 的基本使用。 项目中的资源管理 在做项目的时候，对于需要动态加载的资源，我们有两种选择。 通过 Resources.Load API 动态加载资源通过 AssetBundle API哪种方式好坏先不说，我们先看下 ResKit 对这两种的 API 支持。 Resources 资源加载 首先是对 Resources 目录下下的资源加载。 12345678910111213141516171819202122232425using UnityEngine;using UnityEngine.UI;namespace QFramework.Example&#123; public class LoadResourcesResExample : MonoBehaviour &#123; public RawImage RawImage; private ResLoader mResLoader = ResLoader.Allocate(); // Use this for initialization void Start() &#123; RawImage.texture = mResLoader.LoadSync‹Texture2D›('resources://TestTexture'); &#125; private void OnDestroy() &#123; Log.I('On Destroy '); mResLoader.Recycle2Cache(); mResLoader = null; &#125; &#125;&#125; 代码很简单，只需要在需要加载的资源名字前边加上 resources:// 前缀即可。 运行成功后，我们按下 F1 就可以看到资源的加载情况. API 只要使用 mResLoader.LoadSync 即可。 AssetBundle 资源加载支持。 一般情况下，AssetBundle 的使用流程如下: 对资源进行标记Build AssetBundle加载 AssetBundle加载 AssetBundle 中的资源但是在开发阶段，ResKit 只需两步就可以了。 第一步：对资源进行标记，标记方式如下: 第二步：编写加载代码。 12345678910111213141516171819202122232425262728293031323334353637using UnityEngine;using UnityEngine.UI;namespace QFramework.Example&#123; public class AssetBundleResExample : MonoBehaviour &#123; private ResLoader mResLoader = ResLoader.Allocate(); public RawImage RawImage; private void Awake() &#123; // 游戏启动阶段，需要调用一次 ResMgr.Init，加载 AssetBundle 配置信息 ResMgr.Init(); &#125; // Use this for initialization void Start() &#123; RawImage rawImage = transform.Find('RawImage').GetComponent‹RawImage›(); // 可以只传入资源名 RawImage.texture = mResLoader.LoadSync‹Texture2D›('TestImage'); // 当然同时传入 AssetBundleName 和 AssetName 更精确。// RawImage.texture = mResLoader.LoadSync‹Texture2D›('testimage_png','TestImage'); &#125; private void OnDestroy() &#123; mResLoader.Recycle2Cache(); mResLoader = null; &#125; &#125;&#125; 这样就可以加载成功了。运行之后，我们按下 F1 看下资源加载情况。 非常简单。 这里要注意几点： 在游戏启动之后，需要调用一次 ResMgr.Init。开发阶段，确保勾选 Simulation Mode，可以通过按下快捷键 ctrl/cmd + shift + r 查看。 在打包或者发布阶段，确保取消勾选 Simulation Mode，并且每次打包之前需要通过以上面板进行一次 Build 操作。 这个面板上有，代码生成的功能，主要是生成资源名常量，没啥好说的，笔者自己不怎么用。 设计的初衷 ResKit 与其他的资源管理有一些不一样的地方，首先是 AssetBundle 可以只传入一个 AssetName，为什么要这样做呢？ 答案很简单，就是提高开发效率。 首先同时传入 AssetBundleName 和 Assetname 肯定比只传一个 AssetName 所花费时间要长。 其次 AssetBundleName 和 AssetName 一般只有在打好图集、规划好资源目录之后才能稳定下来。在这之前，资源目录的结构处于非常不稳定的状态，这样就会造成每次资源目录有改动，就要更改很多资源加载的代码。 所以有了只传入一个 AssetName 这个功能，在项目前期，你尽管开发逻辑就好了，等项目后期，美术资源等给全了，再进行规划，到时候再填写 AssetBundleName 也不迟。不过笔者很少用到需要传入 AssetBundleName 的情况，除非是资源重名。 至于 Simulation Mode，很多资源管理方案都有了，这里一句话总结好了，就是开发阶段不用打包就能加载 AB 资源，等到要跑真机或者发布阶段，只需要打包前 Build 一次 AssetBundle 就好了。 其次，第二个有些不一样的地方是是 API 使用的 方式。 ResKit 的 API 使用方式是：每个要用到资源加载功能的脚本都需要先申请一个 ResLoader 对象，才可以进行的加载，而当该脚本销毁时，直接回收 ResLoader 对象即可，用户不需要自己管理资源。 希望用户这样使用的原因是， ResLoader 只是一个资源申请列表，并不进行真正的加载操作，而是每次加载都是从资源池中申请一个资源，然后资源进行引用计数 +1 操作，而在 ResLoader 回收时，会对列表中的所有资源进行一次 -1 操作，当每个资源的引用计数为 0 的时候，就自动把自己卸载了。 大家搞不清楚没关系，用了就知道了。 第二点总结一下，就是为了遵循谁加载资源，谁释放资源的原则，与内存管理原则一致。 其它功能 除了以上说的功能，还有 异步加载，资源 List 的异步加载，网络资源加载，本地图片加载，等功能。不过也没啥好说的，用就知道了。 关于 ResKit 介绍今天就先到这里。 在上一篇，我们了解了 ResKit 的基本使用以及设计的初衷。 在这一篇，了解下 UIKit 的基本使用和设计初衷。 UIKit 基本使用 首先我们创建一个界面的测试场景 TestUIHomePanel。 打开场景，然后在 Project 视图里搜索 UIRoot。 将其拖到 TestUIHomePanel 场景中。 可以看到 UIRoot 有很多的层级。 然后设定 UIRoot 的分辨率，根据自己项目的分辨率填写即可（千万不要点击 UIRoot 的 Apply Prefab ）。 接着在 UIRoot 的 Design 层级下，制作 UIHomePanel。 Design 层，就是设计层，一般是用来拼界面用的，Design 层在 Unity 运行之后会隐藏掉，一般情况下，在 Design 层的下边会放一张 RawImage 效果图，用来在拼界面的时候校正位置用的。 图中的 UIHomePanel 有三个子控件：Username(InputField)、Password(InputField)、BtnLogin(Button)，这三个控件是需要在脚本中访问的，所以对这三个控件进行标记。 标记方式很简单，就是给它们都挂上 UIMark。 接着，把 UIHomePanel 拖到 Art/UIPrefab 目录下。 Art/UIPrefab 是一个固定的 UI Prefab 存放路径，主要是生成代码的时候的一个路径参考。要修改也很简单，快捷键 ctrl + e 按下之后可以看到如下面板。 这个面板包含了，生成代码的命名空间，以及脚本生成路径等配置，可以根据自己需要修改。 我们接着继续，接下来对 UIHomePanel prefab 进行 AssetBundle 标记。 再接着生成代码。 代码生成并且编译之后，可以看到生成的脚本已经挂在 UIHomePanel 上了，如下所示。 其中，标记好的 UIMark 控件，也都自己赋上去了。 而生成的脚本文件如下: UIHomePanel 文件是主要的逻辑编写文件，而 UIHomePanelPanel.Designer 则是控件代码生成的文件。 接下来，我们打开 UIHomePanel 脚本，看到如下代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/**************************************************************************** * 2019.1 LIANGXIE ****************************************************************************/using System;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using QFramework;namespace QFramework.Example&#123; public class UIHomePanelData : UIPanelData &#123; // TODO: Query Mgr's Data &#125; public partial class UIHomePanel : UIPanel &#123; protected override void ProcessMsg (int eventId,QMsg msg) &#123; throw new System.NotImplementedException (); &#125; protected override void OnInit(IUIData uiData = null) &#123; mData = uiData as UIHomePanelData ?? new UIHomePanelData(); //please add init code here &#125; protected override void OnOpen(IUIData uiData = null) &#123; &#125; protected override void OnShow() &#123; &#125; protected override void OnHide() &#123; &#125; protected override void OnClose() &#123; &#125; void ShowLog(string content) &#123; Debug.Log('[ UIHomePanel:]' + content); &#125; &#125;&#125; 生成了 UIHomePanelData 和 UIHomePanel 这两个类。 UIHomePanel 有几个生命周期方法。接下来简单说一下都是做什么的。 OnInit 初始化的时候使用，类似于 MonoBehaviour 的 Awake，只有在创建 Panel 之后进行一次调用。 OnOpen 是每次，调用 UIMgr.OpenPanel 的时候进行调用。 OnShow 和 OnHide 则是调用 Panel 的 Show 和 Hide 时调用。 OnClose 则是，调用 UIMgr.ClosePanel 的时候调用。 接下来我们来写一点代码，用来注册一些按钮的点击事件。 123456789protected override void OnInit(IUIData uiData = null)&#123; mData = uiData as UIHomePanelData ?? new UIHomePanelData(); //please add init code here BtnLogin.onClick.AddListener(() =› &#123; Log.I('Username:&#123;0&#125; Password:&#123;1&#125;', Username.text, Password.text); &#125;);&#125; 代码很简单，就是注册 BtnLogin 的点击事件，然后输出 Username 和 Password 中的内容。 BtnLogin、Username、Password 已经是 UIHomePanel 脚本的成员变量了，不需要再次声明，其声明的代码在另一个代码文件里，这个文件名叫做 UIHomePanel.Designer.cs。 其代码如下： 1234567891011121314151617181920212223242526272829303132333435363738/**************************************************************************** * 2019.1 LIANGXIE ****************************************************************************/namespace QFramework.Example&#123; using UnityEngine; using UnityEngine.UI; public partial class UIHomePanel &#123; public const string NAME = 'UIHomePanel'; [SerializeField] public InputField Username; [SerializeField] public InputField Password; [SerializeField] public Button BtnLogin; protected override void ClearUIComponents() &#123; Username = null; Password = null; BtnLogin = null; mData = null; &#125; private UIHomePanelData mPrivateData = null; public UIHomePanelData mData &#123; get &#123; return mPrivateData ?? (mPrivateData = new UIHomePanelData()); &#125; set &#123; mUIData = value; mPrivateData = value; &#125; &#125; &#125;&#125; 接着，脚本写好了，我们最后还剩下一步，就是在场景中创建一个 GameObject 叫做 TestUIHomePanel，然后挂上脚本 UIPanelTester，在 UIPanelTester 中的 PanelName 填上 UIHomePanel。 如下所示： 这样，一个 UIHomePanel 的制作就完工了。 我们运行这个场景。 看到 UIRoot 变成如下： Design 层的内容被隐藏掉了，而 UIHomePanel 被加载在了 Common 层级上。 我们随便输入点内容。 然后点击登录，可以看到如下输出: 添加控件 当我们再创建一个控件，并且进行标记。 这时候，需要对 UIHomePanel 进行 Apply Prefab 操作。 然后对 UIHomePanel prefab 进行代码生成。 生成之后，UIHomePanel 的 Prefab 如下所示: 在脚本中我们，可以访问到，GameObject 控件。 就这样就可以反复进行添加控件操作了，就算添加了控件，重新生成了代码，也不会对原来的脚本造成破坏。 虽然，步骤看起来比较多，但是在真实场景下，有了代码生成和自动序列化这两个功能之后，制作或修改一个界面会快到飞起。 接下来就来谈谈设计的初衷。 设计初衷 UIKit 使用了代码生成和自动序列化功能，主要是为了减少重复劳动的。 UIKit 在支持这两项功能之前，其实是要写大量的 transform.Find(‘XXX’).GetComponent() 这样的代码的，除了要写这样的代码之外，还要手动声明很多的成员，这些都算作重复劳动。 为什么每个界面要创建一个测试场景? 一个界面对应一个测试场景，可以让这个界面的功能模块化，如果整个项目只有一个入口，那么每次有修改，就要从游戏最开始一直跳转到目标界面，这些步骤是非常浪费时间的。比较理想的情况是，当你需要修改某个界面的逻辑或 prefab 时，直接打开对应的测试场景，运行之后就可以马上得到预览结果。 当然一个界面创建一个测试场景是对界面的脚本代码是有一定的要求的，就是脚本代码最好不要访问一些单例等模块，而是通过 UIPanelData 去与其他的模块交流数据。这部分内容会单独用一篇的篇幅去讨论。 今天的内容就这些。 在上一篇，我们了解了 UIKit 的基本使用和设计原理， 在这一篇，我们了解一下 UI Kit 中的 子界面/子控件—UI Element UIElement 简介 在上一篇，我们了解到，一个 UIPanel 是可以自动绑定几个 子控件的（UIMark）。但是当一个界面结构比较复杂的时候，不可能一个 UIPanel 管理数十个 UIMark 的，这时候就需要对 UIMark 进行一些打组操作。我们的 UIElement 就可以登场了。 UI Element 基本使用 使用方式非常简单，就是将 UIMark 中的 MarkType 改成 Element即可,如下所示。 并且要给 CustomComponent 填写一个名字，这个名字决定生成的类的名字。这里填写 UILoginView。 之后进行 Apply 操作。 再生成代码: 等待编译后，Prefab 变成，如下所示： 原来的 UIHomePanel 管理的三个子控件，现在由 Login 管理了。 我们看下脚本目录: 目录生成了一个新的文件夹，是以父 Panel （UIHomePanel）为名的。 打开 UILoginView 脚本，代码如下所示: 1234567891011121314151617181920212223/**************************************************************************** * 2019.1 LIANGXIE ****************************************************************************/using System;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using QFramework;namespace QFramework.Example&#123; public partial class UILoginView : UIElement &#123; private void Awake() &#123; &#125; protected override void OnBeforeDestroy() &#123; &#125; &#125;&#125; 再看下 UILoginView.Designer.cs 脚本，如下所示: 1234567891011121314151617181920212223242526272829/**************************************************************************** * 2019.1 LIANGXIE ****************************************************************************/using UnityEngine;using UnityEngine.UI;using QFramework;namespace QFramework.Example&#123; public partial class UILoginView &#123; [SerializeField] public Button BtnLogin; [SerializeField] public InputField Username; [SerializeField] public InputField Password; public void Clear() &#123; BtnLogin = null; Username = null; Password = null; &#125; public override string ComponentName &#123; get &#123; return "UILoginView";&#125; &#125; &#125;&#125; 结构与之前的 UIHomePanel 非常相似。 接下来，就可以写一些与子模块相关的逻辑了，关于 UIElement 的基本使用就介绍到这里。 接下来是设计初衷的部分。 UIElement 设计初衷 设计的初衷其实非常简单，就是在没有 UIElement 之前，一个 UIPanel 中的代码经常要管理数十个子控件。在这样的脚本里写代码体验会非常糟糕，bug 频出，所以为了解决这个问题，UIElement 就诞生了，可以让一些职责迁移到子控件里。 今天的内容就这些。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>QFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第17章-反射和特性]]></title>
    <url>%2F2019%2F07%2F29%2F%E7%AC%AC17%E7%AB%A0-%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 特性（attribute）的作用是在程序集中插入额外的元数据，并将元数据同编程构造（比如类、方法或者属性）关联起来。本章探讨了特性的细节，并描述了如何创建自定义特性。自定义特性要用起来就必须能被识别。这是通过反射（reflection）来实现的。本章首先讨论了反射，其中包括如何用它在运行时实现动态绑定，以及如何在编译时利用一个成员的名称来调用该成员。在像代码生成器这样的工具中，会频繁地执行这个操作。除此之外，在执行时调用目标未知的情况下，也要用到反射。 反射可以利用反射做下面这些事情。 访问程序集中类型的元数据。其中包括像完整类型名和成员名这样的构造，以及对一个构造进行修饰的任何特性。 使用元数据，在运行时动态调用一个类型的成员，而不是执行编译时绑定。 反射是指对程序集中的元数据进行检查的过程。在以前，当代码编译成一种机器语言时，关于代码的所有元数据（比如类型和方法名）都会被丢弃。相反，当C#编译成CIL时，它会维持关于代码的大部分元数据。除此之外，可以利用反射枚举程序集中的所有类型，找出满足特定条件的那些。我们通过System. Type的实例来访问类型的元数据，该对象包含了对类型实例的成员进行枚举的方法。除此之外，可在被检查类型的特定对象上调用那些成员。 基于反射，人们发展出了一系列前所未有的编程模式。例如，反射允许枚举程序集中的所有类型及其成员。在这个过程中，可以创建对程序集API进行编档所需的存根（stub）。然后，可将通过反射获取的元数据与通过XML注释（使用/doc开关）创建的XML文档合并，从而创建API文档。类似地，程序员可以利用反射元数据来生成代码，从而将业务对象（business object）持久化（序列化）到数据库中。可以在显示对象集合的列表控件中使用反射。基于这个集合，列表控件可以利用反射来遍历集合中的一个对象的所有属性，并在列表中为每个属性都定义一个列。除此之外，通过调用每个对象的每个属性，列表控件可以使用对象中包含的数据来填充每一行和每一列——即使对象的数据类型在编译时是未知的。 .NET Framework所提供的XmlSerializer、ValueType和DataBinder类均在其实现中利用了反射技术。 使用System.Type访问元数据读取类型的元数据，关键在于获得System.Type的一个实例，它代表了目标类型实例。System.Type提供了获取类型信息的所有方法。可以用它回答以下问题。 类型的名称是什么（Type.Name）？ 类型是public的吗（Type.IsPublic）？ 类型的基类型是什么（Type.BaseType）？ 类型支持任何接口吗（Type.GetInterfaces ()）？ 类型是在哪个程序集中定义的（Type.Assembly）？ 类型的属性、方法、字段是什么（Type.GetProperties()、Type.GetMethods()、Тype.GetFields()）？ 都有什么特性在修饰一个类型（Type.GetcustomAttributes()）？ 还有其他成员未能一列出，但总而言之，它们都提供了与特定类型有关的信息。很明显，现在的关键是获得对类型的Type对象的引用。我们主要通过object.GetType()和typeof()来达到这个目的。 注意GetMethods()调用不能返回扩展方法，扩展方法只能作为实现类型的静态成员使用。 1.GetType() object包含一个GetType()成员。因此，所有类型都包含该方法。调用GetType()可获得与原始对象对应的System.Type实例。代码清单1对此进行了演示，它使用来自DateTime的一个Type实例。输出1展示了结果。 代码清单1 使用Type.GetProperties()获取对象的public属性 123456DateTime dateTime = new DateTime();Type type = dateTime.GetType();foreach(System.Reflection.PropertyInfo property in type.GetProperties())&#123; Console.WriteLine(property.Name);&#125; 输出17-1 12 在调用了GetType()之后，程序遍历从Type.GetProperties()返回的每个System.Reflection.PropertyInfo实例，并显示属性名。成功调用GetType()的关键在于获得一个对象实例。但在某些时候，这样的实例是无法获得的。例如，静态类是无法实例化的，所以没办法调用GetType()。 2.typeof() 获得Type对象的另一个办法是使用typeof表达式。typeof在编译时绑定到特定的Type实例，并直接获取类型作为参数。代码清单2演示了如何同时使用Enum.Parse()和typeof。 代码清单2使用typeof()创建System.Type实例 12345using System.Diagnostics;// ... ThreadPriorityLevel priority; priority = (ThreadPriorityLevel)Enum. Parse(typeof(ThreadPriorityLevel), "Idle");// ... Enum.Parse()获取标识了一个枚举的Type对象，然后将一个字符串转换成特定的枚举值。在本例中，它将”Idle”转换成System.Diagnostics.ThreadPriorityLevel.Idle. 成员调用反射并非仅可以用来获取元数据。下一步是获取元数据，并动态调用它引用的成员。假定现在定义一个类，代表一个应用程序的命令行，并把它命名为CommandLineinfo。对于这个类来说，最困难的地方在于如何在类中填充启动应用程序时的实际命令行数据。然而，利用反射，可以将命令行选项映射到属性名，并在运行时动态设置属性。代码清单3对此进行了演示。 代码清单3 动态调用成员 12 虽然这是一个较长的程序，但代码结构是相当简单的。Main()首先实例化一个CommandLineInfo类。这个类型专门用来包含当前这个程序的命令行数据。每个属性都对应于程序的一个命令行选项，具体的命令行如输出2所示。 输出17-2 12 CommandLineInfo对象被传给CommandLineHandler的TryParse()方法。该方法首先枚举每个选项，并分离出选项名（比如Help或out）。在确定了名称之后，代码在CommandLineInfo对象上执行反射，查找同名的一个实例属性。如果找到这样的属性，就通过一个SetValue ()调用，并指定与属性类型对应的数据，从而完成对属性的赋值。SetValue()的参数包括要设置值的对象、新值以及一个额外的index参数（除非属性是一个索引器，否则该参数就为null）。上述代码能处理3种属性类型：bool、string和枚举。在枚举的情况下，我们要解析选项值，并将文本的枚举等价值赋给属性。如果TryParse()调用成功，方法会退出，而CommandLineInfo对象会使用来自命令行的数据进行初始化。 有趣的是，虽然commandLineinfo是嵌套在Program中的一个private类，但CommandLineHandler在它上面执行反射没有任何问题，甚至可以调用它的成员。换言之，只要设置了恰当的代码访问安全性（code access security, CAS）权限，反射就可以绕过可访问性规则。例如，假定out是private的，TryParse()方法仍然可以向其赋值。由于这一点，所以可以将CommandLineHandler转移到一个单独的程序集中，并在多个程序之间共享它，而且每个程序都有它们自己的command Linennfo类。 在这个特定的例子中，是用PropertyInfo.SetValue()来调用CommandLineInfo的一个成员。此外，PropertyInfo还包含一个Getvalue()方法，可以用它从属性中获取数据。然而，对于方法，有一个MethodInfo类可供利用，该类提供了一个Invoke()成员。MethodInfo和PropertyInfo都是从MemberInfo继承的(虽然并非直接)，如图1所示。 在这个例子中，之所以设置CAS权限来允许私有成员调用，是因为程序是从本地电脑中运行的。默认情况下，本地安装的程序是受信任区域的一部分，已被授予了恰当的权限。然而，从一个远程位置运行的程序需要被显式授予这样的权限。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#本质论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第16章-构建自定义集合]]></title>
    <url>%2F2019%2F07%2F29%2F%E7%AC%AC16%E7%AB%A0-%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： tE14章讨论了标准查询操作符，它们是由IEnumerableT&gt;提供的一套扩展方法，宋适合所有集合。但是，这并不能使所有集合都适合所有任务。我们仍然需要不同的集合类型。有的集合适合根据键来搜索，有的则适合根据位置来访问。有的集合具有“先入先出”的队列行为，有的则更像“先入后出”的栈。还有一些根本没有顺序。 NET Framework针对多种不同的使用场合定义了一系列集合。本章将介绍部分集合类型及其实现的接口。本章还介绍了如何创建自定义集合来支持标准集合功能(比如索引)。除此之外，本章还讨论了如何用yield return语句创建类和方法来实现IEnumerablecT&gt;。利用这个C#2.0引入的特性，可以简单地实现能由foreach语句遍历的集合。 NET Framework中有许多非泛型集合类和接口，但它们主要是为了向后兼容。泛型集合类不仅更快(因为避免了装箱开销) ，还更加类型安全。所以，新代码应该总是使用泛型集合类。本书假定你主要使用泛型集合类型。 更多集合接口前面讨论了集合如何实现IEnumerablecT&gt;，这是实现集合元素遍历功能的主要接口。更复杂的集合实现了其他许多接口。图16-1展示了集合类实现的接口的层次结构。 这些接口提供了一种标准的方式来执行常规任务，包括遍历、索引和计数。本节将讨论这些接口(至少所有泛型版本)，先从图16-1底部的接口开始，然后逐渐上移。 IList IDictionary&lt;Tкey， Tvalue&gt;可将英语字典看成是一个定义集合;查找“键” (被定义的单词) )即可快速找到定义。类似地，字典集合类是值的集合;每个值都可通过关联的、唯一的键来快速访问。但要注意，英语字典一般按照“键”的字母顺序存储定义。字典类也可选择这样，但一般都没有。最好将字典集合看成是键及其关联值的无序列表，除非文档专门指定了排序方式。类似地，一般不说查找”字典的第6个定义” ;字典类一般只按照键进行索引，而不按位置索引。 列表则相反，它按特定顺序存储值并按位置访问它们。从某种意义上说，列表是字典的一个特例，其中“键”总是一个整数， “键集”总是从0开始的非负整数的一个连续集合。但是，由于两者存在重大差异，所以有必要用一个完全不同的类来表示列表。 所以，选择集合类来解决数据存储或者数据获取问题时，首先要考虑的两个接口就是IList和IDictionaryTKey， Tvalue&gt;。这两个接口决定了集合类型是侧重于通过位置索引来获取值，还是侧重于通过键来获取值。 实现这两个接口的类都必须提供索引器。对于1List来说，索引器”的操作数是要获取的元素的位置:索引器获取一个整数，以便你访问列表中的第n个元素。对于IDictionary&lt;Tkey， Tvalue&gt;来说，索引器的操作数是和一个值关联的键，以便你访问那个值。 ICollectionIList和IDictionary&lt;Tkey， TValue)都实现了ICollection。此外，即使集合没有实现LList或IDictionary&lt;TKey， Tvalue&gt;，也极有可能实现了1collection (但并非绝对，因为集合可以实现要求较少的IEnumerable或IEnumerable ) ，ICollection&lt;T是从IEnumerable派生的，包含两个成员: Count和CopyTo()。 Count属性返回集合中的元素总数。从表面来看，只需要用一个for循环就可以遍历集合的每个元素。但是，要真正做到这一点，集合还必须支持按索引来获取(检索)值，而这个功能是ICollection接口不包括的(虽然IList(T)包括)。 CopyTo()方法允许将集合转换成数组。该方法包含一个index参数，允许指定在目标数组的什么位置插入元素。注意，要使用这个方法，必须初始化目标数组并使其具有足够大的容量:从index开始，一直到能装下1collection(T)中的所有元素。 主要集合类共有5类关键的集合类，它们的区别在于数据的插入、存储以及获取的方式。所有泛型类都位于System. Collections .Generic命名空间，等价的非泛型版本位于System.collections命名空间。 列表集合: ListList类具有与数组相似的属性。关键区别是随着元素数量的增多，这种类会自动扩展(与之相反，数组的长度是固定的)。此外，列表可以通过显式调用TrimTosize()或Capacity来缩小(参见图16-2)。 这种类称为列表集合，其独特功能是每个元素都可根据索引来单独访问，这和数组一样。因此，可以使用索引器来设置和访问列表集合类中的元素，索引参数值对应于元素在集合中的位置。代码清单16-1展示了一个例子，输出16-1展示了结果。 C#的索引是基于零的，代码清单16-2中的索引0对应第一个元素，而索引6对应第七个元素。按索引获取元素不会造成搜索操作，而只需快速和简单地“跳”到一个内存位置。List是有序集合。Add()方法将指定的项添加到列表末尾。所以在代码清单16-1中，在调用Sort()之前， “Sneezy”是第一项，而”Grumpy”是最后一项。调用sort()之后，列表按字母顺序排序，而不是按添加时的顺序。有的集合能在元素添加时自动排序，但List不能;显式调用Sort()方能使元素得以排序。 移除元素使用的是Remove()或者RemoveAt()方法，它们用于移除指定元素，或者移除指定索引位置的元素。高级主题:自定义集合排序 你可能好奇代码清单16-1的List&lt;T .Sort()方法是如何知道按字母顺序对列表元素进行排序的呢? string类型实现了IComparable string&gt;接口，它有一个CompareTo()方法。这个方法返回一个整数，指出所传递的元素是大于、小于还是等于当前元素。如果元素类型实现了泛型IComparablexT)接口或者非泛型IComparable接口，排序算法默认就用它来决定排序顺序。 但是，假如元素类型没有实现IComparableT)，或者默认的比较逻辑不符合要求，又该怎么办呢?为了指定非默认的排序顺序，可以调用List.Sort ()的一个重载版本，它获取一个IComparer&lt;T)作为实参。 IComparablecT)和IComparer&lt;T》的区别很细微，但却很重要。前者说“我知道如何将我自己和我的类型的另一个实例进行比较” ，后者说“我知道如何比较给定类型的两个实例” 如果可以采取多种方式对一个数据类型进行排序，但没有哪一种占有绝对优势，就适合使用IComparer&lt;T)接口。例如， contact对象集合可能按姓名、地点、生日、地区或者其他许多条件来排序。这时不该选择让一个contact类来实现IComparable，而应该创建多个不同的类来实现IComparer。代码清单16-2展示了比较LastName和FirstName的一个示例实现。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#本质论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命名空间和程序集]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%9B%86%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： C#的编译过程是什么样的？ VS中的解决方案与项目是什么关系？ 什么是类库？扩展名是.exe吗？如何创建类库？如何引用类库？ 程序集和类库有什么区别？ 什么是命名空间？为什么要使用命名空间？如何使用命名空间？ 程序集包含哪四个部分？ 什么是强命名和弱命名程序集？有什么区别？ 如何创建强命名程序集？ 什么是私有程序集？ 本章涵盖： 引用其他程序集 命名空间 using指令 程序集的结构 程序集标识符 强命名程序集 程序集的私有方式部署 共享程序集和GAC 配置文件 延迟签名 引用其他程序集之前的学习中，我们在高层次上观察了编译过程。编译器接受源代码文件并生称名称为程序集的输出文件。这一章中，我们将详细阐述程序集以及它们是如何生成和部署的。你还会看到命名空间是如何帮助组织类型的。 在迄今为止所看到的所有程序中，大部分都声明并使用它们自己的类。然而，在许多项目中，你会想使用来自其他程序集的类或类型。这些其他的程序集可能来自BCL，或来自一个第三方供应商，或你自己创建了它们。这些程序集称为类库，而且它们的程序集文件的名称通常以.dll扩展名结尾而不是.exe扩展名。 例如，假设你想创建一个类库，它包含可以被其他程序集使用的类和类型。一个简单库的源代码如下面示例中所示，它包含在名称为SuperLib.cs的文件中。该库含有单独一个名称为SquareWidget的公有类。图1阐明了DLL的生成。 123456789// SuperLib.cspublic class SquareWidget&#123; public double SideLength = 0; public double Area &#123; get &#123; return SideLength * SideLength; &#125; &#125;&#125; 图1 SuperLib源代码和结果程序集 要使用Visual Studio创建类库，要在已安装的Windows模板中创建类库模板。具体来说，在Visual Studio中进行的操作步骤如下。 (1)选择File-&gt;New-&gt;Project，然后会打开New Project窗口。 (2)左边的面板，在Installed-&gt;Templates面板中找到Visual C#节点并选中。 (3)在中间的面板中选择Class Library模板。 如果选择的是Console Application（控制台应用程序），则生成的是exe。 假设你还要写一个名称为MyWidgets的程序，而且你想使用SquareWidget类。程序的代码在一个名称为MyWidgets.cs的文件中，如下面的示例所示。这段代码简单创建一个类型为SquareWidget的对象并使用该对象的成员。 12345678910111213141516// MyWidgets.csusing System;public class WidgetsProgram&#123; static void Main() &#123; SquareWidget sq = new SquareWidget(); // 来自类库 // ↑ 未在当前程序集中声明 sq.SideLength = 5.0; // 设置边长 Console.WriteLine(sq.Area); // 输出该区域 // ↑ 未在当前程序集中声明 &#125;&#125; 注意，这段代码没有声明类SquareWidget。相反，使用的是定义在SuperLib中的类。然而，当你编译MyWidgets程序时，编译器必须知道你的代码在使用程序集Superlib，这样它才能得到关于类SquareWidget的信息。要实现这点，需要给编译器一个到该程序集的引用，给出它的名称和位置。 在Visual Studio中，可以用下面的方法把引用添加到项目。 选择Solution Explorer，并在该项目名下找到References目录。References目录包含项目使用的程序集的列表。 右键单击References目录并选择Add Reference。有5个可以从中选择的标签页，允许你以不同的方法找到类库 对于我们的程序，选择Browse标签，浏览到包含SquareWidget类定义的DLL文件，并选择它。 点击OK按钮，引用就被加入到项目了。 在添加了引用之后，可以编译MyWidgets了。图2阐明了全部的编译过程。 图2 引用另一个程序集 mscorlib库 有一个类库，我几乎在先前的每一个示例中都使用它。它就是包含Console类的那个库。Console类被定义在名称为mscorlib的程序集中，在名称为mscorlib.dll的文件里。然而，你不会看到这个程序集被列在References目录中。程序集mscorlib.dll含有C#类型以及大部分.NET语言的基本类型的定义。在编译C#程序时，它必须总是被引用，所以Visual Studio不把它显示在References目录中。 如果算上mscorlib，MyWidgets的编译过程看起来更像图3所示的表述。在此之后，我会假定使用mscorlib程序集而不再描述它。 图3 引用类库 现在假设你的程序已经很好地用SquareWidget类工作了，但你想扩展它的能力以使用一个名称为CircleWidget的类，它被定义在另一个名称为UltraLib的程序集中。MyWidgets的源代码看上去像下面这样。它创建一个SquareWidget对象和一个CircleWidget对象，它们分别定义在SuperLib中和UltraLib中。 12345678public class WidgetsProgram&#123; static void Main() &#123; SquareWidget sq = new SquareWidget(); // 来自SuperLib CircleWidget circle = new CircleWidget(); // 来自UltraLib &#125;&#125; 类库UltralLib的源代码如下面的示例所示。注意，除了类CircleWidget之外，就像库SuperLib，它还声明了一个名称为SquareWidget的类。可以把UltraLib编译成一个DLL并加入到项目MyWidgets的引用列表中。 12345678910111213public class SquareWidget&#123; ...&#125;public class CircleWidget&#123; public double Radius = 0; public double Area &#123; get &#123;...&#125; &#125;&#125; 因为两个库都含有名称为SquareWidget的类，当你试图编译程序MyWidgets时，编译器产生一条错误消息，因为它不知道使用类SquareWidgets的哪个版本。图4阐明了这种命名冲突。 图4 由于程序集SuperLib和UltraLib都含有名称为SquareWidget的类的声明，编译器不知道实例化哪一个 命名空间官方Namespaces 在MyWidgets示例中，由于你有源代码，你能通过在SuperLib源代码或UltraLib源代码中仅仅改变SquareWidget类的名称来解决命名冲突。但是，如果这些类是由不同的公司开发的，而且你还不能拥有源代码会怎么样呢？假设SuperLib由一个名称为MyCorp的公司生产，Ultralib由ABCCorp公司生产。在这种情况下，如果你使用了任何有冲突的类或类型，你将不能把这两个库放在一起使用。 你能想象得出，在你做开发的机器上含有数打（如果不是几百个的话）不同的公司生产的程序集，很可能有一定数量的类名重复。如果仅仅因为它们碰巧有共同的类型名，不能把两个程序集用在一个程序中，这将很可惜。 但是，假设MyCorp有一个策略，让所有类的前缀都是公司名字加上类产品名和描述名。并且进一步假设ABCCorp也有相同的策略。这样的话，我们示例中的3个类名就可能是MyCorpSuperLibSquareWidget、ABCCorpUltraLibSquareWidget和ABCCorpUltraLibCircleWidget，如图5所示。这当然是完全有效的类名，并且一个公司类库的类不太可能与其他公司类库的类发生冲突。 图5 有了消除歧义的字符串前缀，类库之间不会有冲突 但是，在我们的示例程序中，需要使用冗长的名字，看上去如下所示： 12345678class WidgetsProgram&#123; static void Main() &#123; MyCorpSuperLibSquareWidget sq = new MyCorpSuperLibSquareWidget(); // 来自SuperLib ABCCorpUltraLibCircleWidget circle = new ABCCorpUltraLibCircleWidget(); // 来自UltraLib &#125;&#125; 尽管这可以解决冲突问题，但是即使有智能感知，这些新的、已消除歧义的名字还是难以阅读并且容易出错。 不过，假设除了标识符中一般允许的字符，还可以在字符串中使用点——尽管不是在类名的最前面或最后面，那么这些名字就更好理解了，比如MyCorp.SuperLib.SquareWidget、ABCCorp.UltraLib.SquareWidget及ABCCorp.UltraLib.CircleWidget。现在代码看上去如下所示： 12345678class WidgetsProgram&#123; static void Main() &#123; MyCorp.SuperLib.SquareWidget sq = new MyCorp.SuperLib.SquareWidget(); // 来自SuperLib ABCCorp.UltraLib.CircleWidget circle = new ABCCorp.UltraLib.CircleWidget(); // 来自UltraLib &#125;&#125; 这就给了我们命名空间名和命名空间的定义。 你可以把命名空间名视为一个字符串（在字符串中可以使用点），它加在类名或类型名的前面并且通过点进行分隔。 包括命名空间名、分隔点，以及类名的完整字符串叫做类的完全限定名。 命名空间是共享命名空间名的一组类和类型。 图6演示了这些定义。 图6 命名空间是共享同一命名空间名的一组类型定义 你可以使用命名空间来把一组类型组织在一起并且给它们起一个名字。一般而言，命名空间名描述的是命名空间中包含的类型，并且和其他命名空间名不同。 你可以通过在包含你的类型声明的源文件中声明命名空间，从而创建命名空间。如下代码演示了声明命名空间的语法。然后在命名空间声明的大括号中声明你的所有类和其他类型。那么这些类型就是这个命名空间的成员了。 12345// ↓ 关键字 ↓ 命名空间名namespace NamespaceName&#123; TypeDeclarations &#125; 如下代码演示了MyCorp的程序员如何创建MyCorp.SuperLib命名空间以及声明其中的SquareWidget类。 12345678910111213// ↓ 公司名 namespace MyCorp.SuperLib&#123; // ↑ 点 public class SquareWidget &#123; public double SideLength = 0; public double Area &#123; get&#123; return SideLength * SideLength; &#125; &#125; &#125;&#125; 当MyCorp公司给你配上更新的程序集时，你可以通过按照如下方式修改MyWidgets程序来使用它。 123456789101112class WidgetsProgram&#123; static void Main() &#123; // MyCorp.SuperLib.SquareWidget是完全限定名 // MyCorp.SuperLib是命名空间名 // SquareWidget是类名 MyCorp.SuperLib.SquareWidget sq = new MyCorp.SuperLib.SquareWidget(); CircleWidget circle = new CircleWidget(); ... &#125;&#125; 既然你在代码中显式指定了SquareWidget的SuperLib版本，编译器不会再有区分类的问题了。完全限定名称输入起来有点长，但至少你现在能使用两个库了。在本章稍后，会阐述using别名指令以解决不得不在完全限定名称中重复输入的麻烦。 如果UltraLib程序集也被生产它的公司（ABCCorp）使用命名空间更新，那么编译过程会如图7所示。 图7 带命名空间的类库 命名空间名称如你所见，命名空间的名称可以包含创建该程序集的公司的名称。除了标识公司以外，该名称还用于帮助程序员快速了解定义在命名空间内的类型的种类。关于命名空间名称的一些要点如下。 命名空间名称可以是任何有效标识符。 另外，命名空间名称可以包括句点符号，用于把类型组织成层次。 例如，表1列出了一些在.NET BCL中的命名空间的名称。 表1 来自BCL的命名空间示例 System System.IO System.Data Microsoft.CSharp System.Drawing Microsoft.VisualBasic 下面是命名空间命名指南： 使用公司名开始命名空间名称； 在公司名之后跟着技术名称； 不要把命名空间命名为与类或类型相同的名称。 例如，Acme Widget公司的软件开发部门在下面3个命名空间中开发软件，如下面的代码所示： AcmeWidgets.SuperWidget AcmeWidgets.Media AcmeWidgets.Games 12345namespace AcmeWidgets.SuperWidget&#123; class SPDBase... ...&#125; 命名空间的补充关于命名空间，有其他几个要点应该知道。 在命名空间内，每个类型名必须有别于所有其他类型。 命名空间内的类型称为命名空间的成员。 一个源文件可以包含任意数目的命名空间声明，可以顺序也可以嵌套。 图8在左边展示了一个源文件，它顺序声明了两个命名空间，每个命名空间内有几个类型。注意，尽管命名空间内含有几个共有的类名，它们被命名空间名称区分开来，如右边的程序集所示。 图8 多个命名空间在一个源文件中 .NET框架BCL提供了数千个已定义的类和类型以供生成程序时选择。为了帮助组织这组有用的功能，相关功能的类型被声明在相同的命名空间里。BCL使用超过100个命名空间来组织它的类型。 命名空间跨文件伸展命名空间不是封闭的。这意味着可以在该源文件的后面或另一个源文件中再次声明它，以对它增加更多的类型声明。 例如，图9展示了三个类的声明，它们都在相同的命名空间中，但声明在分离的源文件中。源文件可以被编译成单一的程序集，如图9所示，或编译成外离的程序集，如图10所示。 图9 命名空间可以跨源文件伸展并编译成单一程序集 图10 命名空间可以跨源文件伸展并编译成分离的程序集 嵌套命名空间命名空间可以被嵌套，从而产生嵌套的命名空间。嵌套命名空间允许你创建类型的概念层次。有两种方法声明一个嵌套的命名空间，如下所示。 原文嵌套可以把命名空间的声明放在一个封装的命名空间声明体内部，从而创建一个嵌套的命名空间。图11的左边阐明了这种方法。在这个示例中，命名空间OtherNs嵌套在命名空间MyNamespace中。 分离的声明也可以为嵌套命名空间创建分离的声明，但必须在声明中使用它的完全限定名称。图11的右边阐明了这种方法。注意在嵌套命名空间OtherNs的声明中，使用全路径命名MyNamespace.OtherNs. 图11 声明嵌套命名空间的两种形式是等价的 图11所示的两种形式的嵌套命名空间声明生成相同的程序集，如图12所阐明的。该图展示了两个声明在SomeLib.cs文件中的类，使用它们的完全限定名。 图12 嵌套命名空间结构 虽然嵌套命名空间位于父命名空间内部，但是其成员并不属于包裹的父命名空间。有一个常见的误区，认为既然嵌套的命名空间位于父命名空间内部，其成员也是父命名空间的子集，这是不正确的，命名空间之间是相互独立的。 using指令完全限定名可能相当长，在代码中通篇使用它们会变得十分乏味。然而，有两个编译器指令，可以使你避免不得不使用完全限定名：using命名空间指令和using别名指令。关于using指令的两个要点如下。 它们必须放在源文件的顶端，在任何类型声明之前。 它们应用于当前源文件中的所有命名空间。 using命名空间指令在MyWidgets示例中，你看到多个部分使用完全限定名称指定一个类。可以通过在源文件的顶端放置using命名空间指令以避免不得不使用长名称。 using命名空间指令通知编译器你将要使用来自某个指定命名空间的类型。然后你可以继续，并使用简单类名而不必全路径修饰它们。 当编译器遇到一个不在当前命名空间的名称时，它检查在using命名空间指令中给出的命名空间列表，并把该未知名称加到列表中的第一个命名空间后面。如果结果完全限定名称匹配了这个程序集或引用程序集中的一个类，编译器将使用那个类。如果不匹配，那么它试验列表中下一个命名空间。 using命名空间指令由关键字using跟着一个命名空间标识符组成。 123// ↓ 关键字using System;// ↑ 命名空间的名称 一个已经在通篇文字中使用的方法是WriteLine方法，它是类Console的成员，在System命名空间中。不是在通篇代码中使用它的完全限定名，我只是简化了一点我们的工作，在代码的顶端使用using命名空间指令。 例如，下面的代码在第一行使用using命名空间指令以描述该代码使用来自System命名空间的类或其他类型。 1234using System; // using命名空间指令...System.Console.WriteLine("This is text 1"); // 使用完全限定名称Console.WriteLine("This is text 2"); // 使用指令 using别名指令using别名指令允许起一个别名给： 命名空间； 命名空间内的一个类型。 例如，下面的代码展示了两个using别名指令的使用。第一个指令告诉编译器标识符Syst是命名空间System的别名。第二个指令表明标识符SC是类System.Console的别名。 1234// ↓ 关键字 ↓ 命名空间using Syst = System;using SC = System.Console;// ↑ 别名 ↑ 类 下面的代码使用这些别名。在Main中3行代码都调用System.Console.WriteLine方法。 Main的第一条语句使用命名空间（System）的别名。 第二条语句使用该方法的完全限定名。 第三条语句使用类（Console）的别名。 1234567891011121314151617using Syst = System; // using别名指令using SC = System.Console; // using别名指令namespace MyNamespace&#123; class SomeClass &#123; static void Main() &#123; // ↓ 命名空间的别名 Syst.Console.WriteLine(); System.Console.WriteLine() SC.WriteLine(); // ↑ 类的别名 &#125; &#125;&#125; 程序集的结构程序集不包含本地机器代码，而是公共中间语言代码。它还包含实时编译器（JIT）在运行时转换CIL到本机代码所需的一切，包括对它所引用的其他程序集的引用。程序集的文件扩展名通常为.exe或.dll. 大部分程序集由一个单独的文件构成。图13阐明了程序集的4个主要部分。 程序集的清单（manifest）包含以下几点。 程序集名称标识符。 组成程序集的文件列表。 一个指示程序集中内容在哪里的地图。 关于引用的其他程序集的信息。 类型元数据部分包含该程序集中定义的所有类型的信息。这些信息包含关于每个类型要知道的所有事情。 CIL部分包含程序集的所有中间代码。 资源部分是可选的，但可以包含图形或语言资源。 图13 单文件程序集的结构 程序集代码文件称为模块。尽管大部分程序集由单文件组成，但有些也有多个文件。对于有多个模块的程序集，一个文件是主模块（primary module），而其他的是次要模块（secondary modules）。 主模块含有程序集的清单和到次要模块的引用。 次要模块的文件名以扩展名.netmodule结尾。 多文件程序集被视为一个单一单元。它们一起部署并一起定版。 图14闸明了一个带次要模块的多文件程序集。 图14 多文件程序集 程序集标识符在.NET框架中，程序集的文件名不像在其他操作系统和环境中那么重要，更重要的是程序集的标识符（identity）。 程序集的标识符有4个组成部分，它们一起唯一标识了该程序集，如下所示。 简单名 这只是不带文件扩展名的文件名。每个程序集都有一个简单名。它也被称为程序集名或友好名称( friendly name )。 版本号 它由4个句点分开的整数字符串组成，形式为MajorVersion.MinorVersion.Build.Revision，例如2.0.35.9. 文化信息 它是一个字符串，由2-5个字符组成，代表一种语言，或代表一种语言和一个国家或地区。例如，在美国使用英语的文化名是en-US。在德国使用德语，它是de-DE。 公钥 这个128字节字符串应该是生产该程序集的公司唯一的。 公钥是公钥/私钥对的一部分，它们是一组两个非常大的、特别选择的数字，可以用于创建安全的数字签名。公钥，顾名思义，可以被公开。私钥必须被拥有者保护起来。公钥是程序集的标识符的一部分。我们稍后会在本章看到私钥的使用。 程序集名称的组成被包含在程序集清单中。图15阐明了清单部分。 图15 清单中程序集标识符的组成部分 图16展示了用在.NET文档和书籍中的关于程序集标识符的一些术语。 图16 关于程序集标识符的术语 强命名程序集强命名（strongly named）程序集有一个唯一的数字签名依附于它。强命名程序集比没有强名称的程序集更加安全，原因有以下几点。 强名称唯一标识了程序集。没有其他人能创建一个与之有相同名称的程序集，所以用户可以确信该程序集来自于其声称的来源。 没有CLR安全组件来捕获更改，带强名称的程序集的内容不能被改变。 弱命名（weakly named）程序集是没有被强命名的程序集。由于弱命名程序集没有数字签名，它天生是不安全的。因为一根链的强度只和它最弱的一环相同，所以强命名程序集默认只能访问其他强命名程序集（还存在一种方法允许“部分地相信调用者”，但我不会阐述这个主题）。 程序员不产生强名称。编译器产生它，接受关于程序集的信息，并散列化（hash）这些信息以创建一个唯一的数据签名依附到该程序集。它在散列处理中使用的信息如下: 组成程序集的字节序列； 简单名称； 版本号； 文化信息； 公钥/私钥对。 创建强命名程序集 要使用Visual Studio强命名一个程序集，必须有一份公钥/私钥对文件的副本。如果没有密钥文件，可以让Visual Studio产生一个。可以实行以下步骤。(1)打开工程的属性。(2)选择签名页。(3)选择Sign the Assembly复选框并输入密钥文件的位置或创建一个新的。 在编译代码时，编译器会生成一个强命名的程序集。编译器的输入和输出在图17中阐明。 图17 创建强命名程序集 说明要创建强命名程序集还可以使用Strong Name工具（sn.exe），这个工具在安装Visual Studio的时候会自动安装。它是个命令行工具，允许程序员为程序集签名，还能提供大量管理密钥和签名的其他选项。如果Visual Studio IDE还不符合你的要求，它能提供更多选择。 程序集的私有方式部署在目标机器上部署一个程序就像在该机器上创建一个目录并把应用程序复制过去一样简单。如果应用程序不需要其他程序集（比如DLL），或如果所需的DLL在同一目录下，那么程序应该会就在它所在的地方良好工作。这种方法部署的程序集称为私有程序集，而且这种部署方法称为复制文件（XCopy）部署。 私有程序集几乎可以被放在任何目录中，而且只要它们依赖的文件都在同一目录或子目录下就足够了。事实上，可以在文件系统的不同部分有多个目录，每个目录都有同样的一组程序集，并且它们都会在它们各自不同的位置良好工作。关于私有程序集部署的一些重要事情如下。 私有程序集所在的目录被称为应用程序目录。 私有程序集可以是强命名的也可以是弱命名的。 没有必要在注册表中注册组件。 要卸载一个私有程序集，只要从文件系统中删除它即可。 共享程序集和GAC私有程序集是非常有用的，但有时你会想把一个DLL放在一个中心位置，这样一个单独的复制就能被系统中其他的程序集共享。.NET有这样的贮藏库，称为全局程序集缓存（GAC）。放进GAC的程序集称为共享程序集。 关于GAC的一些重要内容如下。 只有强命名程序集能被添加到GAC. GAC的早期版本只接受带.dll扩展名的文件，现在也可以添加带.exe扩展名的程序集了。 GAC位于Windows系统目录的子目录中。.NET4.0之前位于\Windows\Assembly中，从.NET4.0开始位于\Windows\Microsoft.NET\assembly中。 把程序集安装到GAC当试图安装一个程序集到GAC时，CLR的安全组件首先必须检验程序集上的数字签名是否有效。如果没有数据签名，或它是无效的，系统将不会把它安装到GAC. 然而，这是个一次性检查。在程序集已经在GAC内之后，当它被一个正在运行的程序引用时，不再需要进一步的检查。 gacutil.exe命令行工具允许从GAC添加或删除程序集，并列出GAC包含的程序集。它的3个最有用的参数标记如下所示 /i：把一个程序集插入GAC。 /u：从GAC卸载一个程序集。 /l：列出GAC中的程序集。 GAC内的并肩执行在程序集部署到GAC之后，它就能被系统中其他程序集使用了。然而，请记住程序集的标识符由完全限定名称的全部4个部分组成。所以，如果一个库的版本号改变了，或如果它有一个不同的公钥，这些区别指定了不同的程序集。 结果就是在GAC中可以有许多不同的程序集，它们有相同的文件名。虽然它们有相同的文件名，但它们是不同的程序集而且在GAC中完美地共存。这使不同的应用程序在同一时间很容易使用不同版本的同一DLL，因为它们是带不同标识符的不同程序集。这被称为并肩执行（side-by-side Execution）。 图18阐明了GAC中4个不同的DLL，它们都有相同的文件名MyLibary.dll。看这个图，可以看出前3个来自于同一公司，因为它们有相同的公钥，第4个来源不同，因为它有一个不同的公钥。这些版本如下: 英文V1.0.0.0版，来自A公司； 英文V2.0.0.0版，来自A公司； 德文V1.0.0.0版，来自A公司； 英文V1.0.0.0版，来自B公司。 图18 在GAC中4个不同的并肩DLL 配置文件配置文件含有关于应用程序的信息，供CLR在运行时使用。它们可以指示CLR去做这样的事情，比如使用一个不同版本的DLL，或搜索程序引用的DLL时在附加目录中查找。 配置文件由XML代码组成，并不包含C#代码。编写XML代码的细节超出了本书的范围，但应当理解配置文件的目的以及它们如何使用。它们的一种用途是更新一个应用程序集以使用新版本的DLL。 例如，假设有一个应用程序引用了GAC中的一个DLL。在应用程序的清单中，该引用的标识符必须完全匹配GAC中程序集的标识符。如果一个新版本的DLL发布了，它可以被添加到GAC中，在那里它可以幸福地和老版本共存。 然而，应用程序仍然在它的清单中包括老版本DLL的标识符。除非重新编译应用程序并使它引用新版本的DLL，否则它会继续使用老版本。如果这是你想要的，那也不错。 然而，如果你不想重新编译程序但又希望它使用新的DLL，那么你可以创建一个配置文件告诉CLR去使用新的版本而不是旧版本。配置文件被放在应用程序目录中。 图19阐明了运行时过程中的对象。左边的应用程序MyProgram.exe调用MyLibrary.dll的1.0.0.0版，如点化线箭头所示。但应用程序有一个配置文件，而它指示CLR加载2.0.0.0版。注意配置文件的名称由可执行文件的全名（包括扩展名）加上附加扩展名.config组成。 图19 使用配置文件绑定一个新版本 UnityUnity的Project的名字就是解决方案的名字。 Unity创建Project后并新建一个脚本后，VS中项目默认的名字是Assembly-CSharp。 引用下面的都是类库。例如System.dll。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#图解教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[反射和特性]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是元数据？.meta文件在Unity里是干嘛用的？ 反射是什么？有什么作用？ 使用反射需要哪个命名空间？ 本章涵盖： 元数据和反射 Type类 获取Type对象 什么是特性 应用特性 预定义的保留的特性 有关应用特性的更多内容 自定义特性 访问特性 元数据和反射大多数程序都要处理数据，包括读、写、操作和显示数据。然而，对于某些程序来说，它们操作的数据不是数字、文本或图形，而是程序和程序类型本身的信息。 有关程序及其类型的数据被称为元数据（metadata），它们保存在程序的程序集中。 程序在运行时，可以查看其他程序集或其本身的元数据。一个运行的程序查看本身的元数据或其他程序的元数据的行为叫做反射（reflection）。 对象浏览器是显示元数据的程序的一个示例。它可以读取程序集，然后显示所包含的类型以及类型的所有特性和成员。 本章将介绍程序如何使用Type类来反射数据，以及程序员如何使用特性来给类型添加元数据。 说明要使用反射，我们必须使用System.Reflection命名空间。 Type类之前已经介绍了如何声明和使用C#中的类型。包括预定义类型（int、long和string等），BCL中的类型（Console、IEnumerable等）以及用户自定义类型（MyClass、Mydel等），每一种类型都有自己的成员和特性。 BCL声明了一个叫做Type的抽象类，它被设计用来包含类型的特性。使用这个类的对象能让我们获取程序使用的类型的信息。 由于Type是抽象类，因此它不能有实例。而是在运行时，CLR创建从Type（RuntimeType）派生的类的实例，Type包含了类型信息。当我们要访问这些实例时，CLR不会返回派生类的引用而是Type基类的引用。但是，为了简单起见，在本章剩余的篇幅中，我会把引用所指向的对象称为Type类型的对象（虽然从技术角度来说是一个BCL内部的派生类型的对象）. 需要了解的有关Type的重要事项如下。 对于程序中用到的每一个类型， CLR都会创建一个包含这个类型信息的Type类型的对象。 程序中用到的每一个类型都会关联到独立的Type类的对象。 不管创建的类型有多少个实例，只有一个Type对象会关联到所有这些实例。 图1显示了一个运行的程序，它有两个MyClass对象和一个OtherClass对象。注意，尽管有两个MyClass的实例，只会有一个Type对象来表示它。 图1 对于程序中使用的每一个类型CLR都会实例化Type类型的对象 我们可以从Type对象中获取需要了解的有关类型的几乎所有信息。表1列出了类中更有用的成员。 表1 System.Type类部分成员 获取Type对象本节学习使用GetType方法和typeof运算符来获取Type对象。object类型包含了一个叫做GetType的方法，它返回对实例的Type对象的引用。由于每一个类型最终都是从object继承的，所以我们可以在任何类型对象上使用GetType方法来获取它的Type对象，如下所示: 1Type t = myInstance.GetType(); 下面的代码演示了如何声明一个基类以及从它派生的子类。Main方法创建了每一个类的实例并且把这些引用放在了一个叫做bca的数组中以方便使用。在外层的foreach循环中，代码得到了Type对象并且输出类的名字，然后获取类的字段并输出。图2演示了内存中的对象。 图2 基类和派生类对象以及它们的Type对象 12 我们还可以使用typeof运算符来获取Type对象。只需要提供类型名作为操作数，它就会返回Type对象的引用，如下所示: 12Type t = typeof( DerivedClass );// ↑ 运算符 ↑ 希望的Type对象的类型 下面的代码给出了一个使用typeof运算符的简单示例： 什么是特性特性（attribute）是一种允许我们向程序的程序集增加元数据的语言结构。它是用于保存程序结构信息的某种特殊类型的类。 将应用了特性的程序结构（program construct）叫做目标（target）。 设计用来获取和使用元数据的程序（比如对象浏览器）叫做特性的消费者（consumer）。 .NET预定了很多特性，我们也可以声明自定义特性。 图3是使用特性中相关组件的概览，并且也演示了如下有关特性的要点。 我们在源代码中将特性应用于程序结构。 编译器获取源代码并且从特性产生元数据，然后把元数据放到程序集中。 消费者程序可以获取特性的元数据以及程序中其他组件的元数据。注意，编译器同时生产和消费特性。 根据惯例，特性名使用Pascal命名法并且以Attribute后缀结尾。当为目标应用特性时，我们可以不使用后缀。例如，对于SerializableAttribute和MyAttributeAttribute这两个特性，我们在把它们应用到结构时可以使用Serializable和MyAttribute短名称。 应用特性我们先不讲解如何创建特性，而是看看如何使用已定义的特性。这样，你会对它们的使用情况有个大致了解。 特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集。我们可以通过把特性应用到结构来实现。 在结构前放置特性片段来应用特性。 特性片段被方括号包围，其中是特性名和特性的参数列表。 例如，下面的代码演示了两个类的开始部分。最初的几行代码演示了把一个叫做Serializable的特性应用到MyClass。注意，Serializable没有参数列表。第二个类的声明有一个叫做MyAttribute的特性，它有一个带有两个string参数的参数列表。 有关特性需要了解的重要事项如下: 大多数特性只针对直接跟随在一个或多个特性片段后的结构； 应用了特性的结构称为被特性装饰(decorated或adorned，两者都应用得很普遍). 预定义的保留的特性在学习如何定义自己的特性之前，本小节会先介绍几个.NET预定义特性。 obsolete特性一个程序可能在其生命周期中经历多次发布，而且很可能延续多年。在程序生命周期的后半部分，程序员经常需要编写类似功能的新方法替换老方法。出于多种原因，你可能不想再使用那些调用过时的旧方法的老代码，而只想用新编写的代码调用新方法。 如果出现这种情况，你肯定希望稍后操作代码的团队成员或程序员也只使用新代码。要警告他们不要使用旧方法，可以使用obsolete特性将程序结构标注为过期的，并且在代码编译时显示有用的警告消息。以下代码给出了一个使用的示例: 注意，即使Printout被标注为过期， Main方法还是调用了它。代码编译也运行得很好并且产生了如下的输出:Start of Main 不过，在编译的过程中，编译器产生了下面的CS0618警告消息来通知我们正在使用一个过期的结构:Attrobs.Program. PrintOut(string)’ is obsolete: ‘Use method SuperPrintOut’ 另外一个Obsolete特性的重载接受了bool类型的第二个参数。这个参数指定目标是否应该被标记为错误而不仅仅是警告。以下代码指定了它需要被标记为错误:标记为错误[ Obsolete(“Use method SuperPrintout”， true) ] //将特性应用到方法中static void Printout(string str) Conditional特性Conditional特性允许我们包括或排斥特定方法的所有调用。为方法声明应用Conditional特性并把编译符作为参数来使用。 如果定义了编译符号，那么编译器会包含所有调用这个方法的代码，这和普通方法没有什么区别。 如果没有定义编译符号，那么编译器会忽略代码中这个方法的所有调用。定义方法的CIL代码本身总是会包含在程序集中。只是调用代码会被插入或忽略。 例如，在如下的代码中，把Conditional特性应用到对一个叫做TraceMessage的方法的声明上。特性只有一个参数，在这里是字符串DoTrace. 当编译器编译这段代码时，它会检查是否有一个编译符号被定义为DoTrace. 如果DoTrace被定义，编译器就会像往常一样包含所有对TraceMessage方法的调用。 如果没有DoTrace这样的编译符号被定义，编译器就不会输出任何对TraceMessage的调用代码编译符号 123[Conditional( "DoTrace" )]static void TraceMessage(string str)tConsole.Writeline(str); Conditional特性的示，以下代码演示了一个使用Conditional特性的完整示例。 Main方法包含了两个对TraceMessage方法的调用。O TraceMessage方法的声明被用Conditional特性装饰，它带有DoTrace编译符号作为参数。因此，如果DoTrace被定义，那么编译器就会包含所有对TraceMessage的调用代码。 由于代码的第一行定义了叫做DoTrace的编译符，编译器会包含两个对TraceMessage的调用。 调用者信息特性调用者信息特性可以访问文件路径、代码行数、调用成员的名称等源代码信息。 这三个特性名称为CallerFilePath， CallerLineNumber和CallerMemberName。 这些特性只能用于方法中的可选参数。 下面的代码声明了一个名为MyTrace的方法，它在三个可选参数上使用了这三个调用者信息特性。如果调用方法时显式指定了这些参数，则会使用真正的参数值。但在下面所示的Main方法中调用时，没有显式提供这些值，因此系统将会提供源代码的文件路径、调用该方法的代码行数和调用该方法的成员名称。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#图解教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第10章-异常处理]]></title>
    <url>%2F2019%2F07%2F29%2F%E7%AC%AC10%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 多异常类型 捕捉异常 常规catch块 异常处理的规范 定义自定义异常 封装异常并重新引发 小结 第4章讨论了如何使用try/catch/finally块执行标准异常处理。在那一章中，catch块总是捕捉System.Exception类型的异常。本章描述了异常处理的更多细节，具体包括其他异常类型、定义自定义异常类型以及用于处理每种异常类型的多个catch。本章还详细描述了异常对继承的依赖。 多异常类型代码清单10-1引发System.ArgumentException异常，而不是如第4章所述的System.Exception类型的异常。C#允许代码引发从System.Exception派生（无论直接还是间接）的任何异常类型。 代码要引发任何异常，只需为要引发的异常实例附加关键字throw作为前缀。具体选择的异常类型应该能够最好地说明异常发生的背景。 下面以代码清单10-1的TextNumberParser.Parse()方法为例。 代码清单10-1 引发异常 12345678910111213141516public sealed class TextNumberParser&#123; // digit n. (从0到9的任何一个) 数字 public static int Parse(string textDigit) &#123; string[] digitText = &#123; "zero", "first", "two", "three", "four", "five", "six", "seven", "eight", "nine" &#125;; int result = Array.IndexOf(digitText, textDigit.ToLower()); if (result &lt; 0) &#123; throw new ArgumentException("The argument did not represent a digit", "textDigit"); &#125; return result; &#125;&#125; 程序不是引发System.Exception，而是引发更合适的ArgumentException，因为类型本身指出什么地方出错（参数异常），并包含了特殊的参数来指出具体是哪一个参数出错。 两个类似的异常是ArgumentNullException和NullReferenceException，前者应该在错误传递了null时引发。null是无效参数的特例。如果不为null，无效参数所引发的异常是ArgumentException或ArgumentOutOfRangeException，NullReferenceException一般只有在底层“运行时”解引用null值（想调用对象的成员，但发现对象的值为null）时引发。开发人员不要自己引发NullReferenceException。相反，应该在访问参数前检查它们是否为null，并在参数为null的前提下引发ArgumentNullException，从而提供更具体的上下文信息，如参数名等。 还有其他几个仅供“运行时”引发的、直接或间接从System.SystemException派生的异常，其中包括System.StackOverflowException，System.OutOfMemoryException，SystemRuntime.InteropServices.COMException，System.ExecutionEngineException和System.Runtime.InteropServices.SEHException，不要自己引发这些异常。类似地，不要引发System.Exception或System.ApplicationException，它们过于泛泛，对指明问题的起因和问题的解决提供不了太多帮助。相反，要引发符合场景的、最具体的派生的异常。虽然开发人员应避免创建可能造成系统错误的API，但假如代码的执行达到一种再执行就会不安全或者不可恢复的状态，就应该果断地调用System.Environemnt.FailFast()。这样做会向Windows Application事件日志写入一条消息，然后立即终止进程。如果用户事先进行了选择，消息还会发送给“Windows错误报告”。 规范要在向成员传递了错误参数时引发ArgumentException或者它的某个子类型。引发尽可能具体的异常（如ArgumentNullException）。要在引发ArgumentException或者它的某个子类时设置ParamName属性。要引发能说明问题的、最具体的异常（派生得最远的异常）。不要引发NullReferenceException，相反，在值意外为空时引发ArgumentNullException。不要引发System.SystemException或者它的派生类型。不要引发System.Exception或者System.ApplicationException.考虑在程序继续执行会变得不安全时调用System.Enviromment.FailFast()来终止进程。 捕捉异常引发特定的异常类型，可以通过异常类型本身来识别（并解决）问题。换言之，不需要捕捉异常并使用一个switch语句，根据异常消息来决定要采取的操作。相反，C#允许使用多个catch块，每个块都面向一个具体的异常类型，如代码清单10-2所示。 代码清单10-2 捕捉不同的异常类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;namespace TestException&#123; class Program &#123; static void Main(string[] args) &#123; try &#123; throw new InvalidOperationException("Arbitray exception");//Arbitray 任意的 &#125; catch (NullReferenceException exception) &#123; // Handle NullReferenceException &#125; catch (ArgumentException exception) &#123; // Handle ArgumentException &#125; catch (InvalidOperationException exception) &#123; // Handle ApplicationException &#125; catch (SystemException) &#123; // Handle SystemException &#125; catch (Exception exception) &#123; // Handle Exception &#125; catch &#123; // Any unhandle Exception &#125; finally &#123; // Handle any cleanup清理 code here as it runs regardless of an exception or not. // 无论异常与否，都可以在此处运行任何清理代码。 &#125; &#125; &#125;&#125; 代码清单10-2总共有5个catch块，每个块都处理不同的异常类型。发生异常时，会跳转到与异常类型最匹配的catch块执行。匹配度由继承链决定。例如，即使引发的是system.Exception类型的异常，由于System.InvalidOperationException派生自System.Exception，这个“属于”关系就在继承链中发生了。因此InvalidOperationException与引发的异常匹配度最高。最终，将由catch(InvalidOperationException …)捕捉到异常，而不是由catch(Exception …)块捕捉。 catch块必须按照从最具体到最常规的顺序排列，这样才能避免编译错误。例如，将catch(Exception …)块移到其他任何一种异常的前面，都会造成编译错误。因为之前的所有异常都直接或间接从System.Exception派生。 如catch(SystemException){}这个catch块所示， catch块并非一定需要一个命名的参数。事实上，如下一节所述，最后一个catch甚至连类型参数都可以不要。 注意，在捕捉InvalidOperationException的catch块中，有一个未注明要引发什么异常的throw语句（throw自己为一行语句）——虽然当前在catch块的范围内有一个异常实例（exception）可供重新引发。如果引发一个具体的异常，会更新所有栈信息来匹配新的引发位置。这会造成指示异常最初发生的调用位置的所有栈信息丢失，使问题变得更难诊断。有鉴于此，C#支持不带有显式异常引用的throw语句，前提是只能在catch块中使用。这样，代码可以检查异常，判断是否能完整地处理该异常；如果不能，就重新引发异常（虽然没有显式指定这个动作）。结果是异常似乎从未被捕捉，也没有任何栈信息被替换。 常规catch块C#要求代码引发的任何对象都必须从System.Exception派生。从C# 2.0开始，所有异常（不管是不是从system.Exception派生）在进入程序集之后，都会被“包装”成从System.Exception派生。结果是捕捉System.Exception的catch块现在可以捕捉之前的块不能捕捉的所有异常。 C#还支持常规catch块，即catch{}，它在行为上和catch(System.Exception exception)块完全一致，只是没有类型名或变量名。除此之外，常规catch块必须是所有catch块的最后一个。由于常规catch块在功能上完全等价于catch(System.Exception exception)块，而且必须放在最后，所以在同一个try/catch语句中，假如这两个catch块同时出现，编译器就会显示一条警告消息，因为常规catch块永远都得不到调用。 异常处理的规范异常处理为它之前的错误处理机制提供了急需的基本结构。然而，若使用不当，它仍有可能造成一些令人不快的后果。以下规范是异常处理的最佳实践。 只捕捉能处理的异常。通常，一些类型的异常可以处理，但另一些不能。例如，试图打开正在使用的文件进行独占式读/写访问，会引发一个System.IO.IOException，因为文件已经在使用中了。通过捕捉这种类型的异常，代码可以向用户报告该文件正在使用，并允许用户选择取消或者重试。只有那些已知操作的异常才应捕捉。其他异常类型应留给栈中较高的调用者去处理。 不要隐藏你不能完全处理的异常。新手程序员常犯的一个错误是捕捉所有异常，然后假装什么都没有发生，而不向用户报告未处理的异常。这有可能导致严重的系统问题逃过检测。除非代码执行显式的操作来处理一个异常，或者显式地确定一个异常无害，否则catch块应当重新引发异常，而不是在捕捉了异常之后在调用者面前隐藏它们。尤其要注意的是， catch(System.Exception)和常规catch块应放在调用栈中较高的位置，除非决定在块中重新引发异常。 尽可能少地使用System.Exception和常规catch块。几乎所有异常都是从System.Exception派生的。然而，处理某些system.Exception的最佳方式是不对它们进行处理，或者尽快以正常方式关闭应用程序。这些异常包括System.OutofMemoryException和System.StackoverflowException等。在CLR4中，这些异常默认为“不可恢复” 。所以，如果捕捉它们但不重新引发它们，会造成CLR重新引发它们。这些异常是运行时异常，开发人员不能写代码从这些异常中恢复。所以，最佳对策就是关闭应用程序–在CLR 4和更高版本中，这是“运行时”会强制采取的操作。CLR4之前的代码在捕捉这种异常后，也只应运行清理或紧急代码(比如保存任何易失的数据)，然后马上关闭应用程序，或者使用throw:语句重新引发异常 避免在调用栈较低的位置报告或记录异常。新手程序员倾向于异常一发生就记录它，或者向用户报告它。然而，由于当前正处在调用栈中较低的位置，而这些位置很少能够完整地处理异常，所以只好重新引发异常。像这样的catch块不应记录异常，也不应向用户报告。假如异常被记录，然后又被重新引发(调用栈中较高的调用者可能做同样的事情)，就会造成重复出现的异常记录项。更糟的是，取决于应用程序的类型，向用户显示异常可能并不合适。例如，在Windows应用程序中使用System.Console.writeLine ()，用户永远看不到显示的内容。类似地，在无人值守的命令行进程中显示对话框，可能根本不会被人看到，而且可能使应用程序冻结在这个位置。日志记录和与异常相关的用户界面应该保留到调用栈中较高的位置。 在catch块中使用throw;而不是throw &lt;异常对象&gt;语句。可以在catch块中重新引发异常。例如，在catch(ArgumentNu1IException exception)的实现中，可以包含对throw exception的调用。然而，像这样重新引发异常，会将栈追踪重置为重新引发的位置，而不是重用原始引发位置。所以，只要不是重新引发不同的异常类型，或者不是要故意隐藏原始调用栈，就应该使用throw;语句，允许相同的异常在调用栈中向上传播重新引发不同异常时要小心。在catch块中重新引发不同的异常，那么不仅会重置引发点，还会隐藏原始异常。为了保留原始异常，需要设置新异常的InnerException属性(该属性通常可以通过构造器来赋值)。只有以下情况才可以重新引发不同的异常。 a)更改异常类型可以更好地澄清问题。例如，在对Logon(User user)的一个调用中，假如遇到用户列表文件不能访问的情况，那么重新引发一个不同的异常类型要比传播5ystem. Io. IOException更合适。 b)私有数据是原始异常的一部分。在上面的例子中，假如文件路径包含在原始的System. Io. IOException中，就会暴露敏感的系统信息，所以应该使用其他异常类型来包装它。当然，前提是原始异常没有设置InnerException属性。有趣的是， CLR v1的一个非常早的版本(比alpha还要早的一个版本)有一个异常会报告这样的消息: “安全异常:没有足够权限确定c:\temp\foo.txt的路径”. c)异常类型过于具体，以至于调用者不能恰当地处理。例如，不要引发数据库系统的专有异常。相反，可以使用一个较为泛化的异常，避免在调用栈较高的位置写数据库的专有代码。 规范避免在调用栈较低的位置报告或记录异常。 不要捕捉不应该捕捉的异常。要允许异常在调用栈中向上传播，除非能非常清楚地知道如何通过程序准确地定位栈中较低位置的错误。 如果理解特定异常在给定的上下文中为何引发，并能通过程序响应错误，就考虑捕捉该异常。 壁免捕捉System.Exception或System.SystemException，除非是在顶层异常处理程序中在重新引发异常之前执行最后的清理操作。 要在catch块中使用throw;而不是throw &lt;异常对象&gt;语句。 重新引发不同的异常时要小心。 不要引发NullRefernceException，相反，在值意外为空时引发ArgumentNul1Exception. 定义自定义异常在必须引发异常时，首选的方案是使用NET Framework的异常，因为它们得到了良好的构建，能够被很好地理解。例如，首选的不是引发自定义的“无效参数”异常，而是引发System.ArgumentException，然而，假如使用特定API的开发人员想要执行特殊操作(例如，处理自定义异常的逻辑有所不同)，就可以考虑定义一个自定义异常。例如，假定某个地图API接收到邮政编码无效的一个地址，那么不是引发System. ArgumentException，相反，更好的做法也许是引发自定义的InvalidAddressException。这里的关键在于调用者是否愿意编写专门的InvalidAddressExceptioncatch块来进行特殊处理，而不是用一个常规的System.ArgumentException catch块。 定义一个自定义异常时，从System.Exception或者其他异常类型派生就可以了。代码清单10-5展示了一个例子。 代码清单10-5创建自定义异常 这个自定义异常包装了多个专门的数据库异常。例如，因为Oracle和SQL Server会为类似的错误引发不同的异常，所以可以在应用程序中定义一个自定义异常，将不同数据库特有的异常标准化到一个通用的异常封装器中，使应用程序能采取标准方式处理相似的异常。这样，不管应用程序使用的后端数据库是Oracle还是SQL Server，都可以在调用栈较高的位置用同一个catch块处理相似的错误。 自定义异常唯一的要求是必须从System.Exception或者它的某个子类派生。除此之外，在使用自定义异常的时候，还应遵照以下最佳实践。 所有异常都应该使用”Exception”后缀，这样一来，从名称上就很容易得知它们的用途。通常，所有异常都应包含以下3个构造器:无参构造器、获取一个string参数的构造器以及同时获取一个字符串和一个内部异常作为参数的构造器。除此之外，由于异常通常是在引发它们的那个语句中构造的，所以也应允许其他任何异常数据成为构造器的一部分。(当然，假如特定的数据是必需的，而构造器回避了这个要求，则不能创建该构造器。)避免使用深的继承层次结构(一般应该小于5级)。 重新引发一个与已捕捉到的异常不同的异常时，内部异常将发挥重要作用。例如，假定一个数据库调用引发了system.Data.SqlClient.SqLException，但这个异常在数据访问层捕捉到，并作为一个DatabaseException重新引发，那么获取sqlException (或者内部异常)的DatabaseException构造器会将原始SqlException保存到InnerException属性中。这样，在请求与原始异常有关的附加细节时，开发者就可以从InnerException属性中获取异常]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#本质论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TimeLine&Cinemachine技术]]></title>
    <url>%2F2019%2F07%2F27%2FTimeLine-Cinemachine%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 1.Timeline 时间线 2.Cinemachine 虚拟摄像机 3.Frame Recorder 帧录制器 Unity2017.1版本中推出了全新的Timeline技术。Timeline不只是一个可被游戏行业应用的工具，它还可以为各个行业（影视制作、广告、建筑等）的互动内容开发者提供支持。 本章通过介绍Timeline、Cinemachine、Frame Recorder三大相互配合技术，重点讲解游戏对象、角色的动画管理、虚拟摄像机控制、帧录制等，从而构建一个完整的游戏动画全过程。 Timeline 时间线Timeline是一种影视动画与游戏强交互内容的开发工具。一开始的开发目的仅仅是为了游戏中“转场动画”而设立的开发工具，但是后来随着开发的进展，开发人员发现可以不断加入更多的功能，使其更加强大。Timeline就像导演一样，在Unity中控制序列，使用真实世界相机的设置来合成镜头，自动跟踪指定位置。 目前，基于Unity2017.1版本，Timeline的功能可以分为如下4部分： 预渲染过场动画（类似3DMax、Maya软件中的预渲染） 实时渲染过场动画 影视制作（Frame Recorder） 可交互动画片段（timeline基于assets，可被重复使用）不仅限于游戏使用 虽然Timeline随着版本的提升，一定会不断加入新的功能实现，但是2017版本其主要作用还是做“过场动画”（或者说是“转场动画”）。Timeline的操作界面类似Animation时间线，但是本质不同，它可以控制模型、例子、音频、摄像机镜头、脚本等诸多内容，甚至可以开发完整游戏，如图1所示。 与Timeline技术配合使用的还有“Cinemachine”插件（高级虚拟摄像机系统）、“Frame Recorder”帧录制工具。前者是虚拟摄像机系统，提供了丰富功能的影视专业级场景跟踪与拍摄控制技术。后者直接把Timeline工程场景输出到自定义格式贴图中，最终利用帧动画技术完成场景之间的动画过渡，即“过场动画”。 这里的Cinemachine虚拟摄像机系统，以及Frame Recorder并不是直接集成在Unity中使用的，而是需要分别通过Asset Store、Github进行下载安装后使用。这样安排是因为Unity公司认为以上功能的实现还不是最终完善版本，更多内容还在研发之中。所以就把完成度高的部分以插件的形式提供给广大研发人员使用，相信后续版本会做到无缝整合在一起。 首先先来了解Timeline的使用与基本功能 第1步：新建项目（必须使用Unity 2017.1以上版本），导入必要资源。因为本演示项目需要用到角色的动画演示，所以我们打开Asset Store窗口，在搜索框中单击“Mecanim Locomotion Starter”查找插件模型。单击“导入”按钮后，系统会弹出导入内容确认窗口，我们默认单击“Import”导入即可，如图2所示。 第2步：在Project视图中建立TimeLine（鼠标右键弹出窗口-&gt;Create-&gt;Timeline），然后拖曳到Hierarchy视图中。之后我们建立一个简单的演示场景，在一个平面上建立一个红色Cube与黄色Sphere，如图3所示。 第3步：现在我们建立Timeline的“Activation Track”轨，学习游戏对象的隐藏与显示基本控制技术。首先单击Unity顶部菜单Windows-&gt;Timeline Editor，新建Timeline窗口。然后单击Timeline左上角的“Activation Track”选项，建立“Activation Track”轨（见图4），同时把Hierarchy视图中的Cube对象拖曳到本轨道控制物体中，如图5所示。 现在定位Active轨道段，快捷键[Ctrl+D]复制一份，单击Timeline左边的控制三角按钮“Play”，预览场景。此时我们发现cube立方体会随着时间线的移动显示与隐藏交替出现，这说明“Active”轨用于游戏对象的显示控制。 第4步：现在我们建立“Animation Track”轨，学习游戏对象与角色模型的动画控制。首先建立“Animation Track”，把Sphere拖曳到本轨中，此时会立即显示“Create Animator on Sphere”弹出框，单击后我们发现在Sphere对象上添加了Animator组件，只有这样，“Animation Track”才能控制游戏对象录制“方位”（Transform）动画。 第5步：单击Sphere所属的“Animation Track”右边的“红色”点进行录制，此时会发现本轨道发红显示“Recording…”字样，如图6所示。 第6步：拖动Sphere物体，此时录制轨会留下白色的“帧点”，然后在录制状态下移动时间线。再次拖动Sphere就会再次留下“帧点”，这样不断循环，可以记录所有位移信息。单击Timeline的“Play”三角按钮，可以在不运行项目的情况下直接预览录制的位移动画效果。如果认为这种方式比较简单，则可以单击红色录制按钮右边的白色按钮，显示其方位信息。读者可以通过拖曳鼠标的方式，进一步调节出更加复杂的方位动画，如图7所示。 第7步：“Animation Track”轨除了一般的方位（位移、旋转、缩放）动画制作，更多用在角色模型上。现在把角色模型DefaultAvatar.fbx（项目位置：Locomotion-&gt;Setup-&gt;Locomotion-&gt;Animations-&gt;DefaultAvatar.fbx）拖曳到场景视图中。然后再建立一个“Animation Track”，把Hierarchy视图中的DefaultAvatar拖曳到本轨道控制物体中。 第8步：单击“Animation Track”右边（显示三条横线Logo）的按钮，在弹出框中单击“Add From Animation Clip”，在弹出窗口中添加Idle、Walk、Run等角色动画，播放预览效果。如图8所示。 Hierarchy视图中Timeline对象所属的Playables Director组件，改变其“Wrap Mode”属性为“Loop”，可以不断循环重复地预览动画效果，直到满意，比较实用。 Cimemachine 虚拟摄像机Frame Recorder 帧录制器]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D/2D游戏开发从0到1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Unity3D的策略养成类游戏设计与实现]]></title>
    <url>%2F2019%2F07%2F27%2F%E5%9F%BA%E4%BA%8EUnity3D%E7%9A%84%E7%AD%96%E7%95%A5%E5%85%BB%E6%88%90%E7%B1%BB%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[sim（simulation）游戏是模拟经营类游戏的简称，作为游戏大类，模拟经营游戏也是非常热门的，比如模拟人生系列、海岛大亨系列、模拟城市系列、凯撒大帝系等等，喜欢模拟经营游戏的玩家赶紧来看看吧！ 摘要基于Unity3D的策略养成类游戏设计与实现 策略类游戏按照操作方式可分为两大种类,分别为战棋策略类(SLG)和即时战略类(RTS)。 战棋策略(SLG)类,与下棋的模式相似,游戏双方(人-机/人一人)依次行动。 即时战略(RTS)指双方同时行动。 策略游戏强调战略和操作。一般是要从全局入手操作。 养成类游戏一般是要慢慢培养主角,通过各种事件或锻炼使主角到达一定的能力层,完成特定任务。 策略养成类游戏正是融合了策略类游戏和养成类游戏的特点,让玩家在一个逻辑层面上有策略的让游戏剧情按照玩家的意愿发展。本游戏仿照《模拟城市》,以Unity3D为开发引擎,使用C#语言脚本开发,旨在一个场景中从空地发展城市。本游戏分为两大主要界面:开始界面和游戏界面。玩家要在合理发展城市的基础上关注经济值和1污染值让城市发展起来。 关卡内容及操作逻辑在本游戏中,没有明确的关卡切换,只是通过游戏界面上方的等级显示判断游戏关卡进度,玩家一直在同一个界面中进行游戏。玩家开始游戏后只能建造极少数建筑,但随着等级的提升,可追加建造其他建筑。没一个建筑建造好后,都会按照设定时间自动增加经济值,但也会累加污染值,这就需要玩家合理安排建筑数量以及种类,确保污染值不会超过临界线导致游戏结束。当游戏进展到 定等级后,还会加入相应事件导致经济值骤减或污染值骤增,此时需要玩家通过自己的逻辑挽回相应的分数。 游戏对分数规则如下:作品只需考虑经济分数与建造时间,起步分数100,污染分数0,污染分数达到10000或游戏分数达到20000,游戏结束。 游戏内时间规则规定为:现实时间30秒游戏时间1天。 随机灾难袭击与社会问题不可同时出现,每次只随机触发一个,时间间隔为游戏时间40天一次。若因突发事件导致经济值小于已达到等级最低经济值,等级不降。关卡一: 可建造建筑: 居民住宅:一次消耗经济值30,建造时间3天,污染增加5,完成后每天收益10,污染每天增加5; 商场和工厂:一次消耗经济值50,建造时间7天,污染增加10,完成后每天收益30,污染每天增加15;关卡二：经济值累计至500进入关卡二,前提至少建造3个居民住宅, 1个商场和工厂;可添加建筑: 地铁:一次消耗经济值80,建造时间10天,污染增加15,完成后每天收益40,污染每天增加30。 关卡三 经济值累计至1500进入关卡三,前提至少建造5个居民住宅, 2个商场和工厂,1个地铁可添加建筑:公园:一次消耗经济值150,建造时间10天,污染增加30,完成后每天收益50,污染每天减少150。关卡四：经济值累计至4500进入关卡四,前提至少建造10个居民住宅, 2个商场和工厂,2个地铁，2个公园。 可添加建筑: 垃圾站:一次消耗经济值200,建造时间15天,污染增加40,完成后每天收益50,污染每天增加70。随机加入灾难袭击:怪兽:经济值骤减500;火灾:经济值骤减300,污染值骤增200;水灾:经济值骤减400,污染值骤增100随机加入社会问题:犯罪率提升:经济值骤减500;公害污染:污染骤增400。关卡五 经济值累计至9000进入关卡五,前提至少建造15个居民住宅,3个商场和工厂,3个地铁, 3个公园, 1个垃圾站;可添加建筑: 海港:一次消耗经济值300,建造时间25天,污染增加,60,完成后每天收益150,污染每天减少300。随机加入灾难袭击:怪兽:经济值骤减1000:火灾:经济值骤减600,污染值骤增400;水灾:经济值骤减800,污染值骤增200:随机加入社会问题:犯罪率提升:经济值骤减1000;公害污染:污染骤增800。关卡六: 经济值累计至12000进入关卡六,前提至少建造20个居民住宅, 5个商场和工厂, 5个地铁, 5个公园, 2个垃圾站;可添加建筑: 机场:一次消耗经济值500,建造时间50天,污染增加100,每天收益250,污染每天增加200。随机加入灾难袭击: 怪兽:经济值骤减2000:火灾:经济值骤减1200,污染值骤增800;水灾:经济值骤减1600,污染值骤增100:空难:经济值骤减1500,污染值骤增500:随机加入社会问题:犯罪率提升:经济值骤减20002;公害污染:污染骤增1500。 此数值经过多次演算,理论上符合正常逻辑,可顺利进行游戏,只要建筑处理得当,可实现通关。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于XLua的Unity脚本框架的设计与实现]]></title>
    <url>%2F2019%2F07%2F27%2F%E5%9F%BA%E4%BA%8EXLua%E7%9A%84Unity%E8%84%9A%E6%9C%AC%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[摘 要：Unity技术的迅速崛起, 让3D移动游戏逐渐流行。随着游戏系统的不断丰富, 游戏开发迭代速度迅速加快。但Unity的原生C#开发效率较慢, 而且在部分平台上无法进行热更新, 无法满足[…] 行游戏内容的更新,由于APP Store等一些平台不允许Unity游戏热更新C#程序库,必须使用Lua等脚本语言开发来实现热更新功能。1.2.2代码权限管理 完善的代码权限管理可以让业务层的开发者接触不到核心引擎的代码权限,不仅方便进行代码权限管理,还可以防范核心引擎代码泄露。1.2.3崩溃情况 错误的C#代码有可能导致游戏崩溃,而Lua代码出错一般只影响局部逻辑,可以上报脚本错误,方便后续解决问题。1.2.4反破解 反编译等黑客技术让一个C#开发的程序几乎没有秘密,而使用Lua脚本后,脚本部分的代码可以使用加密并在运行时动态解密等技术,保证在进程空间内几乎没有完全代码存在。1.2.5开发效率 C#开发过程中,项目中的任何改动均需要进行重新编译,随着项目体量的增大,会浪费大量时间在编译上。使用!Lua开发,任何改动均可直接运行项目看结果,不需编译,大幅提高开发效率。 综上所述,使用Lua进行开发可以大幅提高开发效率与项目的安全性[5。 2 基于XLua的Unity脚本框架设计与实现2.1 XLua介绍XLua是由腾讯公司维护的一个开源项目，使用XLua不仅可以实现Unity脚本化，更可以在C#层出现BUG后通过热补丁的方式将C#实现替换为Lua实现从而达到仅热更新Lua脚本即可修复C#层BUG的目的。2.2 Unity脚本框架的设计与实现Unity脚本框架由主要由4个部分组成：脚本运行环境（由XLua提供）、脚本管理器、脚本组件、脚本对象。为了提高运行效率，脚本管理器采用单例模式，即游戏程序的生命周期内，只有一个脚本管理的实例。脚本管理器主要负责创建脚本运行环境，管理C#环境与脚本环境交互的接口。为了让C#环境与脚本环境交互，还需要使用到XLua提供的CSharpCallLua标签。使用该标签 的对象可以将脚本环境中的对象映射到C#环境中。 利用标签CSharpCallLua的特性,将Unity中需要使用的方法封装在一个使用CSharpCallLua标签的接口ILua中,并在脚本管理器中实现这个接口,让Unity基础组件的内置方法通过ILua与脚本环境进行交互。 除了实现接口ILua外,还需要设计一个脚本组件去处理C#环境与脚本环境的交互。其核心功能是将Unity内置的回调方法通过ILua与脚本环境交互。 为了提高运行效率,C#环境中并不保存脚本环境的实例,而是通过脚本组件的名字、通过ILua去获取对应脚本环境中的实例,并通过ILua进行交互。 同时,还需要在脚本环境中设计一个与脚本组件对应的映射对象LuaObject,并通过脚本对象管理器进行管理。在创建Unity的GameObject时,脚本对象管理器会自动创建一个对应的LuaObject映射到脚本组件上, LuaObject会通过ILua与C#环境交互。LuaObject在脚本组件被销毁时自动销毁并从管理器中移除。3脚本框架性能测试评估 我们通过一系列的试验对Unity原生C#开发与各种Lua脚本插件实现的脚本框架进行测试评估。我们测试的内容如下:属性读写、成员方法调用、静态方法调用并返回、纯属性设置、构造valuetype返回。3.1时间消耗测试 首先,测试时间消耗。为此我们通过相同的测试用例分别运行Unity mono (Unity C#) , XLua, ulua, cstolua。得到结果如表1所示。 从测试结果可以看出,所有脚本框架的时间效率都不如直接使用C#开发。但对比3种脚本框架, XLua插件的时间效率最好,与C#开发的差距较小。相差较大的是属性读取与写入和构造valuetype返回值。但这两项均可以通过优化代码逻辑去避免使用。 3.2 空间消耗测试接下来我们进行了空间消耗的测试。由于所有插件实际操作的均为Unity的对象，因此这里只对比不同插件所需的额外空间消耗。测试结果如表2所示。 从测试结果可知，XLua是3种脚本插件中空间消耗最小的。对比各项测试，空间消耗最大的是属性读取与写入以及构造valuetype返回。因此，使用脚本框架时需要谨慎使用属性读写与构造valuetype返回。经过上述测试，我们可以发现，使用XLua实现Unity脚本框架无论是空间消耗还是时间消耗，均可以满足项目实际使用的要求。4 结语本文基于XLua设计并实现了Unity的脚本框架，牺牲少许运行效率，大幅提高开发效率与项目安全，让游戏开发商无需花费大量成本去进行引擎的脚本化，专注于游戏设计与逻辑编写，加快开发速度，减少开发成本，具有实际参考价值。]]></content>
  </entry>
  <entry>
    <title><![CDATA[第13章-事件]]></title>
    <url>%2F2019%2F07%2F25%2F%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Action&lt;float&gt;是什么意思？ 事件提供了额外的“封装性”，使publish-subscribe模式更容易实现，更不容易出错怎么理解？ 单一事件（比如对象状态的改变）的通知可以发布给多个订阅者通过什么实现？ 为什么要再把一个委托变量再次赋一个新值？ 为什么可以调用thermostat.OnTemperatureChange += heater.OnTemperatureChanged;而不引发异常（即使thermostat.OnTemperatureChange尚未赋值）？ 一个订阅者引发了异常，链中的后续订阅者还能收到通知吗？怎么处理？ OnTemperatureChange.GetInvocationList())是干嘛用的？ 赋值操作符会引发bug怎么理解？ 事件确保只有包容类才能触发事件通知是怎么实现的？ 订阅者订阅多个发布者，如何知道是哪个发布者发送的消息？ 第一个参数sender应包含调用委托的那个类的实例，为什么要这样规定？ 本章涵盖： 使用多播委托来编码Observer模式 定义订阅者方法 定义发布者 连接发布者和订阅者 调用委托 检查null值 委托操作符 顺序调用 错误处理 方法返回值和传引用 事件 事件的作用 事件的声明 编码规范 泛型和委托 自定义事件的实现 小结 上一章讲述了如何用委托类型的实例引用方法，并通过委托来调用那个方法。委托本身又是一个更大的模式（pattern）的基本单位，这个模式称为publish-subscribe（发布—订阅）。委托的使用及其对publish-subscribe模式的支持是本章的重点。本章描述的所有内容几乎都可以单独使用委托来实现。然而，本章所着眼的事件构造提供了额外的“封装性”，使publish-subscribe模式更容易实现，更不容易出错。 在上一章中，所有委托都只引用一个方法。然而，一个委托值是可以引用一系列方法的，这些方法将顺序调用。这样的委托称为多播委托（multicast delegate）。这样一来，单一事件（比如对象状态的改变）的通知就可以发布给多个订阅者。 虽然事件在C# 1.0中就有了，但C# 2.0对泛型的引入极大地改变了编码规范，因为使用泛型委托数据类型意味着不再需要为每种可能的事件签名声明一个委托。所以，本章的最低起点是C# 2.0。但是，仍在使用C# 1.0的读者也不是不能使用事件，只是必须声明自己的委托数据类型(参见第12章) 使用多播委托来编码Observer模式来考虑一个温度控制的例子。在这个假想的情形中，一个加热器（Heater）和一个冷却器（Cooler）连接到同一个自动调温器。为了控制加热器和冷却器的打开和关闭，要向它们通知温度的变化。自动调温器将温度的变化发布给多个订阅者——也就是加热器和冷却器。在C#中，多播委托的实现是一个通用的模式，目的是避免大量的手工编码。这个模式称为Observer（观察者）或者publish-subscribe模式，它要应对的是这样一种情形：需要将单一事件的通知（如对象状态发生的一个变化）广播给多个订阅者（subscriber）。 定义订阅者方法首先定义Heater和Cooler对象，如代码清单1所示。 代码清单1 Heater和Cooler事件订阅者的实现 123456789101112131415161718192021222324252627282930313233using System;using System.Collections.Generic;namespace Test&#123; class Cooler &#123; // 私有成员以_开头 private float _Temperature; public float Temperature &#123; get &#123; return _Temperature; &#125; set &#123; _Temperature = value; &#125; &#125; // 实例化时有一个默认的温度，大于该值则启动Cooler降温 public Cooler(float temperature) &#123; Temperature = temperature; &#125; public void OnTemperatureChanged(float newTemperature) &#123; if (newTemperature &gt; Temperature) &#123; Console.WriteLine("Cooler: On"); &#125; else &#123; Console.WriteLine("Cooler: Off"); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233using System;using System.Collections.Generic;namespace Test&#123; class Heater &#123; // 私有成员以_开头 private float _Temperature; public float Temperature &#123; get &#123; return _Temperature; &#125; set &#123; _Temperature = value; &#125; &#125; // 实例化时有一个默认的温度，小于该值则启动Heater升温 public Heater(float temperature) &#123; Temperature = temperature; &#125; public void OnTemperatureChanged(float newTemperature) &#123; if (newTemperature &lt; Temperature) &#123; Console.WriteLine("Heater: On"); &#125; else &#123; Console.WriteLine("Heater: Off"); &#125; &#125; &#125;&#125; 除了温度比较，两个类几乎完全一致（事实上，如果在OnTemperatureChanged方法中使用对一个比较方法的委托，两个类还可以再减少一个）。每个类都存储了启动设备所需的温度。此外，两个类都提供了OnTemperatureChanged()方法。调用OnTemperatureChanged()方法的目的是向Heater和Cooler类指出温度已发生改变。在方法的实现中，用newTemperature同存储好的触发温度进行比较，从而决定是否让设备启动。 两个OnTemperatureChanged()方法都是订阅者方法。作为订阅者方法，很重要的一点在于，它们的参数和返回类型必须与来自Thermostat类的委托匹配。 定义发布者Thermostat类负责向heater和cooler对象实例报告温度变化。代码清单2展示了Thermostat类。 代码清单2 定义事件发布者Thermostat 12345678910111213141516171819202122232425using System;using System.Collections.Generic;namespace Test&#123; class Thermostat &#123; // Define the event publisher // 事件是成员，只能在类或结构中定义 // 自动属性 public Action&lt;float&gt; OnTemperatureChange &#123; get; set; &#125; private float _CurrentTemperature; public float CurrentTemperature &#123; get &#123; return _CurrentTemperature; &#125; set &#123; if (value != CurrentTemperature) &#123; _CurrentTemperature = value; &#125; &#125; &#125; &#125;&#125; Thermostat包含一个名为OnTemperatureChange的属性，它具有Action&lt;float&gt;委托类型。OnTemperatureChange存储了订阅者列表。注意，只需一个委托字段即可存储所有订阅者。换言之，来自同一个发布者的温度变化通知会同时被Cooler和Heater类接收。 Thermostat的最后一个成员是CurrentTemperature属性。它负责设置和获取由客户端类报告的当前温度值。 连接发布者和订阅者最后，将所有这些东西都放到一个Main()方法中。代码清单3展示了一个示例Main()。 代码清单3 连接发布者和订阅者 123456789101112131415161718192021222324252627282930using System;using System.Collections.Generic;namespace Test&#123; class Program &#123; static void Main(string[] args) &#123; Thermostat thermostat = new Thermostat(); // 60-80之间不需要打开任何一个 Heater heater = new Heater(60); Cooler cooler = new Cooler(80); string temperature; // 注册事件，也可以在Cooler或Heater的构造函数里注册 // 则需要Heater heater = new Heater(thermostat); thermostat.OnTemperatureChange += heater.OnTemperatureChanged; thermostat.OnTemperatureChange += cooler.OnTemperatureChanged; Console.WriteLine("Enter temperature: "); temperature = Console.ReadLine(); thermostat.CurrentTemperature = int.Parse(temperature); Console.ReadKey(); &#125; &#125;&#125; 上述代码使用+=操作符来直接赋值，向OnTemperatureChange委托注册了两个订阅者即heater.OnTemperatureChanged和cooler.OnTemperatureChanged。 通过获取用户输入的温度值，可以设置thermostat（自动调温器）的CurrentTemperature（当前温度）。然而，目前还没有写任何代码将温度变化发布给订阅者。 调用委托Thermostat类的CurrentTemperature属性每次发生变化时，你都希望调用委托来通知订阅者（heater和cooler）温度的变化。为此，需要修改CurrentTemperature属性来保存新值，并向每个订阅者发出一个通知，如代码清单4所示。 代码清单4 调用委托（不带有检查null值部分） 1234567891011121314151617class Thermostat&#123; ... public float CurrentTemperature &#123; get &#123; return _CurrentTemperature; &#125; set &#123; if (value != CurrentTemperature) &#123; _CurrentTemperature = value; // INCOMPLETE: Check for null needed // Call subscribers OnTemperatureChange(value); &#125; &#125; &#125;&#125; 现在，对CurrentTemperature的赋值包含了一些特殊的逻辑，可以向订阅者通知CurrentTemperature发生的变化。为了向所有订阅者发出通知，只需执行一个简单的C#语句，即OnTemperatureChange(value);。这个语句将温度的变化发布给cooler和heater对象。在此，只需执行一个调用，即可向多个订阅者发出通知——这正是将委托更明确地称为“多播委托”的原因。 检查null值在代码清单4中，遗漏了事件发布代码的一个重要部分。假如当前没有订阅者注册接收通知，则OnTemperatureChange为null，执行OnTemperatureChange(value)语句就会引发一个NullReferenceException异常。为了避免这个问题，有必要在触发事件之前检查null值。代码清单5演示了具体如何做。 代码清单5 调用一个委托 123456789101112131415161718192021class Thermostat&#123; ... public float CurrentTemperature &#123; get &#123; return _CurrentTemperature; &#125; set &#123; if (value != CurrentTemperature) &#123; _CurrentTemperature = value; // If there are any subscribers then notify them of changes in temperature Action&lt;float&gt; localOnChange = OnTemperatureChange; if (localOnChange != null) &#123; localOnChange(value); &#125; &#125; &#125; &#125;&#125; 我们并不是一开始就检查null值，而是首先将OnTemperatureChange赋给另一个委托变量localonChange。这个简单的修改可确保在检查null值和发送通知之间，假如所有OnTemperatureChange订阅者都（由一个不同的线程）移除，那么不会引发Nul1ReferenceException异常。 规范要在调用委托前检查它的值是不是null值。 高级主题：将“-=”操作符应用于委托会返回一个新实例 既然委托是引用类型，那么肯定有人会觉得奇怪：为什么赋值给一个局部变量，再用那个局部变量就可以保证null检查的线程安全性？由于localOnChange指向的位置就是OnTemperatureChange指向的位置，所以很自然的结论就是：OnTemperatureChange中发生的任何变化都会在localOnChange中反映出来。 但实情并非如此。事实上，对OnTemperatureChange-=&lt;listener&gt;的任何调用都不会从OnTemperatureChange删除一个委托而使它的委托比之前少一个。相反，会赋值一个全新的多播委托，原始的多播委托不受任何影响（localOnChange也指向那个原始的多播委托）。 高级主题：线程安全的委托调用 如前所述，由于订阅者可以由不同的线程从委托中增加或删除，所以在进行null值检查前有必要将委托引用复制到一个局部变量中。但是，这虽然能防止调用空委托，却不能防止所有可能的竞态条件。例如，一个线程进行复制，另一个线程将这个委托重置为null，然后原始线程可以调用委托的前一个值，借此通知一个已经不再在订阅者列表中的订阅者。在多线程程序中，订阅者应确保在这种情况下的健壮性。一个“过气”的订阅者随时都可能被调用。 Unity为什么避免使用多线程？不只Unity，大多数游戏引擎都是单线程的，因为大多数引擎都是主循环结构，逻辑更新和画面更新的时间点要求有确定性，如果在逻辑更新和画面更新中引入多线程，就需要做同步而这加大了游戏性程序员（编程关卡的程序员）的开发难度。所以需要异步功能的时候，游戏引擎总是倾向于使用time slicing的策略而不是使用多线程，Unity中的协程（coroutine）yield语法本质就是time slicing。但是多线程也是有好处的，如果不是画面更新，也不是常规的逻辑更新（指包括AI、物理碰撞、角色控制这些），而是一些其他后台任务，比如网络传输，则可以将这个独立出来做成一个工作线程，这需要写Unity游戏的Native扩展。 委托操作符为了合并Thermostat例子中的两个订阅者，要使用+=操作符。这样会获取第一个委托，并将第二个委托添加到委托链中。第一个委托的方法返回后，会调用第二个委托。从委托链中删除委托，则要使用-=操作符，如代码清单6所示。 代码清单6 使用+=和-=委托操作符 123456789101112131415161718192021// ...Thermostat thermostat = new Thermostat();Heater heater = new Heater(60);Cooler cooler = new Cooler(80);Action&lt;float&gt; delegate1;Action&lt;float&gt; delegate2;Action&lt;float&gt; delegate3;delegate1 = heater.OnTemperatureChanged;delegate2 = cooler.OnTemperatureChanged;Console.WriteLine("Invoke both delegates:");delegate3 = delegate1;delegate3 += delegate2;delegate3(90);Console.WriteLine("Invoke only delegate2");delegate3 -= delegate1;delegate3(30); 代码清单6的输出结果如下： 12345Invoke both delegates:Heater: OffCooler: OnInvoke only delegate2Cooler: Off 除此之外，还可以使用+和-操作符来合并委托，如代码清单7所示。 代码清单7 使用+和-委托操作符 12345678910111213141516171819Thermostat thermostat = new Thermostat();Heater heater = new Heater(60);Cooler cooler = new Cooler(80);Action&lt;float&gt; delegate1;Action&lt;float&gt; delegate2;Action&lt;float&gt; delegate3;delegate1 = heater.OnTemperatureChanged;delegate2 = cooler.OnTemperatureChanged;Console.WriteLine("Combine delegates using + operator:");delegate3 = delegate1 + delegate2;delegate3(60);Console.WriteLine("Uncombine delegates using - operator:");delegate3 = delegate3 - delegate2;delegate3(60); 代码清单7的输出结果如下： 12345Combine delegates using + operator:Heater: OffCooler: OffUncombine delegates using - operator:Cooler: Off 使用赋值操作符会清除之前的所有订阅者，并允许用新订阅者替换它们。这是委托很容易让人犯错的一个设计，因为在本来应该使用+=操作符的时候，很容易就会错误地写成=。解决这个问题的良方是事件，详情将在稍后讲述。 应注意的是，无论+、-还是它们的复合赋值版本（+=和-=），在内部都是使用静态方法System.Delegate.Combine()和System.Delegate.Remove()来实现的。两个方法都获取delegate类型的两个参数。第一个方法Combine()会连接两个参数，将两个委托的调用列表按顺序连接到一起。第二个方法Remove()则搜索由第一个参数指定的委托链，删除由第二个参数指定的委托。 对于Combine()方法，一个有趣的地方在于，它的两个参数都可以为null，如果其中任何一个参数为null，Combine()就返回非空的那个。如果两个都为null，则Combine()返回null。这就解释了为什么可以调用thermostat.OnTemperatureChange += heater.OnTemperatureChanged;而不引发异常（即使thermostat.OnTemperatureChange尚未赋值）。 顺序调用图1展示了heater和cooler的顺序通知。 虽然代码中只包含一个简单的OnTemperatureChange()调用，但这个调用会广播给两个订阅者，使cooler和heater都会收到温度发生变化的通知。假如添加更多的订阅者，它们也会收到OnTemperatureChange()的通知。 虽然一个OnTemperatureChange()调用造成每个订阅者都收到通知，但它们仍然是顺序调用的，而不是同时调用，因为它们全都在一个执行线程上调用。 高级主题：多播委托的内部机制 为了理解事件是如何工作的,你需要回顾第12章中我们第一次探讨System.Delegate类型的内部机制的部分。delegate关键字是派生自System.MulticastDelegate的一个类型的别名。System. MulticastDelegate则是从System. Delegate派生的,后者由一个对象引用(以满足非静态方法的需要)和一个方法引用构成。创建委托时,编译器自动使用System.MulticastDelegate类型而不是System. Delegate类型。MulticastDelegate类包含一个对象引用和一个方法引用,这和它的Delegate基类一样。但除此之外,它还包含对另一个System.MulticastDelegate对象的引用。 向多播委托添加方法时, MulticastDelegate类会创建委托类型的一个新实例,在新实例中为新增的方法存储对象引用和方法引用,并在委托实例列表中添加新的委托实例作为下一项。实际上, MulticastDelegate类维护着一个Delegate对象链表。从概念上讲,可以像图13-2那样表示Thermostat的例子。 错误处理错误处理凸显了顺序通知可能造成的问题。假如一个订阅者引发了异常，链中的后续订阅者就收不到通知。例如，假定修改Heater的OnTemperatureChanged()方法，使它引发异常，那么会发生什么？如代码清单8所示。 代码清单8 OnTemperatureChanged()引发异常 12345678910111213141516171819202122232425262728class Program&#123; static void Main(string[] args) &#123; Thermostat thermostat = new Thermostat(); Heater heater = new Heater(60); Cooler cooler = new Cooler(80); string temperature; thermostat.OnTemperatureChange += heater.OnTemperatureChanged; thermostat.OnTemperatureChange += (newTemperature) =&gt; &#123; throw new InvalidOperationException(); &#125;; thermostat.OnTemperatureChange += cooler.OnTemperatureChanged; Console.WriteLine("Enter temperature: "); temperature = Console.ReadLine(); thermostat.CurrentTemperature = int.Parse(temperature); Console.ReadKey(); &#125;&#125; 图3是更新过的顺序图。 虽然cooler和heater已进行了订阅来接收消息,但Lambda表达式异常会使链发生中断,造成cooler对象收不到通知。 为了避免这个问题,使所有订阅者都能收到通知(不管之前的订阅者有过什么行为) ,必须手动遍历订阅者列表,并单独调用它们。代码清单9展示了需要在CurrentTemperature属性中进行的更新。 图3 委托调用顺序图（已添加异常） 代码清单9 处理来自订阅者的异常 12345678910111213141516171819202122232425262728293031323334353637383940class Thermostat&#123; // Define the event publisher public Action&lt;float&gt; OnTemperatureChange; private float _CurrentTemperature; public float CurrentTemperature &#123; get &#123; return _CurrentTemperature; &#125; set &#123; if (value != CurrentTemperature) &#123; _CurrentTemperature = value; if (OnTemperatureChange != null) &#123; List&lt;Exception&gt; exceptionCollection = new List&lt;Exception&gt;(); foreach (Action&lt;float&gt; handler in OnTemperatureChange.GetInvocationList()) &#123; try &#123; handler(value); &#125; catch (Exception exception) &#123; exceptionCollection.Add(exception); &#125; &#125; if (exceptionCollection.Count &gt; 0) &#123; throw new AggregateException("There were exceptions thrown by OnTemperatureChange Event subscribers.", exceptionCollection); &#125; &#125; &#125; &#125; &#125;&#125; 这个代码清单演示了你可以从委托的GetInvocationList()方法获得一份订阅者列表。枚举该列表中的每一项，可以返回给单独的订阅者。如果随后将每个订阅者调用都放到一个try/catch块中，就可以先处理好任何出错的情形，再继续循环迭代。在这个例子中，尽管委托侦听者（delegate listener）引发了一个异常，但cooler仍会接收到温度发生改变的通知。所有通知都发送完毕之后，代码清单9通过引发一个AggregateException来报告所有已发生的异常。AggregateException包装了一个异常集合。集合中的异常可以通过InnerExceptions属性访问。用这种方法，所有异常都得到报告，同时所有订阅者都不会错过通知。 方法返回值和传引用还有一种值得注意的情形，在这种情形下，也有必要遍历委托调用列表，而非直接激活一个通知。这种情形涉及的委托要么不返回void，要么有一个ref或out参数。在Thermostat例子中，OnTemperatureChange委托是Action&lt;float&gt;类型，它返回void，而且没有ref或out参数。其结果是没有数据返回给发布者。这一点相当重要，因为调用委托可能造成将一个通知发送给多个订阅者。假如订阅者会返回一个值，就无法确定应该使用哪个订阅者的返回值。 假如修改OnTemperatureChange，让它不是返回void，而是返回枚举值，指出设备是否因温度的改变而启动，那么新委托就是Func&lt;float, Status&gt;类型，其中Status是包含元素On和Off的枚举。所有订阅者方法都要使用和委托相同的方法签名，所以都必须返回状态值。由于OnTemperatureChange潜在地对应于一个委托链，所以需要遵循和执行错误处理时相同的模式。也就是说，必须使用GetInvocationList()方法遍历每个委托调用列表来获取每个单独的返回值。类似地，使用ref和out参数的委托类型也需要特别对待。然而，虽然在极少数情况下需要，但一般原则是通过返回void来彻底避免该情形。 事件到目前为止，使用的委托都存在两个关键的问题。C#使用关键字event（事件）来解决这些问题。本节描述了如何使用事件，以及它们是如何工作的。 事件的作用本章前面已全面描述了委托是如何工作的。然而，委托结构中存在的缺陷可能造成程序员在不经意中引入一个bug。这个问题和封装有关，无论事件的订阅还是发布，都不能得到充分的控制。 1.封装订阅 如前所述，可以使用赋值操作符将一个委托赋给另一个。遗憾的是，这同时可能造成bug。来看看代码清单10的例子。 代码清单10 错误地使用赋值操作符=而不是+= 1234567891011121314151617181920212223class Program&#123; static void Main(string[] args) &#123; Thermostat thermostat = new Thermostat(); Heater heater = new Heater(60); Cooler cooler = new Cooler(80); string temperature; thermostat.OnTemperatureChange = heater.OnTemperatureChanged; // Bug: assignment operator overrides previous assignment. thermostat.OnTemperatureChange = cooler.OnTemperatureChanged; Console.WriteLine("Enter temperature: "); temperature = Console.ReadLine(); thermostat.CurrentTemperature = int.Parse(temperature); Console.ReadKey(); &#125;&#125; 代码清单10的输出结果如下： 123Enter temperature: // 输入20Cooler: Off 代码清单10和代码清单6如出一辙，只是它不是使用+=操作符，而是使用一个简单赋值操作符。其结果就是，当代码将cooler.OnTemperatureChanged赋给OnTemperatureChange时，heater.OnTemperatureChanged会被清除，因为一个全新的委托链替代了之前的链。在本该使用+=操作符的地方使用了赋值操作符“=”，由于这是一个十分容易犯的错误，所以最好的解决方案就是仅为包容类内部的对象提供对赋值操作符的支持。event关键字的作用就是提供额外的封装，避免不小心地取消其他订阅者。（加了event后如果发现“=”给事件赋值会直接报错，如下图所示。而不加event不会报错，这样强制报错可以避免把+=写成=）。 2.封装发布 委托和事件的第二个重要区别在于，事件确保只有包容类才能触发事件通知。来看看代码清单11的例子。 代码清单11 从事件包容者的外部触发事件 1234567891011121314151617181920class Program&#123; static void Main(string[] args) &#123; Thermostat thermostat = new Thermostat(); Heater heater = new Heater(60); Cooler cooler = new Cooler(80); string temperature; thermostat.OnTemperatureChange += heater.OnTemperatureChanged; thermostat.OnTemperatureChange += cooler.OnTemperatureChanged; thermostat.OnTemperatureChange(42); Console.ReadKey(); &#125;&#125; 代码清单11的输出结果如下： 12Heater: OnCooler: Off 在代码清单11中，即使thermostat的CurrentTemperature没有发生改变，Program也能调用OnTemperatureChange委托。因此，Program触发了对所有thermostat订阅者的一个通知，告诉它们温度已发生改变，而实际上thermostat的温度并没有变化。和之前一样，委托的问题在于封装不充分。Thermostat应禁止其他任何类调用OnTemperatureChange委托。 事件的声明C#用event关键字解决了上述两个问题。虽然看起来像是一个字段修饰符，但event定义的是一个新的成员类型，如代码清单12所示。 代码清单12 为Event-Coding（事件-编码）模式使用event关键字 123456789101112131415161718192021222324public class Thermostat&#123; // Define the event publisher public event EventHandler&lt;TemperatureArgs&gt; OnTemperatureChange = delegate &#123; &#125;; public class TemperatureArgs : System.EventArgs &#123; private float _newTemperature; public float NewTemperature &#123; get &#123; return _newTemperature; &#125; set &#123; _newTemperature = value; &#125; &#125; public TemperatureArgs(float newTemperature) &#123; NewTemperature = newTemperature; &#125; &#125; private float _CurrentTemperature; public float CurrentTemperature &#123; ... &#125;&#125; 这个新的Thermostat类进行了4处修改。首先，OnTemperatureChange属性被移除了。OnTemperatureChange被声明为一个public字段。从表面看，这似乎并不是在解决早先描述的封装问题。现在需要的是增强封装，而不是让一个字段变成public字段来削弱封装。然而，我们进行的第二处修改是在字段声明之前添加event关键字。这一处简单的修改提供了所需的全部封装。添加event关键字后，会禁止为一个public委托字段使用赋值操作符（比如thermostat.OnTemperaturechange = cooler.OnTemperatureChanged）。除此之外，只有包容类才能调用向所有订阅者发出通知的委托（例如，不允许在类的外部执行thermostat.OnTemperatureChange(42)）。换言之，event关键字提供了必要的封装来防止任何外部类发布一个事件或者取消之前不是由其添加的订阅者。这样，就完美地解决了普通委托存在的两个问题，这是在C#中提供event关键字的关键原因之一。 普通委托的另一个不利之处在于，很容易忘记在调用委托之前检查null值。这会引发一个非预期的NullReferenceException异常。幸好，通过event关键字提供的封装，可以在声明时（或者在构造器中）采用一个替代方案，如代码清单12所示。注意在声明事件时，我们赋的值是delegate{}，它是一个空委托，代表由零个侦听者构成的一个集合。通过赋值一个空委托，就可以引发事件而不必检查是否有任何侦听者。（这个行为类似于向变量赋一个包含零个元素的数组。然后，在调用一个数组成员时，就不必先检查变量是否为null。）当然，如果委托存在被重新赋值为null的任何可能，那么仍需进行null值检查。不过，由于event关键字限制赋值只能在类的内部发生，所以要重新对委托进行赋值，只能在类中进行。如果从未在类中赋过null值，就不必在代码每次调用委托时检查null。 编码规范为了获得希望的功能，唯一要做的就是将原始委托变量声明更改为字段，然后添加event关键字。进行了这两处修改之后，就可以提供全部必要的封装。与此同时，其他所有功能都和以前一样。然而，在代码清单12中，委托声明还进行了另一处修改。为了遵循标准的C#编码规范，要将Action&lt;float&gt;替换成一个新的委托类型EventHandler&lt;TemperatureArgs&gt;，这是一个CLR类型，其声明如代码清单13所示（自NET Framework 2.0起添加）。 代码清单13 声明一个泛型委托类型 1public delegate void EventHandler&lt;TEventArgs&gt; (object sender, TEventArgs e) where TEventArgs: EventArgs; 结果是Action委托类型中的单个温度参数被替换成两个新参数，一个代表发送者，另一个代表事件数据。这一处修改并不是C#编译器强制的。但是，声明一个打算作为事件来使用的委托时，规范是要求传递这些类型的两个参数。 第一个参数sender应包含调用委托的那个类的实例。假如一个订阅者方法注册了多个事件，这个参数就尤其有用。例如，假定两个Thermostat实例都订阅了heater.OnTemperatureChanged事件。在这种情况下，任何一个Thermostat实例都可能触发对heater.OnTemperatureChanged的调用。为了判断具体是哪个Thermostat实例触发了事件，要在Heater.OnTemperatureChanged()内部利用sender参数进行判断。如果事件是静态的，就无法做这种判断，所以要为sender传递null值作为实参。 第二个参数TEventArgse是Thermostat.TemperatureArgs类型。关于TemperatureArgs，一个重点在于它是从System.EventArgs派生的。（事实上，一直到.NET Framework 4.5，都通过一个泛型约束来强制从System.EventArgs派生。）System.EventArgs唯一重要的属性是Empty，它用于指出不存在事件数据。然而，从System.EventArgs派生出TemperatureArgs时添加了一个额外的属性，名为NewTemperature，用于将温度从自动调温器传递给订阅者。 这里简单总结一下事件的编码规范：第一个参数sender是object类型的，它包含对调用委托的那个对象的一个引用（静态事件则为null）。第二个参数是System.EventArgs类型的（或者从System.EventArgs派生，但包含了事件的附加数据）。调用委托的方式和以前几乎完全一样，只是要提供附加的参数。代码清单14展示了一个例子。 代码清单14 触发事件通知 1234567891011121314151617181920212223class Thermostat&#123; ... private float _CurrentTemperature; public float CurrentTemperature &#123; get &#123; return _CurrentTemperature; &#125; set &#123; if (value != CurrentTemperature) &#123; _CurrentTemperature = value; // If there are any subscribers then notify them of changes in temperature if (OnTemperatureChange != null) &#123; OnTemperatureChange(this, new TemperatureArgs(value)); &#125; &#125; &#125; &#125;&#125; 通常将sender指定为容器类（this），因为它是唯一个能为事件调用委托的类。 在这个例子中，订阅者可以将sender参数转型为Thermostat，并以那种方式访问当前温度，或者通过TemperatureArgs实例来访问。然而，Thermostat实例上的当前温度可能由一个不同的线程改变。在由于状态改变而发生事件的时候，连同新值传递前一个值是常见的编程模式，它可以控制哪些状态变化是允许的。 规范要在调用委托前检查它的值不为null。不要为非静态事件的sender传递null值。要为静态事件的sender传递nul1值。不要为eventArgs传递null值。要为事件使用EventHandler委托类型。要为TEventArgs使用5ystem.EventArgs类型或者它的派生类型。考虑使用System.EventArgs的子类作为事件的实参类型（TEventArgs），除非完全确定事件永远不需要携带任何数据。 泛型和委托上一节指出，为事件定义类型的规范是使用EventHandler&lt;TEventArgs&gt;委托类型。理论上任何委托类型都可以使用，但根据约定，第一个参数sender是object类型，第二个参数e是从System.EventArgs派生的一个类型。对于C# 1.0中的委托来说，一个较大的麻烦在于，一旦事件处理程序的参数发生改变，就不得不声明一个新的委托类型。每次从System.EventArgs派生（这是相当常见的一个情形），都要声明一个新的委托数据类型来使用新的EventArgs派生类型。例如，为了使用代码清单14的事件通知代码中的TemperatureArgs，必须声明委托类型TemperatureChangeHandler，它以TemperatureArgs作为参数，如代码清单15所示。 代码清单15 使用一个自定义委托类型 12 onTemperatureChange()。其中, OnTemperatureChange后缀是从原始事件名称中截取的。这两个方法分别负责实现“+=”和”–”赋值操作符。如代码清单13-17所示,这两个方法是使用本章前面讨论的静态方法system. Delegate. Combine ()和System. Delegate.Remove()来实现的。传给方法的第一个参数是私有的EventHandler&lt;TemperatureArgs)委托实例OnTemperatureChange。 在从event关键字生成的代码中,或许最奇怪的就是最后一部分。其语法与属性的取值和赋值方法非常相似,只是方法名变成了add和remove,其中, add块负责处理”+=”操作符,将调用传给addonTemperaturechange()。类似地, remove块处理“-”操作符,将调用传给remove OnTemperatureChange()。 必须重视这段代码与属性代码的相似性。本书前面讲过, C#在实现一个属性时,会创建get_和set-,然后将对get和set块的调用传给这些方法。显然,事件的语法与此非常相似 另外要注意,在最终的CIL代码中,仍然保留了event关键字。换言之,事件是CIL代码能够显式识别的一样东西,并非只是一个C#构造。在CIL代码中保留一个等价的event关键字之后,所有语言和编辑器都能将事件识别为一个特殊的类成员,并正确地处理它。 自定义事件的实现编译器为+=和-=生成的代码是可以自定义的。例如，假定改变OnTemperatureChange委托的作用域，使它成为protected而不是private。这样一来，从Thermostat派生的类也能直接访问委托，而无需受到和外部类一样的限制。为此，C#允许使用和代码清单15一样的属性语法。换言之，C#允许添加自定义的add和remove块，为事件封装的各个组成部分提供你自己的实现。代码清单18展示了一个例子。 代码清单18 自定义add和remove处理程序 12 在这个例子中，存储每个订阅者的委托OnTemperatureChange变成了protected。除此之外，在add块的实现中，我们交换了两个委托存储的位置，使添加到链中的最后一个委托是接收通知的第一个委托。 小结本章描述了事件，值得一提的是，通常，方法引用是唯一可以在事件上下文的外部用到委托变量的情况。换句话说，由于事件提供了额外的封装性，而且允许在必要时对实现进行自定义，所以最佳做法就是始终为Observer模式使用事件。 可能需要一段时间的练习，才能脱离示例代码，熟练地进行事件的编程。然而，事件编程正是以后要讲述的异步、多线程编程的重要基础。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#本质论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2019%2F07%2F25%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2F2019%2F07%2F25%2F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么要使用事件？事件的主体是发布者怎么理解？ 什么是回调方法和事件处理程序？ 事件使你无法直接访问委托怎么理解？ 事件被触发时发生了什么？ 事件（event）可以声明为private吗？ 事件可以申明为静态吗？怎么使用？委托可以为静态吗？为什么？ 事件是类型吗？如果不是那是什么？事件可以声明在类或结构外面吗？ 事件的初始值是什么？ EventHandler是干嘛用的？ 多播委托多种方法同样的参数怎么理解？ 本章涵盖： 1.发布者和订阅者 2.源代码组件概览 3.声明事件 4.订阅事件 5.触发事件 6.标准事件的用法 7.事件访问器 发布者和订阅者很多程序都有一个共同的需求，即当一个特定的程序事件发生时，程序的其他部分可以得到该事件已经发生的通知。 你对钱的增加感兴趣，然后我负责监控，每增加12块钱，我就去做你交给我的事情，但你需要先把事情写在我给你的本子上。反了，上面陈述的主体是订阅者，主体应该是发布者才对。我想叫两个人帮我算钱，他们先把计数的按钮放在我的工具箱里，我每增加12块钱，我就打开工具箱按下按钮，他们接收到消息就各自进行处理。 发布者/订阅者模式（publisher/subscriber pattern）可以满足这种需求。在这种模式中，发布者类定义了一系列程序的其他部分可能感兴趣的事件。其他类可以“注册”，以便在这些事件发生时发布者可以通知它们。这些订阅者类通过向发布者提供一个方法来“注册”以获取通知。当事件发生时，发布者“触发事件”，然后执行订阅者提交的所有事件。 由订阅者提供的方法称为回调方法，因为发布者通过执行这些方法来“往回调用订阅者的方法”。还可以将它们称为事件处理程序，因为它们是为处理事件而调用的代码。图1演示了这个过程，展示了拥有一个事件的发布者以及该事件的三个订阅者。 图1 发布者和订阅者 下面是一些有关事件的重要事项。 发布者（publisher） 发布某个事件的类或结构，其他类可以在该事件发生时得到通知。 订阅者（subscriber）注册并在事件发生时得到通知的类或结构。 事件处理程序（event handler） 由订阅者注册到事件的方法，在发布者触发事件时执行。事件处理程序方法可以定义在事件所在的类或结构中，也可以定义在不同的类或结构中。 触发（raise）事件 调用（invoke）或触发（fire）事件的术语。当事件触发时，所有注册到它的方法都会被依次调用。 事件的很多部分都与委托类似。实际上，事件就像是专门用于某种特殊用途的简单委托。委托和事件的行为之所以相似，是有充分理由的。事件包含了一个私有的委托，如图2所示。 图2 事件有被封装的委托 有关事件的私有委托需要了解的重要事项如下。 事件提供了对它的私有控制委托的结构化访问：也就是说，你无法直接访问委托。 事件中可用的操作比委托要少，对于事件我们只可以添加、删除或调用事件处理程序。 事件被触发时，它调用委托来依次调用调用列表中的方法。 注意，在图2中，只有+=和-=运算符在事件框的左边。因为，它们是事件唯一允许的操作（除了调用事件本身）。 图3演示了一个叫做Incrementer（Publisher）的类，它按照某种方式进行计数。 Incrementer定义了一个CountedADozen事件，每次累积到12个项时将会触发该事件。 订阅者类Dozens和SomeOtherClass（Subscriber）各有一个注册到CountedADozen事件的事件处理程序。 每当触发事件时，都会调用这些处理程序。 图3 具有一个事件的类的结构和术语 源代码组件概览需要在事件中使用的代码有5部分，如图4所示。这些组件如下所示。 委托类型声明 事件和事件处理程序必须有共同的签名和返回类型，它们通过委托类型进行描述。 事件处理程序声明 订阅者类中会在事件触发时执行的方法声明。它们不一定是有显式命名的方法，还可以是匿名方法或Lambda表达式。 事件声明 发布者类必须声明一个订阅者类可以注册的事件成员。当声明的事件为public时，称为发布了事件。 事件注册 订阅者必须订阅事件才能在它被触发时得到通知。 触发事件的代码 发布者类中“触发”事件并导致调用注册的所有事件处理程序的代码。 图4 使用事件时的5个源代码组件 声明事件发布者类必须提供事件对象。创建事件比较简单——只需要委托类型和名字。事件声明的语法如下代码所示，代码中声明了一个叫做CountADozen的事件。注意如下有关CountedADozen事件的内容。 事件声明在一个类中。 它需要委托类型的名称，任何附加到事件（如注册）的处理程序都必须与委托类型的签名和返回类型匹配。 它声明为public，这样其他类和结构可以在它上面注册事件处理程序。 不能使用对象创建表达式（new表达式）来创建它的对象。 1234567class Incrementer&#123; // event是关键字 // EventHandler是委托类型 // CountedADozen是事件名 public event EventHandler CountedADozen;&#125; EventHandler是系统定义的委托，原型如下： 123456789101112131415161718192021#region 程序集 mscorlib.dll, v4.0.0.0// C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5\mscorlib.dll#endregionusing System.Runtime.InteropServices;namespace System&#123; // 摘要: // 表示将处理不包含事件数据的事件的方法。 // // 参数: // sender: // 事件源。 // // e: // 不包含任何事件数据的 System.EventArgs。 [Serializable] [ComVisible(true)] public delegate void EventHandler(object sender, EventArgs e);&#125; 我们可以通过使用逗号分隔的列表在一个声明语句中声明一个以上的事件。例如，下面语句声明了3个事件。 1public event EventHandler MyEvent1, MyEvent2, OtherEvent; 我们还可以使用static关键字让事件变成静态的，如下声明所示: 1public static event EventHandler CountedADozen; 事件是成员 一个常见的误解是把事件认为是类型，然而它不是。和方法、属性一样，事件是类或结构的成员，这一点引出了几个重要的特性。 由于事件是成员： 我们不能在一段可执行代码中声明事件； 它必须声明在类或结构中，和其他成员一样。 事件成员被隐式自动初始化为null。 事件声明需要委托类型的名字，我们可以声明一个委托类型或使用已存在的。如果我们声明一个委托类型，它必须指定事件保存的方法的签名和返回类型。 BCL声明了一个叫做EventHandler的委托，专门用于系统事件。 订阅事件订阅者向事件添加事件处理程序。对于一个要添加到事件的事件处理程序来说，它必须具有与事件的委托相同的返回类型和签名。 使用+=运算符来为事件增加事件处理程序，如下面代码所示。事件处理程序位于该运算符的右边。 事件处理程序的规范可以是以下任意一种： 实例方法的名称； 静态方法的名称； 匿名方法； Lambda达式。 例如，下面代码为CountedADozen事件增加了3个方法： 第一个是使用方法形式的实例方法；第二个是使用方法形式的静态方法；第三个是使用委托形式的实例方法。 123456789// incrementer是类名，CountedADozen是事件成员// Increment.DozensCount是实例方法incrementer.CountedADozen += Increment.DozensCount; // 方法引用形式// ClassB.CounterHandlerB是静态方法incrementer.CountedADozen += ClassB.CounterHandlerB; // 方法引用形式 mc.CountedADozen += new EventHandler(cc.CounterHandlerC); // 委托形式 和委托一样，我们可以使用匿名方法和Lambda表达式来添加事件处理程序。例如，如下代码先使用Lambda表达式然后使用了匿名方法。 1234// Lambda表达式incrementer.CountedADozen += () =&gt; DozensCount++;// 匿名方法incrementer.CountedADozen += delegate &#123; DozensCount++; &#125;; 触发事件事件成员本身只是保存了需要被调用的事件处理程序。如果事件没有被触发，什么都不会发生。我们需要确保在合适的时候有代码来做这件事情。 例如，如下代码触发了CountedADozen事件。注意如下有关代码的事项。 在触发事件之前和null进行比较，从而查看是否包含事件处理程序，如果事件是null，则表示没有，不能执行。 触发事件的语法和调用方法一样: 使用事件名称，后面跟的参数列表包含在圆括号中； 参数列表必须与事件的委托类型相匹配。 123// CountedADozen 事件名if (CountedADozen != null) //确认有方法可以执行 CountedADozen(source, args); // 触发事件 把事件声明和触发事件的代码放在一起便有了如下的发布者类声明。这段代码包含了两个成员：事件和一个叫做DoCount的方法，它将在适当的时候触发该事件。 12345678910111213141516class Incrementer&#123; public event EventHandler CountADozen; // 创建事件并发布 public void DoCount(object source, EventArgs args) &#123; int i; for (i = 1; i &lt; 101; i++) &#123; if (i % 12 == 0 &amp;&amp; CountADozen != null) // 确认有方法可以执行 &#123; CountADozen(source, args); // 触发事件 &#125; &#125; &#125;&#125; 下面的代码展示了整个程序，包含发布者类Incrementer和订阅者类Dozens。代码需要注意的地方如下: 在构造函数中，Dozens类订阅事件，将IncrementDozensCount作为事件处理程序； 在Incrementer类的DoCount方法中，每增长12个数就触发CountedADozen事件。 包含发布者和订阅者的完整程序，展示了使用事件所必需的5个部分 发布者Publisher Incrementer.cs 1234567891011121314151617181920212223using System;using System.Collections.Generic;namespace Test&#123; delegate void Handler(); // 声明委托 class Incrementer &#123; public event Handler CountedADozen; // 创建事件并发布 public void DoCount() &#123; int i; for (i = 1; i &lt; 101; i++) &#123; if (i % 12 == 0 &amp;&amp; CountedADozen != null) &#123; CountedADozen(); // 每增加12个计数触发事件一次 &#125; &#125; &#125; &#125;&#125; 订阅者Subscriber Dozens.cs 1234567891011121314151617181920using System;using System.Collections.Generic;namespace Test&#123; class Dozens &#123; public int DozensCount &#123;get; private set; &#125; public Dozens(Incrementer incrementer) &#123; incrementer.CountedADozen += IncrementDozensCount; // 订阅事件 &#125; // 声明事件处理程序 public void IncrementDozensCount() &#123; DozenCount++; &#125; &#125;&#125; Program.cs 1234567891011121314151617181920using System;using System.Collections.Generic;namespace Test&#123; class Program &#123; static void Main(string[] args) &#123; Incrementer incrementer = new Incrementer(); Dozens dozensCount = new Dozens(incrementer); incrementer.DoCount(); Console.WriteLine("Number of dozens = &#123;0&#125;", dozensCount.DozensCount); Console.ReadKey(); &#125; &#125;&#125; 产生如下的结果： 1Number of dozens = 8 标准事件的用法GUI编程是事件驱动的，也就是说在程序运行时，它可以在任何时候被事件打断，比如按钮点击、按下按键或系统定时器。在这些情况发生时，程序需要处理事件然后继续其他事情。 显然，程序事件的异步处理是使用C#事件的绝佳场景。Windows GUI编程如此广泛地使用了事件，对于事件的使用，.NET框架提供了一个标准模式。事件使用的标准模式的根本就是System命名空间声明的EventHandler委托类型。EventHandler委托类型的声明如下代码所示。 1public delegate void EventHandler(object sender, EventArgs e); 关于该声明需要注意以下几点： 第一个参数用来保存触发事件的对象的引用。由于是object类型的，所以可以匹配任何类型的实例； 第二个参数用来保存状态信息，指明什么类型适用于该应用程序； 返回类型是void。 EventHandler委托类型的第二个参数是EventArgs类的对象，它声明在System命名空间中。你可能会想，既然第二个参数用于传递数据，EventArgs类的对象应该可以保存一些类型的数据。你可能错了。 EventArgs设计为不能传递任何数据。它用于不需要传递数据的事件处理程序——通常会被忽略。 如果你希望传递数据，必须声明一个派生自EventArgs的类，使用合适的字段来保存需要传递的数据。 尽管EventArgs类实际上并不传递数据，但它是使用EventHandler委托模式的重要部分。不管参数使用的实际类型是什么，object类和EventArgs总是基类。这样EventHandler就能提供一个对所有事件和事件处理器都通用的签名，只允许两个参数，而不是各自都有不同签名。 如下代码所示，我们修改Incrementer程序使之使用EventHandler委托。注意以下几点。 在声明中使用系统定义的EventHandler委托替换Handler. 订阅者中声明的事件处理程序的签名必须与事件委托（现在使用object和EventArgs参数）的签名（和返回类型）匹配。对于IncrementDozensCount事件处理程序来说，该方法忽略了正式的参数。 触发事件的代码在调用事件时必须使用适当的参数类型的对象。 发布者Publisher Increment.cs 12345678910111213141516171819202122using System;using System.Collections.Generic;namespace Test&#123; class Increment &#123; public event EventHandler CountADozen; // 使用系统定义的EventHandler委托 public void DoCount() &#123; int i; for (i = 1; i &lt; 101; i++) &#123; if (i % 12 == 0 &amp;&amp; CountADozen != null) &#123; CountADozen(this, null); // 触发事件时使用EventHandler的参数 &#125; &#125; &#125; &#125;&#125; 订阅者Subscriber Dozens.cs 123456789101112131415161718192021using System;using System.Collections.Generic;namespace Test&#123; class Dozens &#123; public int DozenCount &#123;get; private set; &#125; public Dozens(Increment increment) &#123; DozenCount = 0; increment.CountADozen += IncrementDozenCount; // 订阅事件 &#125; // 事件处理程序的签名必须与委托的签名匹配 public void IncrementDozenCount(object source, EventArgs e) &#123; DozenCount++; &#125; &#125;&#125; Program.cs 1234567891011121314151617181920using System;using System.Collections.Generic;namespace Test&#123; class Program &#123; static void Main(string[] args) &#123; Increment increment = new Increment(); Dozens dozenCount = new Dozens(increment); increment.DoCount(); Console.WriteLine("Number of dozens = &#123;0&#125;", dozenCount.DozenCount); Console.ReadKey(); &#125; &#125;&#125; 事件访问器自己的总结事件只能用+=委托在类里面别的类.委托字段 调用不安全 事件是由委托进化来的。 订阅 可以往里面装方法，但是没有办法执行。只有类才能执行。所以事件只能定义在类里面。 事件的出现是一个渐进的过程，从安全性出发进行修改从而得到了订阅机制。 委托写在命名空间下和写在类里是不同的。 1234567891011121314151617using System;using System.Collections.Generic;namespace Test&#123; public delegate void MyDel(); class Tool &#123; public MyDel del; &#125; class Weapon &#123; public MyDel del2; &#125;&#125; 此时的Program.cs 1234567891011121314151617181920212223242526272829303132using System;using System.Collections.Generic;namespace Test&#123; class Program &#123; static void Main(string[] args) &#123; Tool tool1 = new Tool(); // 多播委托 tool1.del = Show; tool1.del += Run; // 执行委托 tool1.del(); Console.ReadKey(); &#125; public static void Show() &#123; Console.WriteLine("Show被调用了"); &#125; public static void Run() &#123; Console.WriteLine("Run被调用了"); &#125; &#125;&#125; 此时产生了什么问题呢？即 1tool1.del(); 不安全，任意一个类new Tool后都可以执行这个委托，而这个委托是属于Tool的，本该由Tool类来执行。 这边可以在Tool里加一个方法 123456789101112class Tool&#123; public MyDel del; public void ProcessDel() &#123; if (del != null) &#123; del(); &#125; &#125;&#125; 则Program可以这样执行 1tool1.ProcessDel(); 但是tool1.del();还可以执行，又不能把它变成private，变成私有的则tool1.del = Show;tool1.del += Run;就失效了。 这时候该事件出场了，Tool中给del变量加一个event关键字 1public event MyDel del; 此时Program报错如下： 无法直接调用tool1.del()了。这时候是想要的结果，逼着你只能使用tool1.ProcessDel();来执行委托，也就是用委托所在的类来执行，保证安全性。 接着注释掉tool1.del()这一行，添加tool1.ProcessDel();，还是报错 因为事件只能用+=号，最后修改如下： Tool.cs 1234567891011121314151617181920using System;using System.Collections.Generic;namespace Test&#123; public delegate void MyDel(); class Tool &#123; public event MyDel del; public void ProcessDel() &#123; if (del != null) &#123; del(); &#125; &#125; &#125;&#125; Program.cs 12345678910111213141516171819202122232425262728293031323334using System;using System.Collections.Generic;namespace Test&#123; class Program &#123; static void Main(string[] args) &#123; Tool tool1 = new Tool(); // 多播委托 tool1.del += Show; tool1.del += Run; // 执行委托 //tool1.del(); tool1.ProcessDel(); Console.ReadKey(); &#125; public static void Show() &#123; Console.WriteLine("Show被调用了"); &#125; public static void Run() &#123; Console.WriteLine("Run被调用了"); &#125; &#125;&#125; 这样就实现了订阅。 通过扩展EventArgs来传递数据为了向自己的事件处理程序的第二个参数传入数据，并且又符合标准惯例，我们需要声明一个派生自EventArgs的自定义类，它可以保存我们需要传入的数据。类的名称应该以EventArgs结尾。例如，如下代码声明了一个自定义类，它能将字符串存储在名称为Message的字段中 12345// IncrementerEventArgs是自对应类，EventArgs是基类public class IncrementerEventArgs : EventArgs&#123; public int IterationCount&#123; get; set; &#125; // 存储整数&#125; 现在我们有了一个自定义的类，可以对事件处理程序的第二个参数传递数据，你需要一个使用新自定义类的委托类型。要获得该类，可以使用泛型版本的委托EventHandler&lt;&gt;。第17章将详细介绍C#泛型，所以现在你只需要观察。要使用泛型委托，需要做到以下两点，随后的代码也表达了这个意思。 将自定义类的名称放在尖括号内。 在需要使用自定义委托类型的时候使用整个字符串。例如，event声明可能为如下形式：123// 泛型委托使用自定义类// CountedADozen是事件名称public event EventHandler&lt;IncrementerEventArgs&gt; CountedADozen; 下面我们在处理事件的其他4部分代码中使用自定义类和自定义委托。例如，下面的代码更新了Incrementer，使用自定义的EventArgs类IncrementerEventArgs和泛型EventHandlerk&lt;IncrementerEventArgs&gt;委托。 12]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#图解教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖倒转原则]]></title>
    <url>%2F2019%2F07%2F24%2F%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是依赖倒转原则？和依赖注入和控制反转有什么不同？ 什么是里氏替换原则？ 依赖倒转和依赖注入，控制反转是不一样的东西。 依赖倒转原则面向对象的四个好处是： 可维护 可扩展 可复用 灵活性好 电脑好修而收音机不好修的原因是电脑是模块化的，而收音机不是，各组件紧密结合。 可以把PC电脑理解成是大的软件系统,任何部件如CPU、内存、硬盘、显卡等都可以理解为程序中封装的类或程序集,由于PC易插拔的方式,那么不管哪一个出问题,都可以在不影响别的部件的前提下进行修改或替换。 面向对象里把这种关系叫强内聚、松耦合吧，即高内聚，低耦合。 面向对象的几大设计原则 单一职责原则,对象各自的职责是明确的。开放-封闭原则,对扩展开放，对修改关闭 依赖倒转原则,原话解释是抽象不应该依赖细节,细节应该依赖于抽象,这话绕口,说白了,就是要针对接口编程,不要对实现编程 依赖倒转原则 A.高层模块不应该依赖低层模块。两个都应该依赖抽象。b,抽象不应该依赖细节。细节应该依赖抽象。[ASD] 为什么要叫倒转呢? 面向过程的开发时,为了使得常用代码可以复用,一般都会把这些常用代码写成许许多多函数的程序库,这样我们在做新项目时,去调用这些低层的函数就可以了。比如我们做的项目大多要访问数据库,所以我们就把访问数据库的代码写成了函数,每次做新项目时就去调用这些函数。这也就叫做高层模块依赖低层模块。 我们要做新项目时,发现业务逻辑的高层模块都是一样的,但客户却希望使用不同的数据库或存储信息方式,这时就出现麻烦了。我们希望能再次利用这些高层模块,但高层模块都是与低层的访问数据库绑定在一起的,没办法复用这些高层模块,这就非常糟糕了。就像刚才说的,PC里如果CPU、内存、硬盘都需要依赖具体的主板,主板一坏,所有的部件就都没用了,这显然不合理。反过来,如果内存坏了,也不应该造成其他部件不能用才对。而如果不管高层模块还是低层模块,它们都依赖于抽象,具体一点就是接口或抽象类,只要接口是稳定的,那么任何一个的更改都不用担心其他受到影响,这就使得无论高层模块还是低层模块都可以很容易地被复用。这才是最好的办法。 为什么依赖了抽象的接口或抽象类,就不怕更改呢? 原因就是里氏代换原则。 里氏替换原则里氏代换原则是在1988年发表的,它的白话翻译就是一个软件实体如果使用的是一个父类的话,那么一定适用于其子类,而且它察觉不出父类对象和子类对象的区别。也就是说,在软件里面,把父类都替换成它的子类,程序的行为没有变化,简单地说,子类型必须能够替换掉它们的父类型[ASD]. 里氏代换原则(LSP):子类型必须能够替换掉它们的父类型。 子类继承了父类,所以子类可以以父类的身份出现。如果在面向对象设计时,一个是鸟类,一个是企鹅类,如果鸟是可以飞的,企鹅不会飞,那么企鹅是鸟吗?企鹅可以继承鸟这个类吗” 企鹅是一种特殊的鸟,尽管不能飞,但它也是鸟呀,当然可以继承。 子类拥有父类所有非private的行为和属性。鸟会飞,而企鹅不会飞。尽管在生物学分类上,企鹅是一种鸟,但在编程世界里,企鹅不能以父类–鸟的身份出现,因为前提说所有鸟都能飞,而企鹅飞不了,所以,企鹅不能继承鸟类。 也正因为有了这个原则,使得继承复用成为了可能,只有当子类可以替换掉父类,软件单位的功能不受到影响时,父类才能真正被复用,而子类也能够在父类的基础上增加新的行为。比方说,猫是线承动物类的,以动物的身份拥有吃、喝、跑、叫等行为,可当某一天,我们需要狗、牛、羊也拥有类似的行为,由于它们都是继承于动物,所以除了更改实例化的地方,程序其他处不需要改变。 哈,小菜你这个比方打得好,”大鸟开心地说, “收音机就是典型的耦合过度,只要收音机出故障,不管是没有声音、不能调频,还是有杂音,反正都很难修理,不懂的人根本没法修,因为任何问题都可能涉及其他部件,各个部件相互依赖,难以维护。非常复杂的PC电脑可以修,反而相对简单的收音机不能修,这其实就说明了很大的问题。当然,电脑的所谓修也就是更换配件, CPU或内存要是坏了,老百姓是没法修的。现在在软件世界里,收音机式的强耦合开发还是太多了,比如前段时间某银行出问题,需要服务器停机大半天的排查修整,这要损失多少钱。如果完全面向对象的设计,或许问题的查找和修改就容易得多。依赖倒转其实可以说是面向对象设计的标志,用哪种语言来编写程序不重要,如果编写时考虑的都是如何针对抽象编程而不是针对细节编程,即程序中所有的依赖关系都是终止于抽象类或者接口,那就是面向对象的设计,反之那就是过程化的设计了[ASD].” “是的是的,我听说很多银行目前还是纯C语言的面向过程开发,非常不灵活,维护成本是很高昂的。” 那也是没办法的,银行系统哪是说换就换的,所以现在是大力鼓励年轻人学设计模式,直接面向对象的设计和编程,从大的方向上讲,这是国家大力发展生产力的很大保障呀。” 用子类对象实例化父类对象 注意： 只能调用到子类对象里面的父类对象 如果父类成员方法被子类重写了，那么就调用子类里面重写的方法 里氏替换原则有三种表现形式： 1、用子类对象实例化父类对象。 2、父类作为参数，传入子类对象。 3、父类作为返回值，可以返回子类对象。 使用场景： 游戏中的宠物商店 123456789101112131415static Animal GetAnimal(string name)&#123; if (name == "Cat") &#123; return new Cat(); &#125; else if (name == "Dog") &#123; return new Dog(); &#125; else &#123; return null; &#125; &#125; 单例模式两个作用1、主要是让内存中只有一个对象，保证数据的正确性。2、节省内存 自己的总结并不是你写一个继承就能自动满足里氏替换原则的 比如 鸟类 你写了一个会飞的方法 然后鸵鸟继承了这个类 某处调用了父类鸟飞的方法 然后就满足不了里氏替换原则了 不能用鸵鸟替换掉鸟类 因为 鸵鸟不会飞 所以 这个父类设计错误 比如设计一个宠物类 宠物的属性有 重量 价格 颜色 返回值是宠物类 然后根据传参返回具体的宠物。 然后直接使用宠物类Pets.climbtree()肯定不行 因为狗不会上树 所以设计父类的时候一定要拿到所有的共同点 里氏替换原则不是随便写几个继承就能满足的 依赖倒转 一开始写代码的之后并不是每个人都知道接口和抽象的重要性的，这个原则就是在告诉菜鸟们要这样做]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>大话设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2019%2F07%2F23%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 命令模式的应用场景是什么？ 命令模式的缺点是什么？ 学习设计模式的时候，要抛弃所有的可以直接通过函数执行的想法，所有的功能都必须通过类来完成。 其缺点是：可能产生大量具体命令类。因为针对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。 某个方法需要完成某一个功能,完成这个功能的大部分步骤已经确定了,但可能有少量具体步骤无法确定,必须等到执行该方法时才可以确定。具体一点:假设有个方法需要遍历某个数组的数组元素,但无法确定在遍历数组元素时如何处理这些元素,需要在调用该方法时指定具体的处理行为.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>大话设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常量和宏定义]]></title>
    <url>%2F2019%2F07%2F23%2F%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[第5章-类]]></title>
    <url>%2F2019%2F07%2F23%2F%E7%AC%AC5%E7%AB%A0-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 封装的目的是什么？ 本章涵盖： 前言第1章简单介绍了如何声明一个名为Hel1oMorld的新类。第2章介绍了C#内置的基元类型。由于已经学习了控制流以及如何声明方法,所以现在应学习如何定义自己的类型。这是任何C#程序的核心构造,正是由于C#支持类以及根据类来创建对象,所以我们说C#是一种面向对象语言。 本章利用C#介绍面向对象编程的基础知识。重点在于如何定义类,可以将类理解成对象的模板。 在面向对象编程中,之前学过的所有结构化（过程式）编程构造仍然适用。然而,将那些构造封装在类中,可以创建更大、更有条理以及更容易的维护程序。从结构化（过程式）的、基于控制流的程序转向面向对象的程序,是思维模式发生的一个根本性变化,因为面向对象编程提供了一个额外的组织层次。结果是较小的程序在某种程度上得到了简化。但更重要的是,现在更容易创建较大的程序,因为程序中的代码得到了更好的组织。 面向对象编程的关键优势之一是不需要完全从头创建新的程序。而是可以将现有的一系列对象组装到一起,并用新的功能扩展类,或者添加更多的类。 为了支持封装, C#必须支持类、属性、访问修饰符以及方法。本章着重讨论前3种构造,因为方法已在第4章进行了讨论。掌握这些基础知识之后,第6草将讨论如何通过面向对象编程实现继承和多态性。 面向对象编程如今,成功编程的关键在于提供恰当的组织和结构,以满足大型应用程序的复杂需求。面向对象编程能够很好地解决问题。开发人员一旦熟悉了面向对象编程,除非写一些极为简单程序,否则很难回到结构化编程。 面向对象编程最基本的构造是类。一组类构成了编程抽象、模型或者模板,通常对应于一个现实世界的概念。例如, OpticalStorageMedia (光学存储媒体)类可能有一个Eject()方法,该方法会让光盘从播放器中弹出。OpticalstorageMedia类是现实世界的CD/DVD播放器对象的编程抽象。 类是面问对象编程的3个主要特征(封装、继承和多态性)的基础。 封装封装的目的是隐藏细节。在必要的时候,细节仍然可以访问,但通过巧妙地封装细节,大的程序变得更容易理解,数据不会因为不慎而被修改,代码也变得更容易维护(因为对一处代码进行修改所造成的影响被限制在封装的范围之内)。方法就是封装的一个例子。虽然可以将代码从方法中拿出,把它们直接嵌入调用者的代码中,但将特定的代码重构成一个方法,能享受到封装所带来的好处。 继承考虑这个例子: DVD是光学存储媒体的一个类型。它具有特定的存储容量,能容纳一部数字电影。CD也是光学存储媒体的一个类型,但它具有不同的特征。CD上的版权保护有别于DVD的版权保护,两者的存储容量也不同。无论CD还是DVD,它们都有别于硬盘、U盘和软盘。虽然所有这些都是“存储媒体”,但分别具有不同的特征--即使一些基本功能也是不同的,比如所支持的文件系统,以及媒体的实例是只读还是可读可写的。 面向对象编程中的继承允许在这些相似但又不同的物件之间建立“属于”(is a)关系。可以合理地认为DVD和CD都“属于”存储媒体。因而,它们都具有存储能力.类似地, CD和DVD都“属于”光学存储媒体,后者又“属于”存储媒体。 为上面提到的每种存储媒体类型都定义一个类,就得到一个类层次结构,它由一系列“属于”关系构成。例如,可将基类型(所有存储媒体都从它派生)定义成storageMedia(存储媒体)。CD, DVD、硬盘、U盘和软盘都属于StorageMedia。但是,CD和DVID不必直接从StorageMedia派生。相反,可以从中间类型OpticalStorageMedia (光学存储媒体)派生。可以用一幅UML ( Unified Modeling Language,统一建模语言)风格的类关系图 继承关系至少涉及两个类,其中一个是另一个的更具体的版本。在图5-1中HardDrive是更具体的storageMedia,虽然更特化的类型HardDrive属于StorageMedia,但反之不成立,因为storageMedia的一个实例并非肯定是HardDrive,如图5-1所示,继承涉及的类可能不止两个。 更具体的类型称为派生类型或者子类型。更常规的类型称为基类型或者超类型。也经常将基类型称为“父”类型,将派生类型称为它的“子”类型。虽然这种说法很常见,但可能会带来混淆。“子”毕竟不是一种“父” !本书将采用“派生类型”和“基类型”的说法。 为了从一个类型派生或继承,需要对那个类型进行特化,这意味着要对基类型进行自定义,为了满足特定的需要而调整它。基类型可能包含所有派生类型都适用的实现细节。继承最关键的一点是所有派生类型都继承了基类型的成员。派生类型中可以修改基类型的成员,但无论如何,派生类型除了自己显式添加的成员,还包含了基类型的成员。派生类型确保了用一致性的层次结构组织类。在这个层次结构中,派生类型比它们的基类型更特别。 多态性多态性这个词由一个表示“多”的词和一个表示“态”的词构成。讲到对象时,多态性意味着一个方法或类型可以具有多种形式的实现。假定有一个媒体播放机,它既能播放音乐CD,也能播放包含MP3歌曲的DVD,然而, Play()方法的具体实现会随着媒体类型的变化而变化。在一个音乐CD对象上调用Play()方法,或者在一张音乐DVD上调用Play()方法,都能播放出音乐,因为每种类型都理解自己具体如何“播放”。媒体播放器唯一知道的就是公共基类型OpticalStorageMedia以及它定义了Play()方法的事实。在多态性的帮助下,不同的类型能自己照料一个方法的实现细节,因为共享同一个公共基类型(或接口)的多个派生类型也包含了相同的方法签名。 自己的总结常量const和readonly的区别就是圆周率π和银行卡密码的区别。你永远不能去修改π这个常量，只能把开始的时候把3.14赋值给它，无论什么时候都不能去修改它，也没有必要去修改它。但是银行卡密码却是可以修改的。如果你愿意，你的家人也可以知道密码，但只有你可以修改密码，每次把卡激活的时候你都可以选择修改密码。所以像一些科学知识，比如圆周率，重力等都可以用const。不是这些可以用readonly。 属性的作用：1、属性是对字段的封装，是为了安全性问题。2、可以对字段进行额外的操作，通过setter进行逻辑处理。 简写形式现在要写两块代码 所以需要简写代码，变成了一行。当你开放Name为public时，定义的私有private string name已经没有意义，所以可以去掉，直接使用Name。name这个字段已经不存在了，方法里不能出现这个词。所以可以简写。 internal在项目中生效。跨项目需要引用和引入命名空间 C#是关于类型的语言，int，list，class，delegate，struct，enum等都是类型。 栈和堆的区别 栈的空间比堆小，读写速度比堆快。 多态：是一种概念，比如一个方法返回多个对象，里氏替换原则 密封sealed就是为了让一个类可以从父类继承，但是不能作为其他类的父类。所以直接规定了密封关键字只可以用到override的方法上。 同时规定了粒度，用到类上是整个类不能被继承，用到方法上是粒度变小，方法不能被继承。 因为软件系统不是一个人开发的，我有权力让某个类或方法不能继承和重写。加上里氏替换原则，子类可以用作父类的实例，如果重写了，子类调用的就是自己的方法，父类的方法就作废了。用sealed可以避免这一情况。 抽象也和继承有关。抽象的必须继承。 继承衍生出了很多语法。 抽象、接口、虚方法、override、protected、sealed、里氏替换原则、base、单继承、多继承等都是继承相关的。如果面向对象除去继承，可以少掉非常多的语法。 继承完全可以单独作为一章，因为面向对象关于继承的太多了。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#本质论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第12章-委托和Lambda表达式]]></title>
    <url>%2F2019%2F07%2F22%2F%E7%AC%AC12%E7%AB%A0-%E5%A7%94%E6%89%98%E5%92%8CLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 不需要每次传递一个方法时都定义新接口怎么理解？ 静态类有什么特性？为什么要让一个类为静态？ switch怎么改成委托？ 为什么要使用Lambda表达式？ Action&lt;float&gt;怎么理解？Func代表什么委托？ 本章涵盖： 在前几章中，我们全面讨论了如何创建类来封装数据以及对数据操作。随着创建的类越来越多，你会发现类和类的关系存在着一些常见的模式。一种常见的模式是向方法传递对象，该方法再调用对象的一个方法。例如，向方法传递一个IComparer&lt;int&gt;引用，被调用的方法本身可以在提供的对象上调用Compare()方法。在这种情况下，接口的作用只是向最终被调用的方法传递一个引用。所以，似乎不需要每次传递一个方法时都定义新接口。在本章中，我们讲述如何创建和使用被称为委托（delegate）的特殊类，它允许像处理其他任何数据那样处理对方法的引用。然后，我们展示如何使用Lambda表达式快速和简单地创建自定义委托。 Lambda表达式是从C#3.0开始加入的。C#2.0支持用匿名方法（anonymous method）这样一种不太优雅的语法来创建自定义委托。C#2.0之后的每个C#版本都支持匿名方法以保持向后兼容，但新写的代码应该弃用它，代之以Lambda表达式。本章将通过“高级主题”来描述如何使用匿名方法。只有要使用遗留的C#2.0代码时才需要了解这些主题，否则完全可以忽略这些补充内容。 委托概述长期以来，经验丰富的C和C++程序员利用“函数指针”将对方法的引用作为实参传给另一个方法。C#使用委托提供相同的功能。委托允许捕捉对方法的引用，并像传递其他对象那样传递这个引用，像调用其他方法那样调用这个被捕捉的方法。来看看下面的例子。 背景虽然效率不高，但冒泡排序或许是最简单的排序例程了。代码清单1展示了Bubblesort()方法。 代码清单1 Bubblesort()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace sort&#123; class Program &#123; static void Main(string[] args) &#123; int[] items = &#123; 67, 34, 6, 134, 349, 230, 56 &#125;; SimpleSort1.BubbleSort(items); &#125; &#125; //静态类的主要特性: //1、仅包含静态成员 //2、无法实例化 //3、是密封的 //4、不能包含实例构造函数。 //5、工具类适合作为静态类，像Math类 static class SimpleSort1 &#123; public static void BubbleSort(int[] items) &#123; int i; int j; int temp; if(items == null) &#123; return; &#125; for (i=items.Length-1; i&gt;= 0; i--) &#123; for (j=1; j&lt;=i; j++) &#123; if (items[j-1] &gt; items[j]) &#123; temp = items[j-1]; items[j-1] = items[j]; items[j] = temp; &#125; &#125; &#125; for (int x = 0; x &lt; items.Length; x++) &#123; Console.WriteLine(items[x]); &#125; Console.ReadKey(); &#125; &#125;&#125; 该方法对整数数组执行升序排序。 为了能选择升级或降序来排序整数，有两个方案可选：一是复制上述代码，然后将大于操作符替换成小于操作符。但是复制这么多代码只是改变了一个操作符，这似乎不是一个好主意；二是传递一个附加参数，指出如何排序，如代码清单2所示。 代码清单2 Bubblesort()方法，升序或降序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace sort&#123; class Program &#123; static void Main(string[] args) &#123; int[] items = &#123; 67, 34, 6, 134, 349, 230, 56 &#125;; Simplesort2.BubbleSort(items, Simplesort2.SortType.Descending); &#125; &#125; class Simplesort2 &#123; public enum SortType &#123; Ascending, Descending &#125; public static void BubbleSort(int[] items, SortType sortOrder) &#123; int i; int j; int temp; if (items == null) &#123; return; &#125; for (i = items.Length - 1; i &gt;= 0; i--) &#123; for (j = 1; j &lt;= i; j++) &#123; bool swap = false; switch (sortOrder) &#123; case SortType.Ascending: swap = items[j - 1] &gt; items[j]; break; case SortType.Descending: swap = items[j - 1] &lt; items[j]; break; &#125; if (swap) &#123; temp = items[j - 1]; items[j - 1] = items[j]; items[j] = temp; &#125; &#125; &#125; for (int x = 0; x &lt; items.Length; x++) &#123; Console.WriteLine(items[x]); &#125; Console.ReadKey(); &#125; &#125;&#125; 然而，上述代码只是照顾到了两种可能的排序方式。假如想按字典顺序排序（即1, 10, 11, 12, 2, 20, …），或者按其他方式排序，sortType值以及对应的swich分支的数量很快就会变得非常“恐怖”。 委托数据类型为了增强灵活性和减少重复代码，可以将比较方法作为参数传给Bubblesort()方法。为了能将方法作为参数传递，必须要有一个能够表示方法的数据类型。这个数据类型就是委托，因为它“委托”调用对象所引用的方法。代码清单3对Bubblesort()方法进行了修改，它现在能获取一个委托参数。在本例中，委托数据类型是ComparisonHandler。 代码清单3 带有委托参数的Bubblesort()方法 123456789101112131415161718192021222324252627282930313233class DelegateSample&#123; public static void BubbleSort(int[] items, ComparisonHandler comparisonMethod) &#123; int i; int j; int temp; if(comparisonMethod == null) &#123; throw new ArgumentNullException("comparisonMethod"); &#125; if(items == null) &#123; return; &#125; for(i = items.Length-1; i&gt;=0; i--) &#123; for (j=1; j &lt;=i; j++) &#123; if (comparisonMethod(items[j-1], items[j])) &#123; temp = items[j-1]; items[j-1] = items[j]; items[j] = temp; &#125; &#125; &#125; &#125;&#125; ComparisonHandler是委托类型，代表对两个整数进行比较的方法。在Bubblesort()方法中，可以使用comparisonMethod参数所引用的ComparisonHandler的实例来判断哪个整数更大。由于comparisonMethod代表一个方法，所以调用它的语法与直接调用方法的语法完全一致。在这个例子中，comparisonMethod委托获取两个整数参数，返回一个布尔值来指出第一个整数是否大于第二个。传方法进来要注意的是，ComparisonHandler委托是强类型的，它代表返回一个bool值，而且正好接受两个整数参数的方法。和其他方法调用一样，对委托的调用是强类型的。假如数据类型不匹配，C#编译器会报错。 委托类型的声明前面描述了如何定义使用委托的方法，并介绍了如何将委托变量当作方法，从而简单地发出对委托的调用。然而，还必须学习如何声明委托类型。为了声明委托类型，要使用delegate关键字，后面跟着像是方法声明的东西。这个方法的签名是委托所引用的方法的签名。正常方法声明中方法名称的位置要替换成委托类型的名称。代码清单4展示了如何声明ComparisonHandler委托类型来要求两个整数并返回一个布尔值。 代码清单4 声明一个委托类型 1public delegate bool ComparisonHandler(int first, int second); 就像类能嵌套在其他类中一样，委托也能嵌套在类中。假如委托声明出现在另一个类的内部，委托类型就会成为嵌套类型，如代码清单5所示。 代码清单5 声明嵌套的委托数据类型 1234class DelegateSample&#123; public delegate bool ComparisonHandler(int first, int second);&#125; 在这个例子中，声明的委托数据类型是DelegateSample.ComparisonHandler，因为它被定义成DelegateSample中的嵌套类型。 委托的实例化在使用委托来实现Bubblesort()方法的最后一步中,你将学习如何调用方法并传递委托实例-具体地说,传递ComparisonHandler类型的实例。为了实例化委托,需要一个和委托类型自身的签名匹配的方法。对于ComparisonHandler,这个方法应获取两个整数,并返回boo1值。方法名称无关紧要,但是方法的签名的剩余部分(参数和返回值)必须兼容委托的签名。代码清单12-6展示了与委托类型兼容的GreaterThan()方法。 代码清单12-6声明与ComparisonHandler兼容的方法 123456public delegate bool ComparisonHandler (int first, int second);class DelegateSampletpublic static void Bubblesort(int[] items, ComparisonHandler comparisonMethoa)委托作为参数/.. 原来用的是一个方法,现在是多个方法 12public static bool GreaterThan(int first, int second)।return first &gt; second; 定义好方法之后,就可以调用Bubblesort(),并提供由委托捕捉到的方法的名称作为实参,如代码清单12-7所示。 代码清单12-7 使用方法名作为实参 12public delegate bool ComparisonHandler (int first, int second).class Delegatesampletblic static void Bubblesort( 注意, ComparisonHandler委托是引用类型,但不必用new实例化它。从C# 2.0开始,从方法组(为方法命名的表达式)向委托类型的转换会自动创建一个新的委托对象。 高级主题: C#1.0中的委托实例化 在代码清单12-7中,调用Bubblesort()时传递所需方法的名称(GreaterThan )作为一个实参就可以实例化委托。C#的第一个版本要求使用如代码清单12-8所示的较复杂的语法来实例化委托。 代码清单8 C#1.0中将委托作为参数传递 12Bubblesort(itemsnew ComparisonHandler (GreaterThan)). 以后的版本支持上述两种语法。本书剩余的部分只使用更现代的、简洁的语法。高级主题:委托的内部机制 1委托实际是特殊的类]虽然C#标准没有确切规定类的层次结构应该是怎样的,但委托必须直接或间接地派生自System. Delegate。事实上, .NET中的委托类型总是 生自System.MulticastDelegate,后者又从System.Delegate派生,如图12-1所示。 反射图12-1 委托类型的对象模型 第一个属性属于(System.Reflection. MethodInfo)类型,它是第17章要讨论的主题。Methodinfo描述了特定方法的签名,包括方法名称、参数和返回类型除了Methodinfo,委托还需要一个对象实例,其中包含了要调用的方法。这正是第二个属性Target的作用。|在静态方法的情况下, Target对应于类型自身1至于MulticastDelegate类的作用,将在下一章详细描述。 target字段 注意,所有委托都是不可变的。委托一旦创建好就无法更改。如果变量包含了委托的引用,还想引用其他不同的方法,那就必须创建一个新委托,并把它指派给这个变量。虽然所有委托数据类型都是间接地从System. Delegate派生的,但C#编译器不允许声明直接或间接从System.Delegate或者System.MulticastDelegate派生的类。代码清单12-9的代码是无效的。 代码清单12-9 System.Delegate不能显式地作为基类 123V ERROR: 'ComparisonHandLer. cannot// innerit from special class 'System. Delegate"// public class ComparisonHandLer: System. DeLegate//.. 通过传递委托来指定排序方式显然要比本章开头的方式灵活得多。例如,为了改为按字母排序,只需添加一个附加的委托,在比较过程中将整数转换为字符串。代码清单12-10提供了实现按字母排序的完整代码,输出12-1展示了结果。 代码清单12-10使用其他与ComparisonHandler兼容的方法 1234567891011using System;class DelegateSamplepublic delegate bool comparisonHandler(int first, int second);public static void Bubblesortoint[] items, ComparisonHandler comparisonMethod)int i;int j;int temp;for (1 = items.Length -1; 1 &gt;= 0; 1--).for (j=1;j&lt;=i; j++)tif (comparisonMethod(items [j-1], items [j)temp = items[i-11;items[j-1] - items [3];items[i] = temp;public static bool GreaterThan(int first, int second)return first second; 有新的排序方式时,就再添加方法 123456789101112public static bool AlphabeticalGreaterThan(int first, int second)int comparison;comparison(first.Tostring().CompareTor second. Tostring());return comparison &gt;;static void Main(string[] args)int i;int[] items = new int[5].for (i-e; icitems.Length; it+)Console.write("Enter an integer: ");items[i] - int.Parse(Console, ReadLine());Bubblesort(items, AlphabeticalGreaterThan); |这儿其实就是赋值了for (i = 8: i items. Length; i++) comparisonMethod =tconsole.WriteLine(items[41); AlphabeticalGreaterThan; 按字母排序与按数值排序的结果不同。可以看到,和本章开头描述的方式相比,现在添加一个附加的排序机制是多么简单! 要想按字母排序,唯一要做的就是添加A1phabeticalGreaterThan方法,然后在调用Bubblesort()的时候传递该方法。 通用的委托：Func和Action为了减少自定义委托类型的必要，.NET3.5“运行时”库（对应C#3.0）包含了一组通用的委托，其中大多数都是泛型。System.Func系列委托代表有返回值的方法，而System.Action系列委托代表返回void的方法。 下面展示了这些委托的签名。 Func和Action委托声明 1234public delegate void Action();public delegate void Action&lt;in T&gt;(T arg);public delegate void Action&lt;in T1, in T2&gt;(T1 arg1, T2 arg2);... 一直到16个参数 1234public delegate TResult Func&lt;out TResult&gt;();public delegate TResult Func&lt;in T, out TResult&gt;(T arg);public delegate TResult Func&lt;in T1, in T2, out TResult&gt;(T1 arg1, T2 arg2);... 一直到16个参数]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#本质论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15、事件与委托：没有监视时，代码在做什么]]></title>
    <url>%2F2019%2F07%2F22%2F15%E3%80%81%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%A7%94%E6%89%98%EF%BC%9A%E6%B2%A1%E6%9C%89%E7%9B%91%E8%A7%86%E6%97%B6%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 对象开始自己考虑问题你并不总能控制对象在干什么。有时候会发生一些事情。如果真是如此，你希望对象能足够聪明，对发生的事情做出响应。这正是事件要做的事情。一个对象发布一个事件，其他对象订购这个事件，大家联合起来保证工作顺利进行。听起来不错，不过如果希望对象能控制谁能监听，就不那么容易了。这里就需要用到回调。 发布者，遇到订阅者希望你的对象自己考虑问题吗？ 假设你在编写一个棒球模拟系统。你要为一场比赛建模，想把这个软件卖给棒球队。你创建了Ball、Pitcher、Umpire和Fan对象，还有很多其他对象。另外还编写了代码使Pitcher对象能接住球。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Head First C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存和指针：指向何方？]]></title>
    <url>%2F2019%2F07%2F21%2F%E5%86%85%E5%AD%98%E5%92%8C%E6%8C%87%E9%92%88%EF%BC%9A%E6%8C%87%E5%90%91%E4%BD%95%E6%96%B9%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是指针？ 为什么要使用指针？指针做了几件事？ 学习C指针的诀窍是什么？ 内存分为几部分？内存图是什么样子的？ 函数中的变量存储在哪？函数以外的地方声明变量存储在哪？ 为什么地址有时也叫指针？ 为什么指针是一种间接形式的地址? 如果真的想玩转C语言，就需要理解C语言如何操纵内存。 C语言在如何使用内存方面赋予了你更多的掌控权。在本章中，你将揭开内存神秘的面纱，看到读写变量时到底发生了什么；学习数组的工作原理，以及怎样避免烦人的内存错误，最重要的是，你将看到掌握指针和内存寻址对成为一名地道的C程序员来讲有多么重要。 C代码包含指针指针是理解C语言最基本的要素之一。那么什么是指针？指针就是内存中某条数据的地址。 之所以要在C语言中使用指针有以下几个原因。 1、在函数调用时，可以只传递一个指针，而不用传递整份数据。（因为整份数据可能会很大很大） 2、让两段代码处理同一条数据，而不是处理两份独立的副本。（一个数据可能有多个函数进行处理，需要保持一致。例如金钱。） 指针做了两件事：避免副本和共享数据。但既然指针只是地址而己，为什么它会令很多人感到困惑呢？因为指针是一种间接形式的地址。在茫茫内存中追逐指针，一不小心就会迷路。而学习C指针的诀窍就是慢慢来。 深入挖掘内存为了理解什么是指针，需要切开计算机的内存（内存）瞧瞧。 每当声明一个变量，计算机都会在内存中某个地方为它创建空间。如果在函数（例如main()函数）中声明变量，计算机会把它保存在一个叫栈（Stack）的内存区段中；如果你在函数以外的地方声明变量，计算机则会把它保存在内存的全局量段（Globals）。 1234567int y = 1; // 变量位于全局量段。内存地址1 000 000。值为1。int main()&#123; int x = 4; // 变量x位于栈中，内存地址4 100 000。值为4。 return 0;&#125; 比如说，计算机可能将栈中4 100 000号内存单元分配给变量x。如果把4赋给变量x，计算机就会把4保存在4 100 000号单元。 如果想要找出变量的内存地址，可以用&amp;运算符： 123456// %p用来格式化地址。printf ("x保存在 %p\n", &amp;x); // &amp;x是x的地址// 下面是代码打印的结果// x保存在 0x3E8FA0。// 是4 100 000的十六进制(以16为基数)表示，在你的机器上可能得到不同的地址。 变量的地址告诉你去哪里找内存中的变量，这就是为什么地址有时也叫指针，因为它指向了内存中的变量。 在函数中声明的变量通常保存在栈中。在函数外声明的变量保存在全局量区。 和指针起航想象你在为一个游戏编写程序，游戏中玩家需要控制船的航向。 游戏需要控制很多东西，比如得分、生命值和玩家当前的位置。你不想把游戏写成一段很长的代码，而是可以创建许多小的函数，让每个函数完成游戏的一个功能。 那么这和指针有什么关系？让我们先不考虑指针，写写看。你将和往常一样使用变量，游戏的主要部分是驾驶你的船在百慕大三角航行，我们具体看看代码需要在航行函数中完成哪些事。 船长，向东航行! 游戏用纬度（latitude）和经度（longitude）记录玩家的位置，纬度标记玩家南北方向的位置，经度标记玩家东西方向的位置。如果玩家想要向东南方向航行，他的纬度将减小，经度将增加。 于是可以写一个go_south_east()函数，它接收latitude和longitude这两个变量，然后对它们进行加、减操作: 12345678910111213141516#include &lt;stdio.h&gt; void go_south_east(int lat, int lon) // 传入latitude和longitude&#123; lat = lat - 1; // 纬度减小 lon = lon + 1; // 经度增加&#125;int main()&#123; int latitude = 32; int longitude = -64; go_south_east(latitude, longitude); printf("停！当前位置: [%i, %i]\n", latitude, longitude) ; return 0;&#125; 程序开始时船的位置是[32, -64]，如果它向东南方向航行，船的新坐标将是[31, -63]，前提是代码正确工作…… 仔细看看这段代码，你认为它能正确工作吗？为什么？ C为什么要用指针显而易见，一是用指针可以多个代码执行一个数据，像数据恒加恒减，不会让一个金钱数字因为多段代码而乱掉。 二是传参的时候传一个指针，就可以避免传海量的数据。 进一步说明几个不同数据类型共用同一段内存的结构，称为联合。举个例子： 123456union&#123; int i; char ch; float f;&#125; 这个联合结构有三个元素对吧，一般来说不同的变量存在不同的内存，但联合中的这三个变量就存在同一段内存，只是在固定的某时刻，这个内存中只有这三个元素的其中一个元素存在，说到底是省了内存空间，比如，这个联合结构，就只占(sizeof(float))8个字节，就是元素中占最大空间的元素所占空间的大小。而你看结构体（struct） 123456struct&#123; int i; char ch; float f;&#125; 他占的空间大小就应该是三个元素所占空间的总和（sizeof(int)+sizeof(char)+sizeof(float)）;基本就是这样了。 你想定义一个变量5，想要它既是整形，又是字符，又是浮点型数据，可以和7相乘，又能和字符串拼接，就用到联合。 和结构体同属于C语言数据类型中的结构类型。例如 123456uniuon data&#123; int i ; char c ; float f;&#125;x; 定义共用体类型名称为data类型，有三个属性，分别为 1int i ; char c ;float f; 这三个属性共同占用内存空间，所以空间占用选属性中占用最多的那个，也就是float f。占用四个字节。由于共同占用，所以在同一时间只能保留一个属性内容如果为 123456struct data&#123; int i ; char c ; float f;&#125;x; 则表明定义结构体类型名称为data类型，也是三个属性，不过在内存中占用的是空间大小是三个属性之和。若int类型在编译器中分配4字节的话，总共分配字节数位4+1+4总共9字节。由于单独占用，所以在同一时间可以保留所有属性内容。]]></content>
      <categories>
        <category>Head First C</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构、联合与位字段：创建自己的字段]]></title>
    <url>%2F2019%2F07%2F20%2F%E7%BB%93%E6%9E%84%E3%80%81%E8%81%94%E5%90%88%E4%B8%8E%E4%BD%8D%E5%AD%97%E6%AE%B5%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么要使用结构？怎么使用？ 为什么要为结构创建别名？怎么创建？ 参数太多和多个函数参数相同有什么弊端？ 为什么不能使用数组？ 结构是自定义数据类型怎么理解？ 结构中会保存字符串吗？如何保存？ 把参数封装在结构中有什么好处？ 为什么要使用联合？ 到目前为止，只接触过C语言的基本数据类型，但如果想表示数字、文本以外的其他东西呢，或为现实世界中的事物建立模型（用C语言的一条数据来描述一个人的信息，例如姓名，性别，年龄等），怎么办？结构将帮你创建自己的结构，模拟现实世界中错综复杂的事物。在本章中，你将学习如何把基本数据类型组成结构以及用联合处理生活的不确定性。如果你想简单地模拟“是”或“非”，可以用位字段。 有时要传很多数据C语言可以处理很多不同类型的数据：小数字、大数字、浮点数、字符与文本。但现实世界中的事物往往需要一条以上的数据来记录。比如下面这个例子，两个函数处理同一个东西，因此需要接收相同的数据。 123456789101112// 下面两个函数接收相同的参数。/* 打印目录项 */// const char *用来保存你不想修改的字符串，也就是字符串字面值。void catalog(const char *name, const *species, int teeth, int age)&#123; printf("%s is a %s with %i teeth, he is %i\n", name, species, teeth, age);&#125;/* 打印贴在水缸上的标签 */void label(const char *name, const *species, int teeth, int age)&#123; printf("Name:%s\nSpecies:%s\n%i years old, %i teeth\n", name, species, teeth, age);&#125; 虽然只传了4个参数，但代码已经有点乱了： 1234567int main()&#123; // 两次都传了相同的4个参数。而且只有一条鱼，但参数有四个。 catalog("Snappy", "Piranha", 69, 4); label("Snappy", "Piranha", 69, 4); return 0;&#125; 怎么才能解决这个问题？只是想描述一样东西而已，有没有办法可以不用传那么多数据？ 有些人认为4个参数也没有什么，但是如果修改程序，给鱼多加一条数据呢？我们要把它加到每一个接收鱼作为参数的函数中。对一个大程序来说，这样的函数可能有上百个。 为了修改简单，只要把这些数据组合成一样东西就行了，类似数组。但数组通常保存相同类型的数据，现在要同时保存字符串和整型，所以我们不能把它们放进一个数组。 需要一样东西，能让你在一条大数据中记录多条数据，能让我们同时引用一组不同类型的数据，仿佛它们是一条数据。 用结构创建结构化数据类型如果需要把一批数据打包成一样东西，就可以使用结构（struct）。struct是structured data type（结构化数据类型）的缩写。有了结构，就可以像下面这样把不同类型的数据写在一起，封装成一个新的大数据类型： 1234567struct fish&#123; const char *name; const char *species; int teeth; int age;&#125;; 这段代码会创建一个新的自定义数据类型，它由一批其他数据组成。事实上，结构与数组有些相似，除了以下两点： 结构的大小固定。 结构中的数据都有名字。 定义新结构以后，如何使用它来创建数据？和新建数组很像，你只需要保证每条数据按照它们在结构中定义的顺序出现即可。 12// struct fish是数据类型 Snappy是变量名 struct fish Snappy = &#123;"Snappy", "Piranha", 69, 4&#125;; 在这个例子中，fish结构不会保存字符串，这里的fish结构中只保存了字符串指针，也就是字符串的地址，字符串保存在存储器中其他位置。只要把字符串定义成字符数组，像char name[20]，还是可以把字符串保存在结构中。 只要把鱼给函数就行了现在，你只要把新的自定义数据传给函数就行了，而不必传递一大批零散的数据。 12345678910/* 打印目录项 */void catalog(struct fish f)&#123; ...&#125;/* 打印贴在水缸上的标签 */void label(struct fish f)&#123; ...&#125; 是不是简单多了？现在函数只需接收一条数据，而且调用函数的代码也更易读了： 123struct fish snappy = &#123;"Snappy", "Piranha", 69, 4&#125;;catalog(snappy);label(snappy); 把数据放在结构中传递有一个好处，就是修改结构的内容时，不必修改使用它的函数。比如要在fish中多加一个字段： 12345678struct fish&#123; const char *name; const char *species; int teeth; int age; int favorite_music;&#125;; catalog()和label()知道有人会给它们一条fish，但却不知道fish中现在有了更多的数据，它们也不关心，只要fish有它们需要的所有字段就行了。 这就意味着，使用结构，不但代码更好读，而且能够更好地应对变化。 把参数封装在结构中，代码会更稳定。 以上便是定义自定义数据类型的方法，但怎么才能使用它们呢？函数如何读取结构中保存的某条数据呢？ 使用“.”运算符读取结构字段因为结构和数组有些像，你可能以为能像读取数组元素那样读取结构字段： 12struct fish snappy = &#123;"Snappy", "piranha", 69, 4&#125;;printf("Name = %s\n", snappy&#123;0&#125;); // 既然snappy是数组指针，就可以像访问它的第一个字段。 如果像访问数组元素那样读取结构字段，会得到编译错误。 但不可以这样做。尽管结构可以像数组那样在结构中保存字段，但读取时只能按名访问。可以使用“.”运算符访问结构字段。如果你用过JavaScript或Ruby这样的语言，一定会觉得非常眼熟。 12struct fish snappy = &#123;"Snappy", "piranha", 69, 4&#125;;printf("Name = %s\n", snappy.name); // 将返回字符串“Snappy”。 下面是新版的catalog()函数，函数将使用fish结构。 123456789101112void catalog(struct fish f)&#123; printf("%s is a %s with %i teeth, he is %i\n", f.name, f.species, f.teeth, f.age);&#125;int main()&#123; struct fish Snappy = &#123;"Snappy", "Piranha", 69, 4&#125;; catalog(snappy); /* 暂时先跳过调用label函数的代码 */ return 0;&#125; 用typedef为结构命名。当创建内置数据类型变量时，只要写int或double就行了，但每次创建结构变量时，不得不加上struct关键字。（fish是和int，double一样的，但是声明和赋值整型变量只要写int a = 1;就OK了。但是struct要写struct fish = {…}，不能直接写fish。） 12 在C语言中可以为结构创建别名，你只要在struct关键字前加上typedef，并在右花括号后写上类型名，就可以在任何地方使用这种新类型。 12345678typedef struct cell_phone&#123; int cell_no; const char *wallpaper; float minutes_of_charge;&#125; phone;phone p = &#123;5557879, "sinatra.png", 1.35&#125;; typedef可以用来缩短代码长度，并让代码更容易阅读。试试在代码中加入typedef。 联合不同数据类型同一类事物，不同数据类型 可以用结构来模拟现实世界中错综复杂的事物，但有些数据不止一种数据类型： 假如想记录某样东西的“量”，既可以用个数，也可以用重量，或者用容积。所以大可在一个结构中创建多个字段： 12345typedef struct &#123; short count; float weight; float volume;&#125; fruit; 这不是好主意，原因有以下几点： 结构在存储器中占了更多空间。 用户可以设置多个值。 没有叫“量”的字段。 要是能这样就好了：定义一种叫“量”的数据类型，然后根据特定的数据决定要保存个数、重量还是容积。 在C语言中，可以用联合做到这点。 联合可以有效使用存储器空间每次创建结构实例，计算机都会在存储器中相继摆放字段： 联合则不同。当定义联合时，计算机只为其中一个字段分配空间。假设你有一个叫quantity的联合，它有三个字段、分别是count、weight和volume，那么计算机就会为其中最大的字段分配空间，然后由你决定里面保存什么值。无论设置了count、weight和volume中的哪个字段，数据都会保存在存储器中同一个地方。 如何使用联合声明联合变量后，有很多方法设置它的值。 C89方式 如果联合要保存第一个字段的值，就可以用C89表示法，只要用花括号把值括起来，就可以把值赋给联合中第一个字段。 1quantity = &#123;4&#125;; // 表示“量”是4个。 指定初始化器 指定初始化器（designated initializer）按名设置联合字段的值： 1quantity q = &#123;.weight = 1.5&#125;; // 把联合设为浮点型的重量值 “点”表示法 第三种设置联合值得方法是在第一行创建变量，然后在第二行设置字段的值。 12quantity q;q.volume = 3.7; 自己的总结struct像C#中的委托一样，需要先定义，然后就可以像int一样使用了。但是C#中的委托使用，例如： 12public delegate void MyDelegate();MyDelegate del; 在声明变量的时候没有加上delegate，而C语言则加上了，不合理，所以需要去掉。 123456struct fish&#123; &#125;;struct fish]]></content>
      <categories>
        <category>Head First C</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 算法]]></title>
    <url>%2F2019%2F07%2F20%2F%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 算法具有的五个基本特性是什么？ 函数的渐近增长是什么？ 如何推导大O阶呢？ 本章涵盖： 1.两种算法的比较 2.算法定义 3.算法的特性 4.算法设计的要求 5.算法效率的度量方法 6.函数的渐近增长 7.算法时间复杂度 8.常见的时间复杂度 9.最坏情况与平均情况 10.算法空间复杂度 两种算法的比较现在要求你写一个求1+2+3+……+100结果的程序，你应该怎么写呢？ 大多数人会马上写出下面的C语言代码： 1234567int i, sum = 0, n = 100;for (i = 1; i &lt;= n; i++)&#123; sum = sum + i;&#125;printf("%d", sum); 这是最简单的计算机程序之一，它就是一种算法。问题在于，你的第一直觉是这样写的，但这样是不是真的很好？是不是最高效？ 用高斯算法来实现如下： 123int sum = 0,n = 100;sum = (1 + n) * n / 2;printf("%d", sum); 神童就是神童，他用的方法相当于另一种求等差数列的算法，不仅仅可以用于1加到100，就是加到一千、一万、一亿（需要更改整型变量类型为长整型，否则会溢出），也就是瞬间之事。但如果用刚才的程序，显然计算机要循环一千、一万、一亿次的加法运算。人脑比电脑算得快，似乎成为了现实。 算法定义什么是算法呢？算法是描述解决问题的方法。算法（Algorithm）的定义是：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 刚才的例子我们也看到，对于给定的问题，是可以有多种算法来解决的。 现实世界中的问题千奇百怪，算法当然也就千变万化，没有通用的算法可以解决所有的问题。甚至解决一个小问题，很优秀的算法却不一定适合它。 算法定义中，提到了指令，指令能被人或机器等计算装置执行。它可以是计算机指令，也可以是我们平时的语言文字。 为了解决某个或某类问题，需要把指令表示成一定的操作序列，操作序列包括一组操作，每一个操作都完成特定的功能，这就是算法了。 算法的特性算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。 输入输出输入和输出特性比较容易理解，算法具有零个或多个输入。尽管对于绝大多数算法来说，输入参数都是必要的，但对于个别情况，如打印“helloworld！”这样的代码，不需要任何输入参数，因此算法的输入可以是零个。算法至少有一个或多个输出，算法是一定需要输出的，不需要输出，你用这个算法干吗？输出的形式可以是打印输出，也可以是返回一个或多个值等。 有穷性有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。现实中经常会写出死循环的代码，这就是不满足有穷性。当然这里有穷的概念并不是纯数学意义的，而是在实际应用当中合理的、可以接受的“有边界”。你说你写一个算法，计算机需要算上个二十年，一定会结束，它在数学意义上是有穷了，可是媳妇都熬成婆了，算法的意义也不就大了。 确定性确定性：算法的每一步骤都具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。 可行性可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。 算法设计的要求刚才我们谈到了，算法不是唯一的。也就是说，同一个问题，可以有多种解决问题的算法。尽管算法不唯一，相对好的算法还是存在的。掌握好的算法，对我们解决问题很有帮助，否则前人的智慧我们不能利用，就都得自己从头研究了。那么什么才叫好的算法呢？ 正确性正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。 但是算法的“正确”通常在用法上有很大的差别，大体分为以下四个层次。 1.算法程序没有语法错误。 2.算法程序对于合法的输入数据能够产生满足要求的输出结果。 3.算法程序对于非法的输入数据能够得出满足规格说明的结果。 4.算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。 对于这四层含义，层次1要求最低，但是仅仅没有语法错误实在谈不上是好算法。这就如同仅仅解决温饱，不能算是生活幸福一样。而层次4是最困难的，我们几乎不可能逐一验证所有的输入都得到正确的结果。 因此算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。证明一个复杂算法在所有层次上都是正确的，代价非常昂贵。所以一般情况下，我们把层次3作为一个算法是否正确的标准。 好算法还有什么特征呢？ 可读性可读性：算法设计的另一目的是为了便于阅读、理解和交流。 可读性高有助于人们理解算法，晦涩难懂的算法往往隐含错误，不易被发现，并且难于调试和修改。 我们写代码的目的，一方面是为了让计算机执行，但还有一个重要的目的是为了便于他人阅读，让人理解和交流，自己将来也可能阅读，如果可读性不好，时间长了自己都不知道写了些什么。可读性是算法（也包括实现它的代码）好坏很重要的标志。 健壮性一个好的算法还应该能对输入数据不合法的情况做合适的处理。比如输入的时间或者距离不应该是负数等。 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。 时间效率高和存储量低最后，好的算法还应该具备时间效率高和存储量低的特点。 时间效率指的是算法的执行时间，对于同一个问题，如果有多个算法能够解决，执行时间短的算法效率高，执行时间长的效率低。存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。设计算法应该尽量满足时间效率高和存储量低的需求。在生活中，人们都希望花最少的钱，用最短的时间，办最大的事，算法也是一样的思想，最好用最少的存储空间，花最少的时间，办成同样的事就是好的算法。求100个人的高考成绩平均分，与求全省的所有考生的成绩平均分在占用时间和内存存储上是有非常大的差异的，我们自然是追求可以高效率和低存储量的算法来解决问题。 综上，好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征。 算法效率的度量方法刚才我们提到设计算法要提高效率。这里效率大都指算法的执行时间。那么我们如何度量一个算法的执行时间呢？ 比较容易想到的方法就是，我们通过对算法的数据测试，利用计算机的计时功能，来计算不同算法的效率是高还是低。 事后统计方法事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。 但这种方法显然是有很大缺陷的： 必须依据算法事先编制好程序，这通常需要花费大量的时间和精力。如果编制出来发现它根本是很糟糕的算法，不是竹篮打水一场空吗？ 时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优劣。要知道，现在的一台四核处理器的计算机，跟当年286、386、486等老爷爷辈的机器相比，在处理算法的运算速度上，是不能相提并论的；而所用的操作系统、编译器、运行框架等软件的不同，也可以影响它们的结果；就算是同一台机器，CPU使用率和内存占用情况不一样，也会造成细微的差异。 算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模有很大关系，效率高的算法在小的测试数据面前往往得不到体现。比如10个数字的排序，不管用什么算法，差异几乎是零。而如果有一百万个随机数字排序，那不同算法的差异就非常大了。那么我们为了比较算法，到底用多少数据来测试，这是很难判断的问题。 基于事后统计方法有这样那样的缺陷，我们考虑不予采纳。 事前分析估算方法我们的计算机前辈们，为了对算法的评判更科学，研究出了一种叫做事前分析估算的方法。 事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。 经过分析，我们发现，一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素： 1.算法采用的策略、方法。 2.编译产生的代码质量。 3.问题的输入规模。 4.机器执行指令的速度。 第1条当然是算法好坏的根本，第2条要由软件来支持，第4条要看硬件性能。也就是说，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少。 我们来看看今天刚上课时举的例子，两种求和的算法： 第一种算法： 123456int i, sum = 0,n = 100; /* 执行1次 */for (i = 1; i &lt;= n; i++) /* 执行了n+1次 */&#123; sum = sum + i; /* 执行n次 */&#125;printf("%d", sum); /* 执行1次 */ 第二种算法： 123int sum = 0,n = 100; /* 执行一次 */sum = (1 + n) * n / 2; /* 执行一次 */printf("%d", sum); /* 执行一次 */ 显然，第一种算法，执行了1+(n+1)+n+1次=2n+3次；而第二种算法，是1+1+1=3次。事实上两个算法的第一条和最后一条语句是一样的，所以我们关注的代码其实是中间的那部分，我们把循环看作一个整体，忽略头尾循环判断的开销，那么这两个算法其实就是n次与1次的差距。算法好坏显而易见。 我们再来延伸一下上面这个例子： 12345678910int i, j, x = 0, sum = 0, n = 100; /* 执行一次 */for (i = 1; i &lt;= n; i++)&#123; for (j = 1; j &lt;= n; j++) &#123; x++; /* 执行n×n次 */ sum = sum + x; &#125;&#125;printf("%d", sum); /* 执行一次 */ 这个例子中，i从1到100，每次都要让j循环100次，而当中的x++和sum=sum+x；其实就是1+2+3+…+10000，也就是1002次，所以这个算法当中，循环部分的代码整体需要执行n2（忽略循环体头尾的开销）次。显然这个算法的执行次数对于同样的输入规模n=100，要多于前面两种算法，这个算法的执行时间随着n的增加也将远远多于前面两个。 此时你会看到，测定运行时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数。运行时间与这个计数成正比。 我们不关心编写程序所用的程序设计语言是什么，也不关心这些程序将跑在什么样的计算机中，我们只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止条件、变量声明、打印结果等操作，最终，在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。 可以从问题描述中得到启示，同样问题的输入规模是n，求和算法的第一种，求1+2+…+n需要一段代码运行n次。那么这个问题的输入规模使得操作数量是f(n)=n，显然运行100次的同一段代码规模是运算10次的10倍。而第二种，无论n为多少，运行次数都为1，即f(n)=1；第三种，运算100次是运算10次的1000倍。因为它是f(n)=n2。 我们在分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数（如图1所示）。 图1 我们可以这样认为，随着n值的越来越大，它们在时间效率上的差异也就越来越大。 函数的渐近增长我们现在来判断一下，以下两个算法A和B哪个更好。假设两个算法的输入规模都是n，算法A要做2n+3次操作，你可以理解为先有一个n次的循环，执行完成后，再有一个n次循环，最后有三次赋值或运算，共2n+3次操作。算法B要做3n+1次操作。你觉得它们谁更快呢？ 准确说来，答案是不一定的（如表1所示）。 表1 当n=1时，算法A效率不如算法B（次数比算法B要多一次）。而当n=2时，两者效率相同；当n&gt;2时，算法A就开始优于算法B了，随着n的增加，算法A比算法B越来越好了（执行的次数比B要少）。于是我们可以得出结论，算法A总体上要好过算法B。 此时我们给出这样的定义，输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐近增长的。 函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。 从中我们发现，随着n的增大，后面的+3还是+1其实是不影响最终的算法变化的，例如算法A′与算法B′，所以，我们可以忽略这些加法常数。后面的例子，这样的常数被忽略的意义可能会更加明显。 我们来看第二个例子，算法C是4n+8，算法D是2n2+1（如表2所示）。 表2 当n≤3的时候，算法C要差于算法D（因为算法C次数比较多），但当n&gt;3后，算法C的优势就越来越优于算法D了，到后来更是远远胜过。而当后面的常数去掉后，我们发现其实结果没有发生改变。甚至我们再观察发现，哪怕去掉与n相乘的常数，这样的结果也没发生改变，算法C′的次数随着n的增长，还是远小于算法D′。也就是说，与最高次项相乘的常数并不重要。 我们再来看第三个例子。算法E是2n2+3n+1，算法F是2n3+3n+1（如表3所示）。 表3 当n=1的时候，算法E与算法F结果相同，但当n&gt;1后，算法E的优势就要开始优于算法F，随着n的增大，差异非常明显。通过观察发现，最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快。 我们来看最后一个例子。算法G是2n2，算法H是3n+1，算法I是2n2+3n+1（如表4所示）。 表4 这组数据应该就看得很清楚。当n的值越来越大时，你会发现，3n+1已经没法和2n2的结果相比较，最终几乎可以忽略不计。也就是说，随着n值变得非常大以后，算法G其实已经很趋近于算法I。于是我们可以得到这样一个结论，判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。 判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的。根据刚才的几个样例，我们发现，如果我们可以对比这几个算法的关键执行次数函数的渐近增长性，基本就可以分析出：某个算法，随着n的增大，它会越来越优于另一算法，或者越来越差于另一算法。这其实就是事前估算方法的理论依据，通过算法时间复杂度来估算算法时间效率。 算法时间复杂度算法时间复杂度定义在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。 这样用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。 一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。 显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别为O(n)，O(1)，O(n2)。我们分别给它们取了非官方的名称，O(1)叫常数阶、O(n)叫线性阶、O(n2)叫平方阶。 推导大O阶方法那么如何分析一个算法的时间复杂度呢？即如何推导大O阶呢？我们给出了下面的推导方法，基本上，这也就是总结前面我们举的例子。 推导大O阶： 1.用常数1取代运行时间中的所有加法常数。 2.在修改后的运行次数函数中，只保留最高阶项。 3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。 得到的结果就是大O阶。 哈，仿佛是得到了游戏攻略一样，我们好像已经得到了一个推导算法时间复杂度的万能公式。可事实上，分析一个算法的时间复杂度，没有这么简单，我们还需要多看几个例子。 常数阶首先顺序结构的时间复杂度。下面这个算法，也就是刚才的第二种算法（高斯算法），为什么时间复杂度不是O(3)，而是O(1)。 123int sum = 0,n = 100; /* 执行一次 */sum = (1 + n) * n / 2; /* 执行一次 */printf("%d", sum); /* 执行一次 */ 这个算法的运行次数函数是f(n)=3。根据我们推导大O阶的方法，第一步就是把常数项3改为1。在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为O(1)。 另外，我们试想一下，如果这个算法当中的语句sum=(1+n)*n/2有10句，即： 123456789101112int sum = 0, n = 100; /* 执行1次 */sum = (1 + n) * n / 2; /* 执行第1次 */sum = (1 + n) * n / 2; /* 执行第2次 */sum = (1 + n) * n / 2; /* 执行第3次 */sum = (1 + n) * n / 2; /* 执行第4次 */sum = (1 + n) * n / 2; /* 执行第5次 */sum = (1 + n) * n / 2; /* 执行第6次 */sum = (1 + n) * n / 2; /* 执行第7次 */sum = (1 + n) * n / 2; /* 执行第8次 */sum = (1 + n) * n / 2; /* 执行第9次 */sum = (1 + n) * n / 2; /* 执行第10次 */printf("%d", sum); /* 执行1次 */ 事实上无论n为多少，上面的两段代码就是3次和12次执行的差异。这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。 注意：不管这个常数是多少，我们都记作O(1)，而不能是O(3)、O(12)等其他任何数字，这是初学者常常犯的错误。 对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着n的变大而发生变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度也是O(1)。 线性阶线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行的次数。因此，我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。 下面这段代码，它的循环的时间复杂度为O(n)，因为循环体中的代码须要执行n次。 12345int i;for (i = 0; i &lt; n; i++)&#123; /* 时间复杂度为O(1)的程序步骤序列 */&#125; 对数阶下面的这段代码，时间复杂度又是多少呢？ 123456int count = 1;while (count &lt; n)&#123; count = count * 2; /* 时间复杂度为O(1)的程序步骤序列 */&#125; 由于每次count乘以2之后，就距离n更近了一分。也就是说，有多少个2相乘后大于n，则会退出循环。由2x=n得到x=log2n。所以这个循环的时间复杂度为O(logn)。 平方阶下面例子是一个循环嵌套，它的内循环刚才我们已经分析过，时间复杂度为O(n)。 12345678int i, j;for (i = 0; i &lt; n; i++)&#123; for (j = 0; j &lt; n; j++) &#123; /* 时间复杂度为O(1)的程序步骤序列 */ &#125;&#125; 而对于外层的循环，不过是内部这个时间复杂度为O(n)的语句，再循环n次。所以这段代码的时间复杂度为O(n2)。 如果外循环的循环次数改为了m，时间复杂度就变为O(m×n)。 12345678int i, j;for (i = 0; i &lt; m; i++)&#123; for (j = 0; j &lt; n; j++) &#123; /* 时间复杂度为O(1)的程序步骤序列 */ &#125;&#125; 所以我们可以总结得出，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。 那么下面这个循环嵌套，它的时间复杂度是多少呢？ 123456789int i, j;for (i = 0; i &lt; n; i++)&#123; /* 注意j = i 而不是0 */ for (j = i; j &lt; n; j++) &#123; /* 时间复杂度为O(1)的程序步骤序列 */ &#125;&#125; 由于当i=0时，内循环执行了n次，当i=1时，执行了n-1次，……当i=n-1时，执行了1次。所以总的执行次数为： 用我们推导大O阶的方法，第一条，没有加法常数不予考虑；第二条，只保留最高阶项，因此保留n2/2；第三条，去除这个项相乘的常数，也就是去除1/2，最终这段代码的时间复杂度为O(n2)。 从这个例子，我们也可以得到一个经验，其实理解大O推导不算难，难的是对数列的一些相关运算，这更多的是考察你的数学知识和能力，所以想考研的朋友，要想在求算法时间复杂度这里不失分，可能需要强化你的数学，特别是数列方面的知识和解题能力。 我们继续看例子，对于方法调用的时间复杂度又如何分析。 12345int i, j;for (i = 0; i &lt; n; i++)&#123; function(i);&#125; 上面这段代码调用一个函数function。 1234void function(int count)&#123; print(count);&#125; 函数体是打印这个参数。其实这很好理解，function函数的时间复杂度是O(1)。所以整体的时间复杂度为O(n)。 假如function是下面这样的： 12345678void function(int count)&#123; int j; for (j = count; j &lt; n; j++) &#123; /* 时间复杂度为O(1)的程序步骤序列 */ &#125;&#125; 事实上，这和刚才举的例子是一样的，只不过把嵌套内循环放到了函数中，所以最终的时间复杂度为O(n2)。 下面这段相对复杂的语句： 1234567891011121314n++; /* 执行次数为1 */function(n); /* 执行次数为n */int i, j;for (i = 0; i &lt; n; i++) /* 执行次数为n2 */&#123; function (i);&#125;for (i = 0; i &lt; n; i++) /* 执行次数为n(n + 1)/2 */&#123; for (j = i; j &lt; n; j++) &#123; /* 时间复杂度为O(1)的程序步骤序列 */ &#125;&#125; 它的执行次数f(n)=1+n+n2+n(n+1)/2=3/2·n2+3/2·n+1，根据推导大O阶的方法，最终这段代码的时间复杂度也是O(n2)。 常见的时间复杂度常见的时间复杂度如表5所示。 表5 常用的时间复杂度所耗费的时间从小到大依次是： O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n3)&lt;O(2n)&lt;O(n!)&lt;O(nn) 我们前面已经谈到了O(1)常数阶、O(logn)对数阶、O(n)线性阶、O(n2)平方阶等，至于O(nlogn)我们将会在今后的课程中介绍，而像O(n3)，过大的n都会使得结果变得不现实。同样指数阶O(2n)和阶乘阶O(n!)等除非是很小的n值，否则哪怕n只是100，都是噩梦般的运行时间。所以这种不切实际的算法时间复杂度，一般我们都不去讨论它。 最坏情况与平均情况找东西有运气好的时候，也有怎么也找不到的情况。但在现实中，通常我们碰到的绝大多数既不是最好的也不是最坏的，所以算下来是平均情况居多。 算法的分析也是类似，我们查找一个有n个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是O(n)，这是最坏的一种情况了。 最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。 而平均运行时间也就是从概率的角度看，这个数字在每一个位置的可能性是相同的，所以平均的查找时间为n/2次后发现这个目标元素。 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。也就是说，我们运行一段程序代码时，是希望看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。 对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。一般在没有特殊说明的情况下，都是指最坏时间复杂度。 算法空间复杂度我们在写代码时，完全可以用空间来换取时间，比如说，要判断某某年是不是闰年，你可能会花一点心思写了一个算法，而且由于是一个算法，也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。还有另一个办法就是，事先建立一个有2050个元素的数组（年数略比现实多一点），然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是1，如果不是值为0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们的运算是最小化了，但是硬盘上或者内存中需要存储这2050个0和1。 这是通过一笔空间上的开销来换取计算时间的小技巧。到底哪一个好，其实要看你用在什么地方。 算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。 一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。 通常，我们都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。显然我们这本书重点要讲的还是算法的时间复杂度的问题。 总结回顾不容易，终于又到了总结的时间。 我们这一章主要谈了算法的一些基本概念。谈到了数据结构与算法的关系是相互依赖不可分割的。 算法的定义：算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。 算法的特性：有穷性、确定性、可行性、输入、输出。 算法的设计的要求：正确性、可读性、健壮性、高效率和低存储量需求。 算法特性与算法设计容易混，需要对比记忆。 算法的度量方法：事后统计方法（不科学、不准确）、事前分析估算方法。 在讲解如何用事前分析估算方法之前，我们先给出了函数渐近增长的定义。 函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，如果我们可以对比算法的关键执行次数函数的渐近增长性，基本就可以分析出：某个算法，随着n的变大，它会越来越优于另一算法，或者越来越差于另一算法。 然后给出了算法时间复杂度的定义和推导大O阶的步骤。 推导大O阶： 用常数1取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是1，则去除与这个项相乘的常数。 得到的结果就是大O阶。 通过这个步骤，我们可以在得到算法的运行次数表达式后，很快得到它的时间复杂度，即大O阶。同时我也提醒了大家，其实推导大O阶很容易，但如何得到运行次数的表达式却是需要数学功底的。 接着我们给出了常见的时间复杂度所耗时间的大小排列： O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n3)&lt;O(2n)&lt;O(n!)&lt;O(nn) 最后，我们给出了关于算法最坏情况和平均情况的概念，以及空间复杂度的概念。 很多学生，学了四年计算机专业，很多程序员，做了很长时间的编程工作，却始终都弄不明白算法的时间复杂度的估算，这是很可悲的一件事。因为弄不清楚，所以也就从不深究自己写的代码是否效率低下，是不是可以通过优化让计算机更加快速高效。 他们通常的借口是，现在CPU越来越快，根本不用考虑算法的优劣，实现功能即可，用户感觉不到算法好坏造成的快慢。可事实真是这样吗？还是让我们用数据来说话吧。 假设CPU在短短几年间，速度提高了100倍，这其实已经很夸张了。而我们的某个算法本可以写出时间复杂度是O(n)的程序，却写出了O(n2)的程序，仅仅因为容易想到，也容易写。即在O(n2)的时间复杂度算法程序下，速度其实只提高了10倍。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言入门：进入C语言的世界]]></title>
    <url>%2F2019%2F07%2F20%2FC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%EF%BC%9A%E8%BF%9B%E5%85%A5C%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 自己画图 相比其他大多数语言，C语言的工作层次更低，因此理解C语言可以让你更清楚程序在运行时到底发生了什么，C语言还可以帮助你更好地理解其他语言。 C语言如何工作C语言用来创建空间小、速度快的程序 C语言旨在创建空间小、速度快的程序。它比其他大多数语言的抽象层次更低，也就是说用C语言写的代码更加接近机器语言。 C语言的工作方式 计算机只理解一种语言--机器代码，即一串二进制0、1流。你可以在编译器的帮助下将C代码转化为机器代码。 123456#include &lt;stdio.h&gt;int main()&#123; puts("C Rocks!"); return 0;&#125; 你可能会遇到三种C标准。ANSI C始于20世纪80年代后期，适用于最古老的代码，1999年开始的C99标准有了很大的改进；在2011年发布的最新标准C11中，加入了一些很酷、很新的语言特性。不同版本的标准之间差别不是很大，如果碰到我们会指出。 1234567891011121314151617181920212223242526272829303132333435int card_count = 11;if (card_count &gt; 10) puts("这副牌赢面很大，我要加注！");int c = 10;while (c &gt; 0)&#123; puts("我决不在课堂上写代码！"); c = c - 1;&#125;/* */char ex[20];puts("");scanf();printf("%s\n", );char suit= 'H';switch(suit)&#123; case 'C': puts(""); break; case 'D': puts(""); break; case 'H': puts(""); break; default: puts("");&#125;]]></content>
      <categories>
        <category>Head First C</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多路查找树（B树）]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88B%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是多路查找树？是为了解决什么问题？ 2-3树的含义是什么？2-3树复杂的地方在哪里？ 内存数据需要对外存磁盘进行存取操作。 内存一般都是由硅制的存储芯片组成，这种技术的每一个存储单位代价都要比磁存储技术昂贵两个数量级，因此基于磁盘技术的外存，容量比内存的容量至少大两个数量级。这也就是目前PC通常内存几个G而已、而硬盘却可以成百上千G容量的原因。 我们前面讨论过的数据结构，处理数据都是在内存中，因此考虑的都是内存中的运算时间复杂度。 但如若我们要操作的数据集非常大，大到内存已经没办法处理了怎么办呢？如数据库中的上千万条记录的数据表、硬盘中的上万个文件等。在这种情况下，对数据的处理需要不断从硬盘等存储设备中调入或调出内存页面。 一旦涉及到这样的外部存储设备，关于时间复杂度的计算就会发生变化，访问该集合元素的时间已经不仅仅是寻找该元素所需比较次数的函数，我们必须考虑对硬盘等外部存储设备的访问时间以及将会对该设备做出多少次单独访问。 试想一下，为了要在一个拥有几十万个文件的磁盘中查找一个文本文件，你设计的算法需要读取磁盘上万次还是读取几十次，这是有本质差异的。此时，为了降低对外存设备的访问次数，我们就需要新的数据结构来处理这样的问题。 我们之前谈的树，都是一个结点可以有多个孩子，但是它自身只存储一个元素。二叉树限制更多，结点最多只能有两个孩子。 一个结点只能存储一个元素，在元素非常多的时候，就使得要么树的度非常大（结点拥有子树的个数的最大值），要么树的高度非常大，甚至两者都必须足够大才行。这就使得内存存取外存次数非常多，这显然成了时间效率上的瓶颈，这迫使我们要打破每一个结点只存储一个元素的限制，为此引入了多路查找树的概念。 多路查找树（muitl-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。由于它是查找树，所有元素之间存在某种特定的排序关系。 在这里，每一个结点可以存储多少个元素，以及它的孩子数的多少是非常关键的。为此，我们讲解它的4种特殊形式：2-3树、2-3-4树、B树和B+树。 2-3树2和3是最基本的阿拉伯数字，用它们来命名一种树结构，显然是说明这种结构与数字2和3有密切关系。 2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点）。 一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。 一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。 并且2-3树中所有的叶子都在同一层次上。如图1所示，就是一棵有效的2-3树。 事实上，2-3树复杂的地方就在于新结点的插入和已有结点的删除。毕竟，每个结点可能是2结点也可能是3结点，要保证所有叶子都在同一层次，是需要进行一番复杂操作的。 图1 1．2-3树的插入实现 对于2-3树的插入来说，与二叉排序树相同，插入操作一定是发生在叶子结点上。可与二叉排序树不同的是，2-3树插入一个元素的过程有可能会对该树的其余结构产生连锁反应。 2-3树插入可分为三种情况。 1）对于空树，插入一个2结点即可，这很容易理解。 2）插入结点到一个2结点的叶子上。应该说，由于其本身就只有一个元素，所以只需要将其升级为3结点即可。如图2所示。我们希望从左图的2-3树中插入元素3，根据遍历可知，3比8小、比4小，于是就只能考虑插入到叶子结点1所在的位置，因此很自然的想法就是将此结点变成一个3结点，即右图这样完成插入操作。当然，要视插入的元素与当前叶子结点的元素比较大小后，决定谁在左谁在右。例如，若插入的是0，则此结点就是“0”在左“1”在右了。 图2 3）要往3结点中插入一个新元素。因为3结点本身已经是2-3树的结点最大容量（已经有两个元素），因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层。复杂的情况也正在于此。 第一种情况，见图3，需要向左图中插入元素5。经过遍历可得到元素5比8小比4大，因此它应该是需要插入在拥有6、7元素的3结点位置。问题就在于，6和7结点已经是3结点，不能再加。此时发现它的双亲结点4是个2结点，因此考虑让它升级为3结点，这样它就得有三个孩子，于是就想到，将6、7结点拆分，让6与4结成3结点，将5成为它的中间孩子，将7成为它的右孩子，如图3的右图所示。 图3 另一种情况，如图4所示，需要向左图中插入元素11。经过遍历可得到元素11比12、14小比9、10大，因此它应该是需要插入在拥有9、10元素的3结点位置。同样道理，9和10结点不能再增加结点。此时发现它的双亲结点12、14也是一个3结点，也不能再插入元素了。再往上看，12、14结点的双亲，结点8是个2结点。于是就想到，将9、10拆分，12、14也拆分，让根结点8升级为3结点，最终形成如图4的右图样子。 图4 再来看个例子，如图5所示，需要在左图中插入元素2。经过遍历可得到元素2比4小、6比1大，因此它应该是需要插入在拥有1、3元素的3结点位置。与上例一样，你会发现，1、3结点，4、6结点都是3结点，都不能再插入元素了，再往上看，8、12结点还是一个3结点，那就意味着，当前我们的树结构是三层已经不能满足当前结点增加的需要了。于是将1、3拆分，4、6拆分，连根结点8、12也拆分，最终形成如图5的右图样子。 图5 通过这个例子，也让我们发现，如果2-3树插入的传播效应导致了根结点的拆分，则树的高度就会增加。 2．2-3树的删除实现 对于2-3树的删除来说，如果对前面插入的理解足够到位的话，应该不是难事了。2-3树的删除也分为三种情况。与插入相反，我们从3结点开始说起。 1）所删除元素位于一个3结点的叶子结点上， 这非常简单，只需要在该结点处删除该元素即可，不会影响到整棵树的其他结点结构。如图6所示，删除元素9，只需要将此结点改成只有元素10的2结点即可。 图6 2）所删除的元素位于一个2结点上，即要删除的是一个只有一个元素的结点。如果按照以前树的理解，删除即可，可现在的2-3树的定义告诉我们这样做是不可以的。比如图7所示，如果我们删除了结点1，那么结点4本来是一个2结点（它拥有两个孩子），此时它就不满足定义了。 图7 因此，对于删除叶子是2结点的情况，我们需要分四种情形来处理。 情形一，此结点的双亲也是2结点，且拥有一个3结点的右孩子。如图8所示，删除结点1，那么只需要左旋，即6成为双亲，4成为6的左孩子，7是6的右孩子。 图8 情形二，此结点的双亲是2结点，它的右孩子也是2结点。如图9所示，此时删除结点4，如果直接左旋会造成没有右孩子，因此需要对整棵树变形，办法就是，我们目标是让结点7变成3结点，那就得让比7稍大的元素8下来，随即就得让比元素8稍大的元素9补充结点8的位置，于是就有了图9的中间图，于是再用左旋的方式，变成右图结果。 图9 情形三，此结点的双亲是一个3结点。如图10所示，此时删除结点10，意味着双亲12、14这个结点不能成为3结点了，于是将此结点拆分，并将12与13合并成为左孩子。 图10 情形四，如果当前树是一个满二叉树的情况，此时删除任何一个叶子都会使得整棵树不能满足2-3树的定义。如图11所示，删除叶子结点8时（其实删除任何一个结点都一样），就不得不考虑要将2-3的层数减少，办法是将8的双亲和其左子树6合并为一3个结点，再将14与9合并为3结点，最后成为右图的样子。 图11 3）所删除的元素位于非叶子的分支结点。此时我们通常是将树按中序遍历后得到此元素的前驱或后继元素，考虑让它们来补位即可。 如果我们要删除的分支结点是2结点。如图8-8-13所示我们要删除4结点，分析后得到它的前驱是1后继是6，显然，由于6、7是3结点，只需要用6来补位即可，如图12右图所示。 图12 如果我们要删除的分支结点是3结点的某一元素，如图13所示我们要删除12、14结点的12，此时，经过分析，显然应该是将是3结点的左孩子的10上升到删除位置合适。 图13 当然，如果对2-3树的插入和删除等所有的情况进行讲解，既占篇幅，又没必要，总的来说它是有规律的，需要你们在上面的这些例子中多去体会后掌握。 2-3-4树有了2-3树的讲解，2-3-4树就很好理解了，它其实就是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。 由于2-3-4树和2-3树是类似的，我们这里就简单介绍一下，如果我们构建一个数组为{7,1,2,5,6,9,8,4,3}的2-3-4树的过程，如图14所示。图1是在分别插入7、1、2时的结果图，因为3个元素满足2-3-4树的单个4结点定义，因此此时不需要拆分，接着插入元素5，因为已经超过了4结点的定义，因此拆分为图2的形状。之后的图其实就是在元素不断插入时最后形成了图7的2-3-4树。 图14 图15是对一个2-3-4树的删除结点的演变过程，删除顺序是1、6、3、4、5、2、9。 图15 B树我们本节名称叫B树，但到了现在才开始提到它，似乎这主角出来的实在太晚了，可其实，我们前面一直都在讲B树。 B树（B-tree）是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶（order），因此，2-3树是3阶B树，2-3-4树是4阶B树。 一个m阶的B树具有如下属性： 如果根结点不是叶结点，则其至少有两棵子树。 每一个非根的分支结点都有k-1个元素和k个孩子，其中。每一个叶子结点n都有k-1个元素，其中。 所有叶子结点都位于同一层次。 所有分支结点包含下列信息数据 （n,A0,K1,A1,K2,A2,…,Kn,An），其中：Ki(i=1,2,…,n)为关键字，且Ki&lt;Ki+1(i=1,2,…,n-1)；Ai(i=0,2,…,n)为指向子树根结点的指针，且指针Ai-1所指子树中所有结点的关键字均小于Ki(i=1,2,…,n)，An所指子树中所有结点的关键字均大于Kn，n(≤n≤m-1)为关键字的个数（或n+1为子树的个数）。 例如，在讲2-3-4树时插入9个数后的图转成B树示意就如图16的右图所示。左侧灰色方块表示当前结点的元素个数。 图16 在B树上查找的过程是一个顺指针查找结点和在结点中查找关键字的交叉过程。 比方说，我们要查找数字7，首先从外存（比如硬盘中）读取得到根结点3、5、8三个元素，发现7不在当中，但在5和8之间，因此就通过A2再读取外存的6、7结点，查找到所要的元素。 至于B树的插入和删除，方式是与2-3树和2-3-4树相类似的，只不过阶数可能会很大而已。 我们在本节的开头提到，如果内存与外存交换数据次数频繁，会造成了时间效率上的瓶颈，那么B树结构怎么就可以做到减少次数呢？ 我们的外存，比如硬盘，是将所有的信息分割成相等大小的页面，每次硬盘读写的都是一个或多个完整的页面，对于一个硬盘来说，一页的长度可能是211到214个字节。 在一个典型的B树应用中，要处理的硬盘数据量很大，因此无法一次全部装入内存。因此我们会对B树进行调整，使得B树的阶数（或结点的元素）与硬盘存储的页面大小相匹配。比如说一棵B树的阶为1001（即1个结点包含1000个关键字），高度为2，它可以储存超过10亿个关键字，我们只要让根结点持久地保留在内存中，那么在这棵树上，寻找某一个关键字至多需要两次硬盘的读取即可。这就好比我们普通人数钱都是一张一张的数，而银行职员数钱则是五张、十张，甚至几十张一数，速度当然是比常人快了不少。 通过这种方式，在有限内存的情况下，每一次磁盘的访问我们都可以获得最大数量的数据。由于B树每结点可以具有比二叉树多得多的元素，所以与二叉树的操作不同，它们减少了必须访问结点和数据块的数量，从而提高了性能。可以说，B树的数据结构就是为内外存的数据交互准备的。 那么对于n个关键字的m阶B树，最坏情况是要查找几次呢？我们来作一分析。 第一层至少有1个结点，第二层至少有2个结点，由于除根结点外每个分支结点至少有|m/2|棵子树，则第三层至少有2×|m/2|个结点，……，这样第k+1层至少有2×(|m/2|)k-1个结点，而实际上，k+1层的结点就是叶子结点。若m阶B树有n个关键字，那么当你找到了叶子结点，其实也就等于查找不成功的结点为n+1，因此n+1≥2×(|m/2|)k-1，即： 图16 B+树尽管前面我们已经讲了B树的诸多好处，但其实它还是有缺陷的。对于树结构来说，我们都可以通过中序遍历来顺序查找树中的元素，这一切都是在内存中进行。 可是在B树结构中，我们往返于每个结点之间也就意味着，我们必须得在硬盘的页面之间进行多次访问，如图17所示，我们希望遍历这棵B树，假设每个结点都属于硬盘的不同页面，我们为了中序遍历所有的元素，页面2→页面1→页面3→页面1→页面4→页面1→页面5。而且我们每次经过结点遍历时，都会对结点中的元素进行一次遍历，这就非常糟糕。有没有可能让遍历时每个元素只访问一次呢？ 图17 为了说明这个解决的办法，我举个例子。一个优秀的企业尽管可能有非常成熟的树状组织结构，但是这并不意味着员工也很满意，恰恰相反，由于企业管理更多考虑的是企业的利益，这就容易忽略员工的各种诉求，造成了管理者与员工之间的矛盾。正因为此，工会就产生了，工会原意是指基于共同利益而自发组织的社会团体。这个共同利益团体诸如为同一雇主工作的员工，在某一产业领域的个人。工会组织成立的主要作用，可以与雇主谈判工资薪水、工作时限和工作条件等。这样，其实在整个企业的运转过程中，除了正规的层级管理外，还有一个代表员工的团队在发挥另外的作用。 同样的，为了能够解决所有元素遍历等基本问题，我们在原有的B树结构基础上，加上了新的元素组织方式，这就是B+树。 B+树是应文件系统所需而出的一种B树的变形树，注意严格意义上讲，它其实已经不是第六章定义的树了。在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。 例如图18所示，就是一棵B+树的示意，灰色关键字即是根结点中的关键字在叶子结点再次列出，并且所有叶子结点都链接在一起。 图18 一棵m阶的B+树和m阶的B树的差异在于： 有n棵子树的结点中包含有n个关键字； 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接； 所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字。 这样的数据结构最大的好处就在于，如果是要随机查找，我们就从根结点出发，与B树的查找方式相同，只不过即使在分支结点找到了待查找的关键字，它也只是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。 如果我们是需要从最小关键字进行从小到大的顺序查找，我们就可以从最左侧的叶子结点出发，不经过分支结点，而是延着指向下一叶子的指针就可遍历所有的关键字。 B+树的结构特别适合带有范围的查找。比如查找我们学校18～22岁的学生人数，我们可以通过从根结点出发找到第一个18岁的学生，然后再在叶子结点按顺序查找到符合范围的所有记录。 B+树的插入、删除过程也都与B树类似，只不过插入和删除的元素都是在叶子结点上进行而已。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 数据结构绪论]]></title>
    <url>%2F2019%2F07%2F19%2F%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 画图和背诵是必须的吗？自己画图是可行的吗？ 理解一个概念要多类比，如何类比？ 按照视点的不同，怎么区分数据结构？ 学习方法一图值千言。要多用画图工具来画图。 世界上很多道理都是相通的。精心构思的类比能让人发出“原来如此”的感叹。看似枯燥的数据结构知识背后，也隐藏着一个个生活中的小故事。 人们无法理解他没有经历过的事情。–尼采 吸引学生的注意力，比较好的办法是用他们比较熟知的知识开始。所以可以多和PHP进行比对。 人与人的交流不可能只是就事论事，一定会有情感的沟通，这种情感如果能产生共鸣、达成互信，就会让事情本身更容易理解和接受。 人都是有感情的动物。 --韩国瑜 数据结构是计算机软件相关专业的基础课程，几乎可以说，要想从事编程工作，无论你是否是科班出身，都不可以绕过这部分知识。 事实上，任何有难度的知识和技巧，都不是那么容易被掌握的。有些数据结构，特别是经典算法，是几代科学家的智慧结晶，因此要掌握它们还是需要读者的全力投入。 美国畅销书《如何阅读一本书》中提到“阅读可以是一件主动的事，阅读越主动，效果越好（手动画图）。拿同样的书给背景相近的两个人阅读，一个人却比另一个人从书中得到了更多，这是因为，首先在于这人的主动，其次，在于他在阅读中的每一种活动（打开画图工具画图）都参与了更多的技巧。这两件事是息息相关的。阅读是一个复杂的活动，就跟写作一样，包含了大量不同的活动。要达成良好的阅读，这些活动都是不可或缺的。一个人越能良好运作这些活动，阅读的效果也就越好。” 要想获得更多，您可能也需要付出类似我写作一样的力气来阅读，例如摘抄文字、眉批心得、稿纸演算、代码输入电脑、画图，以及您自己在编程工作中的运用等。这些相应活动的执行，将会使您得到巨大的收获。 最佳的效果就是你可以不看书也做到一点不错地默写出相关算法。还是要背诵的。 数据结构在某种程度上和设计模式类似，都是前辈的武功套路。不同的是，设计模式是近几十年的卓越程序员的智慧结晶，而数据结构是几百上千年的无数科学家、数学家的智慧沉淀，更加具有深厚的背景。 最后，我想对那些已经开始自学数据结构的同学说，可能你们会困惑、不懂、不理解、不会应用，甚至不知所云。可实际上，无论学什么，都是要努力才可以学到真东西。只有真正掌握技术的人，才有可能去享用它。如果你中途放弃了，之前所有的努力和付出都会变得没有价值。学会游泳难吗？掌握英语口语难吗？可能是难，但在掌握了的人眼里，这根本不算什么，“就那么回事呀”。只要你相信自己一定可以学得会、学得好，既然无数人已经掌握了，你凭什么不行。 掌握Java、C#、VB等面向对象语言的读者，当面对书中大量的C语言式的结构（struct）声明和针对结构的参数传递的代码时，可以理解为是类的定义和由类生成对象的传递。尽管的确存在差异，但并不影响整体对数据结构知识和算法原理的理解。 逻辑结构与物理结构按照视点的不同，我们把数据结构分为逻辑结构和物理结构。 逻辑结构逻辑结构：是指数据对象中数据元素之间的相互关系。其实这也是我们今后最需要关注的问题。逻辑结构分为以下四种： 1．集合结构 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各个数据元素是“平等”的，它们的共同属性是“同属于一个集合”。数据结构中的集合关系就类似于数学中的集合（如图1-5-1所示）。 2．线性结构 线性结构：线性结构中的数据元素之间是一对一的关系（如图1-5-2所示）。 3．树形结构 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系（如图1-5-3所示）。 4．图形结构 图形结构：图形结构的数据元素是多对多的关系（如图1-5-4所示）。 我们在用示意图表示数据的逻辑结构时，要注意两点： 将每一个数据元素看做一个结点，用圆圈表示。元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示。从之前的例子也可以看出，逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。 物理结构说完了逻辑结构，我们再来说说数据的物理结构（很多书中也叫做存储结构，你只要在理解上把它们当一回事就可以了）。 物理结构：是指数据的逻辑结构在计算机中的存储形式。 数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。 数据的存储结构应正确反映数据元素之间的逻辑关系，这才是最为关键的，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。 数据元素的存储结构形式有两种：顺序存储和链式存储。 1．顺序存储结构 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（如图1-5-5所示）。 这种存储结构其实很简单，说白了，就是排队占位。大家都按顺序排好，每个人占一小段空间，大家谁也别插谁的队。我们之前学计算机语言时，数组就是这样的顺序存储结构。当你告诉计算机，你要建立一个有9个整型数据的数组时，计算机就在内存中找了片空地，按照一个整型所占位置的大小乘以9，开辟一段连续的空间，于是第一个数组数据就放在第一个位置，第二个数据放在第二个，这样依次摆放。 2．链式存储结构 如果就是这么简单和有规律，一切就好办了。可实际上，总会有人插队，也会有人要上厕所、有人会放弃排队。所以这个队伍当中会添加新成员，也有可能会去掉老元素，整个结构时刻都处于变化中。显然，面对这样时常要变化的结构，顺序存储是不科学的。那怎么办呢？ 现在如银行、医院等地方，设置了排队系统，也就是每个人去了，先领一个号，等着叫号，叫到时去办理业务或看病。在等待的时候，你爱在哪在哪，可以坐着、站着或者走动，甚至出去逛一圈，只要及时回来就行。你关注的是前一个号有没有被叫到，叫到了，下一个就轮到了。 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置（如图1-5-6所示）。 显然，链式存储就灵活多了，数据存在哪里不重要，只要有一个指针存放了相应的地址就能找到它了。 前几年香港有部电影叫《无间道》，大陆还有部电视剧叫《潜伏》，都很火，不知道大家有没有看过。大致说的是，某一方潜伏在敌人的内部，进行一些情报收集工作。为了不暴露每个潜伏人员的真实身份，往往都是单线联系，只有上线知道下线是谁，并且是通过暗号来联络。正常情况下，情报是可以顺利地上传下达的，但是如果某个链条中结点的同志牺牲了，那就麻烦了，因为其他人不知道上线或者下线是谁，后果就很严重。比如在《无间道》中，梁朝伟是警方在黑社会中的卧底，一直是与黄秋生扮演的警官联络，可当黄遇害后，梁就无法证明自己是一个警察。所以影片的结尾，当梁朝伟用枪指着刘德华的头说，“对不起，我是警察。”刘德华马上反问道：“谁知道呢？”是呀，当没有人可以证明你身份的时候，谁知道你是谁呢？影片看到这里，多少让人有些唏嘘感慨。这其实就是链式关系的一个现实样例。 逻辑结构是面向问题的，而物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中。 抽象数据类型数据类型数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。 当年那些设计计算机语言的人，为什么会考虑到数据类型呢？ 比如，大家都需要住房子，也都希望房子越大越好。但显然，没有钱，考虑房子是没啥意义的。于是商品房就出现了各种各样的房型，有别墅的，有错层的，有单间的；有一百多平米的，也有几十平米的，甚至在北京还出现了胶囊公寓--只有两平米的房间……这样就满足了不同人的需要。 同样，在计算机中，内存也不是无限大的，你要计算一个如1+1=2、3+5=8这样的整型数字的加减乘除运算，显然不需要开辟很大的适合小数甚至字符运算的内存空间。于是计算机的研究者们就考虑，要对数据进行分类，分出来多种数据类型。 在C语言中，按照取值的不同，数据类型可以分为两类： 原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等。结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。 比如，在C语言中变量声明int a,b，这就意味着，在给变量a和b赋值时不能超出int的取值范围，变量a和b之间的运算只能是int类型所允许的运算。 因为不同的计算机有不同的硬件系统，这就要求程序语言最终通过编译器或解释器转换成底层语言，如汇编语言甚至是通过机器语言的数据类型来实现的。可事实上，高级语言的编程者不管最终程序运行在什么计算机上，他的目的就是为了实现两个整型数字的运算，如a+b、a-b、a×b和a/b等，他才不关心整数在计算机内部是如何表示的，也不想知道CPU为了实现1+2进行几次开关操作，这些操作是如何实现的，对高级语言开发者来讲根本不重要。于是我们就会考虑，无论什么计算机、什么计算机语言，大都会面临着如整数运算、实数运算、字符运算等操作，我们可以考虑把它们都抽象出来。 抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。 抽象数据类型我们对已有的数据类型进行抽象，就有了抽象数据类型。 抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。 比如刚才的例子，各个计算机，不管是大型机、小型机、PC、平板电脑、PDA，甚至智能手机都拥有“整数”类型，也需要整数间的运算，那么整型其实就是一个抽象数据类型，尽管它在上面提到的这些在不同计算机中实现方法上可能不一样，但由于其定义的数学特性相同，在计算机编程者看来，它们都是相同的。因此，“抽象”的意义在于数据类型的数学抽象特性。 而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还可以是计算机编程者在设计软件程序时自己定义的数据类型，比如我们编写关于计算机绘图或者地图类的软件系统，经常都会用到坐标。也就是说，总是有成对出现的x和y，在3D系统中还有z出现，既然这三个整型数字是始终在一起出现，我们就定义一个叫point的抽象数据类型，它有x、y、z三个整型变量，这样我们很方便地操作一个point数据变量就能知道这一点的坐标了。 根据抽象数据类型的定义，它还包括定义在该模型上的一组操作。就像“超级玛丽”这个经典的任天堂游戏，里面的游戏主角是马里奥（Mario）。我们给他定义了几种基本操作，走（前进、后退、上、下）、跳、打子弹等。一个抽象数据类型定义了：一个数据对象、数据对象中各数据元素之间的关系及对数据元素的操作。至于，一个抽象数据类型到底需要哪些操作，这就只能由设计者根据实际需要来定。像马里奥，可能开始只有两种操作，走和跳，后来发现应该要增加一种打子弹的操作，再后来发现有些玩家希望它可以走得快一点，就有了按住打子弹键后前进就会“跑”的操作。这都是根据实际情况来设计的。 图1-6-1 事实上，抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。抽象数据类型把实际生活中的问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。 为了便于在之后的讲解中对抽象数据类型进行规范的描述，我们给出了描述抽象数据类型的标准格式： 12345678910111213ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义Operation 操作1 初始条件 操作结果描述 操作2 ...... 操作n ......endADT 总结本章首先说明数据结构很重要。接着讲了数据结构的起源，再接着正式介绍了数据结构的一些相关概念，如下图所示。 由这些概念，给出了数据结构的定义：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。同样是结构，从不同的角度来讨论，会有不同的分类，如下图所示。 之后，我们还介绍了抽象数据类型及它的描述方法，为今后的课程打下基础。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String与StringBuilder]]></title>
    <url>%2F2019%2F07%2F18%2FString%E4%B8%8EStringBuilder%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 内存的栈和堆是怎么回事？ String类型有没有问题？什么时候用String？什么时候用StringBuilder? 1.什么时候用String？什么时候用StringBuilder? 字符串一旦创建就不可修改大小，每次使用System.String类中的方法之一时，都要在内存中创建一个新的字符串对象，这就需要为该新对象分配新的空间。在需要对字符串执行重复修改的情况下，与创建新的String对象相关的系统开销可能会非常昂贵。如果要修改字符串而不创建新的对象，则可以使用System.Text.StringBuilder类。例如当在一个循环中将许多字符串连接在一起时，使用StringBuilder类可以提升性能。 所以对字符串添加或删除操作不频繁的话，就几个固定的string累加的时候就不需要StringBuilder了，毕竟StringBuilder的初始化也是需要时间的。对字符串添加或删除操作比较频繁的话那就用StringBuilder。 123456String a1 = "abc"; //分配固定的内存大小a1+="def"; //创建新的内存分配a1，代价比较昂贵StringBuilder sb = new StringBuilder(20); //指定分配大小sb.Append("abc"); //分配到堆区sb.Append("def"); //不会被销毁，而是直接追加到后面。 总结：上面的a1和sb在输出结果一样的。但是在内存分配上面来说就区别很大了。 2.String与StringBuilder的区别String声明之后在内存中大小是不可修改的，而StringBuilder可以自由扩展大小(String分配在栈区，StringBuilder分配在堆区)1)StringString s1 = new String(new char[] { ‘c’， ‘h’， ‘i’， ‘n’， ‘a’ });String s2 = “abc”;2)StringBuilder 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849StringBuilder sb = new StringBuilder(5); //当指定分配大小之后，性能就会得到提升。在达到容量之前，它不会为其自己重新分配空间。如果超过指定大小系统会当前大小倍增，也就10，15，20。建议指定大小sb.Append('china');sb.Capacity = 25; //另外，可以使用读/写Capacity属性来设置对象的最大长度。//EnsureCapacity方法可用来检查当前StringBuilder的容量。如果容量大于传递的值，则不进行任何更改；但是，如果容量小于传递的值，则会更改当前的容量以使其与传递的值匹配。 //也可以查看或设置Length属性。如果将Length属性设置为大于Capacity属性的值，则自动将Capacity属性更改为与Length属性相同的值。如果将Length属性设置为小于当前StringBuilder对象内的字符串长度的值，则会缩短该字符串。 //5个修改StringBuilder的内容的方法StringBuilder.Append //将信息追加到当前StringBuilder的结尾。 StringBuilder.AppendFormat //用带格式文本替换字符串中传递的格式说明符。 StringBuilder.Insert //将字符串或对象插入到当前StringBuilder对象的指定索引处。 StringBuilder.Remove //从当前StringBuilder对象中移除指定数量的字符。 StringBuilder.Replace //替换指定索引处的指定字符。//Append //Append方法可用来将文本或对象的字符串表示形式添加到由当前StringBuilder对象表示的字符串的结尾处。//以下示例将一个StringBuilder对象初始化为“Hello World”，然后将一些文本追加到该对象的结尾处。将根据需要自动分配空间。 StringBuilder sb = new StringBuilder("Hello World!"); sb.Append(" What a beautiful day."); Console.WriteLine(sb); //结果：Hello World! What a beautiful day. //AppendFormat //AppendFormat方法将文本添加到StringBuilder的结尾处，而且实现了IFormattable接口，因此可接受格式化部分中描述的标准格式字符串。可以使用此方法来自定义变量的格式并将这些值追加到StringBuilder的后面。//以下示例使用AppendFormat方法将一个设置为货币值格式的整数值放置到StringBuilder的结尾。 int MyInt = 25; StringBuilder sb = new StringBuilder("Your total is "); sb.AppendFormat("&#123;0:C&#125; "， MyInt); Console.WriteLine(sb); //结果：Your total is $25.00 //Insert //Insert方法将字符串或对象添加到当前StringBuilder中的指定位置。//以下示例使用此方法将一个单词插入到StringBuilder的第六个位置。StringBuilder sb = new StringBuilder("Hello World!"); sb.Insert(6，"Beautiful "); Console.WriteLine(sb); //结果：Hello Beautiful World! //Remove //Remove方法从当前StringBuilder中移除指定数量的字符，移除过程从指定的从零开始的索引处开始。//以下示例使用Remove方法缩短StringBuilder。 StringBuilder sb = new StringBuilder("Hello World!"); sb.Remove(5，7); Console.WriteLine(sb); //结果：Hello//Replace //使用Replace方法，可以用另一个指定的字符来替换StringBuilder对象内的字符。//以下示例使用Replace方法来搜索StringBuilder对象，查找所有的感叹号字符(!)，并用问号字符(?)来替换它们。StringBuilder sb = new StringBuilder("Hello World!"); sb.Replace('!'， '?'); Console.WriteLine(sb); //结果：Hello World? 下面看一下在内存中如何分配的：如下图 3)知道它们是如何分配之后，就可以很好的区分”==”， “Equals”， “Object.ReferenceEquals(obj1，obj2)”。(1)在这==之前先讲一下：可能java程序员看到这里的时候会感觉有一点懵。在java中String类型它都是放在堆中的。而C#则不同，微软对String类型进行优化(2)微软在处理字符串的时候用到散列表：它是什么呢？简单理解就是当你创建了字符串”china”这个字符串的时候，当你再创建这个字符串的时候，编译器是不会再去开辟新的内存来存储的。它会直接指向第一次创建的地址。(3)看如下代码： 1234567891011121314151617181920212223242526string s1 = "china";string s2 = "china"; String s3 = new String(new char[] &#123; 'c'， 'h'， 'i'， 'n'， 'a' &#125;);String s4 = new String(new char[] &#123; 'c'， 'h'， 'i'， 'n'， 'a' &#125;); Console.WriteLine(s1 == s2); //True Console.WriteLine(s1.Equals(s2)); //TrueConsole.WriteLine(Object.ReferenceEquals(s1， s2)); //TrueConsole.WriteLine("--------------------------"); Console.WriteLine(s3 == s4); //True 微软对它进行优化，String s1 = new String(new char[] &#123; 'c'， 'h'， 'i'， 'n'， 'a' &#125;);相当于string s1 = "china";所以上面s1 == s3就为True了。Console.WriteLine(s3.Equals(s4)); //TrueConsole.WriteLine(Object.ReferenceEquals(s3， s4)); //FalseConsole.WriteLine("--------------------------"); Console.WriteLine(s1 == s3); //TrueConsole.WriteLine(s1.Equals(s3)); //TrueConsole.WriteLine(Object.ReferenceEquals(s1， s3)); //FalseConsole.WriteLine("---------StringBuilder-----------------"); StringBuilder sb1 = new StringBuilder("china");StringBuilder sb2 = new StringBuilder("china");Console.WriteLine(sb1 == sb2); //FalseConsole.WriteLine(sb1.Equals(sb2)); //TrueConsole.WriteLine(Object.ReferenceEquals(sb1， sb2)); //False 堆和栈分析图： 总结1)==它是比较的栈里面的值是否相等(值比较)2)Equals它比较的是堆里面的值是否相等(引用地址值比较)3)Object.ReferenceEquals(obj1，obj2)它是比较的是内存地址是否相等]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 树]]></title>
    <url>%2F2019%2F07%2F18%2F%E7%AC%AC6%E7%AB%A0-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 非空树有哪两个特点？ 什么是结点的度？树的度呢？ 结点互相之间怎么称呼？ 树的深度是什么意思？什么是有序树和无序树？ 什么是森林？ 树的树的存储结构的三种表示法是什么？分别描述。 什么是前序遍历？中序遍历和后序遍历？层序遍历呢？ 本章涵盖： 树的定义 结点分类 结点间关系 树的定义之前我们一直在谈的是一对一的线性结构，可现实中，还有很多一对多的情况需要处理，所以我们需要研究这种一对多的数据结构--“树”，考虑它的各种特性，来解决我们在编程中碰到的相关问题。 树（Tree）是n（n≥0）个结点的有限集。n=0时称为空树。在任意一棵非空树中： （1）有且仅有一个特定的称为根（Root）的结点； （2）当n＞1时，其余结点可分为m（m＞0）个互不相交的有限集T1 、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree），如图1所示。 图1 树的定义其实就是我们在讲解栈时提到的递归的方法。也就是在树的定义之中还用到了树的概念，这是一种比较新的定义方法。图2的子树T1和子树T2就是根结点A的子树。当然，D、G、H、I组成的树又是B为根结点的子树，E、J组成的树是以C为根结点的子树。 图2 对于树的定义还需要强调两点： 1.n&gt;0时根结点是唯一的，不可能存在多个根结点。 2.m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。像图3中的两个结构就不符合树的定义，因为它们都有相交的子树。 图3 结点分类树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。如图4所示，因为这棵树结点的度的最大值是结点D的度，为3，所以树的度也为3。 图4 结点间关系结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。嗯，为什么不是父或母，叫双亲呢？呵呵，对于结点来说其父母同体，唯一的一个，所以只能把它称为双亲了。同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。所以对于H来说，D、B、A都是它的祖先。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。B的子孙有D、G、H、I，如图5所示。 图5 树的其他相关概念结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第l层，则其子树就在第l+1层。其双亲在同一层的结点互为堂兄弟。显然图6中的D、E、F是堂兄弟，而G、H、I与J也是堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度，当前树的深度为4。 图6 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。 森林（Forest）是m（m≥0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。对于图1中的树而言，图2中的两棵子树其实就可以理解为森林。 对比线性表与树的结构，它们有很大的不同，如图7所示。 图7 树的抽象数据类型相对于线性结构，树的操作就完全不同了，这里我们给出一些基本和常用操作。 123456789101112131415161718192021ADT 树(tree)Data 树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。Operation InitTree(*T): 构造空树T。 DestroyTree(*T): 销毁树T。 CreateTree(*T, definition): 按definition中给出树的定义来构造树。 ClearTree(*T): 若树T存在，则将树T清为空树。 TreeEmpty(T): 若T为空树，返回true，否则返回false。 TreeDepth(T): 返回T的深度。 Root(T): 返回T的根结点。 Value(T, cur_e): cur_e是树T中一个结点，返回此结点的值。 Assign(T, cur_e, value): 给树T的结点cur_e赋值为value。 Parent(T, cur_e): 若cur_e是树T的非根结点，则返回它的双亲，否则返回空。 LeftChild(T, cur_e): 若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空。 RightSibling(T, cur_e): 若cur_e有右兄弟，则返回它的右兄弟，否则返回空。 InsertChild(*T, *p, i, c): 其中p指向树T的某个结点，i为所指结点p的度加上1， 非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树。 DeleteChild(*T, *p, i): 其中p指向树T的某个结点，i为所指结点p的度， 操作结果为删除T中p所指结点的第i棵子树。endADT 树的存储结构说到存储结构，就会想到我们前面章节讲过的顺序存储和链式存储两种结构。 先来看看顺序存储结构，用一段地址连续的存储单元依次存储线性表的数据元素。这对于线性表来说是很自然的，对于树这样一多对的结构呢？ 树中某个结点的孩子可以有多个，这就意味着，无论按何种顺序将树中所有结点存储到数组中，结点的存储位置都无法直接反映逻辑关系，你想想看，数据元素挨个的存储，谁是谁的双亲，谁是谁的孩子呢？简单的顺序存储结构是不能满足树的实现要求的。 不过充分利用顺序存储和链式存储结构的特点，完全可以实现对树的存储结构的表示。我们这里要介绍三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法。 双亲表示法双亲表示法，言外之意就是以双亲作为索引关键词的一种存储方式。 人一定会有父母。树这种结构也不例外，除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。 我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。它的结点结构为表1所示。 表1 data parent 其中data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。 以下是我们的双亲表示法的结点结构定义代码。 1234567891011121314151617181920212223/* 树的双亲表示法结点结构定义 */#define MAX_TREE_SIZE 100/* 树结点的数据类型，目前暂定为整型 */typedef int TElemType;/* 结点结构 */typedef struct PTNode&#123; /* 结点数据 */ TElemType data; /* 双亲位置 */ int parent;&#125; PTNode;/* 树结构 */typedef struct&#123; /* 结点数组 */ PTNode nodes[MAX_TREE_SIZE]; /* 根的位置和结点数 */ int r, n;&#125; PTree; 有了这样的结构定义，我们就可以来实现双亲表示法了。由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这也就意味着，我们所有的结点都存有它双亲的位置。如图8中的树结构和表2中的树双亲表示所示。 图8 表2 这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲结点，所用的时间复杂度为O(1)，直到parent为-1时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，对不起，请遍历整个结构才行。 这真是麻烦，能不能改进一下呢？ 当然可以。我们增加一个结点最左边孩子的域，不妨叫它长子域，这样就可以很容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为-1，如表3所示。 表3 对于有0个或1个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。甚至是有2个孩子，知道了长子是谁，另一个当然就是次子了。 另外一个问题场景，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，那我们怎么办？嗯，可以增加一个右兄弟域来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。同样的，如果右兄弟不存在，则赋值为-1，如表4所示。 表4 但如果结点的孩子很多，超过了2个。我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。 注意也不是越多越好，有需要时再设计相应的结构。就像再好听的音乐，不停反复听上千遍也会腻味，再好看的电影，一段时间反复看上百遍，也会无趣，你们说是吧？ 孩子表示法换一种完全不同的考虑方法。由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。不过，树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。 方案一 一种是指针域的个数就等于树的度，复习一下，树的度是树各个结点度的最大值。其结构如表5所示。 表5 其中data是数据域。child1到childd是指针域，用来指向该结点的孩子结点。 对于图8的树来说，树的度是3，所以我们的指针域的个数是3，这种方法实现如图9所示。 图9 这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。 既然很多指针域都可能为空，为什么不按需分配空间呢。于是我们有了第二种方案。 方案二 第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数，其结构如表6所示。 表6 其中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1到childd为指针域，指向该结点的各个孩子的结点。 对于图10的树来说，这种方法实现如图10所示。 图10 这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。 能否有更好的方法，既可以减少空指针的浪费又能使结点结构相同。 仔细观察，我们为了要遍历整棵树，把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系。 这就是我们要讲的孩子表示法。具体办法是，把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中，如图11所示。 图11 为此，设计两种结点结构，一个是孩子链表的孩子结点，如表7所示。 表7 child next 其中child是数据域，用来存储某个结点在表头数组中的下标。next是指针域，用来存储指向某结点的下一个孩子结点的指针。 另一个是表头数组的表头结点，如表8所示。 表8 data firstchild 其中data是数据域，存储某结点的数据信息。firstchild是头指针域，存储该结点的孩子链表的头指针。 以下是我们的孩子表示法的结构定义代码。 1234567891011121314151617181920212223242526/* 树的孩子表示法结构定义 */#define MAX_TREE_SIZE 100/* 孩子结点 */typedef struct CTNode&#123; int child; struct CTNode *next;&#125; *ChildPtr;/* 表头结构 */typedef struct&#123; TElemType data; ChildPtr firstchild;&#125; CTBox;/* 树结构 */typedef struct&#123; /* 结点数组 */ CTBox nodes[MAX_TREE_SIZE]; /* 根的位置和结点数 */ int r,n;&#125; CTree; 这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。 但是，这也存在着问题，我如何知道某个结点的双亲是谁呢？比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗？当然是可以。如图12所示。 图12 我们把这种方法称为双亲孩子表示法，应该算是孩子表示法的改进。至于这个表示法的具体结构定义，这里就略过，留给同学们自己去设计了。 孩子兄弟表示法刚才我们分别从双亲的角度和从孩子的角度研究树的存储结构，如果我们从树结点的兄弟的角度考虑又会如何呢？当然，对于树这样的层级结构来说，只研究结点的兄弟是不行的，我们观察后发现，任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。 结点结构如表9所示。 表9 data firstchild rightsib 其中data是数据域，firstchild为指针域，存储该结点的第一个孩子结点的存储地址，right-sib是指针域，存储该结点的右兄弟结点的存储地址。 结构定义代码如下。 1234567/* 树的孩子兄弟表示法结构定义 */typedef struct CSNode&#123; TElemType data; struct CSNode *firstchild, *rightsib;&#125; CSNode, *CSTree; 对于图8的树来说，这种方法实现的示意图如图13所示。 图6-4-6这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过fistchild找到此结点的长子，然后再通过长子结点的rightsib找到它的二弟，接着一直下去，直到找到具体的孩子。当然，如果想找某个结点的双亲，这个表示法也是有缺陷的，那怎么办呢？ 呵呵，对，如果真的有必要，完全可以再增加一个parent指针域来解决快速查找双亲的问题，这里就不再细谈了。 其实这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树。我们把图6-4-6变变形就成了图6-4-7这个样子。 图6-4-7这样就可以充分利用二叉树的特性和算法来处理这棵树了。嗯？有人问，二叉树是什么？哈哈，别急，这正是我接下来要重点讲的内容。 二叉树的定义现在我们来做个游戏，我在纸上已经写好了一个100以内的正整数数字，请大家想办法猜出我写的是哪一个？注意你们猜的数字不能超过7个，我的回答只会告诉你是“大了”或“小了”。 这个游戏在一些电视节目中，猜测一些商品的定价时常会使用。我看到过有些人是一点一点的数字累加的，比如5、10、15、20这样猜，这样的猜数策略太低级了，显然是没有学过数据结构和算法的人才做得出的事。 其实这是一个很经典的折半查找算法。如果我们用图6-5-1（下三层省略）的办法，就一定能在7次以内，猜出结果来。 图6-5-1 由于是100以内的正整数，所以我们先猜50（100的一半），被告之“大了”，于是再猜25（50的一半），被告之“小了”，再猜37（25与50的中间数），小了，于是猜43，大了，40，大了，38，小了，39，完全正确。过程如表6-5-1所示。 表6-5-1 我们发现，如果用这种方式进行查找，效率高 图6-5-2 6.5.1 二叉树特点二叉树的特点有： 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。左子树和右子树是有顺序的，次序不能任意颠倒。就像人有双手、双脚，但显然左手、左脚和右手、右脚是不一样的，右手戴左手套、右脚穿左鞋都会极其别扭和难受。即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。图6-5-3中，树1和树2是同一棵树，但它们却是不同的二叉树。就好像你一不小心，摔伤了手，伤的是左手还是右手，对你的生活影响度是完全不同的。 图6-5-3 二叉树具有五种基本形态： 1.空二叉树。 2.只有一个根结点。 3.根结点只有左子树。 4.根结点只有右子树。 5.根结点既有左子树又有右子树。 应该说这五种形态还是比较好理解的，那我现在问大家，如果是有三个结点的树，有几种形态？如果是有三个结点的二叉树，考虑一下，又有几种形态？ 若只从形态上考虑，三个结点的树只有两种情况，那就是图6-5-4中有两层的树1和有三层的后四种的任意一种，但对于二叉树来说，由于要区分左右，所以就演变成五种形态，树2、树3、树4和树5分别代表不同的二叉树。 图6-5-4 6.5.2 特殊二叉树我们再来介绍一些特殊的二叉树。这些树可能暂时你不能理解它有什么用处，但先了解一下，以后会提到它们的实际用途。 1．斜树 顾名思义，斜树一定要是斜的，但是往哪斜还是有讲究。所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。图6-5-4中的树2就是左斜树，树5就是右斜树。斜树有很明显的特点，就是每一层都只有一个结点，结点的个数与二叉树的深度相同。 有人会想，这也能叫树呀，与我们的线性表结构不是一样吗。对的，其实线性表结构就可以理解为是树的一种极其特殊的表现形式。 2．满二叉树 苏东坡曾有词云：“人有悲欢离合，月有阴晴圆缺，此事古难全”。意思就是完美是理想，不完美才是人生。我们通常举的例子也都是左高右低、参差不齐的二叉树。那是否存在完美的二叉树呢？ 嗯，有同学已经在空中手指比划起来。对的，完美的二叉树是存在的。 在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 图6-5-5就是一棵满二叉树，从样子上看就感觉它很完美。 图6-5-5 单是每个结点都存在左右子树，不能算是满二叉树，还必须要所有的叶子都在同一层上，这就做到了整棵树的平衡。因此，满二叉树的特点有：（1）叶子只能出现在最下一层。出现在其他层就不可能达成平衡。（2）非叶子结点的度一定是2。否则就是“缺胳膊少腿”了。（3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。 3．完全二叉树 对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树，如图6-5-6所示。 图6-5-6 这是一种有些理解难度的特殊二叉树。 首先从字面上要区分，“完全”和“满”的差异，满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。 其次，完全二叉树的所有结点与同样深度的满二叉树，它们按层序编号相同的结点，是一一对应的。这里有个关键词是按层序编号，像图6-5-7中的树1，因为5结点没有左子树，却有右子树，那就使得按层序编号的第10个编号空档了。同样道理，图6-5-7中的树2，由于3结点没有子树，所以使得6、7编号的位置空档了。图6-5-7中的树3又是因为5编号下没有子树造成第10和第11位置空档。只有图6-5-6中的树，尽管它不是满二叉树，但是编号是连续的，所以它是完全二叉树。 图6-5-7 从这里我也可以得出一些完全二叉树的特点：（1）叶子结点只能出现在最下两层。（2）最下层的叶子一定集中在左部连续位置。（3）倒数二层，若有叶子结点，一定都在右部连续位置。（4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。（5）同样结点数的二叉树，完全二叉树的深度最小。 从上面的例子，也给了我们一个判断某二叉树是否是完全二叉树的办法，那就是看着树的示意图，心中默默给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空档，就说明不是完全二叉树，否则就是。 6.6 二叉树的性质二叉树有一些需要理解并记住的特性，以便于我们更好地使用它。 6.6.1 二叉树性质1性质1：在二叉树的第i层上至多有2i-1个结点（i≥1）。 这个性质很好记忆，观察一下图6-5-5。 第一层是根结点，只有一个，所以21-1=20=1。 第二层有两个，22-1=21=2。 第三层有四个，23-1=22=4。 第四层有八个，24-1=23=8。 通过数据归纳法的论证，可以很容易得出在二叉树的第i层上至多有2 i-1个结点（i≥1）的结论。 6.6.2 二叉树性质2性质2：深度为k的二叉树至多有2k-1个结点（k≥1）。 注意这里一定要看清楚，是2k后再减去1，而不是2k-1。以前很多同学不能完全理解，这样去记忆，就容易把性质2与性质1给弄混淆了。 深度为k意思就是有k层的二叉树，我们先来看看简单的。 如果有一层，至多1=21-1个结点。 如果有二层，至多1+2=3=22-1个结点。 如果有三层，至多1+2+4=7=23-1个结点。 如果有四层，至多1+2+4+8=15=24-1个结点。 通过数据归纳法的论证，可以得出，如果有k层，此二叉树至多有2k-1个结点。 6.6.3 二叉树性质3性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。 终端结点数其实就是叶子结点数，而一棵二叉树，除了叶子结点外，剩下的就是度为1或2的结点数了，我们设n1为度是1的结点数。则树T结点总数n=n0+n1+n2。 比如图6-6-1的例子，结点总数为10，它是由A、B、C、D等度为2结点，F、G、H、I、J等度为0的叶子结点和E这个度为1的结点组成。总和为4+1+5=10。 图6-6-1 我们换个角度，再数一数它的连接线数，由于根结点只有分支出去，没有分支进入，所以分支线总数为结点总数减去1。图6-6-1就是9个分支。对于A、B、C、D结点来说，它们都有两个分支线出去，而E结点只有一个分支线出去。所以总分支线为4×2+1×1=9。 用代数表达就是分支线总数=n-1=n1＋2n2。因为刚才我们有等式n=n0＋n1＋n2，所以可推导出n0＋n1＋n2-1=n1＋2n2。结论就是n0=n2＋1。 6.6.4 二叉树性质4性质4：具有n个结点的完全二叉树的深度为|log2n+1|（|x|表示不大于x的最大整数）。 由满二叉树的定义我们可以知道，深度为k的满二叉树的结点数n一定是2k-1。因为这是最多的结点个数。那么对于n=2k-1倒推得到满二叉树的深度为k=log2(n＋1)，比如结点数为15的满二叉树，深度为4。 完全二叉树我们前面已经提到，它是一棵具有n个结点的二叉树，若按层序编号后其编号与同样深度的满二叉树中编号结点在二叉树中位置完全相同，那它就是完全二叉树。也就是说，它的叶子结点只会出现在最下面的两层。 它的结点数一定少于等于同样深度的满二叉树的结点数2k-1，但一定多于2k-1-1。即满足2k-1-1&lt;n≤2k-1。由于结点数n是整数，n≤2k-1意味着n&lt;2k，n&gt;2k-1-1，意味着n≥2k-1，所以2k-1≤n&lt;2k，不等式两边取对数，得到k-1≤log2n&lt;k，而k作为深度也是整数，因此k=|log2n|+1。 6.6.5 二叉树性质5性质5：如果对一棵有n个结点的完全二叉树（其深度为）的结点按层序编号（从第1层到第层，每层从左到右），对任一结点i（1≤i≤n）有： 1．如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点。 2．如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。 3．如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1。 我们以图6-6-2为例，来理解这个性质。这是一个完全二叉树，深度为4，结点总数是10。 图6-6-2 对于第一条来说是很显然的，i=1时就是根结点。i&gt;1时，比如结点7，它的双亲就是，结点9，它的双亲就是。 第二条，比如结点6，因为2×6=12超过了结点总数10，所以结点6无左孩子，它是叶子结点。同样，而结点5，因为2×5=10正好是结点总数10，所以它的左孩子是结点10。 第三条，比如结点5，因为2×5+1=11，大于结点总数10，所以它无右孩子。而结点3，因为2×3+1=7小于10，所以它的右孩子是结点7。 遍历二叉树二叉树遍历原理假设，我手头有20张100元的和2000张1元的奖券，同时洒向了空中，大家比赛看谁最终捡的最多。如果是你，你会怎么做？ 相信所有同学都会说，一定先捡100元的。道理非常简单，因为捡一张100元等于1元的捡100张，效率好得不是一点点。所以可以得到这样的结论，同样是捡奖券，在有限时间内，要达到最高效率，次序非常重要。对于二叉树的遍历来讲，次序同样显得很重要。 二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。 这里有两个关键词：访问和次序。 访问其实是要根据实际的需要来确定具体做什么，比如对每个结点进行相关计算，输出打印等，它算作是一个抽象操作。在这里我们可以简单地假定访问就是输出结点的数据信息。 二叉树的遍历次序不同于线性结构，最多也就是从头至尾、循环、双向等简单的遍历方式。树的结点之间不存在唯一的前驱和后继关系，在访问一个结点后，下一个被访问的结点面临着不同的选择。就像你人生的道路上，高考填志愿要面临哪个城市、哪所大学、具体专业等选择，由于选择方式的不同，遍历的次序就完全不同了。 二叉树遍历方法二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分为四种： 1．前序遍历 规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。如图6-8-2所示，遍历的顺序为：ABDGH-CEIF。 图6-8-2 2．中序遍历 规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。如图6-8-3所示，遍历的顺序为：GDHBAE-ICF。 图6-8-3 3．后序遍历 规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。如图6-8-4所示，遍历的顺序为：GHDBIEFCA。 图6-8-4 4．层序遍历 规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。如图6-8-5所示，遍历的顺序为：ABCDEFGHI。 图6-8-5 有同学会说，研究这么多遍历的方法干什么呢？ 我们用图形的方式来表现树的结构，应该说是非常直观和容易理解，但是对于计算机来说，它只有循环、判断等方式来处理，也就是说，它只会处理线性序列，而我们刚才提到的四种遍历方法，其实都是在把树中的结点变成某种意义的线性序列，这就给程序的实现带来了好处。 另外不同的遍历提供了对结点依次处理的不同方式，可以在遍历过程中对结点进行各种处理。 赫夫曼树及其应用赫夫曼树在计算机和互联网技术中，文本压缩是一个非常重要的技术。玩电脑的人几乎都会应用压缩和解压缩软件来处理文档。因为它除了可以减少文档在磁盘上的空间外，还有重要的一点，就是我们可以在网络上以压缩的形式传输大量数据，使得保存和传递都更加高效。 那么压缩而不出错是如何做到的呢？简单说，就是把我们要压缩的文本进行重新编码，以减少不必要的空间。接下来介绍一下最基本的压缩编码方法--赫夫曼编码。 在介绍赫夫曼编码前，必须得介绍赫夫曼树。 什么叫做赫夫曼树呢？我们先来看一个例子。 过去我们小学、中学一般考试都是用百分制来表示学科成绩的。这带来了一个弊端，就是很容易让学生、家长，甚至老师自己都以分取人，让分数代表了一切。有时想想也对，90分和95分也许就只是一道题目对错的差距，但却让两个孩子可能受到完全不同的待遇，这并不公平。于是在如今提倡素质教育的背景下，我们很多的学科，特别是小学的学科成绩都改作了优秀、良好、中等、及格和不及格这样模糊的词语，不再通报具体的分数。 不过对于老师来讲，他在对试卷评分的时候，显然不能凭感觉给优良或及格不及格等成绩，因此一般都还是按照百分制算出每个学生的成绩后，再根据统一的标准换算得出五级分制的成绩。比如下面的代码就实现了这样的转换。 12345678910if (a &lt; 60) b = "不及格";else if (a &lt; 70) b = "及格";else if (a &lt; 80) b = "中等";else if (a &lt; 90) b = "良好";else b = "优秀"; 下图粗略看没什么问题，可是通常都认为，一张好的考卷应该是让学生成绩大部分处于中等或良好的范围，优秀和不及格都应该较少才对。而上面这样的程序，就使得所有的成绩都需要先判断是否及格，再逐级而上得到结果。输入量很大的时候，其实算法是有效率问题的。 如果在实际的学习生活中，学生的成绩在5个等级上的分布规律如下表所示。 那么70分以上大约占总数80%的成绩都需要经过3次以上的判断才可以得到结果，这显然不合理。 有没有好一些的办法，仔细观察发现，中等成绩（70～79分之间）比例最高，其次是良好成绩，不及格的所占比例最少。我们把图6-12-2这棵二叉树重新进行分配。改成如图6-12-3的做法试试看。 从图中感觉，应该效率要高一些了，到底高多少呢。这样的二叉树又是如何设计出来的呢？我们来看看赫夫曼大叔是如何说的吧。 赫夫曼树定义与原理我们先把这两棵二叉树简化成叶子结点带权的二叉树（注：树结点间的边相关的数叫做权Weight），如下图所示。其中A表示不及格、B表示及格、C表示中等、D表示良好、E表示优秀。每个叶子的分支线上的数字就是刚才我们提到的五级分制的成绩所占百分比。 赫夫曼大叔说，从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。图6-12-4的二叉树a中，根结点到结点D的路径长度就为4，二叉树b中根结点到结点D的路径长度为2。树的路径长度就是从树根到每一结点的路径长度之和。二叉树a的树路径长度就为1+1+2+2+3+3+4+4=20。二叉树b的树路径长度就为1+2+3+3+2+1+2+2=16。 如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。假设有n个权值{w1,w2,…,wn}，构造一棵有n个叶子结点的二叉树，每个叶子结点带权wk，每个叶子的路径长度为lk，我们通常记作，则其中带权路径长度WPL最小的二叉树称做赫夫曼树。也有不少书中也称为最优二叉树，我个人觉得为了纪念做出巨大贡献的科学家，既然用他们的名字命名，就应该要坚持用他们的名字称呼，哪怕“最优”更能体现这棵树的品质也应该只作为别名。 有了赫夫曼对带权路径长度的定义，我们来计算一下图6-12-4这两棵树的WPL值。 二叉树a的WPL=5×1+15×2+40×3+30×4+10×4=315 注意：这里5是A结点的权，1是A结点的路径长度，其他同理。 二叉树b的WPL=5×3+15×3+40×2+30×2+10×2=220 这样的结果意味着什么呢？如果我们现在有10000个学生的百分制成绩需要计算五级分制成绩，用二叉树a的判断方法，需要做31500次比较，而二叉树b的判断方法，只需要22000次比较，差不多少了三分之一量，在性能上提高不是一点点。 那么现在的问题就是，图6-12-4的二叉树b这样的树是如何构造出来的，这样的二叉树是不是就是最优的赫夫曼树呢？别急，赫夫曼大叔给了我们解决的办法。 1．先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即：A5，E10，B15，D30，C40。 2．取头两个最小权值的结点作为一个新节点N1的两个子结点，注意相对较小的是左孩子，这里就是A为N1的左孩子，E为N1的右孩子，如图6-12-5所示。新结点的权值为两个叶子权值的和5+10=15。 图6-12-5 3．将N1替换A与E，插入有序序列中，保持从小到大排列。即：N115，B15，D30，C40。 4．重复步骤2。将N1与B作为一个新节点N2的两个子结点。如图6-12-6所示。N2的权值=15+15=30。 图6-12-6 5．将N2替换N1与B，插入有序序列中，保持从小到大排列。即：N230，D30，C40。 6．重复步骤2。将N2与D作为一个新节点N3的两个子结点。如图6-12-7所示。N3的权值=30+30=60。 图6-12-7 7．将N3替换N2与D，插入有序序列中，保持从小到大排列。即：C40，N360。 8．重复步骤2。将C与N3作为一个新节点T的两个子结点，如图6-12-8所示。由于T即是根结点，完成赫夫曼树的构造。 图6-12-8 此时的图6-12-8二叉树的带权路径长度WPL=40×1+30×2+15×3+10×4+5×4=205。与图6-12-4的二叉树b的WPL值220相比，还少了15。显然此时构造出来的二叉树才是最优的赫夫曼树。 不过现实总是比理想要复杂得多，图6-12-8虽然是赫夫曼树，但由于每次判断都要两次比较（如根结点就是a&lt;80&amp;&amp;a&gt;=70，两次比较才能得到y或n的结果），所以总体性能上，反而不如图6-12-3的二叉树性能高。当然这并不是我们要讨论的重点了。 通过刚才的步骤，我们可以得出构造赫夫曼树的赫夫曼算法描述。 1.根据给定的n个权值{w1,w2,…,wn}构成n棵二叉树的集合F={T1,T2,…,Tn}，其中每棵二叉树Ti中只有一个带权为wi根结点，其左右子树均为空。2.在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。3.在F中删除这两棵树，同时将新得到的二叉树加入F中。4.重复2和3步骤，直到F只含一棵树为止。这棵树便是赫夫曼树。 6.12.3 赫夫曼编码当然，赫夫曼研究这种最优树的目的不是为了我们可以转化一下成绩。他的更大目的是为了解决当年远距离通信（主要是电报）的数据传输的最优化问题。 比如我们有一段文字内容为“BADCADFEED”要网络传输给别人，显然用二进制的数字（0和1）来表示是很自然的想法。我们现在这段文字只有六个字母ABCDEF，那么我们可以用相应的二进制数据表示，如表6-12-2所示。 表6-12-2 这样真正传输的数据就是编码后的“001000011010000011101100100011”，对方接收时可以按照3位一分来译码。如果一篇文章很长，这样的二进制串也将非常的可怕。而且事实上，不管是英文、中文或是其他语言，字母或汉字的出现频率是不相同的，比如英语中的几个元音字母“ae i o u”，中文中的“的 了 有 在”等汉字都是频率极高。 假设六个字母的频率为A 27，B 8，C 15，D15，E 30，F 5，合起来正好是100%。那就意味着，我们完全可以重新按照赫夫曼树来规划它们。 图6-12-9左图为构造赫夫曼树的过程的权值显示。右图为将权值左分支改为0，右分支改为1后的赫夫曼树。 图6-12-9 此时，我们对这六个字母用其从树根到叶子所经过路径的0或1来编码，可以得到如表6-12-3所示这样的定义。 表6-12-3 我们将文字内容为“BADCADFEED”再次编码，对比可以看到结果串变小了。 原编码二进制串：001000011010000011101100100011（共30个字符）新编码二进制串：1001010010101001000111100（共25个字符）也就是说，我们的数据被压缩了，节约了大约17%的存储或传输成本。随着字符的增加和多字符权重的不同，这种压缩会更加显出其优势。 当我们接收到1001010010101001000111100这样压缩过的新编码时，我们应该如何把它解码出来呢？ 编码中非0即1，长短不等的话其实是很容易混淆的，所以若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码。 你仔细观察就会发现，表6-12-3中的编码就不存在容易与1001、1000混淆的“10”和“100”编码。 可仅仅是这样不足以让我们去方便地解码的，因此在解码时，还是要用到赫夫曼树，即发送方和接收方必须要约定好同样的赫夫曼编码规则。 当我们接收到1001010010101001000111100时，由约定好的赫夫曼树可知，1001得到第一个字母是B，接下来01意味着第二个字符是A，如图6-12-10所示，其余的也相应的可以得到，从而成功解码。 图6-12-10 一般地，设需要编码的字符集为{d1,d2,…,dn}，各个字符在电文中出现的次数或频率集合为{w1,w2,…,wn}，以d1,d2,…,dn作为叶子结点，以w1,w2,…,wn作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码。 总结回顾终于到了总结的时间，这一章与前面章节相比，显得过于庞大了些，原因也就在于树的复杂性和变化丰富度是前面的线性表所不可比拟的。即使在本章之后，我们还要讲解关于树这一数据结构的相关知识，可见它的重要性。 开头我们提到了树的定义，讲到了递归在树定义中的应用。提到了如子树、结点、度、叶子、分支结点、双亲、孩子、层次、深度、森林等诸多概念，这些都是需要在理解的基础上去记忆的。 我们谈到了树的存储结构时，讲了双亲表示法、孩子表示法、孩子兄弟表示法等不同的存储结构。 并由孩子兄弟表示法引出了我们这章中最重要一种树，二叉树。 二叉树每个结点最多两棵子树，有左右之分。提到了斜树，满二叉树、完全二叉树等特殊二叉树的概念。 我们接着谈到它的各种性质，这些性质给我们研究二叉树带来了方便。 二叉树的存储结构由于其特殊性使得既可以用顺序存储结构又可以用链式存储结构表示。 遍历是二叉树最重要的一门学问，前序、中序、后序以及层序遍历都是需要熟练掌握的知识。要让自己要学会用计算机的运行思维去模拟递归的实现，可以加深我们对递归的理解。不过，并非二叉树遍历就一定要用到递归，只不过递归的实现比较优雅而已。这点需要明确。 二叉树的建立自然也是可以通过递归来实现。 研究中也发现，二叉链表有很多浪费的空指针可以利用，查找某个结点的前驱和后继为什么非要每次遍历才可以得到，这就引出了如何构造一棵线索二叉树的问题。线索二叉树给二叉树的结点查找和遍历带来了高效率。 树、森林看似复杂，其实它们都可以转化为简单的二叉树来处理，我们提供了树、森林与二叉树的互相转换的办法，这样就使得面对树和森林的数据结构时，编码实现成为了可能。 最后，我们提到了关于二叉树的一个应用，赫夫曼树和赫夫曼编码，对于带权路径的二叉树做了详尽地讲述，让你初步理解数据压缩的原理，并明白其是如何做到无损编码和无错解码的。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[［设计模式］唠唠依赖注入]]></title>
    <url>%2F2019%2F07%2F17%2F%EF%BC%BB%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%BD%E5%94%A0%E5%94%A0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 工厂模式的应用场景就是解决改名问题如何理解？ 来源：［设计模式］唠唠依赖注入 啥是依赖注入(Dependency injection)? 直接上例子： 这不是依赖注入！ 123456789101112131415161718192021//这不是依赖注入！！！class Bar&#123;&#125;class Foo&#123; protected $bar; public function __construct() &#123; $this-&gt;bar = new Bar(); &#125; public function getBar() &#123; return $this-&gt;bar; &#125;&#125;$foo = new Foo(); 这就是依赖注入 12345678910111213141516171819202122//这就是依赖注入。。。class Bar&#123;&#125;class Foo&#123; protected $bar; public function __construct(Bar $bar) &#123; $this-&gt;bar = $bar; &#125; public function getBar() &#123; return $this-&gt;bar; &#125;&#125;$bar = new Bar();$foo = new Foo($bar); 这也是依赖注入 123456789101112131415161718192021222324252627//这也是依赖注入。。。class Bar&#123;&#125;class Foo&#123; protected $bar; public function __construct() &#123; &#125; public function setBar(Bar $bar) &#123; $this-&gt;bar = $bar; &#125; public function getBar() &#123; return $this-&gt;bar; &#125;&#125;$bar = new Bar();$foo = new Foo();$foo-&gt;setBar($bar); 依赖注入就是new好了依赖的对象注入进去，而不是在类中显式的new一个依赖的对象。其实，就是这么简单。。。 为啥要用依赖注入？虽然思想简单，但是在降低耦合度方面作用巨大。 依赖注入都可以怎么用下面举个例子说明（just for demonstration）： 比如我们做了个小游戏，里面的男人可以亲自己的妻子。 123456789101112131415161718192021222324abstract class Human&#123;&#125;class Woman extends Human&#123;&#125;class Man extends Human&#123; protected $wife; public function __construct() &#123; $this-&gt;wife = new Woman(); &#125; public function kissWife() &#123; echo "the man kissed his wife"; &#125;&#125;$man = new Man();$man-&gt;kissWife(); 玩的人越来也多，新需求随之而来。。。 产品经理（腐腐）：妻子改成可以是男的吧，好多用户有这个需求，这样玩我们游戏的肯定更多。 程序员（猿猿）心里：擦，Wife又可以是Man，又可以是Woman，这可咋整。 这个时候，依赖注入就可以闪亮登场了。 123456789101112131415161718192021222324252627282930abstract class Human&#123;&#125;class Woman extends Human&#123;&#125;class Man extends Human&#123; protected $wife; public function setWife(Human $human) &#123; $this-&gt;wife = $human; &#125; public function kissWife() &#123; echo "the man kissed his wife"; &#125;&#125;$man = new Man();$man-&gt;setWife(new Woman());$man-&gt;kissWife();$anotherMan = new Man();$anotherMan-&gt;setWife(new Man());$anotherMan-&gt;kissWife(); 这里我们看到，依赖注入的可以是继承依赖类的任何类，所以现在Man的Wife既可以是Woman也可以是Man。 玩的人越来也多，新需求随之而来。。。 产品经理（宅宅）：把妻子改成伴侣吧，伴侣里面除了Man和Woman再加个Cat，好多用户有这个需求，这样玩我们游戏的肯定更多。 程序员（猿猿）心里：擦，又是Man又是Woman还有Cat，幸好我会依赖注入。 123456789101112131415161718192021222324252627282930313233343536373839404142abstract class Human&#123;&#125;interface canBePartner&#123;&#125;class Cat implements canBePartner&#123;&#125;class Woman extends Human implements canBePartner&#123;&#125;class Man extends Human implements canBePartner&#123; protected $partner; public function setPartner(canBePartner $partner) &#123; $this-&gt;partner = $partner; &#125; public function kissPartner() &#123; echo "the man kissed his partner"; &#125;&#125;$man = new Man();$man-&gt;setPartner(new Woman());$man-&gt;kissPartner();$man2 = new Man();$man2-&gt;setPartner(new Man());$man2-&gt;kissPartner();$man3 = new Man();$man3-&gt;setPartner(new Cat());$man3-&gt;kissPartner(); 这里我们看到，依赖注入不但可以是继承依赖类的所有子类，也可以是实现依赖接口的所有类。 所以如果我们在伴侣中再加入一个Dog，只需要让它实现canBePartner接口就可以了： 12345class Dog implements canBePartner&#123;&#125;$man = new Man();$man-&gt;setPartner(new Dog()); 实际应用依赖注入虽然降低了耦合度，但是也有缺点，就是需要我们自己管理注入的对象。 所以，在实际应用中，我们通常需要实现一个容器去管理和实现依赖对象的注入。实际上，PHP的常用Web框架中都是这么做的。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈依赖注入与控制反转]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%B5%85%E8%B0%88%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 工厂模式的应用场景就是解决改名问题如何理解？ 来源：浅谈依赖注入与控制反转 前言：设计模式其实是一个很空洞的东西，设计模式有几十种，有些人觉得工厂模式和单例模式已经足够解决大部分问题。而有些人觉得任何设计模式都会让开发变得更“复杂”，更“低效”。所以千万不要太过追求他的实际意义和作用，否则你已经坠入云雾。但是不管怎么样，实际工作中还是要对它们有所了解，下面从php的角度来讲一下依赖注入、控制反转、反射等概念。 首先设定场景，假如一个类需要数据库连接，最简单的做法可能是： 12345678910111213class example &#123; private $_db; function __construct() &#123; include "./Lib/Db.php"; $this-&gt;_db = new Db("localhost","root","123456","test"); &#125; function getList() &#123; $this-&gt;_db-&gt;query("......"); &#125;&#125; 但事实上稍微有点经验的同学都不会这样写，因为一旦越来越多的类用到db，而db一旦发生变化（名字或路径改变），那么岂不是要每个文件都修改一遍？这就是程序设计中的耦合问题。所有的类过度依赖“./Lib/Db.php”这个文件。OK，为了解决这个问题，工厂模式出现了，我们新建一个Factory工厂类: 1234567891011121314151617181920class Factory &#123; public static function getDb() &#123; include "./Lib/Db.php"; return new Db("localhost","root","123456","test"); &#125;&#125;class example &#123; private $_db; function __construct() &#123; $this-&gt;_db = Factory::getDb(); &#125; function getList() &#123; $this-&gt;_db-&gt;query("......"); &#125;&#125; 如果我们用到db模块那么直接Factory::getDb()从工厂中取出来就是了，看似解决了问题。但事实是这样吗？不，这样只不过是把程序与db模块的耦合转移到了Factory，一旦后期业务发生变动，Factory发生变动（名字改了），依旧要对每个文件改动。那如何解决呢？ 我们可以不从example类内部获取db组件，我们从外部把db组件注入进example类。 12345678910111213141516class example &#123; private $_db; function getList() &#123; $this-&gt;_db-&gt;query("......");//执行查询 &#125; //从外部注入db连接 function setDb($connection) &#123; $this-&gt;_db = $connection; &#125;&#125;$example = new example();$example-&gt;setDb(Factory::getDb());//注入db连接$example-&gt;getList(); 这样一来example就不用关心db组件怎么来的了，只用暴露一个注入方法即可。这就是DI/依赖注入（Dependency Injection），不在内部处理依赖关系，而是把依赖作为参数传递进去，以降低程序的耦合性。 然后我们的项目继续进行，用到了文件处理类，图像处理类，我们可能会这样写： 123$example-&gt;setDb(Factory::getDb());//注入db连接$example-&gt;setFile(Factory::getFile());//注入文件处理类$example-&gt;setImage(Factory::getImage());//注入Image处理类 但是这样似乎也不行啊，每次都要写这么多代码，于是我们又写了一个工厂方法： 1234567891011class Factory &#123; public static function getExample() &#123; $example = new example(); $example-&gt;setDb(Factory::getDb());//注入db连接 $example-&gt;setFile(Factory::getFile());//注入文件处理类 $example-&gt;setImage(Factory::getImage());//注入Image处理类 return $expample; &#125;&#125; example也不直接new了。我们用Factory::getExample()中获取。但是，这是不是又有点熟悉的感觉？和上面第一次用工厂类的时候一样依赖于工厂。于是又有了容器的概念。 12345678910111213141516171819class example &#123; private $_di; function __construct(Di &amp;$di) &#123; $this-&gt;_di = $di; &#125; //通过di容器获取db实例 function getList() &#123; $this-&gt;_di-&gt;get('db')-&gt;query("......"); &#125;&#125;$di = new Di();$di-&gt;set("db",function()&#123; return new Db("localhost","root","root","test"); &#125;);$example = new example($di);$example-&gt;getList(); Di就是一个存放各种可扩展的组件的容器，需要注入的时候调用di-&gt;set()方法注入组件即可。程序中即可通过di-&gt;get()获取组件。这样被调用的组件（db）并不是由调用者（example）创建，而是由Di容器创建，调用者失去控制权，而容器得到控制权，发生了控制权转移，所以叫 做控制反转（Inversion of Control）。 但是这样又有一些比较有强迫症的同学发现了，每个类都要注入一遍容器是不是有些麻烦。没错，其实注入容器这个动作可以交给另外的程序处理，那就是反射。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php/** * example*/class example &#123; //通过di容器获取db实例 function getList() &#123; $this-&gt;_di-&gt;get('db')-&gt;query("......"); &#125;&#125;//di容器class Di&#123; public $_container; public function get($cls) &#123; return $this-&gt;_container[$cls]; &#125; public function set($cls,$_instance) &#123; $this-&gt;_container[$cls]=$_instance; &#125;&#125;//db组件class db&#123; private static $_instance;//保存单例 //单例方法 public static function getInstance() &#123; if(!(self::$_instance instanceof self)) &#123; self::$_instance = new self; &#125; return self::$_instance; &#125; //查询方法 public function query($sql) &#123; echo $sql; &#125;&#125;$di = new Di();//实例化容器$di-&gt;set('db',db::getInstance()); //注入db实例$reflector = new ReflectionClass('example'); //反射example，通过反射可以获得该类的所有信息$reflector-&gt;getDefaultProperties(); //example属性$reflector-&gt;getDocComment(); //注释$instance =$reflector-&gt;newInstanceArgs(); //相当于实例化反射的example类$instance-&gt;_di=$di; //注入di容器$reflector-&gt;getmethod('getList')-&gt;invoke($instance);//调用example类方法 通过反射我们可以得到该类的全部信息，包括方法、方法名、属性甚至注释等等。通过反射我们可以方便的控制程序中使用的类，对他们进行扩展、修正、以及监听。通常反射在插件开发和框架开发中大量应用。在框架开发中也会把反射与依赖注入、控制反转搭配使用，让程序有强大的可控性和扩展性。 依赖注入的本质就是自动实例化类的一个过程，合理的使用依赖注入恰恰能提高性能。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP的依赖注入(DI)和控制反转(IoC)]]></title>
    <url>%2F2019%2F07%2F17%2FPHP%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-DI-%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-IoC%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 这两种模式的目的是什么？ 整个过程中参与者都有谁？ 依赖：谁依赖于谁？为什么需要依赖？ 注入：谁注入于谁？到底注入了什么？ 控制反转：谁控制谁？控制什么？为何叫反转（有反转就应该有正转了，正转是什么呢？） 依赖注入和控制反转是同一概念吗？ 简介 IoC - Inversion of Control 控制反转 DI - Dependency Injection 依赖注入 依赖注入和控制反转说的实际上是同一个东西，它们是一种设计模式，这种设计模式用来减少程序间的耦合. 优势（为什么使用） 使用依赖注入，最重要的一点好处就是有效的分离了对象和它所需要的外部资源，使得它们松散耦合，有利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 概念 依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。 依赖注入是从应用程序的角度在描述，可以把依赖注入，即：应用程序依赖容器创建并注入它所需要的外部资源； 而控制反转是从容器的角度在描述，即：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。 问答对于一个菜鸟，如果你看了上面的概念还是一头雾水的话，那么恭喜你，你和我一样不是天才，那么下面就让我们借助于几个问答来搞清楚这个概念的意思吧。 整个过程中参与者都有谁？ 1234一般有三方参与者，一个是某个对象；一个是IoC/DI的容器；另一个是某个对象的外部资源。某个对象指的就是任意的、普通的PHP对象; IoC/DI的容器简单点说就是指用来实现IoC/DI功能的一个框架程序；对象的外部资源指的就是对象需要的，但是是从对象外部获取的，都统称资源，比如：对象需要的其它对象、或者是对象需要的文件资源等等。 谁依赖于谁： 1当然是某个对象依赖于IoC/DI的容器 为什么需要依赖： 1对象需要IoC/DI的容器来提供对象需要的外部资源 谁注入于谁： 1是IoC/DI的容器注入某个对象 到底注入什么： 1就是注入某个对象所需要的外部资源 谁控制谁： 1当然是IoC/DI的容器来控制对象了 控制什么： 1主要是控制对象实例的创建 为何叫反转： 1234反转是相对于正向而言的，那么什么算是正向的呢？考虑一下常规情况下的应用程序，如果要在A里面使用C，你会怎么做呢？当然是直接去创建C的对象，也就是说，是在A类中主动去获取所需要的外部资源C（$c = new C();），这种情况被称为正向的。那么什么是反向呢？就是A类不再主动去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中。用图例来说明一下，先看没有IoC/DI的时候，常规的A类使用C类的示意图，如下图所示： 代码示意： 1234567891011121314151617181920212223242526272829303132333435&lt;?php/** * 没有IoC/DI的时候，常规的A类使用C类的示例 *//** * Class c */class c&#123; public function say() &#123; echo 'hello'; &#125;&#125;/** * Class a */class a&#123; private $c; public function __construct() &#123; $this-&gt;c = new C(); // 实例化创建C类 &#125; public function sayC() &#123; echo $this-&gt;c-&gt;say(); // 调用C类中的方法 &#125;&#125;$a = new a();$a-&gt;sayC(); 当有了IoC/DI的容器后，A类不再主动去创建C了，如下图所示： 而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中，如下图所示： 代码示意： 12345678910111213141516171819202122232425262728293031323334353637&lt;?php/** * 当有了IoC/DI的容器后,a类依赖c实例注入的示例 *//** * Class c */class c&#123; public function say() &#123; echo 'hello'; &#125;&#125;/** * Class a */class a&#123; private $c; public function setC(C $c) &#123; $this-&gt;c = $c; // 实例化创建C类 &#125; public function sayC() &#123; echo $this-&gt;c-&gt;say(); // 调用C类中的方法 &#125;&#125;$c = new C();$a = new a();$a-&gt;setC($c);$a-&gt;sayC(); 什么是正转？ 1正转就是按照普通的，在类中直接创建对象实例，如 $c = new C(); 依赖注入和控制反转是同一概念吗？ 根据上面的讲述，我们不难出来，`依赖注入`和`控制反转`确实是对同一件事情的不同描述，从某个方面讲，就是它们描述的`角度`不同。 总结其实IoC/DI对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC/DI容器来创建并注入它所需要的资源了。 注意我们上面说了，这是一种“设计模式”，就像“工厂模式”和“单例模式”等是一样的，它是一种面向对象中的编程“思想”，自然它也不仅限于PHP，而是所有面向对象的语言基本都是可以适用的。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%A7%94%E6%89%98-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 多播委托的返回值是什么样的？ 调用带引用参数的委托是什么样的？ 本章涵盖：** 调用带返回值的委托如果委托有返回值并且在调用列表中有一个以上的方法，会发生下面的情况。 调用列表中最后一个方法返回的值就是委托调用返回的值。 调用列表中所有其他方法的返回值都会被忽略。 例如，如下代码声明了返回int值的委托。Main创建了委托对象并增加了另外两个方法。然后，它在WriteLine语句中调用委托并打印了它的返回值。图10演示了代码的图形表示。 123456789101112131415161718192021222324252627282930313233343536using System;using System.Collections.Generic;namespace Test&#123; delegate int MyDel(); // 声明有返回值的方法 class MyClass &#123; int IntValue = 5; public int Add2() &#123; IntValue += 2; return IntValue; &#125; public int Add3() &#123; IntValue += 3; return IntValue; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; MyClass mc = new MyClass(); MyDel mDel = mc.Add2; // 创建并初始化委托 mDel += mc.Add3; // 增加方法 mDel += mc.Add2; // 增加方法 Console.WriteLine("Value:&#123;0&#125;", mDel()); // 调用委托并使用返回值 Console.ReadKey(); &#125; &#125;&#125; 这段代码产生了如下的输出： 1value:12 图10 最后一个方法执行的返回值是委托返回的值 调用带引用参数的委托&lt;/span如果委托有引用参数，参数值会根据调用列表中的一个或多个方法的返回值而改变。 在调用委托列表中的下一个方法时，参数的新值（不是初始值）会传给下一个方法。 例如，如下代码调用了具有引用参数的委托。图11演示了这段代码。 12345678910111213141516171819202122232425262728293031323334using System;using System.Collections.Generic;namespace Test&#123; delegate void MyDel(ref int x); class MyClass &#123; public void Add2(ref int x) &#123; x += 2; &#125; public void Add3(ref int x) &#123; x += 3; &#125; static void Main() &#123; MyClass mc = new MyClass(); MyDel mDel = mc.Add2; // 创建并初始化委托 mDel += mc.Add3; // 增加方法 mDel += mc.Add2; // 增加方法 int x = 20; mDel(ref x); Console.WriteLine("Value:&#123;0&#125;", x); // 调用委托 Console.ReadKey(); &#125; &#125;&#125; 这段代码产生了如下的输出： 1value:12 图11 引用参数的值会在调用间发生改变 自己的理解和总结学习委托一定要明确使用场景。设计模式也是。为了解决什么问题而使用委托。 这边举个例子。写日志问题。日志从一处产生。产生之后可以有很多种处理。比如写进数据库，比如发送邮件，比如直接展示。 没有委托之前，如果需要增加一个日志处理，则需要在日志产生的代码处改动增加代码。 有委托后，只需要在日志产生的地方直接调用委托就OK了。想再增加处理方式可以在外面扩展。写好一个方法后再追加进委托即可。 目的就是为了解耦合，对修改关闭，对扩展开放。 事件是对委托的进一步封装，增强了委托的安全性，实现了发布/订阅。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#图解教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 泛型让数据类型就不用硬编码怎么理解？ 什么是构造类型？ 本章涵盖： 什么是泛型 C#中的泛型 泛型类 声明泛型类 创建构造类型 创建变量和实例 类型参数的约束 泛型方法 扩展方法和泛型类 泛型结构 泛型委托 泛型接口 什么是泛型使用已经学习的语言结构，我们已经可以建立多种不同类型的强大对象。大部分情况下是声明类，然后封装需要的行为，最后创建这些类的实例。 到现在为止，所有在类声明中用到的类型都是特定的类型--或许是程序员定义的，或许是语言或BCL定义的。然而，很多时候，如果我们可以把类的行为提取或重构出来，使之不仅能应用到它们编码的数据类型上，而且还能应用到其他类型上的话，类就会更有用。 有了泛型就可以做到这一点了。我们可以重构代码并且额外增加一个抽象层，对于这样的代码来说，数据类型就不用硬编码了。这是专门为多段代码在不同的数据类型上执行相同指令的情况专门设计的。 一个栈的示例 假设我们首先创建了如下的代码，它声明了一个叫做MyIntStack的类，该类实现了一个int类型的栈。它允许我们把int压入栈中，以及把它们弹出。顺便说一下，这不是系统定义的栈。 1234567891011121314class MyIntStack // int类型的栈&#123; int StackPointer = 0; int[] StackArray; // int类型的数组 public void Push(int x) // 输入类型：int &#123; &#125; public int Pop() // 返回类型：int &#123; &#125;&#125; 假设现在希望将相同的功能应用于float类型的值，可以有几种方式来实现，一种方式是按照下面的步骤产生后续的代码。 剪切并粘贴MyIntStack类的代码。 把类名改为MyFloatStack。 把整个类声明中相应的int声明改为float声明。1234567891011121314class MyFloatStack // float类型的栈&#123; int StackPointer = 0; float[] StackArray; // float类型的数组 public void Push(float x) // 输入类型：float &#123; &#125; public float Pop() // 返回类型：float &#123; &#125;&#125; 这个方法当然可行，但是很容易出错而且有如下缺点。 我们需要仔细检查类的每一个部分来看哪些类型的声明需要修改，哪些类型的声明需要保留。 每次需要新类型(long、double、string等)的栈类时，我们都需要重复这个过程。 在这些过程后，我们有了很多几乎具有相同代码的副本，占据了额外的空间。 调试和维护这些相似的实现不但复杂而且容易出错。 C#中的泛型泛型（generic）特性提供了一种更优雅的方式，可以让多个类型共享一组代码。泛型允许我们声明类型参数化（type-parameterized）的代码，可以用不同的类型进行实例化。也就是说，我们可以用“类型占位符”来写代码，然后在创建类的实例时指明真实的类型。 我们应该很清楚类型不是对象而是对象的模板这个概念了。同样地，泛型类型也不是类型，而是类型的模板。图1演示了这点。 图1 泛型类型是类型的模板 C#提供了5种泛型：类、结构、接口、委托和方法。注意，前面4个是类型，而方法是成员。图2演示了泛型类型如何用于其他类型。 图2 泛型和用户自定义类型 继续栈的示例 在栈的示例中，MyIntStack和MyFloatStack两个类的主体声明都差不多，只不过在处理由栈保存的类型时有点不同。 在MyIntStack中，这些位置使用int类型占据。 在MyFloatStack中，这些位置被float占据。 通过如下步骤我们可以从MyIntStack创建一个泛型类。 (1)在MyIntStack类定义中，使用类型占位符T而不是float来替换int.(2)修改类名称为MyStack.(3)在类名后放置。 结果就是如下的泛型类声明。由尖括号和T构成的字符串表明T是类型的占位符。(也不一定是字母T，它可以是任何标识符。)在类声明的主体中，每一个T都会被编译器替换为实际类型。 1234567891011121314class MyStack &#123; int StackPointer = 0; T[] StackArray; public void Push(T x) &#123; &#125; public T Pop() &#123; &#125;&#125; 泛型类既然已经见过了泛型类，让我们再来详细了解一下它，并看看如何创建和使用它。 创建和使用常规的、非泛型的类有两个步骤：声明类和创建类的实例。但是泛型类不是实际的类，而是类的模板，所以我们必须先从它们构建实际的类类型，然后创建这个构建后的类类型的实例。 图3从一个较高的层面上演示了这个过程。 图3 在某些类型上使用占位符来声明一个类。 为占位符提供真实类型。这样就有了真实类的定义，填补了所有的“空缺”。该类型称为构造类型（constructed type）。 创建构造类型的实例。 声明泛型类声明一个简单的泛型类和声明普通类差不多，区别如下。 在类名之后放置一组尖括号。 在尖括号中用逗号分隔的占位符字符串来表示希望提供的类型。这叫做类型参数(type parameter). 在泛型类声明的主体中使用类型参数来表示应该替代的类型 例如，如下代码声明了一个叫做SomeClass的泛型类。类型参数列在尖括号中，然后当作真实类型在声明的主体中使用。 类型参数 class SomeClass&lt;T1, T2&gt; { //通常在这些位置使用类型 public T1 SomeVar = new T1(); public T2 OtherVar = new T2(); } 在泛型类型声明中并没有特殊的关键字。取而代之的是尖括号中的类型参数列表，它可以区分泛型类与普通类的声明。 创建构造类型一旦创建了泛型类型，我们就需要告诉编译器能使用哪些真实类型来替代占位符(类型参数)，编译器获取这些真实类型并创建构造类型(用来创建真实类对象的模板)。 创建构造类型的语法如下，包括列出类名并在尖括号中提供真实类型来替代类型参数。要替代类型参数的真实类型叫做类型实参(type argument )。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#图解教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#的插入排序和二分查找]]></title>
    <url>%2F2019%2F07%2F17%2FC-%E7%9A%84%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[通过dll实现代码热更新2]]></title>
    <url>%2F2019%2F07%2F16%2F%E9%80%9A%E8%BF%87dll%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E7%83%AD%E6%9B%B4%E6%96%B02%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 完成dll热更新的程序逻辑，然后试着修改外部dll中的代码逻辑。 将你已有工程中的一部分代码打包成dll使用 小新：“大智，昨天我把以前工程中的部分代码打包成dll了，放到工程里也可以正常运行。下一步是不是就该动态加载这个dll了？”大智：“现在我们打包dll只能叫做封装代码，要想做到动态加载就必须了解C#中的反射的技术。下面我们接着昨天一步一步来~” 2、动态加载逻辑dll 既然是动态加载dll，那就意味着这个dll是在运行时才加载进来。我们平时使用dll时都是直接放到工程中，那么如何动态加载进来呢？ 动态加载dll 我们先将ClassLibrary.dll放到StreamingAssets目录中准备在运行时加载它。 放到StreamingAssets目录中的资产会保持原样，比如代码或dll文件都不会被引擎编译加载。动态加载Dll的基础代码如下： 12345678910111213141516171819using System.IO;using System.Reflection;using UnityEngine;public class HotDllManager : MonoBehaviour&#123; void Start() &#123; var path = Path.Combine(Application.streamingAssetsPath, "ClassLibrary.dll"); var dll = Assembly.LoadFile(path); foreach (var i in dll.GetTypes()) &#123; //调试代码 Debug.Log(i.Name); gameObject.AddComponent(i); &#125; &#125;&#125; 通过log可以看到执行的流程 由于我们的dll中有两个类，一个继承了MonoBehaviour，一个没有继承，所以Class1不能被当作组件添加到GameObject上。 那如何获取dll中特定的类来使用呢？ 1234567891011121314151617using System.IO;using System.Reflection;using UnityEngine;public class SpecDllManager : MonoBehaviour&#123; void Start() &#123; var path = Path.Combine(Application.streamingAssetsPath, "ClassLibrary.dll"); var dll = Assembly.LoadFile(path); // 注意要写类型的全路径 var type = dll.GetType("ClassLibrary.ConfigMgr"); Debug.Log(type.Name); gameObject.AddComponent(type); &#125;&#125; 注意：由于ConfigMgr上面还有命名空间，所以需要写全路径才能去获取这个类型。 不过如果执行这段代码，你会发现有一个报错！ 12NullReferenceException: Object reference not set to an instance of an objectSpecDllManager.Start () (at Assets/Scripts/SpecDllManager.cs:14) 这是怎那么回事呢？明明之前我们已经加载成功了啊！ 如果回到昨天，你会看到我们的ConfigMgr类并没有加public修饰符。GetTypes方法可以获取到所有的类，但是GetType只能获取到公共的类，通过下面的代码可以看出来： 123456789101112131415161718192021222324using System.IO;using System.Reflection;using UnityEngine;public class HotDllManager : MonoBehaviour&#123; void Start() &#123; var path = Path.Combine(Application.streamingAssetsPath, "ClassLibrary.dll"); var dll = Assembly.LoadFile(path); foreach (var i in dll.GetTypes()) &#123; //GetTypes Debug.Log("GetTypes:" + i.Name); &#125; foreach (var i in dll.GetExportedTypes()) &#123; //GetExportedTypes Debug.Log("Exported:" + i.Name); &#125; &#125;&#125; 上面你就能看到导出的公共类只有Class1，如果想要加载ConfigMgr，需要将ConfigMgr的类修饰符改成public。 反射Reflection 在这用一点时间说一说反射。反射指程序可以访问、检测和修改它本身状态或行为的一种能力。 程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。 你可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。 优缺点 优点：1、反射提高了程序的灵活性和扩展性。2、降低耦合性，提高自适应能力。3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。 缺点：1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。 反射（Reflection）的用途 反射（Reflection）有下列用途： 它允许在运行时查看特性（attribute）信息。它允许审查集合中的各种类型，以及实例化这些类型。它允许延迟绑定的方法和属性（property）。它允许在运行时创建新类型，然后使用这些类型执行一些任务。C#中反射的常用方法 首先是加载外部dll的方法，也就是： 12345678910111213// 从文件加载var dll = Assembly.LoadFile(path);// 从字节流加载var dll2 = Assembly.Load(bytes);从dll中加载类型：// 注意要写全路径var type = dll.GetType("Namespace.ClassName");调用类型中的方法：var method = type.GetMethod("MethodName");// 如果为静态方法，第一个可传null，如果为实例方法，应该传实例对象method.Invoke(null, null); 常用的一些反射的方法就是这些，遇到具体的问题可以具体分析。 替换dll，实现热更新 上面我们发现了一个bug，如果是往常的开发模式，我们需要修改源代码，重新编译发布。 但是！现在不用了，即使是在发布后发现了这个问题，我们只需要修改这个dll就可以实现bug的修复。 按照下图修改我们类库中的代码并重新编译发布。 将生成的dll覆盖原来的dll。 虽然我们在这为了简便，是在编辑器中进行操作，但即使发布出来以后也只需要替换dll就可以实现热更新。这时候再运行SpecDllMgr，你就会发现： 大功告成了！ 总结如果想在商业项目中使用这种热更新的方案，一定要记住以下两点： 使用这种方案就和iOS系统无缘了 尽量减少工程和动态dll的耦合性，只通过一个或几个类完成工程中的代码和热更新dll的交互。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过dll实现代码热更新1]]></title>
    <url>%2F2019%2F07%2F16%2F%E9%80%9A%E8%BF%87dll%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E7%83%AD%E6%9B%B4%E6%96%B01%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 通过dll实现代码热更新的优缺点是什么？ 将你已有工程中的一部分代码打包成dll使用 昨天我们提到了几种代码逻辑热更新的方案，其中最简单的是通过dll进行热更新。虽然这种热更新方案不是主流方案，兼容性也无法覆盖所有平台，但是思路及过程还是值得学习的。 通过dll实现代码热更新通过dll实现代码热更新，顾名思义就是将代码打包到dll中，通过动态加载dll，实现代码的热更新。 什么是dll？dll全称是Dynamic Link Library，动态链接库文件。DLL文件中存放的是各类程序的函数(子过程)实现过程，当程序需要调用函数时需要先载入DLL，然后取得函数的地址，最后进行调用。dll是将一些代码进行编译并打包成了一个dll文件。 先说这种方式的局限性：主要就是不支持iOS平台。 但是这种方式的好处是：简单，无需太多额外的学习成本。 这种热更方式的思路其实和其他一些方案也是类似的，而且这过程中可以学习到打包dll、C#的反射的相关知识，所以我们从这个比较简单的热更技术开始学习。 这种热更新的流程一般分为以下几步：1、编写逻辑dll2、动态加载逻辑dll3、读取逻辑dll，执行外部dll中的代码4、替换dll，实现逻辑的热更新 1、编写逻辑dll大多数同学们都是在Unity中写代码，并没有写过单独的dll，今天我们一起来编写一个外部的dll。 创建一个类库工程 打开Visual Studio，新建一个项目，选择： 创建新项目 如果没有这个类库的选项，说明你的Visual Studio没有安装相应的组件，可以看下面这一小节进行安装。 安装Visual Studio相应组件 打开Visual Studio Installder 选择修改 选中.Net桌面开发，右边可选的所有选项可以取消勾选 编写代码 工程创建完成后，你就可以编写C#代码了，这些代码在编译的时候会生成一个dll文件，可以供我们程序进行调用。 12345678910namespace ClassLibrary&#123; public class Class1 &#123; public static string GetName() &#123; return "大智"; &#125; &#125;&#125; 上面就是一段最简单的代码，可以从代码中获取一段名称。 调用Unity API 当然了，通常我们的代码不可能这么简单，通常需要调用Unity的API。比如我们新建一个类，叫ConfigMgr.cs，添加如下代码： 123456namespace ClassLibrary&#123; class ConfigMgr:MonoBehaviour &#123; &#125;&#125; 上面代码里使用到了Unity的API，你会发现有报错： 报错 这是因为平时我们通过Unity打开的VS工程，Unity自动帮我们处理好了相关dll的引用工作，但是如果是我们自己创建的类库需要调用Unity的API，那需要我们自己添加引用Unity的dll。 在引用上右键，添加引用 点击下方的浏览，到对应的路径获取Unity的dll 比如我的路径是：C:\Program Files\Unity\Hub\Editor\2018.3.6f1\Editor\Data\Managed 添加引用dll 最后一步，记得勾选后确定 这时候这样的代码就可以了： 123456789101112using UnityEngine;namespace ClassLibrary&#123; class ConfigMgr:MonoBehaviour &#123; void Start() &#123; Debug.Log("我是外部的dll"); &#125; &#125;&#125; 编译dll 代码写好以后，我们需要将这些代码编译为dll，这个过程也很简单。 点击菜单栏 生成 › 生成解决方案 即可（快捷键F6）。 编译生成 在左下角看到生成成功，那就是dll生成完毕。可以在这个类库工程目录的bin/Debug中找到生成的dll。 生成好的dll 为什么目录中会有一个Debug目录呢？这是因为一般都存在调试模式和发布模式，可以在VS中切换，生产环境中建议使用Release。调试模式和发布模式调试模式和发布模式在工程内使用dll 添加到Unity工程 添加到Unity工程后如上图所示，可以看到Dll文件和一个ConfigMgr类。继承了MonoBehaviour的类会单独显示出来，这样可以将这个类拖到场景中的GameObject上。 将ConfigMgr类拖到场景物体上，运行后在Console的显示 可以显示出Log说明我们已经成功调用了这个dll。 总结大智：“今天我们学习了dll打包的过程，dll打包虽然我们是第一次接触，但是会经常遇到，还有很多应用的场景。” 将一些经常复用的类打包成dll，方便在不同项目间共享打包成dll后，无法直接看到源码，可以一定程度地保护代码（反编译还是可以看到大部分代码）如果需要更好地保护代码，可以学习一下代码混淆的知识（这样虽然还是可以被反编译，但是反编译后的各种类名、变量名都是无意义的符号，拿到的代码几乎没有价值）]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是热更新？]]></title>
    <url>%2F2019%2F07%2F16%2F%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 回想一下你玩过的游戏，哪些用到了热更新技术？带来了什么好处？ 为什么Unity热更新这个词不是传统意义上真正的热更新？ 有没有热更新对用户体验有什么区别？ 热更新分为哪两类？ 如果把项目发布出来，发现有个BUG，修改了一行代码就得重新发布一遍么？ 是的，因为代码需要编译。 那有没有什么办法可以不重新发布，就能修改程序呢？ 复习一下之前所学的内容，如果程序中的内容通过配置文件配置，是不是就不用修改代码就可以完成对程序行为的控制呢？ 还真是。不过这些配置也是需要提前设计的，就没有比较通用的办法么？ 当然也有了，这个就涉及到比较大的话题热更新了。 热更新什么是热更新呢？ 热更新，是对hot update 或者hot fix的翻译，计算机术语，表示在不停机的前提下对系统进行更改。 更新大家应该都能明白，就是对原有的程序进行修复或升级。 那“热”是什么含义呢？ hot就是热，机器运行会发烫，hot就是不停机的意思。 热更新，是个很形象的词，机器烫的时候更新，开着更新。 比如Windows 不重启的前提下安装补丁 比如Http服务器在不重启的前提下换掉一个文件 那么对于Unity3D来说，何谓热更新？ 额……这个真相实在是不想讲出来，因为很多时候，这个词都用错了。 Unity3D是一个客户端工具（热更新一般指服务器后端），用户是否重启客户端，根本是我们不关心的问题。 很多时候我们用着热更新这个词汇，却不需要真的热更新。 只有少部分游戏，游戏资源在玩的过程中边玩边下，不重启的前提下变更了资源。 但更多时候我们不需要用户不重启客户端就能实现资源代码的更新（不需要边玩边下载），我们需要的是用户重启客户端的时候能实现资源代码的更新。 让我们暂时放过这个我们的需求连词汇都用错了这个基本事实，来总结一下何谓Unity3D热更新。 Unity3D热更新一般指：用户重启客户端就能实现客户端资源或代码的更新（无需安装）。 热更新的好处热更新能够缩短用户取得新版客户端的时间，改善用户体验。 没有热更新的时候： pc用户：下载客户端-›等待下载-›安装客户端-›等待安装-›启动-›等待加载-›玩 手机用户：商城下载APP-›等待下载-›等待安装-›启动-›等待加载-›玩 有了热更新以后： pc用户：启动-›等待热更新-›等待加载-›玩 有独立loader的pc用户：启动loader-›等待热更新-›启动游戏-›等待加载-›玩 手机用户：启动-›等待热更新-›等待加载-›玩 通过对比就可以看出，有没有热更新对于用户体验的影响还是挺大的，主要就是省去用户自行更新客户端的步骤。 为了方便用户、留住用户、进而从留住的用户身上赚到钱，热更新如今已经成为了大部分游戏的标配功能。 如果你的游戏不标配这个功能，那么竞争力就会少一些，无论是主动还是被动，无论是方便用户还是被标配，你都必须面对热更新这个课题，虽然这个词用错了。 热更新的分类热更新的内容分为两类：一类是资源内容的更新，一类是代码逻辑的更新。 资源内容的更新资源内容的更新一般是采用assetbundle的形式，将资源独立出来，客户端作为一个容器，资源作为外部的内容独立下载更新。 代码逻辑的更新对于代码，Unity3D是不提供变更机制的（不像资源的更新，提供了Asset Bundle，没有提供什么工具用来更新代码）。但是Unity3D执行核心是Mono，也就是dotnet，dotnet有一种符号反射机制，可以直接加载一个dll，然后反射出其中的类型进行操作。符号和反射的主要问题是有些平台不能使用，比如ios、windows phone。另外dotnet有一种emit（发射）机制，可以运行时调用编译器对代码进行编译，它的问题也是平台不支持。 那么对于占据半壁江山的iOS平台，有没有解决方案能覆盖主流平台呢？ 目前较为主流的方案有两种： Unity + Lua：代表作有xLua、uLua、sLua等 Unity + C#：代表作有ILRuntime、cshotfix等 总结今天我们主要了解了一下什么是热更新，后面我们会逐步学习热更新方案的演进过程以及目前最主流的热更新技术xLua。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#基础]]></title>
    <url>%2F2019%2F07%2F15%2FC-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： .Net的本质是个软件怎么理解？ 电脑上的.Net Framework是怎么来的？安装在什么位置？ Mono是什么？ Unity是基于.Net什么版本的？ .sln和.csproj分别是什么意思？ C#的数组存在什么问题？是如何解决的？ C#是为Unity服务的，C#学的再好Unity学不好没多大意义。 C#基础.Net的本质其实是一个运行在操作系统上的软件。一般所说的.Net指的是.Net Framework框架。 安装路径：C:\Windows\Microsoft.NET mono是一个开源跨平台的.net运行环境。Mono也是一个软件。https://download.mono-project.com/archive/5.20.1/windows-installer/mono-5.20.1.19-x64-0.msi C#通过.Net平台开发的应用程序，能不能运行在某个计算机上面，取决于该计算机是否安装了对应版本的.Net Framework框架。 基于.Net Framework3.0开发的程序如果只使用了.Net Framework2.0的功能，也可以运行在.Net Framework2.0环境下。 Unity是基于.Net Framework3.5的。 VS解决方案和项目一个解决方案可以有多个项目 启动项目是粗体，可以右键“设为启动项目”，运行的时候就执行此项目。 解决方案（.sln）文件其实是一个文本文件，这个文件记录着解决方案管理的项目（项目名称与路径）。 项目文件(.csproj)，也是一个文本文件，这个记录了项目里面的资源。 注意：在VS里面，项目移除可以重新加载，项目里的资源被移除则是永久删除。 快捷注释注释：先CTRL+K，然后CTRL+C。 取消注释： 先CTRL+K，然后CTRL+U。 .Net编译原理Main函数是程序的入口，也是程序的出口。 Net平台的重要组成部分 一、 重要组成部分： 1、FCL: 框架类库 我们在编程的时候，经常会用到一些功能，微软事先把这些功能写好（比如像控制台输出信息（例如Console.WriteLine()），产生一个随机数），封装在一个一个的类里面，然后把这些类放在.Net平台中，这些类的集合，我们就叫做框架类库（可以看做是功能的集合）。我们可以用各自的语法来调用 2、CLR：公共语言运行时 它是.Net程序运行的必备环境如果.Net程序要在系统上运行，那么系统上面必须安装CLR注意：CLR是无法单独安装的，它集成在.Net框架里面，将.Net框架安装在系统上，系统里面就有了CLR和FCL 二、如何获取.Net程序的可运行文件 这个文件能不能在电脑上运行，取决于电脑是否安装了对应的.Net框架 Net程序的编译原理1、C#源代码通过C#编译器，编译成程序集，程序集里面包含微软中间语言（MSIL） 2、运行程序集的时候，CLR中的即时编译器（JIT,Just In Time）会将微软中间语言转换为本地平台对应的二进制指令，然后交给CPU去运行 C#编译器也是由.Net框架提供的。 CLR在运行时管理程序的执行，包括以下内容： 内存管理和垃圾收集（C和C++是自己操作内存，内存泄漏时，需要自己检查内存泄漏，但C#通过CLR完成） 代码安全验证 代码执行、线程管理及异常处理 托管代码和非托管代码 从 .NET Framework 4 开始，所有 .NET Framework 版本都是就地更新的，因此，在系统中只能存在一个 4.x 版本。 此外，某些版本的 Windows 操作系统上预装了特定版本的 .NET Framework。 这表示：如果在计算机上已安装了更高的 4.x 版本，则无法安装以前的 4.x 版本。如果操作系统预安装了特定的 .NET Framework 版本，则无法在同一计算机上安装以前的 4.x 版本。如果你安装更高版本，则无需先卸载以前的版本。 .NET Framework 是软件开发平台（框架），C#是.NET框架中支持的其中一种语言。C#语言的运行载体是.NET框架。 C#源文件要经过C#编译器编译成托管程序集元数据，就是exe程序或者dll库。 然后由.NET Framework编译器编译成机器代码，被操作系统识别。 C#是跟随.NET的开发工具Visual Studio一起发布的，在安装Visual Studio时是把.NET Framework框架一并安装的，所以C#的版本是跟随.NET Framework的，换句话说C#语言本身没有单独版本之说，和.NET框架版本同步。 在同一台机器上可以同时存在不同版本的.NET Framework，互不干扰，正常运作。 微软产品的特性：高版本兼容低版本，向下兼容。 c# 跟.net Framework不是一个概念。另外我们通常说的版本都是指.net framework的版本。 不过c#语言本身也有版本之分。 像PHP一样，PHP7比5是语法上有提升，然后解释器不一样。C#的版本是和VS绑定的。VS就是个解释器，也会识别新语法。 C# 7.02017 年 3 月随 Visual Studio 2017 和 .NET Framework 4.7 发布C# 6.02015 年 7 月随 Visual Studio 2015 和 .NET Framework 4.6 发布C# 5.02012 年 8 月随 Visual Studio 2012 和 .NET Framework 4.5 发布C# 4.02010 年 4 月随 Visual Studio 2010 和 .NET Framework 4.0 发布C# 3.02007 年 11 月随 Visual Studio 2008 和 .NET Framework 3.5 发布 语法int a = 100;a++和++a对于a来说都是一样的值，都是101 int b = a++ 和 int b = ++a对于b是不一样的。前者是先返回再加，后者是先加后返回。所以b分别是100和101 byte范围为0-255short范围为-32768-32767byte类型相加，结果为intshort类型相加，结果为int int=byte+byteint=short+shortint=short+byte byte与short相互参与运算，运算的结果为int类型。为什么？因为byte和short的存储范围比较小，byte与short相互参与运算的时候经常超出范围，所以微软规定，结果都为int类型。 关于范围：整型的数据范围比较：long&gt;int&gt;short&gt;byte浮点类型的范围一定比整型大浮点型的数据范围比较：double&gt;float&gt;decimal(精度与范围无关，精度比较decimal&gt;double&gt;float )3、string类型无法参与算术运算，只能进行字符串拼接4、参与算术表达式的类型只能是数值类型和char类型5、char类型参与运算的时候，会转换成ASCII码（在线转换的链接： https://www.qqxiuzi.cn/bianma/ascii.htm）6、decimal不能与其他浮点类型的变量进行运算，因为会丢失精度 int是个类型，像new Class1一样int[] arr1 = new int[8];int[] arr2 = new int[] { 1, 2, 3 };int[] arr3 = { 5, 6, 7, 8, 9 }; 数组的三种写法，遇到这种写法多的时候就确定用一或两种。第三种是对第二种的简化，所以就使用1，3就行。看第一种new int，就知道int是个类。然后和Class1，Delegate一样的。 C#数组存在的问题是长度固定。 硬件硬盘的读写效率取决于磁盘的转速。买硬盘的衡量标准在于容量和转速。为什么内存比硬盘快？内存的数据存储在电子元件里面，直接读取与写入，效率比硬盘高。为什么系统装在C盘？ 垃圾收集1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Collections;using System.Collections.Generic;namespace Test&#123; //垃圾回收 //CLR只回收栈里面的内存 //垃圾回收是回收堆里面的内存 //垃圾回收是定期启动的，但是具体什么时间回收没办法确定 //如果确定垃圾很多，那么可以手动调用垃圾回收 //注意：垃圾回收是很耗费性能的，所以不能频繁的调用 class Program &#123; static void Main(string[] args) &#123; //Tool tl = new Tool(); //tl = null; ////手动调用垃圾回收 //GC.Collect(); //装箱与拆箱 //装箱：把任意的变量的值赋值给object类型的变量 int num = 100; object obj = num; //拆箱：把object类型的变量转化为对应类型的变量 int theNum = (int)obj; string str = "www"; object objStr = str; int strNum = (int)objStr; ArrayList list = new ArrayList(); list.Add("www"); list.Add(true); list.Add(55); object count= list[0]; //int s = (int)count;//报错 &#125; &#125;&#125; 委托委托作为传参 多播委托需要连续调用。 隐藏了 委托赋值的过程]]></content>
  </entry>
  <entry>
    <title><![CDATA[第14章-对付空间限制]]></title>
    <url>%2F2019%2F07%2F15%2F%E7%AC%AC14%E7%AB%A0-%E5%AF%B9%E4%BB%98%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是空间复杂度？ 本书至此，在分析各种算法的效率时，我们只关注了它们的时间复杂度。换句话说，就是它们运行得有多快。但有些时候，我们还得以另一种名为空间复杂度的度量方式，去估计它们会消耗多少内存。 当内存有限时，空间复杂度便会成为选择算法的一个重要的参考因素。比如说，在给小内存的小型设备写程序时，或是处理一些会迅速占满大内存的大数据时都会考虑空间复杂度。 既省时又省内存的算法当然是最理想的。但有些情况下我们却只能二者选其一，这时要想做出正确选择，就得仔细分析了。 描述空间复杂度的大O记法有趣的是，计算机科学家还是用描述时间复杂度的大O记法来描述空间复杂度。 至今我们一直这样用大O记法来描述一个算法的速度：当所处理的数据有N个元素时，该算法所需的步数相对于元素数量是多少。例如，O(N)算法就是处理N个元素需要N步的算法。 O(N2)算法就是处理N个元素需要N2步的算法。 类似地，我们也可以用大O来描述一个算法需要多少空间：当所处理的数据有N个元素时，该算法还需额外消耗多少元素大小的内存空间。让我们看一个简单的例子。 假设要写一个JavaScript函数，它接收一个字符串数组，并返回一个含有那些字符串的大写形式的数组。如果接收的数组是[“amy”, “bob”, “cindy”, “derek”] ，那么返回的就是[“AMY”, “BOB”, “CINDY”, “DEREK”] 。以下是该函数的一种写法。 123456789function makeUpperCase(array) &#123; var newArray = []; for(var i = 0; i &lt; array.length; i++) &#123; newArray[i] = array[i].toUpperCase(); &#125; return newArray;&#125; makeUpperCase函数接收一个数组作为参数array。然后它创建了一个全新的数组，名为newArray，并将原数组array里的字符串的大写形式填进去。 等到该函数结束的时候，内存里会存在两个数组，一个是array ，它里面是[“amy”, “bob”,”cindy”, “derek”]；另一个是newArray ，它里面是[“AMY”, “BOB”, “CINDY”, “DEREK”] 。 分析该函数的话，你会发现它接收一个N元素的数组，就会产生另一个新的N元素数组。 因此，我们会说这个makeUpperCase函数的空间效率是O(N)。 这种复杂度的图应该很熟悉了。 注意它的画法跟前面章节的O(N)是一样的，只是这次的纵坐标不是代表速度，而是代表内存。 我们再写一个更高效利用内存的makeUpperCase。 12345678function makeUpperCase(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; array[i] = array[i].toUpperCase(); &#125; return array;&#125; 在这第二个版本里，我们没有创建任何新的变量或新的数组，也确实没有消耗额外的内存空间。我们只是变动了原array里的每个字符串，将它们逐一换成大写。最后返回这个修改过的array。 因为该函数并不消耗额外的内存空间，所以我们把它的空间复杂度描述为O(1)。记住，时间复杂度的O(1)意味着一个算法无论处理多少数据，其速度恒定。相似地，空间复杂度的O(1)则意味着一个算法无论处理多少数据，其消耗的内存恒定。 刚才的例子中，无论传入的array包含4个元素还是100个元素，该算法所需的额外的空间都一样（为零）。因此，我们认为新版的makeUpperCase的空间效率是O(1)。 值得一再强调的是，空间复杂度是根据额外需要的内存空间（也叫辅助空间）来算的，也就是说原本的数据不纳入计算。尽管在第二个版本里我们有array这一入参，占用了N个元素的空间，但除此之外它并没有消耗额外的内存，所以它是O(1)。 （有些参考书在计算空间复杂度时是连原始输入也一起算的，那没问题。但此处我们不计算它，当你在其他地方看到某一算法的空间复杂度的描述时，最好留意一下它是否计算原始输入。） 我们比较一下makeUpperCase两个版本的时间复杂度和空间复杂度。 ** 版 本 ** ** 时间复杂度 ** ** 空间复杂度 ** 1 O(N) O(N) 2 O(N) O(1) 因为N项数据要花N步去处理，所以两个版本的时间复杂度都是O(N)。然而在空间复杂度方面，第二个版本只有O(1)，与第一个版本的O(N)相比，它对内存的使用效率更高。 因此选择第二个版本更为合理。 时间和空间之间的权衡第4章我们写了一个用于检查数组是否含有重复值的JavaScript函数。它的第一版是这样的： 1234567891011121314function hasDuplicateValue(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; for(var j = 0; j &lt; array.length; j++) &#123; if(i !== j &amp;&amp; array[i] == array[j]) &#123; return true; &#125; &#125; &#125; return false;&#125; 它用了嵌套循环，时间复杂度为O(N2)。 后来我们又写了一版效率更高的，如下所示。 12345678910111213141516function hasDuplicateValue(array) &#123; var existingNumbers = []; for(var i = 0; i &lt; array.length; i++) &#123; if(existingNumbers[array[i]] === undefined) &#123; existingNumbers[array[i]] = 1; &#125; else &#123; return true; &#125; &#125; return false;&#125; 该版本会创建一个名为existingNumbers的数组，然后以array遇到的每个数字为索引，到existingNumbers那里找到相应的格子填个 1。如果相应的格子里已被填了1，则可知该数字已经存在，证明有重复值。 因为与第一版的O(N2)相比，它的时间复杂度只有O(N)，所以我们宣称它胜过第一版。确实，单从时间角度考虑的话，第二版是更快的。 但要是把空间也考虑进去的话，你会发现它与第一版相比有一缺点。第一版除了原数组，并不会消耗额外的内存，因此它的空间复杂度为 O(1)。第二版却要创建一个与原数组大小相等的全新数组，因此它的空间复杂度为 O(N)。 ①我们来给两个版本的 hasDuplicateValue 做个全面的对比。 版 本 时间复杂度 空间复杂度1 O(N 2 ) O(1)2 O(N) O(N) 可见第一版所用的内存更少，但跑得更慢，第二版虽跑得快但用的内存更多。那要怎么决定该用哪个呢？ 答案当然是看情况。如果你想要程序跑得超级快，而且你的内存十分充足，那么用第二版会比较好。但如果你不看重速度，而且你的程序是跑在需要谨慎使用内存的嵌入式系统上，那你应该选择第一版。所有技术讨论都是这样的，当需要做出取舍时，你应从全局看待问题。 写在最后的话通过这次学习之旅，你已掌握了很多知识，其中最重要的是，你懂得了数据结构和算法的分析，这对代码的速度、内存占用，甚至其可读性都有着重大影响。 在此书中你收获了一套思路清晰的技术分析框架。你明白了计算包含各种细节，尽管大O之类的理论会建议你哪种做法更好，但若考虑其他因素，你可能会做出不同的选择。机器对内存的管理方式和编程语言的底层实现都会影响程序的性能，甚至有时你以为是最高效的做法也可能会随着外部环境的变化而变得低效。 因此，你最好时刻配备性能测试工具来验证你的调优是否有效。测量代码速度和内存消耗的优秀工具有很多。本书的知识只告诉你调优的方向，而测试工具会负责检验你调优的具体实现是否正确。 我希望你能通过本书明白一个道理：很多看似复杂、深奥的事物，其实都是由你所掌握的简单概念构筑而成的。不要因为某些资料没解释到位，就以为它很困难而被吓退，你一定能找到更详尽的解释资料。 数据结构和算法博大精深，本书所述仅为皮毛而已。尽管需要学习的东西还有很多，但有了目前的基础，你学下去是没问题的。祝你好运！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第13章-连接万物的图]]></title>
    <url>%2F2019%2F07%2F14%2F%E7%AC%AC13%E7%AB%A0-%E8%BF%9E%E6%8E%A5%E4%B8%87%E7%89%A9%E7%9A%84%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是图？怎么实现图？ 什么是顶点？什么是边？怎么才叫相邻？ 什么是有向图？什么是无向图？ 什么是二度联系人？ 什么是广度优先搜索？ 什么是加权图？ 本章涵盖： 1.图 2.广度优先搜索 3.图数据库 4.加权图 5.Dijkstra算法 假设我们正在打造一个像Facebook那样的社交网络。在该应用里，大家可以加别人为“朋友”。这种朋友关系是相互的，如果Alice是Bob的朋友，那么Bob也会是Alice的朋友。 这些关系数据要怎么管理才好呢？ 一种简单的方法是，以二维数组来保存每一对关系。 123456789relationships = [ ["Alice", "Bob"], ["Bob", "Cynthia"], ["Alice", "Diana"], ["Bob", "Diana"], ["Elise", "Fred"], ["Diana", "Fred"], ["Fred", "Alice"]] 不幸的是，这样无法快速地知道Alice的朋友是哪些人。你只能在数组里按逐对关系检查，看Alice在不在那对关系中。在检查过程中，你还得创建一个列表来暂存查出的朋友（此例中有Bob、Diana和Fred）。 由于数据以这种结构存储，若想查找Alice的朋友就得检查数据库中的所有关系，需要O(N)的时间复杂度。 其实有一种更好的存储方法。使用图这种数据结构的话，我们可以在O(1)时间内找出Alice的所有朋友。 图图是一种善于处理关系型数据的数据结构，使用它可以很轻松地表示数据之间是如何关联的。 下图是我们的Facebook网络。 每个人都是一个结点，人与人之间的朋友关系则以线段表示。按照图的术语来说，每个结点都是一个顶点，每条线段都是一条边。当两个顶点通过一条边联系在一起时，我们会说这两个顶点是相邻的。 图的实现形式有很多，最简单的方法之一就是用散列表（参见第7章）。例如，使用Ruby散列表来实现一个极为基础的社交网络。 12345678friends = &#123; "Alice" =&gt; ["Bob", "Diana", "Fred"], "Bob" =&gt; ["Alice", "Cynthia", "Diana"], "Cynthia" =&gt; ["Bob"], "Diana" =&gt; ["Alice", "Bob", "Fred"], "Elise" =&gt; ["Fred"], "Fred" =&gt; ["Alice", "Diana", "Elise"]&#125; 因为从散列表里查找一个键所对应的值只需要1步，所以查找Alice的朋友能以O(1)的时间复杂度完成，如下所示。 1friends["Alice"] 跟Facebook不同，Twitter里面的关系不是相互的。Alice可以关注Bob，但Bob不一定要关注Alice。让我们构造一个新的图来表示谁关注了谁。 图中箭头表示了关系的方向。Alice关注了Bob和Cynthia，但没有人关注Alice。Bob和Cynthia互相关注。 用散列表来表示的话，就是这样： 12345followees = &#123; "Alice" =&gt; ["Bob", "Cynthia"], "Bob" =&gt; ["Cynthia"], "Cynthia" =&gt; ["Bob"]&#125; 虽然Facebook跟Twitter的例子很相似，但它们本质上是不一样的。Twitter中的关系是单向的，我们也在图中用箭头表示了其方向，因此它的图是有向图。Facebook中的关系则是相互的，我们只画成了普通的线段，它的图是无向图。 尽管只用散列表也可以实现一个图，但是以面向对象的方法来写会更加健壮。 以下便是一种更为健壮的实现方式，它采用的语言是Ruby。 123456789101112class Person attr_accessor :name, :friends def initialize(name) @name = name @friends = [] end def add_friend(friend) @friends &lt;&lt; friend endend 有了这个 Ruby类，我们就可以创建人物并且给他们添加朋友了。 1234mary = Person.new("Mary")peter = Person.new("Peter")mary.add_friend(peter)peter.add_friend(mary) 广度优先搜索LinkedIn也是一个流行的社交网络，其专注于职业社交。LinkedIn的一个有名的功能就是，你除了能够看到自己直接添加的联系人，还可以发掘你的二度、三度联系人。 如图所示，Alice能直接联系到Bob，Bob能直接联系到Cynthia。但Alice无法直接联系到Cynthia。由于她们之间的联系要经过Bob，因此Cynthia是Alice的二度联系人。 如果我们想查看Alice的整个关系网，包括她那些间接的关系，需要怎么做呢？ 图有两种经典的遍历方式：广度优先搜索和深度优先搜索。在此我们会研究广度优先搜索，深度优先搜索你可以自己去学习。两者是相似的，并且在大多数情况下都一样好用。 广度优先搜索算法需要用队列（参见第8章）来记录后续要处理哪些顶点。该队列最初只含有起步的顶点（对本例来说，就是Alice）。于是算法一开始，我们的队列如下所示。 [Alice] 然后处理Alice顶点。我们将其移出队列，标为“已访问”，并记为当前顶点。（很快我们就会走一遍整个流程，让你看得更明白一些。） 接着按照以下3步去做。 (1)找出当前顶点的所有邻接点。如果有哪个是没访问过的，就把它标为“已访问”，并且将它入队。（尽管该顶点并未作为“当前顶点”被访问过。） (2) 如果当前顶点没有未访问的邻接点，且队列不为空，那就再从队列中移出一个顶点作为当前顶点。 (3) 如果当前顶点没有未访问的邻接点，且队列里也没有其他顶点，那么算法完成。 下面来实际演示一遍。Alice的LinkedIn关系网如下图所示。 首先，将Alice设为当前顶点。为了在图中表示她是当前顶点，我们用线段将其围绕。为了表示Alice已被访问，我们在她旁边打了个钩。继续该算法，找出一个未访问的邻接点--本例中的Bob，在他名字旁边打个钩，如下图所示。 我们也将Bob入队，使队列变为[Bob]。这意味着Bob未曾作为当前顶点。注意，虽然当前顶点是Alice，但我们也能访问Bob。 接着，检查当前顶点Alice是否还有未访问的邻接点。发现有Candy，于是将其标为已访问。 现在队列为[Bob, Candy] 。 Alice还有邻接点Derek没访问过，于是访问他。 现在队列为[Bob, Candy, Derek] 。 Alice还有一个未访问的关系Elaine，于是我们也要访问她。 现在队列为[Bob, Candy, Derek, Elaine] 。 因为Alice已经没有未访问的邻接点了，所以执行本算法的第2条规则，从队列里移出一个顶点，把它设为当前顶点。回想第8章提到的，队列只能在队头移除数据，于是现在要移出的就是Bob。 现在队列变为[Candy, Derek, Elaine]，Bob成为了当前顶点。 然后回到第1条规则，找出当前顶点的所有未访问的邻接点。Bob有一个邻接点Fred，于是将他标记为已访问，并把他加入队列。 现在队列为[Candy, Derek, Elaine, Fred]。 因为Bob没有其他未访问的邻接点了，所以出队一个顶点--Candy--作为当前顶点。 然而Candy没有未访问的邻接点。于是再从队列中拿出一个顶点--Derek--使得队列变成[Elaine, Fred]。 Derek有一个未访问的邻接点Gina，我们将其标记为已访问。 现在队列为[Elaine, Fred, Gina]。 Derek没有邻接点需要访问了，于是我们从队列里拿出Elaine，将她标记为当前顶点。 Elaine没有未访问的邻接点，于是从队列中拿出Fred。 此时队列变为[Gina]。 Fred有一个联系人要访问--Helen--于是将其标为已访问，并且入队，使队列变成[Gina, Helen]。 Fred已经没有未访问的关系了，所以我们将Gina移出队列，将她设为当前顶点。 现在队列里只剩[Helen]了。 Gina有一个邻接点要访问--Irena。 现在队列为[Helen, Irena]。 Gina没有其他关系需要访问了，所以让Helen出队，将她设为当前顶点，于是队列里剩下的是[Irena]。Helen没有什么人需要访问，于是我们让Irena出队，将她设为当前顶点。因为Irena没有顶点需要访问，而且队列空了，所以算法结束！ 我们在Person类里加上display_network方法，以广度优先搜索的方式展示一个人的关系网里所有的名字。 123456789101112131415161718192021222324252627282930313233343536373839class Person attr_accessor :name, :friends, :visited def initialize(name) @name = name @friends = [] @visited = false end def add_friend(friend) @friends &lt;&lt; friend end def display_network # 记下每个访问过的人，以便算法完结后能重置他们的 visited 属性为 false to_reset = [self] # 创建一个开始就含有根顶点的队列 queue = [self] self.visited = true while queue.any? # 设出队的顶点为当前顶点 current_vertex = queue.shift puts current_vertex.name # 将当前顶点的所有未访问的邻接点加入队列 current_vertex.friends.each do |friend| if !friend.visited to_reset &lt;&lt; friend queue &lt;&lt; friend friend.visited = true end end end # 算法完结时，将访问过的结点的 visited 属性重置为 false to_reset.each do |node| node.visited = false end endend 为了使它运作起来，我们还给Person类增加了visited属性，来记录一个人在本次搜索中是否已被访问。 将算法的步骤分为两类之后，我们可以看出图的广度优先搜索的效率。 让顶点出队，将其设为当前顶点。 访问每个顶点的邻接点。 这样看来，每个顶点都会有一次出队的经历。以大O记法表示，就是O(V)，意思是有V个顶点，就有V次出队。 既然要处理N个顶点，不应该表示为O(N)吗？不是的，因为在此算法（以及很多其他图的算法）中，除了处理顶点本身，还得处理边，下面就来解释。 我们观察一下访问邻接点需要多少步。 以当前顶点为Bob的时候为例。 此时我们会运行如下代码。 123456current_vertex.friends.each do |friend| if !friend.visited queue &lt;&lt; friend friend.visited = true endend 就是说，我们会访问Bob所有的邻接点，其中不但有Fred，还有Alice！尽管她曾被访问过，不用再入队，但访问她还是增加了一次each循环。 要是你再认真地运行一遍整个广度优先搜索的流程，你会发现访问邻接点所用的步数，是图中边数的两倍。因为一条边连接着两个顶点，对于每个顶点，我们都要访问其所有邻接点。所以每条边都会被使用两次。 因此，有E条边，就会有2E步来访问邻接点，即每对邻接点都会被访问两次。不过由于大O忽略常数，所以只写作O(E)。 因为广度优先搜索有O(V)次出队，还有O(E)次访问，所以我们说它的效率为O(V + E)。 图数据库因为图擅长处理关系信息，所以有些数据库就以图的形式来存储数据。传统的关系型数据库（以行和列的形式保存数据的数据库）也能存储这类信息，我们不妨比较一下它们处理社交网络之类的数据时的表现。 假设有一个5人的社交网络，分别是Alice、Bob、Cindy、Dennis和Ethel，他们互相都有联系。保存他们个人信息的图数据库大概会如下图所示。 这种信息也可以用关系型数据库来存储。那得需要两张表--一张保存个人信息，另一张保存朋友关系。以下是Users表。 另一张Friendships表记录着谁是谁的朋友。 我们不会太过深入地研究数据库理论，但你得知道在Friendships表中只需以用户id来指代用户。 如果这个社交网络允许用户查看其朋友的全部信息，而Cindy也正要这么做，那意味着她想看到一切关于Alice、Bob、Dennis和Ethel的信息，包括他们的邮件地址和电话号码。 那我们就来看看以关系型数据库为后端的应用会怎样执行她的请求。首先，我们得找出User表中Cindy的id。 然后，找出Friendships表中所有user_id为3的行。 我们就得到了Cindy朋友的id列表：[1, 2, 4, 5]。 有了id列表之后，我们还得回Users表找出这些id对应的行。计算机从Users表查找一行的速度大概是O(log N)。因为数据库中的行会按照id的顺序来维护，所以我们可以用二分查找来找出id对应的行。（以上解释只适用于部分关系型数据库，其他关系型数据库可能有不同做法。） Cindy有4个朋友，所以计算机需要做4次O(log N)查询才能提取出她全部朋友的个人信息。推广开来，若有M个朋友，那么提取他们个人信息的效率就为O(M log N)。换句话说，对于每个朋友，都要执行一次步数为log N的搜索。 相比之下，后端为图数据库时，一旦在数据库中定位到Cindy，那么只需一步就能查到她任一朋友的信息。因为数据库中的每个顶点已经包含了该用户的所有信息，所以你只需遍历那些连接Cindy与朋友的边即可。如下图所示，总共也就4步。 用图数据库的话，有N个朋友就需要O(N)步去获取他们的数据。与关系型数据库的O(M log N)相比，确实是极大的效率提升。 Neo4j是开源的图数据库中比较受欢迎的一个。我建议你上它的官网去了解更多关于图数据库的知识。其他开源的图数据库还有ArangoDB和Apache Giraph。 但记住，图数据库也并不总是最好的解决方案。你得谨慎地评估每个应用场景的需求再做选择。 加权图还有一种图叫作加权图。它跟普通的图类似，但边上带有信息。 以下这个包含了美国几个主要城市的简陋地图，就是一个加权图。 此图中，每条边上都有一个数字，它表示那条边所连接的两个城市相距多少英里。例如，Chicago和New York City之间的距离为714英里。 加权图可以是有方向的。以下图为例，尽管从Dallas飞到Toronto只要138美元，但从Toronto飞到Dallas要216美元。 要往图里加上权重，得稍微更改一下我们的Ruby代码。具体来说，我们要把表示邻接点的数组换成散列表。对于上图来说，一个顶点就是一个City类的对象。 12345678910111213class City attr_accessor :name, :routes def initialize(name) @name = name # 把表示邻接点的数组换成散列表 @routes = &#123;&#125; end def add_route(city, price) @routes[city] = price endend 这样就可以创建城市和不同价格的航线了。 1234dallas = City.new("Dallas")toronto = City.new("Toronto")dallas.add_route(toronto, 138)toronto.add_route(dallas, 216) 我们可以借助加权图来解决最短路径问题。 下图展示了5个城市之间的航线价格。 假设我目前身在Atlanta，想飞去El Paso。不幸的是，现在没有直达航班。然而，我也可以在其他城市转机过去。例如，先从Atlanta到Denver，再从Denver到El Paso。这会花费300美元。但再看仔细一点，你会发现从Atlanta沿Denver、Chicago再到ElPaso会更加便宜。虽然多转一次，但只需花280美元。 这就是一种最短路径问题：如何以最低的价钱从Atlanta飞往El Paso。 Dijkstra算法解决最短路径问题的算法有好几种，其中一种有趣的算法是由Edsger Dijkstra于1959年发现的。该算法也很自然地被称为Dijkstra算法。 Dijkstra算法的规则如下（别担心，之后我们跟着例子运行一遍就会更明白了）。 (1)以起步的顶点为当前顶点。 (2)检查当前顶点的所有邻接点，计算起点到所有已知顶点的权重，并记录下来。 (3)从未访问过（未曾作为当前顶点）的邻接点中，选取一个起点能到达的总权重最小的顶点，作为下一个当前顶点。 (4)重复前3步，直至图中所有顶点都被访问过。 下面来一步步地运行一遍整个算法。 我们用以下表格来记录Atlanta到其他城市最便宜的价格。 首先，以起步顶点（Atlanta）作为当前顶点。此时我们能访问的就是当前顶点以及其邻接点。为指明哪个点是当前顶点，我们以线段将其围绕。为指明哪些点曾作为当前顶点，我们给它们打上钩。 接着检查所有邻接点，记下从起点（Atlanta）到所有已知地点的权重。可见从Atlanta到 Boston是100美元，从Atlanta到Denver是160美元，于是记录到表格里。 接着从Atlanta可到达但又未访问过的顶点中，找出最便宜的那个。就目前所知，从Atlanta出发可以到达Boston和Denver，并且Boston（100美元）比Denver（160美元）更便宜。因此，选择Boston作为当前顶点。 然后检查从Boston出发的航线，更新从起点Atlanta到所有已知地点的花费。我们看到Boston到Chicago是120美元。Atlanta到Boston是100美元，Boston到Chicago是120美元，所以从Atlanta到Chicago最便宜的（而且是目前唯一的）路线要220美元。我们把它记在表里。 再看看从Boston出发的另一条航线--Denver--要180美元。于是我们又发现了一条从Atlanta到Denver的路线：Atlanta到Boston再到Denver。不过这条路线要280美元，而Atlanta直飞Denver才160美元，所以无须更新价格表，毕竟我们只想记录最便宜的路线。 既然从当前顶点（Boston）出发的航线都已探索过了，就得找下一个从起点Atlanta 所能到达的最便宜的未访点了。根据表格来看，最便宜的还是Boston，但它已经打过钩了。这样最便宜的未访问城市应该是Denver了，因为与220美元的Chicago相比，它只要160美元。于是Denver变成了当前顶点。 那么我们就来观察由Denver出发的航线，其中一条从Denver到Chicago的航线是40美元。 于是我们可以更新Atlanta到Chicago的最低价格了。因为现在的价格表里Atlanta到Chicago要220美元，但若经Denver转机，则只需200美元。所以更新一下表格。 从Denver飞出的航班还有一个，它的目的地是El Paso。我们要计算Atlanta到El Paso的最低价格，目前只能从Atlanta到 Denver再到El Paso，共300美元。将价钱记下。 现在还没访问的顶点有两个：Chicago和El Paso。Atlanta到Chicago的最低价（200美元）比Atlanta到El Paso的最低价（300美元）要低，所以下一步选择Chicago作为当前顶点。 Chicago只有一个出发航班：80美元到El Paso。于是Atlanta到El Paso路线的最低价格得以更新：从Atlanta到Denver，再到Chicago，最后抵达El Paso，总共花费280美元。我们把它记下。 最后只剩一个城市可作为当前顶点了，那就是El Paso。 El Paso只有一个出发航班：100美元飞到Boston。这并没刷新Atlanta到其他地方的最低价，所以我们无须更新价格表。 现在所有顶点都访问过了，这就意味着Atlanta到其他城市的所有路径都已发掘。于是算法结束，我们也可以从价格表得知从Atlanta到地图上任一城市的最低价格了。 以下是Dijkstra算法的Ruby实现。 我们先创建一个代表城市的Ruby类。一个城市就是图上的一个结点，它记有自己的名字以及可到达的城市。 123456789101112131415class City attr_accessor :name, :routes def initialize(name) @name = name # 把表示邻接点的数组换成散列表 @routes = &#123;&#125; # 如果此城市是 Atlanta，则散列表应包含： # &#123;boston =&gt; 100, denver =&gt; 160&#125; end def add_route(city, price_info) @routes[city] = price_info endend 然后用add_route来建立城市间的航线。 123456789101112atlanta = City.new("Atlanta")boston = City.new("Boston")chicago = City.new("Chicago")denver = City.new("Denver")el_paso = City.new("El Paso")atlanta.add_route(boston, 100)atlanta.add_route(denver, 160)boston.add_route(chicago, 120)boston.add_route(denver, 180)chicago.add_route(el_paso, 80)denver.add_route(chicago, 40)denver.add_route(el_paso, 140) Dijkstra算法的代码是有点复杂的，所以我在每一步都做了注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def dijkstra(starting_city, other_cities) # 散列表 routes_from_city 用来保存从给定城市到其他所有城市的价格 # 以及途经的城市 routes_from_city = &#123;&#125; # 它的格式如下： # &#123;终点城市 =&gt; [价格, 到达终点城市前所要经过的那个城市]&#125; # 以上图为例，此散列表最后会是： # &#123;atlanta =&gt; [0, nil], boston =&gt; [100, atlanta], chicago =&gt; [200, denver], # denver =&gt; [160, atlanta], el_paso =&gt; [280, chicago]&#125; # 从起点城市到起点城市是免费的 routes_from_city[starting_city] = [0, staring_city] # 初始化该散列表时，因为去往所有其他城市的花费都未知，所以先设为无限 other_cities.each do |city| routes_from_city[city] = [Float::INFINITY, nil] end # 以上图为例，此散列表起初会是： # &#123;atlanta =&gt; [0, nil], boston =&gt; [Float::INFINITY, nil], # chicago =&gt; [Float::INFINITY, nil], # denver =&gt; [Float::INFINITY, nil], el_paso =&gt; [Float::INFINITY, nil]&#125; # 已访问的城市记录在这个数组里 visited_cities = [] # 一开始先访问起点城市，将 current_city 设为它 current_city = starting_city # 进入算法的核心逻辑，循环访问每个城市 while current_city # 正式访问当前城市 visited_cities &lt;&lt; current_city # 检查从当前城市出发的每条航线 current_city.routes.each do |city, price_info| # 如果起点城市到其他城市的价格比 routes_from_city 所记录的更低， # 则更新记录 if routes_from_city[city][0] &gt; price_info + routes_from_city[current_city][0] routes_from_city[city] = [price_info + routes_from_city[current_city][0], current_city] end end # 决定下一个要访问的城市 current_city = nil cheapest_route_from_current_city = Float::INFINITY # 检查所有已记录的路线 routes_from_city.each do |city, price_info| # 在未访问的城市中找出最便宜的那个， # 设为下一个要访问的城市 if price_info[0] &lt; cheapest_route_from_current_city &amp;&amp; !visited_cities.include?(city) cheapest_route_from_current_city = price_info[0] current_city = city end end end return routes_from_cityend 该方法可以这样使用： 1234routes = dijkstra(atlanta, [boston, chicago, denver, el_paso])routes.each do |city, price_info|p "#&#123;city.name&#125;: #&#123;price_info[0]&#125;"end 虽然这个例子是找出最便宜的航线，但其解决方法也适用于地图软件和GPS技术。如果边上的权重不是表示价格，而是表示行车用时，那就可以用Dijkstra算法来确定从一个城市去另一个城市应该走哪条路线。 总结这一章讲的是本书最后一种重要的数据结构，我们的学习之旅也接近了尾声。我们知道了图是处理关系型数据的强大工具，它除了能让代码跑得更快，还能帮忙解决一些复杂的问题。 学习至今，我们关注的主要是代码运行的速度。我们以时间和算法的步数来衡量代码的性能。 然而，性能的衡量方法不止这些。在某些情况下，还有比速度更重要的东西，比如我们可能更关心一种数据结构或算法会消耗多少内存。下一章，我们就来学习如何分析一段代码在空间上的效率。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity中的Git最佳实践]]></title>
    <url>%2F2019%2F07%2F11%2FUnity%E4%B8%AD%E7%9A%84Git%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： .meta文件是干嘛用的？ Git最佳实践在说Unity与Git之前，我们先来看一下一些Git的通用最佳实践是什么。 提交相关的变化一次提交应该是相关联的修改。如果是修改了两个不同的BUG，应该分两次提交。小的commit可以让你的协作者更容易理解，并且一旦出现问题可以很容易回退版本。 经常提交经常提交可以确保你的提交足够小，并且提交相关联的变化，还可以减少代码冲突。 不要提交没做完的工作这不是说你要完成一个完整的功能才能提交，而是要将功能拆分，然后经常提交。不能让协作者拿到你的代码后出现编译错误、系统不能运行等情况。 提交之前应该测试提交之前应该进行测试，不要让你的代码影响别人的工作。 重视提交Message提交Message应该清楚地写明和本次提交相关的内容（不超过25个字）。如果需要填写更详细的内容，空一行后写下具体的提交信息。 很多童鞋经常着急提交，Message经常写一些无关的字符来满足提交的需求，这种坏习惯总有一天会害了你自己。 版本控制不是备份系统版本控制虽说可以备份你的项目，但是不要把Git当作一个备份的工具。不要将你本地的乱七八糟的文件都使用Git进行备份。记住Git是用来进行版本管理的，是用来跟踪管理这些文件的变化。 多用分支分支是Git最强大的功能之一。你应该多使用分支来拓宽开发的工作流：新功能、BUG修复、新创意等等。 团队内就工作流程达成一致Git给了你很多选择，比如划分几个分支，什么时候开辟新的分支，merge还是rebase等等。这些都应该基于你的项目进行选择，并且在团队中达成一致后严格执行。 Unity与Git在理解并执行上述的Git最佳实践之后，我们再来看Git在Unity中有哪些特殊的地方。 使用Git管理Unity项目一般流程如下： 在托管平台（之前介绍过多个国内外的托管平台，也可以自建）上创建Git项目 在本地Clone创建的项目 创建Unity工程到该版本库目录中 设置Unity工程的一些配置 设置gitignore文件 commit和push，在Git的保驾护航下开始愉快地开发Unity项目！ 配置Unity的文件属性为什么需要配置Unity的文件属性呢？这也是基于Git的一些原则： Git无法合并二进制文件，尽量避免会发生变化的文件使用二进制格式 一个Git版本库应该是一个完整的项目，需要包含项目可运行调试的所有代码、配置文件和资源。 通常Unity中需要设置的内容有以下几项： 设置Asset Serialization为Force Text上面提到了，Git无法处理二进制文件的合并，只能处理文本文件的合并。如果二进制文件出现了冲突，那只能选择一个文件保留，无法将两个文件进行合并。对于Unity中的文件，我们需要尽量避免这种情况。 默认情况下，Unity的资产序列化模式是Mixed。 资产序列化有三种模式： Mixed：混合模式，保持资产原来的序列化的模式，新的资产使用二进制的方式序列化。 Force Binary：强制二进制，如果不需要合并，可以使用二进制模式节省存储空间。如果一个项目只有你一个人开发，不会出现合并的情况，可以使用这个模式。 Force Text：强制文本模式。只要你的项目有多个人一起开发，就需要将资产序列化的模式设置为这个模式。 设置Version Control为Meta FilesUnity的Editor设置中，Version Control的Mode需要设置为Meta Files。 对于使用新版本Unity的童鞋，一般不需要进行额外设置，默认为Visible Meta Files，只需要检查一下即可。 一共有4种模式： Hidden Meta Files：隐藏的Meta文件，即该文件的属性是隐藏的，在系统中如果不查看隐藏文件这些文件是看不到的。如果你不想看到这些Meta Files，你可以设置为该选项。 Visible Meta Files：可见的Meta文件。 Perforce：Unity内置的一种版本控制工具。 PlasticSCM：Unity内置的一种版本控制工具。 什么是Meta文件？Meta文件在Unity中用来跟踪资产文件的一些信息，比如元数据、资产之间的关联等，是非常重要的一种数据，不能删除。删除后可能会丢失文件之间的关联信息。 在较旧版本的Unity中，还有一个Off的选项，选中这个选项时Unity不会生成meta文件，资产文件之间的关联都存储在临时文件中，使用版本控制管理时会造成关联丢失。 使用Git时，一定要选中Meta Files这个选项。 设置好Gitignore提前设置好gitignore文件可以防止将临时文件及不需要版本控制的文件提交到版本库中。 对于Unity工程自动生成的文件夹，只有下面几个目录是需要加入版本控制的： Assets ProjectSettings Packages 其他Unity自动生成的文件和文件加不需要加入版本控制，但是需要注意将你自己创建的文件或者文件夹加入版本控制。 Github中的Unity项目的gitignore文件是最好的初始模板：https://github.com/github/gitignore/blob/master/Unity.gitignore 123456789101112131415161718192021222324252627282930313233343536[Ll]ibrary/[Tt]emp/[Oo]bj/[Bb]uild/[Bb]uilds/Assets/AssetStoreTools*# Visual Studio cache directory.vs/# Autogenerated VS/MD/Consulo solution and project filesExportedObj/.consulo/*.csproj*.unityproj*.sln*.suo*.tmp*.user*.userprefs*.pidb*.booproj*.svd*.pdb*.opendb# Unity3D generated meta files*.pidb.meta*.pdb.meta# Unity3D Generated File On Crash Reportssysinfo.txt# Builds*.apk*.unitypackage 注意：gitignore文件可能随着项目的开发过程而发生变化，要注意根据项目的实际情况进行维护。 不要将大文件放入git管理项目中可能有很大的文件比如参考资料、视频、发布的程序等。这些尺寸很大、几乎不会变化的文件建议使用网盘等方式在团队之间共享，不要放到Git版本库中。 尽量不将美术中间文件放到工程中在Unity项目的开发过程中经常会有比较大的文件：比如贴图的原始PSD文件，模型的原始max文件等。这些文件一般情况会很大，尽量不要放到Git中进行管理。在版本库中存储的文件尽量是最终的图片或fbx格式的文件。 注意：这条建议也并非绝对，有时候使用psd或max文件可能更合理，需要自行判断。 总结在Unity项目中使用Git进行管理，需要注意以下流程： 在托管平台上创建Git项目 在本地Clone创建的项目 创建Unity工程到该版本库目录中 设置Unity工程的一些配置（Asset Serialization设置为Force Text） 设置gitignore文件（参考Github提供的gitignore文件） commit和push，在Git的保驾护航下开始愉快地开发Unity项目！]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 线性表]]></title>
    <url>%2F2019%2F07%2F10%2F%E7%AC%AC3%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是线性表？星座和生肖是不是线性表？公司的组织架构，班级同学之间是不是线性表？ 本章涵盖： 线性表的定义 线性表的抽象数据类型 线性表的顺序存储结构 顺序存储结构的插入与删除 线性表的链式存储结构 单链表的读取 单链表的插入与删除 单链表的整表创建 单链表的整表删除 单链表结构与顺序存储结构优缺点 静态链表 循环链表 双向链表 总结回顾 线性表的定义线性表，从名字上你就能感觉到，是具有像线一样的性质的表。 线性表（List）：零个或多个数据元素的有限序列。 这里需要强调几个关键的地方。 首先它是一个序列。也就是说，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。 然后，线性表强调是有限的，小朋友班级人数是有限的，元素个数当然也是有限的。事实上，在计算机中处理的对象都是有限的，那种无限的数列，只存在于数学的概念中。 如果用数学语言来进行定义。可如下： 若将线性表记为（a1，…，ai-1，ai，ai+1，…，an），则表中ai-1领先于ai，ai领先于ai+1，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i=1，2，…，n-1时，ai有且仅有一个直接后继，当i=2，3，…，n时，ai有且仅有一个直接前驱。如图1所示。 图1 所以线性表元素的个数n（n≥0）定义为线性表的长度，当n=0时，称为空表。 在非空表中的每个数据元素都有一个确定的位置，如a1是第一个数据元素，an是最后一个数据元素，ai是第i个数据元素，称i为数据元素ai在线性表中的位序。 我现在说一些数据集，大家来判断一下是否是线性表。 先来一个大家最感兴趣的，一年里的星座列表，是不是线性表呢？如图2所示。 图2 当然是，星座通常都是用白羊座打头，双鱼座收尾，当中的星座都有前驱和后继，而且一共也只有十二个，所以它完全符合线性表的定义。 公司的组织架构，总经理管理几个总监，每个总监管理几个经理，每个经理都有各自的下属和员工。这样的组织架构是不是线性关系呢？ 不是，为什么不是呢？哦，因为每一个元素，都有不只一个后继，所以它不是线性表。那种让一个总经理只管一个总监，一个总监只管一个经理，一个经理只管一个员工的公司，俗称皮包公司，岗位设置等于就是在忽悠外人。 班级同学之间的友谊关系，是不是线性关系？哈哈，不是，因为每个人都可以和多个同学建立友谊，不满足线性的定义。 班级同学的点名册，是不是线性表？是，这和刚才的友谊关系是完全不同了，因为它是有限序列，也满足类型相同的特点。这个点名册（如表1所示）中，每一个元素除学生的学号外，还可以有同学的姓名、性别、出生年月什么的，这其实就是我们之前讲的数据项。在较复杂的线性表中，一个数据元素可以由若干个数据项组成。 表1 一群同学排队买演唱会门票，每人限购一张，此时排队的人群是不是线性表？是，对的。此时来了三个同学要插当中一个同学A的队，说同学A之前拿着的三个书包就是用来占位的，书包也算是在排队。如果你是后面早已来排队的同学，你们愿不愿意？肯定不愿意，书包怎么能算排队的人呢，如果这也算，我浑身上下的衣服裤子都在排队了。于是不让这三个人进来。 这里用线性表的定义来说，是什么理由？嗯，因为要相同类型的数据，书包根本不算是人，当然排队无效，三个人想不劳而获，自然遭到大家的谴责。看来大家的线性表学得都不错。 线性表的抽象数据类型前面我们已经给了线性表的定义，现在我们来分析一下，线性表应该有一些什么样的操作呢？ 举幼儿园小朋友排队的例子，老师为了让小朋友有秩序地出入，所以就考虑给他们排一个队，并且是长期使用的顺序，这个考虑和安排的过程其实就是一个线性表的创建和初始化过程。 一开始没经验，把小朋友排好队后，发现有的高有的矮，队伍很难看，于是就让小朋友解散重新排--这是一个线性表重置为空表的操作。 排好了队，我们随时可以叫出队伍某一位置的小朋友名字及他的具体情况。比如有家长问，队伍里第五个孩子，怎么这么调皮，他叫什么名字呀，老师可以很快告诉这位家长。这种可以根据位序读取得到数据元素也是一种很重要的线性表操作。 还有什么呢，有时我们想知道，某个小朋友，比如麦兜是否是班里的小朋友，老师会告诉我说，不是，麦兜在春田花花幼儿园里，不在我们幼儿园。这种查找某个元素是否存在的操作很常用。 而后有家长问老师，班里现在到底有多少个小朋友呀，这种获得线性表长度的问题也很普遍。 显然，对于一个幼儿园来说，加入一个新的小朋友到队列中，或因某个小朋友生病，需要移除某个位置，都是很正常的情况。对于一个线性表来说，插入数据和删除数据都是必须的操作。 所以，线性表的抽象数据类型定义如下： 12345678910111213ADT 线性表(List)Data 线性表的数据对象集合为&#123;a1, a2, ......, an&#125;，每个元素的类型均为DataType。 其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素， 除了最后一个元素an外，每一个元素有且只有一个直接后继元素。 数据元素之间的关系是一对一的关系。Operation InitList(*L): 初始化操作，建立一个空的线性表L。 ListEmpty(L): 若线性表为空，返回true，否则返回false。 ClearList(*L): 将线性表清空。 GetElem(L, i, *e): 将线性表L中的第i个位置元素值返回给e。 LocateElem(L, e): 在线性表L中查找与给定值e相等的元素， 如果查找成功，返回该元素在表中序号表示成功； 仔细分析一下这个操作，发现我们只要循环集合B中的每个元素，判断当前元素是否存在A中，若不存在，则插入到A中即可。思路应该是很容易想到的。 12345678910111213141516171819/* 将所有的在线性表Lb中但不在La中的数据元素插入到La中 */void unionL(List *La, List Lb)&#123; int La_len, Lb_len, i; /* 声明与La和Lb相同的数据元素e */ ElemType e; /* 求线性表的长度 */ La_len = ListLength(*La); Lb_len = ListLength(Lb); for (i = 1; i &lt;= Lb_len; i++) &#123; /* 取Lb中第i个数据元素赋给e */ GetElem(Lb, i, &amp;e); /* La中不存在和e相同数据元素 */ if (!LocateElem(*La, e)) /* 插入 */ ListInsert(La, ++La_len, e); &#125;&#125; 这里，我们对于union操作，用到了前面线性表基本操作ListLength、GetElem、LocateElem、ListInsert等，可见，对于复杂的个性化的操作，其实就是把基本操作组合起来实现的。 注意一个很容易混淆的地方：当你传递一个参数给函数的时候，这个参数会不会在函数内被改动决定了使用什么参数形式。如果需要被改动，则需要传递指向这个参数的指针，如果不用被改动，可以直接传递这个参数。 线性表的顺序存储结构顺序存储定义说这么多的线性表，我们来看看线性表的两种物理结构的第一种--顺序存储结构。 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。 线性表（a1,a2,……,an）的顺序存储示意图如下： 我们在第一课时已经讲过顺序存储结构。今天我再举一个例子。 记得大学时，我们同宿舍有一个同学，人特别老实、热心，我们时常会让他帮我们去图书馆占座，他总是答应，你想想，我们一个宿舍连他共有九个人，这其实明摆着是欺负人的事。他每次一吃完早饭就冲去图书馆，挑一个好地儿，把他书包里的书，一本一本地按座位放好，若书包里的书不够，他会把他的饭盒、水杯、笔都用上，长长一排，九个座硬是被他占了，后来有一次因占座的事弄得差点都要打架。 顺序存储方式线性表的顺序存储结构，说白了，和刚才的例子一样，就是在内存中找了块地儿，通过占位的形式，把一定内存空间给占了，然后把相同数据类型的数据元素依次存放在这块空地中。既然线性表的每个数据元素的类型都相同，所以可以用C语言（其他语言也相同）的一维数组来实现顺序存储结构，即把第一个数据元素存到数组下标为0的位置中，接着把线性表相邻的元素存储在数组中相邻的位置。 我那同学占座时，如果图书馆里空座很多，他当然不必一定要选择第一排第一个位子，而是可以选择风水不错、美女较多的地儿。找到后，放一个书包在第一个位置，就表示从这开始，这地方暂时归我了。为了建立一个线性表，要在内存中找一块地，于是这块地的第一个位置就非常关键，它是存储空间的起始位置。 接着，因为我们一共九个人，所以他需要占九个座。线性表中，我们估算这个线性表的最大存储容量，建立一个数组，数组的长度就是这个最大存储容量。 可现实中，我们宿舍总有那么几个不是很好学的人，为了游戏，为了恋爱，就不去图书馆自习了。假设我们九个人，去了六个，真正被使用的座位也就只是六个，另三个是空的。同样的，我们已经有了起始的位置，也有了最大的容量，于是我们可以在里面增加数据了。随着数据的插入，我们线性表的长度开始变大，不过线性表的当前长度不能超过存储容量，即数组的长度。想想也是，如果我们有十个人，只占了九个座，自然是坐不下的。 来看线性表的顺序存储的结构代码。 12345678910111213/* 存储空间初始分配量 */#define MAXSIZE 20 /* ElemType类型根据实际情况而定，这里假设为int */typedef int ElemType; typedef struct&#123; /* 数组存储数据元素，最大值为MAXSIZE */ ElemType data[MAXSIZE]; /* 线性表当前长度 */ int length; &#125; SqList; 这里，我们就发现描述顺序存储结构需要三个属性： 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。 线性表的最大存储容量：数组长度MaxSize。 线性表的当前长度：length。 数组长度与线性表长度区别注意哦，这里有两个概念“数组的长度”和“线性表的长度”需要区分一下。 数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。有个别同学可能会问，数组的大小一定不可以变吗？我怎么看到有书中谈到可以动态分配的一维数组。是的，一般高级语言，比如C、VB、C++都可以用编程手段实现动态分配数组，不过这会带来性能上的损耗。 线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。 在任意时刻，线性表的长度应该小于等于数组的长度。 地址计算方法由于我们数数都是从1开始数的，线性表的定义也不能免俗，起始也是1，可C语言中的数组却是从0开始第一个下标的，于是线性表的第i个元素是要存储在数组下标为i-1的位置，即数据元素的序号和存放它的数组下标之间存在对应关系（如图所示）。 用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度。 其实，内存中的地址，就和图书馆或电影院里的座位一样，都是有编号的。存储器中的每个存储单元都有自己的编号，这个编号称为地址。当我们占座后，占座的第一个位置确定后，后面的位置都是可以计算的。试想一下，我是班级成绩第五名，我后面的10名同学成绩名次是多少呢？当然是6，7，…、15，因为5+1，5+2，…，5+10。由于每个数据元素，不管它是整型、实型还是字符型，它都是需要占用一定的存储单元空间的。假设占用的是c个存储单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。 1LOC(ai+1)=LOC(ai)+c 所以对于第i个数据元素ai的存储位置可以由a1推算得出： 1LOC(ai)=LOC(a1)+(i-1)*c 从下图来理解： 通过这个公式，你可以随时算出线性表中任意位置的地址，不管它是第一个还是最后一个，都是相同的时间。那么我们对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，因此用我们算法中学到的时间复杂度的概念来说，它的存取时间性能为O(1)。我们通常把具有这一特点的存储结构称为随机存取结构。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Layer]]></title>
    <url>%2F2019%2F07%2F04%2FLayer%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Layer有什么作用？应用的场景是什么？如何创建Layer？ Weight是什么意思？0和1有什么区别？ Mask上的M小图标是什么意思？ Layer可以和其他层混合吗？ Avatar Mask是什么意思？如何创建？两种定义身体遮罩的方式分别是什么？ 身体映射图包含几个部分？绿色和红色分别代表什么？ 手部和脚部的IK是什么意思？ 使用Mask的好处是什么？ 什么是正向动力学？反向动力学呢？ Layer中的IK Pass是什么意思？ Sync的作用是什么？ 本章涵盖： Animation Layers Avatar Mask Sync Animator状态机里面的状态复杂了之后会变得很多，会太难管理。比如有很多姿势，不拿枪，拿手枪，拿冲锋枪，拿步枪，每种姿势都要做一个混合树，再去加蹲的状态，会十分繁琐。 每个混合树里都有好多状态，这些动画之间有没有什么相似的地方可以提取出来呢？它们腿部的动画是类似的，不管拿枪姿势如何，腿部都是一样的，只有胳膊的动画不太一样。 这时候可以用到Animator Controller中的Layer。 Animation Layers使用Layer可以用来管理角色的不同身体部位。比如下半身用于行走或跑步，上半身用于射击或投掷物体。 可以从Animator左上角的Layer标签中管理Layer。 点击加号可以添加一个Layer。点击Layer旁边的齿轮图标，会弹出一个小窗口，可以设置该Layer对应的参数。 Weight 这一层的权重，0代表该层权重是0（该层不生效），1代表该层权重为1（该层中的动画能完全表现） Mask 设置该Layer能控制身体的哪部分，设置后该Layer上面会显示一个M的小图标。 Blending 和其他层混合的模式。 Override 覆盖上面的层中对应Mask的部位 Additive 会加在之前Layer的动画之上 Sync 复用其他层中的状态机。 IK Pass 每帧会调用脚本中的OnAnimatorIK方法，可以在这个方法中动态设置IK Avatar Mask用来设置该Layer的动画会影响角色的哪一部分的遮罩。 创建Avatar Mask在Project窗口中右键，Create ›Avatar Mask点击后会创建一个AvatarMask文件，此时可以对文件命名。 编辑AvatarMaskAvatarMask有两种定义身体遮罩的方式： 通过Humanoid身体映射图 通过Transform层次结构选择包含或不包含的骨骼 Humanoid 如果你的动画是人形动画，建议用这一种方式可以快速设置AvatarMask。 身体映射图包含以下几部分： 头部 胸腹 左臂 右臂 左手 右手 左腿 右腿 Root（脚下的圆形阴影部分） 可以通过鼠标点击每一部分，绿色代表动画可以影响这一部分，红色代表动画不会影响。在空白处点击可以全选/全不选。 手部和脚部的IK可以开关，表示该部分的IK曲线是否参与动画混合。 Transform 如果动画没有使用Humanoid，或者你想更精细的控制遮罩，你可以通过Transform层级结构来控制每一个骨骼。 1、选择一个Avatar（动画模型的Avatar）2、点击Import Skeleton按钮。avatar的层级结构会显示出来。3、可以设置对应的骨骼是否受动画控制 其他用途 在模型导入设置的Animation页签中，也可以设置Mask，设置后只会导入对应Mask的动画数据。 使用Mask的好处是：可以减少内存占用和CPU占用。因为不需要的身体部位的动画曲线不会被加载，并且不会参与计算。 实例比如你想人物保持行走、跑步、站立的同时上身能够投掷东西，你可以按下图设置Layer： Sync有时能够在不同的Layer重用其他Layer的状态机非常有用。比如你想模拟一个“受伤”的状态，你有受伤状态的各种动画比如走跑跳。这时候你可以选中Sync复选框，选择你想要同步的Layer。状态机的结构会保持一致，但是可以设置不同的Animation Clip。选中时，Layer旁边会有一个S小图标。 这意味着，同步出来的Layer不需要再去定义状态机，并且源Layer中状态机的任何变化都会同步到这一同步Layer。唯一需要你做的就是设置每个State中使用的动画。 Sync复选框旁边还有一个Timing复选框。 不选中时，Sync出来的Layer中每一个State的动画长度会变为源Layer中的时长。 选中时，根据Weight调整动画时长，Weight为1时使用Sync Layer中的动画时长。 IK Pass大多数动画是通过旋转骨骼来实现的。子骨骼的位置跟着父骨骼的旋转而改变，因此关节链的终点可以根据前面的各个骨骼的角度和相对位置确定。这种构成骨骼动画的方法称为正向动力学。 反向动力学就是根据骨骼的最终节点，反向推算之前的骨骼节点的位置。有些时候我们需要根据空间中的位置来确定骨骼节点的位置，比如让角色拿枪，不同的枪可能握持的位置不太相同，就需要根据握持的位置来决定角色手的位置。Unity中的IK支持所有人形动画。 Animator中的State设置中的Foot IK就是设置脚部受IK的影响。 总结有了Layer，动画可以分为上半身和下半身两个Layer，这样一来就不需要对每个拿枪的动作设置移动的混合树了，能简化不少工作。合理利用Layer不仅可以减少动画师的动画制作工作量，还能在性能上对游戏进行优化。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第12章-让一切操作都更快的二叉树]]></title>
    <url>%2F2019%2F07%2F01%2F%E7%AC%AC12%E7%AB%A0-%E8%AE%A9%E4%B8%80%E5%88%87%E6%93%8D%E4%BD%9C%E9%83%BD%E6%9B%B4%E5%BF%AB%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.什么是树？什么是二叉树？ 本章涵盖： 1.二叉树 2.查找 3.插入 4.删除 5.二叉树实战 第2章介绍了二分查找这一概念，并演示了当数组有序时，运用二分查找就能以O(log N)的时间复杂度找出任意值的所在位置。可见，有序的数组是多么美好。 但是有序数组存在着另一个问题。 有序数组的插入和删除是缓慢的。往有序数组中插入一个值前，你得将所有大于它的元素右移一格。从有序数组中删除一个值后，你得将所有大于它的元素左移一格。最坏情况下（插入或删除发生在数组开头）这会需要N步，平均情况则是N/2步。不管怎样，都是O(N)的效率，而O(N)算是挺慢的。 后来，学到了散列表能以O(1)的效率进行查找、插入和删除，但它又有另一明显的不足：不保持顺序。 既要保持顺序，又要快速查找、插入和删除，看来有序数组和散列表都不行。那还有什么数据结构可以选择？ 看看二叉树吧。 二叉树上一章我们通过链表见识了基于结点的数据结构。一个普通的链表里，每一个结点会包含一个连接自身和另一结点的链。树也是基于结点的数据结构，但树里面的每个结点，可以含有多个链分别指向其他多个结点。 以下是一棵典型的树 此例中，每个结点链接着另外两个结点。简单起见，我们也可以不用画出存储链的格子。 谈论树的时候，我们会用到以下术语。 最上面的那一结点（此例中的“j”）被称为根。是的，图中的根位于树的顶端，请自行意会。 此例中，“j”是“m”和“b”的父结点，反过来，“m”和“b”是“j”的子结点。“m”又是“q”和“z”的父结点，“q”和“z”是“m”的子结点。 树可以分层。此例中的树有3层。 基于树的数据结构有很多种，但本章只关注其中一种--二叉树。二叉树是一种遵守以下规则的树。 每个结点的子结点数量可为0、1、2。 如果有两个子结点，则其中一个子结点的值必须小于父结点，另一个子结点的值必须大于父结点。 以下是一个二叉树的例子，其中结点的值是数字。 注意，小于父结点的子结点用左箭头来表示，大于父结点的子结点则用右箭头来表示。 尽管下图是一棵树，但它不是二叉树。 之所以不是二叉树，是因为它的两个子结点的值都小于父结点。 以Python来实现一个树结点的话，大概是这样： 12345class TreeNode: def __init__(self,val,left=None,right=None): self.value = val self.leftChild = left self.rightChild = right 然后就可以用它来构建一棵简单的树了。 123node = TreeNode(1)node2 = TreeNode(10)root = TreeNode(5, node, node2) 用python来构建树，然后再来构建二叉树。不是一开始一个类就是二叉树类，是new树类的对象后再构建二叉树。 因为二叉树具有这样独特的结构，所以我们能在其中非常快速地进行查找操作，下面就来看看。 查找这是一棵二叉树。 二叉树的查找算法先从根结点开始。 (1) 检视该结点的值。(2) 如果正是所要找的值，太好了！(3) 如果要找的值小于当前结点的值，则在该结点的左子树查找。(4) 如果要找的值大于当前结点的值，则在该结点的右子树查找。 以下是用Python写的递归式查找。 12345678910111213def search(value, node): # 基准情形：如果 node 不存在 # 或者 node 的值符合 if node is None or node.value == value: return node # 如果 value 小于当前结点，那就从左子结点处查找 elif value &lt; node.value: return search(value, node.leftChild) # 如果 value 大于当前结点，那就从右子结点处查找 else: # value &gt; node.value return search(value, node.rightChild) 假设现在我们要找61，那来看看整个过程要花多少步。 树的查找必须从根开始。 接着，计算机会问自己：我们要找的值与该结点的值相比，是大还是小呢？如果小于当前结点，那就在左子结点上找。如果大于当前结点，那就在右子结点上找。 本例中，因为61大于50，所以它只能在树的右侧，于是我们检查右子结点。 算法继续检查该结点的值。因为75不是我们要找的61，所以还得往下一层找。由于61小于75，它只能在75的左侧，于是下一步去的是左子结点。 因为 61大于 56，所以到 56的右子结点上找。 在这棵树里找出61，我们总共用了4步。 推广开来，我们会说二叉树查找的时间复杂度是 O(log N)。因为每行进一步，我们就把剩余的结点排除了一半（不过很快就能看到，只在最好情况下，即理想的平衡二叉树才有这样的效率）。 再与二分查找比较，它也是每次尝试会排除一半可能性的O(log N)算法，可见二叉树查找跟有序数组的二分查找拥有同样的效率。 要说二叉树哪里比有序数组更亮眼，那应该是插入操作。 插入要探索二叉树插入的算法，我们还是从一个实例入手吧。假设现在要往刚才的树里插入45。 首先要做的就是找出45应该被链接到哪个结点上。先从根开始找起。 因为45小于50，所以我们转到左子结点上。 因为45大于25，所以我们检查右子结点。 45大于33，所以检查33的右子结点。 至此，我们到达了一个没有子结点的结点，也就无法再往下了。这意味着可以做插入了。 因为45大于40，所以将其作为40的右子结点来插入。 在这个例子里，插入花了5步，包括4步查找和1步插入。插入这1步总是发生在查找之后，所以总共log N+1步。按照忽略常数的大O来说，就是O(log N)步。 有序数组的插入则是O(N)，因为该过程中除了查找，还得移动大量的元素来给新元素腾出空间。 这就是二叉树的高效之处。有序数组查找需要O(log N)，插入需要O(N)，而二叉树都是只要O(log N)。当你估计应用会发生许多数据改动时，这一比较将有助你做出正确选择。 以下是二叉树插入的Python实现，它跟search一样都是递归的。 12345678910111213def insert(value, node): if value &lt; node.value: # 如果左子结点不存在，则将新值作为左子结点 if node.leftChild is None: node.leftChild = TreeNode(value) else: insert(value, node.leftChild) elif value &gt; node.value: # 如果右子结点不存在，则将新值作为右子结点 if node.rightChild is None: node.rightChild = TreeNode(value) else: insert(value, node.rightChild) 注意，只有用随意打乱的数据创建出来的树才有可能是比较平衡的。要是插入的都是已排序的数据，那么这棵树就失衡了，它用起来也会比较低效。比如说，按顺序插入1、2、3、4、5的话，得出的树就会是这样。 从中查找5，效率会是O(N)。 但要是按3、2、4、1、5的顺序来插入的话，得出的树就是平衡的。 因此，假若你要用有序数组里的数据来创建二叉树，最好先把数据洗乱。 在完全失衡的最坏情况下，二叉树的查找需要O(N)。在理想平衡的最好情况下，则是O(log N)。在数据随机插入的一般情况下，因为树也大致平衡，所以查询效率也大约是O(log N)。 删除删除是二叉树的各种操作中最麻烦的一个，必须考虑周全才好动手。假设现在要删除这棵二叉树中的4。 首先，我们查找出它所在的结点，然后一步将该结点删掉。 这看起来好像很简单，那我们再试试删掉10吧。 如果删掉10的话，就会导致11的那个结点从树上脱离。当然这是不允许的，否则这个11就永远都找不到了。好在我们还有解决办法：将11放到之前10所在的位置。 至此，删除操作遵循以下规则。 如果要删除的结点没有子结点，那直接删掉它就好。 如果要删除的结点有一个子结点，那删掉它之后，还要将子结点填到被删除结点的位置上。 要删除带有两个子结点的结点是最复杂的。比如说现在要删除56。 那52和61要怎么处理呢？显然不能将它们都放到 56原本的位置上，还需要第三条规则。 如果要删除的结点有两个子结点，则将该结点替换成其后继结点。一个结点的后继结点，就是所有比被删除结点大的子结点中，最小的那个。 上面这句话听起来有点绕。或者你把这些结点按顺序排好，那么每个结点后续的那个结点就是其后继结点。就像本例中56的所有后裔中，只有61能被称为其后继结点。按照这个规则，我们将56替换成61。 那计算机是怎么找出后继结点的呢？这是有算法可循的。 跳到被删除结点的右子结点，然后一路只往左子结点上跳，直到没有左子结点为止，则所停留的结点就是被删除节点的后继结点。 再来看一个更复杂的删除，这次我们删除根结点。 现在需要找后继结点来填补根的位置。 首先，访问右子结点，然后一路往左下方向移步，直至没有左子结点的结点上。 这就找出后继结点52了，接着我们将其填到被删除结点的位置上。 删除完成！ 然而，还有一种情况我们没遇到过，那就是后继结点带有右子结点。让我们回到根被删除之前的状态，并且给52加上一个右子结点。 如此一来，就不能只将后继结点52移到根那里了，因为这样会使其子结点55悬空。于是，我们再加一条关于删除的规则。 如果后继结点带有右子结点，则在后继结点填补被删除结点以后，用此右子结点替代后继结点的父节点的左子结点。 下面运行一遍这个流程。 首先，将后继结点填到根处。 此时55便悬在半空中了。接下来，将55转换为继承节点的父节点的左子节点，本例中，61是继承结点的父结点，所以55成为61的左子结点。 这才算真正完成了。 以下为二叉树的删除算法的所有规则。 如果要删除的结点没有子结点，那直接删掉它就好。 如果要删除的结点有一个子结点，那删掉它之后，还要将子结点填到被删除结点的位置上。 如果要删除的结点有两个子结点，则将该结点替换成其后继结点。一个结点的后继结点，就是所有比被删除结点大的子结点中，最小的那个。 如果后继结点带有右子结点，则在后继结点填补被删除结点以后，用此右子结点替代后继结点的父节点的左子结点。 以下是用Python写的二叉树递归式删除算法。为了易于理解，安插了一些注释进去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546def delete(valueToDelete, node): # 当前位置的上一层无子结点，已到达树的底层，即基准情形 if node is None: return None # 如果要删除的值小于（或大于）当前结点， # 则以左子树（或右子树）为参数，递归调用本方法， # 然后将当前结点的左链（或右链）指向返回的结点 elif valueToDelete &lt; node.value: node.leftChild = delete(valueToDelete, node.leftChild) # 将当前结点（及其子树，如果存在的话）返回， # 作为其父结点的新左子结点（或新右子结点） return node elif valueToDelete &gt; node.value: node.rightChild = delete(valueToDelete, node.rightChild) return node # 如果要删除的正是当前结点 elif valueToDelete == node.value: # 如果当前结点没有左子结点， # 则以右子结点（及其子树，如果存在的话）替换当前结点成为当前结点之父结点的新子结点 if node.leftChild is None: return node.rightChild # 如果当前结点没有左子结点，也没有右子结点，那这里就是返回 None elif node.rightChild is None: return node.leftChild # 如果当前结点有两个子结点，则用 lift 函数（见下方）来做删除， # 它会使当前结点的值变成其后继结点的值 else: node.rightChild = lift(node.rightChild, node) return node def lift(node, nodeToDelete): # 如果此函数的当前结点有左子结点， # 则递归调用本函数，从左子树找出后继结点 if node.leftChild: node.leftChild = lift(node.leftChild, nodeToDelete) return node # 如果此函数的当前结点无左子结点， # 则代表当前结点是后继结点，于是将其值设置为被删除结点的新值 else: nodeToDelete.value = node.value # 用后继结点的右子结点替代后继结点的父节点的左子结点 return node.rightChild 跟查找和插入一样，平均情况下二叉树的删除效率也是O(log N)。因为删除包括一次查找，以及少量额外的步骤去处理悬空的子结点。有序数组的删除则由于需要左移元素去填补被删除元素产生的空隙，最终导致O(N)的时间复杂度。 二叉树实战二叉树在查找、插入和删除上引以为傲的O(log N)效率，使其成为了存储和修改有序数据的一大利器。它尤其适用于需要经常改动的数据，虽然在查找上它跟有序数组不相伯仲，但在插入和删除方面，它迅速得多。 比如说你正在做一个书目维护的应用，它需要具备以下功能。 该应用可以将书名依照字母序打印。 该应用可以持续更新书目。 该应用可以让用户从书目中搜索书名。 如果你预期该书目不常变动的话，那么用有序数组作为存储结构是可以的。但这个应用偏偏要经常实时更新数据。要是其中包含上百万册图书，那还是用二叉树来保存比较好。 存储书名的二叉树大概是下面这个样子。 书名的搜索和更新，可以按我们之前介绍的二叉树查找、插入和删除来解决。但依照字母序打印书名该怎么做呢？ 首先，我们得学会如何访问树上的所有结点。访问数据结构中所有元素的过程，叫作遍历数据结构。 接着，为了使书名以字母序打印，我们得确保遍历也是以字母序进行。虽然有多种方法可以遍历树，但对于这个要求字母序打印的应用，我们采用中序遍历。 递归是实施中序遍历的有力工具。我们将创建一个名为traverse的递归函数，它可以在任一结点上调用。然后执行以下步骤。 (1) 如果此结点有左子结点，则在左子结点上调用自身（traverse）。(2) 访问此结点（对于书目应用来说，就是打印结点的值）。(3) 如果此结点有右子结点，则在右子结点上调用自身（traverse）。 若当前结点没有子结点，则意味着该递归算法到达了基准情形，这时我们无须再调用traverse，只需打印结点中的书名就行了。 在“Moby Dick”上调用traverse的话，就能以下图的顺序访问树上的所有结点。 这样就能依照字母序打印书目了。遍历会访问树上所有的结点，所以树的遍历效率为O(N)。 以下是用Python写的以字母序打印书目的traverse_and_print函数。 123456def traverse_and_print(node): if node is None: return traverse_and_print(node.leftChild) print(node.value) traverse_and_print(node.rightChild) 总结二叉树是一种强大的基于结点的数据结构，它既能维持元素的顺序，又能快速地查找、插入和删除。尽管比它的近亲链表更为复杂，但它更有用。 值得一提的是，树形的数据结构除了二叉树以外还有很多种，包括堆、B树、红黑树、2-3-4树等。它们也各有自己适用的场景。 下一章，我们还会遇见另一种基于结点的数据结构--图。图是社交网络和地图软件等复杂应用的核心组成部分，强大且灵活。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第11章-基于结点的数据结构]]></title>
    <url>%2F2019%2F07%2F01%2F%E7%AC%AC11%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E7%BB%93%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是链表？什么是结点？什么是链？ 链表的第一个节点有什么作用？ 链表的物理结构与数组不同怎么理解？链表相对数组有什么好处？ 用一种语言来实现链表。 链表的读取和查找如何进行？是什么时间复杂度？ 链表的开头插入和末尾插入如何进行？是什么时间复杂度？ 什么场景适合使用链表？ 什么是双向链表？ 本章涵盖： 链表 实现一个链表 读取 查找 插入 删除 链表实战 双向链表 接下来的几章将要学习的各种数据结构，都涉及一种概念--结点。基于结点的数据结构拥有独特的存取方式，因此在某些时候具有性能上的优势。 本章我们会探讨链表，它是最简单的一种基于结点的数据结构，而且也是后续内容的基础。 你会发现，虽然链表和数组看上去差不多，但在性能上却各有所长。 链表像数组一样，链表也用来表示一系列的元素。事实上，能用数组来做的事情，一般也可以用链表来做。然而，链表的实现跟数组是不一样的，在不同场景它们会有不同的性能表现。 如第1章所述，计算机的内存就像一大堆格子，每格都可以用来保存比特形式的数据。当要创建数组时，程序会在内存中找出一组连续的空格子，给它们起个名字，以便你的应用存放数据，见下图。 我们之前说过，计算机能够直接跳到数组的某一索引上。如果代码要求它读取索引4的值，那么计算机只需一步就可以完成任务。重申一次，之所以能够这样，是因为程序事先知道了数组开头所在的内存地址--例如地址是1000--当它想去索引4时，便会自动跳到1004处。 与数组不同的是，组成链表的格子不是连续的。它们可以分布在内存的各个地方。这种不相邻的格子，就叫作结点。 那么问题来了，计算机怎么知道这些分散的结点里，哪些属于这个链表，哪些属于其他链表呢？ 这就是链表的关键了：每个结点除了保存数据，它还保存着链表里的下一结点的内存地址。 这份用来指示下一结点的内存地址的额外数据，被称为链。链表如下图所示。 此例中，我们的链表包含4项数据：”a”、”b”、”c”和”d”。因为每个结点都需要2个格子，头一格用作数据存储，后一格用作指向下一结点的链（最后一个结点的链是null，因为它是终点），所以整体占用了8个格子。 若想使用链表，你只需知道第一个结点在内存的什么位置。因为每个结点都有指向下一结点的链，所以只要有给定的第一个结点，就可以用结点1的链找到结点2，再用结点2的链找到结点3……如此遍历链表的剩余部分。 链表相对于数组的一个好处就是，它可以将数据分散到内存各处，无须事先寻找连续的空格子。 实现一个链表我们用Ruby来写一个链表，最终实现包含两个类：Node和LinkedList 。先是Node。 12345678class Node # 创建读写变量data,next_node attr_accessor :data, :next_node def initialize(data) @data = data endend Node类有两个属性：data表示结点所保存的数据，next_node表示指向下一结点的链，使用方法如下。 1234567node_1 = Node.new("once")node_2 = Node.new("upon")node_1.next_node = node_2node_3 = Node.new("a")node_2.next_node = node_3node_4 = Node.new("time")node_3.next_node = node_4 以上代码创建了4个连起来的结点，它们分别保存着”once”、”upon”、”a”和”time”4项数据。 虽然只用Node也可以创建出链表，但我们的程序无法由此轻易地得知哪个结点是链表的开端。因此我们还得创建一个LinkedList 类。下面是一个最基本的LinkedList 的写法。 12345678class LinkedList attr_accessor :first_node def initialize(first_node) @first_node = first_node endend 有了这个类，我们就可以用以下代码让程序知道链表的起始位置了。 1list = LinkedList.new(node_1) LinkedList的作用就是一个指针，它指向链表的第一个结点。 既然知道了链表是什么，那么接下来做个它跟数组的性能对比，观察它们在读取、查找、插入和删除上有何优劣。 读取我们曾经说过，当计算机要从数组中读取一个值时，它会一步跳到对应的格子上，其效率为O(1)。但在链表中就不是这样了。 假设程序要读取链表中索引2的值，计算机不可能在一步之内完成，因为无法一下子算出它在内存的哪个位置。毕竟，链表的结点可以分布在内存的任何地方。程序知道的只有第1个结点的内存地址，要找到索引2的结点（即第3个），程序必须先读取索引0的链，然后顺着该链去找索引1。接着再读取索引1的链，去找索引2，这才能读取到索引2里的值。 下面我们在LinkedList类中加入读取操作。 12345678910111213141516171819202122232425class LinkedList attr_accessor :first_node def initialize(first_node) @first_node = first_node end def read(index) # 从第一个结点开始 current_node = first_node current_index = 0 while current_index &lt; index do # 顺着链往下找，直至我们要找的那个索引值 current_node = current_node.next_node current_index += 1 # 如果读到最后一个结点之后，就说明 # 所找的索引不在链表中，因此返回 nil return nil unless current_node end return current_node.data endend 当想要读取某个索引时，可以这样写： 1list.read(3) 读取链表中某个索引值的最坏情况，应该是读取最后一个索引。这种情况下，因为计算机得从第一个结点开始，沿着链一直读到最后一个结点，于是需要N步。由于大O记法默认采用最坏情况，所以我们说读取链表的时间复杂度为O(N)。这跟读取数组的O(1)相比，的确是一大劣势。 查找链表的查找效率跟数组一样。记住，所谓查找就是从列表中找出某个特定值所在的索引。对于数组和链表来说，它们都是从第一格开始逐个格子地找，直至找到。如果是最坏情况，即所找的值在列表末尾，或完全不在列表里，那就要花O(N)步。 下面是查找方法的实现。 12345678910111213141516171819202122232425class LinkedList attr_accessor :first_node # 其他方法略…… def index_of(value) # 从第一个结点开始 current_node = first_node current_index = 0 begin # 如果找到，就返回 if current_node.data == value return current_index end # 否则，看下一个结点 current_node = current_node.next_node current_index += 1 end while current_node # 如果遍历整个链表都没找到，就返回 nil return nil endend 有了它我们就可以这样来查找了： 1list.index_of("time") 插入在某些情况下，链表的插入跟数组相比，有着明显的优势。回想插入数组的最坏情况：当插入位置为索引 0 时，因为需要先将插入位置右侧的数据都右移一格，所以会导致O(N)的时间复杂度。然而，若是往链表的表头进行插入，则只需一步，即O(1)。下面看看为什么。 假设我们的链表如下所示。 要在表头增加”yellow” ，我们只需创建一个新的结点，然后使其链接到”blue”那一结点。 因为无须平移其他数据，所以与数组相比，链表在前端插入数据更为便捷。 虽然理论上在链表的任何一处做插入都只需要1步，但事实上没那么简单。假设现在链表是这样的： 然后我们想在索引2（”blue”和”green”之间）插入”purple”。由于插入动作创建了一个新的结点，如下图那样改动”blue”和”purple”的链，因此实际的操作只需1步。 但是，在该动作之前，计算机还得先找到索引1的结点（”blue”），让结点1的链指向新的结点。这个过程就是之前所说的读取链表，其效率为O(N)。下面我们来演示一下。 因为新结点是加在索引1之后，所以计算机要先找出索引1。这得从第一个结点开始。 接着通过第一个链访问下一个结点。 既然已到达索引1的结点，那就可以增加新的结点进去了。 刚才添加”purple”的例子花了3步。若想将它添加到链表的末尾，就得花5步：先是用4步跳到索引3上，再用1步插入新结点。 因此，链表的插入效率为O(N)，与数组一样。 有趣的是，通过以上分析，你会发现链表的最坏情况和最好情况与数组刚好相反。在链表开头插入很方便，在数组开头插入却很麻烦；在数组的末尾插入是最好情况，在链表的末尾插入却是最坏情况。总结起来如下表所示。 ** 场 景 ** ** 数 组 ** ** 链 表 ** 在前端插入 最坏情况 最好情况 在中间插入 平均情况 平均情况 在末端插入 最好情况 最坏情况 下面给LinkedList类加上插入方法。 12345678910111213141516171819202122232425262728class LinkedListattr_accessor :first_node # 其他方法略…… def insert_at_index(index, value) # 创建新结点 new_node = Node.new(value) # 如果在开头插入，则将新结点的 next_node 指向原 first_node， # 并为其设置新的 first_node if index == 0 new_node.next_node = first_node return @first_node = new_node end current_node = first_node current_index = 0 # 先找出新结点插入位置前的那一结点 prev_index = index - 1 while current_index &lt; prev_index do current_node = current_node.next_node current_index += 1 end new_node.next_node = current_node.next_node # 使前一结点的链指向新结点 current_node.next_node = new_node endend 删除从效率上来看，删除跟插入是相似的。如果删除的是链表的第一个结点，那就只要1步：将链表的first_node设置成当前的第二个结点。 回到”once”、”upon”、”a”和”time”的例子。如果要删除”once”，那直接让链表以”upon”为开头就好了。 1list.first_node = node_2 再回想删除数组的第一个元素时，得把剩余的所有元素左移一格，需要O(N)的时间复杂度。 删除链表的最后一个结点，其实际的删除动作只需1步--令倒数第二的结点的链指向null。 然而，要找出倒数第二的结点，得花N步，因为我们依然只能从第一个结点顺着链往下一个个地找。 下面这个表格对比了各种情况下数组和链表删除操作的效率。注意它跟插入效率的表格几乎一模一样。 ** 场 景 ** ** 数 组 ** ** 链 表 ** 在前端删除 最坏情况 最好情况 在中间删除 平均情况 平均情况 在末端删除 最好情况 最坏情况 要在链表中间做删除，计算机需要修改被删结点的前一结点的链，看下面的例子你就会明白。 假设现在要删除刚才例子的索引2的值（”purple”），计算机就会找出索引1的结点，将其链指向”green”结点。 LinkedList类的删除操作实现如下。 12345678910111213141516171819202122232425262728293031class LinkedList attr_accessor :first_node # 其他方法略…… def delete_at_index(index) # 如果删除的是第一个结点， # 则将 first_node 重置为第二个结点， # 并返回原第一个结点 if index == 0 deleted_node = first_node @first_node = first_node.next_node return deleted_node end current_node = first_node current_index = 0 # 先找出被删结点前的那一结点， # 将其命名为 current_node while current_index &lt; index - 1 do current_node = current_node.next_node current_index += 1 end # 再找出被删结点后的那一结点 deleted_node = current_node.next_node node_after_deleted_node = deleted_node.next_node # 将 current_node 的链指向 node_after_deleted_node， # 这样被删结点就被排除在链表之外了 current_node.next_node = node_after_deleted_node deleted_node endend 经过一番分析，链表与数组的性能对比如下所示。 ** 操 作 ** ** 数 组 ** ** 链 表 ** 读取 O(1) O(N) 查找 O(N) O(N) 插入 O(N)（在末端是O(1)） O(N)（在前端是O(1)） 删除 O(N)（在末端是 O(1)） O(N)（在前端是O(1)） 尽管两者的查找、插入、删除的效率看起来差不多，但在读取方面，数组比链表要快得多。 既然如此，那为什么还要用链表呢？ 链表实战高效地遍历单个列表并删除其中多个元素，是链表的亮点之一。假设我们正在写一个整理电子邮件地址的应用，它会删掉列表中无效格式的地址。具体算法是，每次读取一个地址，然后用正则表达式（一种用于识别数据格式的特定模式）来校验其有效性。如果发现该地址无效，就将它从列表中移除。 不管这个列表是数组还是链表，要检查每个元素的话，都得花 N步。然而，当要删除邮件地址时，它们的效率却不同，下面我们来验证一下。 用数组的话，每次删除邮件地址，我们就要另外再花O(N)步去左移后面的数据，以填补删除所产生的空隙。而且还必须完成这些平移才能执行下一次邮件地址的检查。 所以如果存在需要删除的无效地址，那么除了遍历邮件地址的N步，还得加上N步乘以无效地址数。 假设每10个地址就有1个是无效的。如果列表包含1000个地址，那么无效的就应该会有100个。于是我们的算法就要花1000步来读取，再加上删除所带来的大约100000步的操作（100个无效地址 × N）。 但要是链表的话，每次删除只需1步就好，因为只需改动结点中链的指向，然后就可以继续检查下一邮件地址了。按这种算法去处理1000个邮件地址，只需要1100步（1000步读取和100步删除）。 双向链表链表的另一个引人注目的应用，就是作为队列的底层数据结构。第8章我们已经介绍过队列，你应该还记得它就是一种只能在末尾插入元素，在开头删除元素的数据结构。当时我们用数组作为队列的底层，并解释说队列只是有约束条件的数组。其实，改用链表来做队列的底层也可以，同样地，只要使该链表的元素只在末尾插入，并在开头删除就好了。那么用链表来代替数组有什么好处呢？下面来分析一下。 再强调一次，队列插入数据只能在末尾。如上文所述，在数组的末尾插入是极快的，时间复杂度为O(1)。链表则要O(N)。所以在插入方面，选择数组比链表更好。 但到了删除的话，就是链表更快了，因为它只要O(1)，而数组是 O(N)。 基于以上分析，似乎用数组还是链表都无所谓。因为它们总有一种操作是O(1)，另一种是O(N)：数组的插入是O(1)，删除是O(N)；链表则反过来，分别是O(N)和O(1)。 然而，要是采用双向链表这一链表的变种，就能使队列的插入和删除都为O(1)。 双向链表跟链表差不多，只是它每个结点都含有两个链--一个指向下一结点，另一个指向前一结点。此外，它还能直接访问第一个和最后一个结点。 以下是一个双向链表。 用代码来表述的话，如下所示。 123456789101112131415161718class Node attr_accessor :data, :next_node, :previous_node def initialize(data) @data = data endendclass DoublyLinkedList attr_accessor :first_node, :last_node def initialize(first_node=nil, last_node=nil) @first_node = first_node @last_node = last_node endend 由于双向链表总会记住第一个和最后一个结点，因此能够一步（以O(1)的时间）访问到它们。 更进一步地，在末尾插入数据也可以一步完成，如下所示。 这里创建了一个新结点（”Sue”），并使其previous_node指向双向链表的last_node（”Greg”）。然后，再将last_node（”Greg”）的next_node指向这个新结点（”Sue”）。最后，把last_node改为新结点（”Sue”）。 以下是在双向链表中实现的新方法insert_at_end 。 1234567891011121314151617181920212223class DoublyLinkedList attr_accessor :first_node, :last_node def initialize(first_node=nil, last_node=nil) @first_node = first_node @last_node = last_node end def insert_at_end(value) new_node = Node.new(value) # 如果链表还没有任何结点 if !first_node @first_node = new_node @last_node = new_node else new_node.previous_node = @last_node @last_node.next_node = new_node @last_node = new_node end endend 因为双向链表能直接访问前端和末端的结点，所以在两端插入的效率都为O(1)，在两端删除的效率也为O(1)。由于在末尾插入和在开头删除都能在O(1)的时间内完成，因此拿双向链表作为队列的底层数据结构就最好不过了。 以下是基于双向链表的队列的完整代码示例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Node attr_accessor :data, :next_node, :previous_node def initialize(data) @data = data endendclass DoublyLinkedList attr_accessor :first_node, :last_node def initialize(first_node=nil, last_node=nil) @first_node = first_node @last_node = last_node end def insert_at_end(value) new_node = Node.new(value) # 如果链表还没有任何结点 if !first_node @first_node = new_node @last_node = new_node else new_node.previous_node = @last_node @last_node.next_node = new_node @last_node = new_node end end def remove_from_front removed_node = @first_node @first_node = @first_node.next_node return removed_node endendclass Queue attr_accessor :queue def initialize @queue = DoublyLinkedList.new end def enque(value) @queue.insert_at_end(value) end def deque removed_node = @queue.remove_from_front return removed_node.data end def tail return @queue.last_node.data endend 总结尽管目前还没用到队列，或者用了数组但没用双向链表也运行得很好。但是现在，你知道了还有其他选择，也学习了什么时候应该做出什么选择。 你学会了在特定情况下使用链表来改善性能。后面还会介绍更复杂的基于结点的数据结构，它们更常用，并且对性能的提升更大。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第10章-飞快的递归算法]]></title>
    <url>%2F2019%2F07%2F01%2F%E7%AC%AC10%E7%AB%A0-%E9%A3%9E%E5%BF%AB%E7%9A%84%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 分区 快速排序 快速排序的效率 最坏情况 快速选择 递归给我们带来了新的算法实现方式，例如上一章的文件系统遍历。本章我们还会看到，递归能使算法效率大大提高。 前几章我们学会了一些排序算法，包括冒泡排序、选择排序和插入排序。但在现实中，数组排序不是通过它们来做的。为了免去大家重复编写排序算法的烦恼，大多数编程语言都自带用于数组排序的函数，其中很多采用的都是快速排序。 虽然它已经实现好了，但我们还是想研究一下它的原理，因为其运用递归来给算法提速的做法极具推广意义。 快速排序真的很快。尽管在最坏情况（数组逆序）下它跟插入排序、选择排序的效率差不多，但在日常多见的平均情况中，它的确表现优异。 快速排序依赖于一个名为分区的概念，所以我们先从它开始了解。 分区此处的分区指的是从数组随机选取一个值，以其为轴，将比它小的值放到它左边，比它大的值放到它右边。分区的算法实现起来很简单，例子如下所示。 假设有一个下面这样的数组。 从技术上来说，选任意值为轴都可以，我们就以数组最右的值为轴吧。现在轴就是3了，我们把它圈起来。 然后放置指针，它们应该分别指向排除轴元素的数组最左和最右的元素。 接着就可以分区了，步骤如下。 (1)左指针逐个格子向右移动，当遇到大于或等于轴的值时，就停下来。 (2)右指针逐个格子向左移动，当遇到小于或等于轴的值时，就停下来。 (3)将两指针所指的值交换位置。 (4)重复上述步骤，直至两指针重合，或左指针移到右指针的右边。 (5)将轴与左指针所指的值交换位置。 当分区完成时，在轴左侧的那些值肯定比轴要小，在轴右侧的那些值肯定比轴要大。因此，轴的位置也就确定了，虽然其他值的位置还没有完全确定。 让我们来把此流程套到示例数组上。 第1步：拿左指针（正指向0）与轴（值为3）比较。 由于0比轴小，左指针可以右移。 第2步：右移左指针。 将左指针（值为5）与轴比较。它比轴小吗？不。于是左指针停在这里，下一步我们启动右指针。 第3步：比较右指针（值为6）和轴。它比轴大吗？对。于是右指针左移。 第4步：左移右指针。 比较右指针（值为1）和轴。它比轴大吗？不。于是右指针停下。 第5步：因为两个指针都停住了，所以交换它们的值。 随后，再次启动左指针。 第6步：右移左指针。 比较左指针（值为2）和轴。它比轴小吗？对。于是继续右移。 第7步：左指针移到下一格子。注意，这时两个指针都指向同一个值了。 比较左指针和轴。由于左指针的值比轴要大，我们将其停在那里。而且现在左指针与右指针重合，无须再移动指针了。 第8步：到了分区的最后一步，将左指针的值与轴交换位置。 虽然数组还没完全排好序，但我们已完成了一次分区。即比轴（值为3）小的值都聚在了它的左侧，比轴大的值都聚在了它的右侧，这就意味着 3已经被放置到正确的位置上了。 下面是用Ruby写的SortableArray类，其中的partition!方法能如上所述对数组进行分区。 123456789101112131415161718192021222324252627282930313233343536373839class SortableArray attr_reader :array def initialize(array) @array = array end def partition!(left_pointer, right_pointer) # 总是取最右的值作为轴 pivot_position = right_pointer pivot = @array[pivot_position] # 将右指针指向轴左边的一格 right_pointer -= 1 while true do while @array[left_pointer] &lt; pivot do left_pointer += 1 end while @array[right_pointer] &gt; pivot do right_pointer -= 1 end if left_pointer &gt;= right_pointer break else swap(left_pointer, right_pointer) end end # 最后将左指针的值与轴交换 swap(left_pointer, pivot_position) # 根据快速排序的需要，返回左指针 # 具体原因接下来会解释 return left_pointer end def swap(pointer_1, pointer_2) temp_value = @array[pointer_1] @array[pointer_1] = @array[pointer_2] @array[pointer_2] = temp_value endend 此partition!方法接受两个参数作为左指针和右指针的起始位置，并在结束时返回左指针的最终位置。这是实现快速排序所必需的，下面我们将会看到。 快速排序快速排序严重依赖于分区。它的运作方式如下所示。 (1)把数组分区。使轴到正确的位置上去。 (2)对轴左右的两个子数组递归地重复第 1、2步，也就是说，两个子数组都各自分区，并形成各自的轴以及由轴分隔的更小的子数组。然后也对这些子数组分区，以此类推。 (3)当分出的子数组长度为0或1时，即达到基准情形，无须进一步操作。 将以下quicksort!方法加到刚才的SortableArray类中，快速排序就完整了。 12345678910111213def quicksort!(left_index, right_index) # 基准情形：分出的子数组长度为 0 或 1 if right_index - left_index &lt;= 0 return end # 将数组分成两部分，并返回分隔所用的轴的索引 pivot_position = partition!(left_index, right_index) # 对轴左侧的部分递归调用 quicksort quicksort!(left_index, pivot_position - 1) # 对轴右侧的部分递归调用 quicksort quicksort!(pivot_position + 1, right_index)end 想看实际效果的话，可执行以下代码。 1234array = [0, 5, 2, 1, 6, 3]sortable_array = SortableArray.new(array)sortable_array.quicksort!(0, array.length - 1)p sortable_array.array 再回到刚才的例子。最初的数组是[0, 5, 2, 1, 6, 3]，然后我们做了一次分区。所以我们的快速排序已经有一点进度了，目前状态如下。 正如你看到的，其中3为轴。它已经处于正确的位置，接下来对其左右两侧的元素进行排序。 注意，虽然我们看到左侧的元素碰巧已经按顺序排好了，但计算机是不知道的。 下一步，我们把轴左侧的那些元素当作一个独立的数组来分区。 除此之外的元素则先不用看，暂时给它们涂上阴影。 现在，对于这个 [0, 1, 2] 的子数组，我们选取其最右端的元素作为轴。于是，轴为 2。 然后，设置左右指针。 让我们接着之前的第 8步，开始子数组的分区。 第 9步：比较左指针（值为 0）与轴（值为 2）。由于 0小于轴，可将左指针右移。 第 10步：将左指针右移一格，这时它刚好跟右指针重合了。 比较左指针与轴。由于 1小于轴，继续右移。 第 11步：将左指针右移一格，它便指向轴了。 这时左指针的值与轴相等了（因为它正指向轴），左指针停下。 第 12步：启动右指针。然而，右指针（值为 1）小于轴，所以不用动。 因为左指针已经跑到右指针的右边了，所以本次分区无须再移动指针。 第 13 步：最后，将左指针的值跟轴交换。但左指针已经指向轴，因此轴与自身交换，结果没有任何改变。至此，分区完成，轴（值为 2）也到达正确位置了。 于是轴（值为 2）分出了左侧的子数组 [0, 1] ，右侧没有子数组。那么接下来将左侧的 [0, 1] 分区。 为了专注于 [0, 1] ，我们将其余的元素涂上阴影。 然后选取其最右的元素（值为 1）作为轴。但是左右指针应该如何放置呢？是的，左指针指向0，右指针因为总是从轴左侧那格开始，所以也是指向 0，如下所示。 可以开始分区了。 第 14步：比较左指针（值为 0）与轴（值为 1）。 它比轴小，继续右移。 第 15步：将左指针往右移一格，这时它指向了轴。 由于左指针不再小于轴了（因为它的值就是轴），于是停下。 第 16 步：比较右指针与轴。由于其值小于轴，就不用再左移了。而且现在左指针走到了右指针的右边，所以指针无须继续移动，可以进入最后一步。 第 17 步：将左指针与轴交换。但同样地，这次左指针也指向了轴，所以交换不会产生什么位置改变。于是轴的位置便排好了，分区结束。 此时数组如下所示。 接着，对最近一次的轴的左侧子数组 [0] 进行分区。因为它只包含一个元素，到达了“数组长度为0或1”的基准情形，所以我们什么都不用干。该元素已随着之前的分区被挪到了正确的位置。现在数组如下所示。 最开始我们以3为轴，然后把其左侧的子数组 [0, 1, 2] 做了分区。按照约定，现在轮到了它右侧的 [6, 5] 。[0, 1, 2, 3] 已经排好了，所以将它们涂上阴影，以便我们专注于 [6, 5] 。 接下来的分区以最右端的元素（值为 5）为轴，如下所示。 左右指针只能同时指向 6。 第 18步：比较左指针（值为 6）与轴（值为 5）。由于 6大于轴，左指针不再右移。 第 19 步：本来指着 6 的右指针应该左移，但 6 的左边已经没有其他元素了，所以右指针停止。由于左指针与右指针重合，也不用再做任何移动了，可以跳到最后一步。 第 20步：将左指针的值与轴交换。 这样轴（值为 5）就放到正确位置上了，数组变成了下面这样。 尽管随后我们应该递归地对 [5, 6] 左右两侧的子数组进行分区，但现在轴左侧没有元素，右侧也只有长度为 1的子数组，即到达了基准情形--6已自动挪到了正确位置。 于是整个排序完成！ 快速排序的效率为了搞清楚快速排序的效率，我们先从分区开始。分解来看，你会发现它包含两种步骤。 比较：每个值都要与轴做比较。 交换：在适当时候将左右指针所指的两个值交换位置。 一次分区至少有N次比较，即数组的每个值都要与轴做比较。因为每次分区时，左右指针都会从两端开始靠近，直到相遇。 交换的次数则取决于数据的排列情况。一次分区里，交换最少会有1次，最多会有N/2次，因为即使所有元素都需要交换，我们也只是将左半部分与右半部分进行交换，如下图所示。 对于随机排列的数据，粗略来算就是N/2的一半，即N/4次交换。于是，N次比较加上N/4次交换，共1.25N步。最后根据大 O记法的规则，忽略常数项，得出分区操作的时间为 O(N)。 这就是一次分区的效率。但完整的快速排序需要对多个数组以及不同大小的子数组分区，想知道整个过程所花的时间，还要再进一步分析才行。 为了更形象地描述，我们将一个含有 8个元素的数组的快速排序过程画了出来。它旁边有每一次分区所作用的元素个数。由于元素值并不重要，因此就不显示了。注意，作用范围就是那些白色的格子。 这里有 8次分区，但每次作用的范围大小不一。因为只含1个元素的子数组就是基准情形，无须任何交换和比较，所以只有元素量大于或等于 2的子数组才要算分区。 由于此例属于平均情况的一种，因此我们假设每次分区大约要花 1.25N步，得出：8 个元素 * 1.25 = 10 步3 个元素 * 1.25 = 3.75 步4 个元素 * 1.25 = 5 步 2 个元素 * 1.25 = 2.5 步 总共约为 21 步 如果再对不同大小的数组做统计，你会发现 N个元素，就要 N×log N步。想体会什么是NlogN的话，可参考下表。 N log N N×log N4 2 88 3 2416 4 64 在上面一个数组含 8个元素的例子中，快速排序花了大约 21步，也很接近 8×log8（等于 24）。 这种时间复杂度的算法我们还是第一次遇到，用大 O记法来表达的话，它是 O(N log N)算法。 快速排序的步数接近 N×log N绝非偶然。如果我们以更平均的情况来考察快速排序，就能看出原因了。 快速排序开始时会对整个数组进行分区。假设此次分区会将轴最终安放到数组中央--这也是平均情况--然后我们就要对由此切开的两半进行分区。巧合的是，它们的轴也最终落在各自的中央，分出4个大小为原数组四分之一的子数组。并且，接下来所有分区都出现了这种轴在中央的情况。 这样一来，我们基本上就是在不断地对半切分子数组，直至产生出的子数组长度为1。那么，一个数组要经历多少次分区才能切到这么小呢？如果数组元素有N个，那就是logN次。假设元素有8个，那就要对半切3次，才能分出只有1个元素的子数组。这个原理你应该在二分查找那节学过了。 对两个新的子数组所执行的分区操作，需要处理的数据量还是相当于对原数组所做的分区。 如下图所示。 因为等分发生了log N次，而每次都要对总共 N个元素做分区，所以总步数为 N×log N。 之前我们看到的很多算法，最佳情况都发生在元素有序的时候。但在快速排序里，最佳情况应该是每次分区后轴都刚好落在子数组的中间。 最坏情况快速排序最坏的情况就是每次分区都使轴落在数组的开头或结尾。导致这种情况的原因有好几种，包括数组已升序排列，或已降序排列。下面我们把这种情况用图来说明一下。 虽然在此情况下，每次分区都只有一次交换，但比较的次数却变得很多。在轴总落在中央的例子里，每次分区都能划分出比原数组小得多的子数组（过程中产生的最大的子数组长度为4），使各部分都能很快地到达基准情形。然而如果轴落在其中一端，前5次分区就需要处理长度大于4的数组。而且这5次分区里，每次所需的比较次数还是和子数组的元素量一样多。 于是在最坏情况下，对 8 + 7 + 6 + 5 + 4 + 3 + 2个元素进行分区，一共 35次比较。 写成公式的话，就是 N个元素，需要 N + (N  1) + (N  2) + (N  3) + … + 2步，即 N 2 / 2步， 如下图所示。 又因为大O忽略常数，所以最终我们会说，快速排序最坏情况下的效率为 O(N 2 )。 既然把快速排序分析完了，我们将它与插入排序比较一下。 最好情况 平均情况 最坏情况插入排序O(N) O(N 2 ) O(N 2 )快速排序O(N log N) O(N log N) O(N 2 ) 虽然快速排序在最好情况和最坏情况都没能超越插入排序，但在最常遇见的平均情况，前者的 O(N log N)比后者的 O(N 2 )好得多，所以总体来说，快速排序优于插入排序。 以下是各种时间复杂度的对比。 由于快速排序在平均情况下表现优异，于是很多编程语言自带的排序函数都采用它来实现。 因此一般你不需要自己写快速排序。但你可能需要学会写快速选择--它是一种类似快速排序的实用算法。 快速选择假设有一个无序的数组，你不需要将它排序，只要找出里面第 10 小的值，或第 5 大的值。 就像从一堆测试成绩中找出第 25百分位，或找出中等成绩那样。 你首先想到的，可能是把整个数组排序，然后再跳到对应的格子里去找。 但这样做的话，即使是用快速排序那样高效的算法，一般也需要O(N log N)。虽然这也不算差，但一种名为快速选择的算法可以做得更好。快速选择需要对数组分区，这跟快速排序类似，或者你可以把它想象成是快速排序和二分查找的结合。 如之前所述，分区的作用就是把轴排到正确的格子上。快速选择就利用了这一点。 例如要在一个长度为 8的数组里，找出第 2小的值。 先对整个数组分区。 轴很可能落到数组中间某个地方。 现在轴已安放在正确位置了，因为那是第 5个格子，所以我们掌握了数组第 5小的值是什么。 虽然我们要找的是第 2小的值，但刚才的操作足以让我们忽略轴右侧的那些元素，将查找范围缩小到轴左侧的子数组上。这看起来就像是不断地把查找范围缩小一半的二分查找。 然后，继续对轴左侧的子数组分区。 假设子数组的轴最后落到第 3个格子上。 现在第 3个格子的值已经确定了，该值就是数组第3小的值，第2小的值也就是它左侧的某个元素。于是再对它左侧的元素分区。 这次分区过后，最小和第 2小的元素也就能确定了。 这么一来，我们就可以拿出第 2个格子的值，告诉别人找到第2小的元素了。快速选择的优势就在于它不需要把整个数组都排序就可以找到正确位置的值。 如果像快速排序那样，每次分区后还是要处理原数组那么多的数据，就会导致O(N log N)的步数。但快速选择不同，下一次的分区操作只需在上一次分出的一半区域上进行，即值可能存在的那一半。 分析快速选择的效率，你会发现它的平均情况是O(N)。回想每次分区的步数大约等于作用数组的元素量，你便可算出，对于一个含有 8个元素的数组，会有 3次分区：第一次处理整个数组的 8个元素，第二次处理子数组的 4个元素，还有一次处理更小的子数组的 2个元素。加起来就是 8 + 4 + 2 = 14步。于是 8个元素大概是 14步。 如果是 64个元素，就会是 64 + 32 + 16 + 8 + 4 + 2 = 126步；如果是 128个元素，就会是 254步；如果是 256个元素，就会是 510步。 用公式来表达，就是对于 N个元素，会有 N + (N / 2) + (N / 4) + (N / 8) + … + 2步。结果大概是 2N步。由于大 O忽略常数，我们最终会说快速选择的效率为 O(N)。 你可以把以下实现了快速选择的quickselect!方法加到刚才的SortableArray里。你会发现它跟quicksort!很像。 1234567891011121314151617181920def quickselect!(kth_lowest_value, left_index, right_index) # 当子数组只剩一个格子——即达到基准情形时， # 那我们就找到所需的值了 if right_index - left_index &lt;= 0 return @array[left_index] end # 将数组分成两部分，并返回分隔所用的轴的索引 pivot_position = partition!(left_index, right_index) if kth_lowest_value &lt; pivot_position quickselect!(kth_lowest_value, left_index, pivot_position - 1) elsif kth_lowest_value &gt; pivot_position quickselect!(kth_lowest_value, pivot_position + 1, right_index) else # 至此 kth_lowest_value 只会等于 pivot_position # 如果分区后返回的轴的索引等于 kth_lowest_value， # 那这个轴就是我们要找的值 return @array[pivot_position] endend 想要从一个无序数组中找出第 2小的值，可以运行如下代码。 123array = [0, 50, 20, 10, 60, 30]sortable_array = SortableArray.new(array)p sortable_array.quickselect!(1, 0, array.length - 1) 此方法的第一个参数是查找的位置。因为数组索引从 0开始算起，所以我们传入 1来查找第2小的值。 总结由于运用了递归，快速排序和快速选择可以将棘手的问题解决得既巧妙又高效。这也提醒了我们，有些看上去很普通的算法，可能是经过反复推敲的高性能解法。 其实能递归的不只有算法，还有数据结构。后面几章将要接触的链表、二叉树以及图，就利用了自身递归的特性，给我们提供了迅速的数据操作方式。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第9章-递归]]></title>
    <url>%2F2019%2F07%2F01%2F%E7%AC%AC9%E7%AB%A0-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是递归？递归适用于什么场景？ 几乎所有循环都能够转换成递归怎么理解？ 什么是基准情形？ 如何阅读递归代码？ 什么是调用栈？递归发生时内存是怎么处理的？ 计算机处理3的阶乘的过程是什么样的？ 什么是栈溢出，为什么会发生？ 本章涵盖： 用递归代替循环 基准情形 阅读递归代码 计算机眼中的递归 递归实战 总结 在学习本书其余算法之前，你得先学会递归。解决很多看似复杂的问题时，如果从递归的角度去思考，会出人意料地简单，而且代码量还会大大减少。 不过，我们先做一个突击测试！ 运行一个定义如下的blah()函数，会发生什么？ 1234function blah() &#123; blah();&#125; 正如你所想的，blah()会调用blah()，后者也会调用blah()，于是就这样无限地调用下去。 函数调用自身，就叫作递归。无限递归用处不大，甚至还挺危险，但是有限的递归很强大。掌控好递归能帮助我们解决某些棘手的问题，我很快就会证明给你看。 用递归代替循环假设在NASA工作的你，需要写一个用于发射飞船的倒数程序。该程序接收一个数字，例如10，然后显示从10到0的数字。现在先暂停一下，选择一门编程语言来实现这个程序，做完以后，再往下阅读。 或许你用了JavaScript，并且写了如下循环。 12345678function countdown(number) &#123; for(var i = number; i &gt;= 0; i--) &#123; console.log(i); &#125;&#125;countdown(10); 这样写没什么问题，只是你可能没想到循环以外的做法。 那还能怎么做呢？ 试试换成递归吧。以下是初级版的递归countdown 。 123456function countdown(number) &#123; console.log(number); countdown(number - 1);&#125;countdown(10) 让我们一步步来分析。 第1步：调用countdown(10)，因此参数number为 10。 第2步：将number（值为10）打印到控制台。 第3步：countdown函数在结束前，调用了countdown(9)（因为number - 1等于 9）。 第4步：countdown(9)被执行，会将number（值为9）打印到控制台。 第5步：countdown(9)结束前，调用了countdown(8) 。 第6步：countdown(8)被执行，会将number（值为8）打印到控制台。 在继续步骤分解之前，先回顾下该递归是怎样实现我们的需求的。countdown里并没有任何循环结构，它通过调用自身就能够从10开始倒数并将每个数字打印出来。 几乎所有循环都能够转换成递归。但能用不代表该用。递归的强项在于巧妙地解决问题，但在上面的例子中，它并不比普通的循环更加优雅、高效。我们很快就会看到能让递归发挥威力的场景，但在那之前，还是先理清递归的运作方式。 基准情形让我们把countdown函数继续下去。为了简洁一点，我们跳过一些步骤。 第21步：调用countdown(0) 。 第22步：将number（值为0）打印到控制台。 第23步：调用countdown(-1) 。 第24步：将number（值为1）打印到控制台。 糟了，你也看到了，这种写法不够完善，这样下去我们就会不断地打印负数。 要解决这个问题，得在数到0时就停住，以免递归一直往下数。 我们可以加个条件判断，来保证当number为0时，不再调用countdown()。 12345678910111213function countdown(number) &#123; console.log(number); if(number === 0) &#123; return; &#125; else &#123; countdown(number - 1); &#125;&#125;countdown(10); 这样，当number为0时，我们的代码就不会再去调用countdown()，而是直接返回。 在递归领域（真有这么一个地方），不再递归的情形称为基准情形。对于刚才的countdown()函数来说，0就是基准情形。 阅读递归代码递归是需要时间和练习才能适应的，到那时候，你会掌握两种技巧：阅读递归代码和编写递归代码。阅读递归代码相对简单一点，所以就先从这里入手吧。 我们会以阶乘作为例子。阶乘的演示如下所示。 3的阶乘是：3 * 2 * 1 = 6 5的阶乘是：5 * 4 * 3 * 2 * 1 = 120 以此类推。以下Ruby代码会以递归计算的方式返回一个数的阶乘。 1234567def factorial(number) if number == 1 return 1 else return number * factorial(number - 1) endend 此代码初看可能会让人有点困惑，可以按照以下流程来读。 (1) 找出基准情形。 (2) 看该函数在基准情形下会做什么。 (3) 看该函数在到达基准情形的前一步会做什么。 (4) 就这样往前推，看每一步都在做什么。 让我们将此流程应用到刚才的代码上。稍作分析，就可以看出里面有两条路径。 12345if number == 1 return 1else return number * factorial(number - 1)end 第二条路的factorial有调用自身，是递归发生的地方。 123else return number * factorial(number - 1)end 第一条路并没有调用自身，因此这里是基准情形。 12if number == 1 return 1 于是，number为1时，是基准情形。 接着，想象factorial方法在基准情形下，即factorial(1) 的处理流程。其相关代码如下。 12if number == 1 return 1 好，这很简单，因为是基准情形，所以没有递归。调用factorial(1)就会直接返回1。于是找来一张纸，记下该结果。 然后，回到上一步的factorial(2)，相关代码如下。 123else return number * factorial(number - 1)end 调用factorial(2)就会返回2 * factorial(1) 。要计算2 * factorial(1)，就得先知道factorial(1)的结果。要是检查下前面所记，你会发现那是1。因此，2 * factorial(1)就是2 * 1 ，即是2。 把这个也记到纸上。 那么，factorial(3)又会是什么呢？再回看代码。 123else return number * factorial(number - 1)end 代入参数便是3 * factorial(2) 。那么factorial(2)是什么呢？你不用从头计算，因为它的结果已经写在纸上了，是2。于是factorial(3)会返回 6（3 * 2 = 6）。将结果记下，然后继续。 现在请自行计算factorial(4) 。 如你所见，这种从基准情形入手再往上分析的思路，对理解递归代码是多么有益。 事实上，此方法不仅为人类所利用，计算机也差不多是这样做的。下面就来看看。 计算机眼中的递归细想一下我们的factorial方法，你会发觉当factorial(3)执行时，会有如下事情发生。 计算机调用factorial(3)，并在该方法返回前，调用了factorial(2)，而在factorial(2)返回前，又调用了factorial(1)。从技术上来说，当计算机执行factorial(1)时，它其实还在factorial(2)之中，而factorial(2)又正在factorial(3)之中。 计算机是用栈来记录每个调用中的函数。这个栈就叫作调用栈。 让我们以factorial为例来观察调用栈如何运作。 起初计算机调用的是factorial(3)。然而，在该方法完成之前，它又调用了factorial(2)。为了记住自己还在factorial(3)中，计算机将此事压入调用栈中。 接着计算机开始处理factorial(2)。该factorial(2)会调用factorial(1)。不过在进入factorial(1)前，计算机得记住自己还在factorial(2)中，于是，它将此事也压入调用栈中。 然后计算机执行factorial(1)。因为1已经是基准情形了，所以它可以返回，不用再调用factorial。 尽管factorial(1)结束了，但调用栈内仍存在数据，意味着整件事还没完，计算机还处于其他函数当中。你应该还记得，栈的规定是只有栈顶元素（即最后的元素）才能被看到。所以，计算机接下来就去检查了调用栈的栈顶，发现那是factorial(2)。 由于factorial(2)是调用栈的最后一项，因此代表最近调用并且最应该先完成的是factorial(2)。 于是计算机将factorial(2)从调用栈弹出。 并将其结束。 然后计算机再次检查调用栈，看下一步应该结束哪个方法。调用栈如下所示。 于是计算机将factorial(3)从调用栈弹出，并将其结束。 到这里，调用栈就清空了，计算机也因此得知所有方法都执行完了，递归结束。 从更高的角度去看，可以看出计算机处理3的阶乘时，步骤如下。 (1)factorial(3)被第一个调用。 (2)factorial(2)被第二个调用。 (3)factorial(1)被第三个调用。 (4)factorial(1)被第一个完成。 (5)factorial(2)在factorial(1)的基础上完成。 (6)最后，factorial(3)在factorial(2)的基础上完成。 有趣的是，无限递归（如本章开头的例子）的程序会一直将同一方法加到调用栈上，直到计算机的内存空间不足，最终导致栈溢出的错误。 递归实战虽然上面的NASA倒数程序和阶乘计算能用递归来解决，但用普通的循环来做也不难。除了好玩以外，递归在这些问题上没体现出什么优势。 事实上，递归可以自然地用于实现那些需要重复自身的算法。在这些情况下，递归可以增强代码的可读性，你接下来就会看到。 比如说遍历文件系统。假设你现在要写一个脚本，它用于对一个目录下的所有文件进行某种操作。这里的“所有文件”，不仅指的是该目录中的文件，还包括其子目录的文件，以及子目录里的子目录的文件，以此类推。 我们先用Ruby写一个打印某目录下所有子目录名字的脚本。 123456789def find_directories(directory) Dir.foreach(directory) do |filename| if File.directory?("#&#123;directory&#125;/#&#123;filename&#125;") &amp;&amp; filename != "." &amp;&amp; filename != ".." puts "#&#123;directory&#125;/#&#123;filename&#125;" end endend# 以当前目录为参数，调用 find_directoriesfind_directories(".") 此脚本遍历给定目录下的所有文件。当遇到的某个文件为子目录时（即文件类型为目录，但又不是代表“当前目录”“上级目录”的句号和双句号的那些文件），将其名字打印出来。 虽然这跑起来没问题，但它只打印了当前目录的直属子目录的名字，并没有打印出那些子目录的子目录的名字。 接着我们改进一下，使该脚本能再深入到下一层目录。 1234567891011121314151617def find_directories(directory) # 遍历给定目录下的文件 Dir.foreach(directory) do |filename| if File.directory?("#&#123;directory&#125;/#&#123;filename&#125;") &amp;&amp; filename != "." &amp;&amp; filename != ".." puts "#&#123;directory&#125;/#&#123;filename&#125;" # 遍历其子目录下的文件 Dir.foreach("#&#123;directory&#125;/#&#123;filename&#125;") do |inner_filename| if File.directory?("#&#123;directory&#125;/#&#123;filename&#125;/#&#123;inner_filename&#125;") &amp;&amp;inner_filename != "." &amp;&amp; inner_filename != ".." puts "#&#123;directory&#125;/#&#123;filename&#125;/#&#123;inner_filename&#125;" end end end endend# 以当前目录为参数，调用 find_directoriesfind_directories(".") 这样，我们就可以对每个子目录再发起另一个循环去遍历其中的孙子目录了。不过，它只能进到两层目录的深度而已。如果我们还想进到第三层、第四层、第五层，甚至最底层，那要怎么做呢？以目前的思路似乎不可能实现。 这就是递归出马的时候了。使用递归的话，我们可以写一个进入任意深度的脚本，而且很简洁！ 1234567891011def find_directories(directory) Dir.foreach(directory) do |filename| if File.directory?("#&#123;directory&#125;/#&#123;filename&#125;") &amp;&amp; filename != "." &amp;&amp; filename != ".." puts "#&#123;directory&#125;/#&#123;filename&#125;" find_directories("#&#123;directory&#125;/#&#123;filename&#125;") end endend# 以当前目录为参数，调用 find_directoriesfind_directories(".") find_directories会对所遇到的每个子目录再调用find_directories 。这样一来，所有子目录都会被挖出来，没有一个会漏掉。 此算法如下图所示，其中的号码代表目录被访问的顺序。 注意，改用递归并不会改变算法的大O。但是，在下一章你会看到，递归可以作为算法的核心组件，影响算法的速度。 总结正如文件系统的例子所示，递归十分适用于那些无法预估计算深度的问题。 掌握递归，你就解锁了一批高效但更为高深的算法。它们都离不开递归的原理。 C#遍历指定文件夹下的所有文件和所有子目录]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL复制原理]]></title>
    <url>%2F2019%2F06%2F30%2FMySQL%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.如何创建一个空表？ 如果正确使用 MySQL 的复制，那么它就是一个非常有用的工具 ；但如果复制出现故障，或配置和使用不当，就会相当令人头疼。本章从一个简单的配置开始，涵盖 MySQL 复制的基础内容，然后介绍一些基本技巧以丰富你的“复制工具箱”。本章包括以下复制用例。通过热备份达到高可用性如果服务器宕机，一切都将停止 ：不能执行（可能很关键的）事务， 无法得到用户信息，也不能检索其他重要数据。要不惜（几乎）一切代价避免这种情况发生，因为它会严重破坏业务。最简单的方法就是配置一个额外的服务器专门作为热备份（hotstandby），在主服务器宕机的时候随时接管业务。2324复制的基本步骤 ｜ 19产生报表直接用服务器上的数据创建报表将大大降低服务器的性能，在某些情况下尤其显著。如果产生报表需要大量的后台作业，最好创建一个额外的服务器来运行这些作业。停止报表数据库上的复制，然后在不影响主要业务服务器的情况下运行大量查询，从而得到数据库在某一特定时间的快照。例如，如果在每天最后一个事务处理完毕后停止复制，可以提取日报表而其他业务仍正常运转。调试和审计还可以审查服务器上的查询。例如，查看某些查询是否有性能问题，以及服务器是否由于某个糟糕的查询而不同步。复制的基本步骤本章将介绍一些最大化复制的效率和价值的尖端技术。首先我们要搭建一个如图 3-1 所示的简单复制，即单一的主从复制实例。这里不需要了解内部架构或复制过程的执行细节（在介绍更复杂的方案之前，我们先探讨这些内容）。图3-1：简单的复制建立基本的复制可以总结为以下三个简单步骤 ： 配置一个服务器作为 master。 配置一个服务器作为 slave。 将 slave 连接到 master。除非你从一开始就规划了复制且正确配置了 my.cnf 文件，否则步骤 1 和步骤 2 要求必须重启每个服务器。2520 ｜ 第3章 MySQL复制原理执行这些步骤最简单的方法是拥有一个可以修改 my.cnf 文件权限的 shell 账号和一个具有 ALL 权限的服务器账号。 注 1必须严格限制在生产环境中授予权限。准确的指导方法请查阅本章后面的“配置复制的用户权限”。配置 master将服务器配置为 master，要确保该服务器有一个活动的二进制日志（binary log）和唯一的服务器 ID。我们后面再仔细研究二进制日志，现在只要知道二进制日志上保存了master 上的所有变更记录，并且可以在 slave 上重新执行。服务器 ID 用于区分服务器。要创建二进制日志和服务器 ID，你需要停掉服务器，然后按示例 3-1 所示将 log-bin 、log-bin-index 和 server-id 选项添加到 my.cnf 配置文件。加粗部分为添加的配置选项。示例3-1：向my.cnf添加选项以配置master[mysqld]user = mysqlpid-file = /var/run/mysqld/mysqld.pidsocket = /var/run/mysqld/mysqld.sockport = 3306basedir = /usrdatadir = /var/lib/mysqltmpdir = /tmplog-bin = master-binlog-bin-index = master-bin.indexserver-id = 1log-bin 选项给出了二进制日志产生的所有文件的基本名（稍后你将看到，二进制日志包含多个文件）。如果你创建了一个以 log-bin 为基本名的扩展文件名，该扩展名将被忽略，而只使用文件的基本名（也就是没有扩展的文件名）。log-bin-index 选项给出了二进制索引文件的文件名，这个索引文件保存了所有 binlog文件的列表。严格地说，不需要为 log-bin 选项提供值，其默认值是 hostname-bin 。 hostname 的值来自 pid-file 选项，默认值是主机名（可以通过 gethostname(2) 系统调用得到）。如果管理员后来修改了主机名，binlog 文件名也会随之改变，但是索引文件仍可以获取正确的值。最好为 MySQL 服务器创建一个机器无关的唯一的服务器名，因 binlog 文件序列中途改名可能会很混乱。如果没有为 log-bin-index 赋予任何值，其默认值与 binlog 文件的基本名相同（如果没有为 log-bin 提供值，则默认为 hostname-bin ）。也就是说，如果你不赋值给 log-bin-注 1 在 Windows 中，命令行工具（CMD）或 PowerShell 就相当于 UNIX 中的 shell。26复制的基本步骤 ｜ 21index ，索引文件名会随主机名的改变而改变。所以，如果你改变主机名然后重启服务器，将找不到索引文件，从而认为索引文件不存在，导致二进制日志为空。每个服务器都有一个唯一的服务器 ID，所以如果一个 slave 连接了 master，并且其server-id 的参数值与 master 相同，则会报 master 和 slave 服务器 ID 相同的错误。设置完配置文件后重启服务器，然后添加一个复制用户，这样便完成了配置。修改 master 的配置文件以后，重启 master，使配置生效。slave 启动一个标准的客户端连到 master，并请求 master 将所有的变更发送给它。slave连接时要求 master 上有一个特殊复制权限的用户。示例 3-2 展示了 master 上的一个标准的 mysql 客户端会话，通过命令创建新用户并赋予适当的权限。示例3-2：在master上创建一个复制用户master&gt; CREATE USER repl_user;Query OK, 0 rows affected (0.00 sec)master&gt; GRANT REPLICATION SLAVE ON . -&gt; TO repl_user IDENTIFIED BY ‘xyzzy’;Query OK, 0 rows affected (0.00 sec)REPLICATION SLAVE 权限并没有什么特别之处，不过拥有这个权限的用户能够获取 master 上的二进制日志。完全可以给一个常规用户赋予 REPLICATIONSLAVE 权限，但最好还是将复制 slave 用户与其他用户区别开来。这样的话，以后如果想禁止某些 slave 的连接，只要删除该用户就可以了。配置 slave配置完 master 后，还需要配置 slave。与 master 一样，需要为每个 slave 分配一个唯一的服务器 ID。分别使用 relay-log 和 relay-log-index 选项向 my.cnf 文件添加中继日志文件（relay log file）和中继日志索引文件（relay log index file）的文件名（我们将在第 8章的“复制架构基础”小节中详细讨论中继日志）。示例 3-3 给出了推荐的配置选项，其中新添加的选项加粗表示。示例3-3：向my.cnf文件添加选项来配置slave[mysqld]user = mysqlpid-file = /var/run/mysqld/mysqld.pidsocket = /var/run/mysqld/mysqld.sockport = 33062722 ｜ 第3章 MySQL复制原理basedir = /usrdatadir = /var/lib/mysqltmpdir = /tmpserver-id = 2relay-log-index = slave-relay-bin.indexrelay-log = slave-relay-bin与 log-bin 和 log-bin-index 选项一样， relay-log 和 relay-log-index 选项的默认值取决于 hostname。 relay-log 的默认值是 hostname-relay-bin ， relay-log-index 的默认值是 hostname-relay-bin.index 。使用默认值有一个问题，即一旦服务器的主机名改变，将会因为无法找到中继日志索引文件而认为中继日志文件为空。修改 my.cnf 文件以后，重启 slave，使配置生效。配置复制的用户权限要把 slave 连接到 master 做复制，除了需要一个能访问关键文件的 shell 账户，还要有一个具有特定权限的账户。出于安全原因，通常要严格控制这个账号只具备配置 master 和 slave 所需的必要权限。为了创建和删除用户，这个账号需要具备CREATE USER 权限。为了将 REPLICATION SLAVE 权限赋予复制账号，还需要具有GRANT OPTION 的 REPLICATION SLAVE 权限。要进一步执行复制相关的工作（本章稍后将介绍），还需要更多选项 ：y 执行 FLUSH LOGS 命令（或任何 FLUSH 命令）需要 RELOAD 权限。y 执行 SHOW MASTER STATUS 和 SHOW SLAVE STATUS 命令需要 SUPER 或 REPLICATIONCLIENT 权限。y 执行 CHANGE MASTER TO 命令需要 SUPER 权限。举个例子，向用户 mats 赋予足够的权限以完成本章中的所有工作，使用如下命令：server&gt; GRANT REPLICATION SLAVE, RELOAD, CREATE USER, SUPER-&gt; ON .-&gt; TO mats@’192.168.2.%’-&gt; WITH GRANT OPTION;连接 master 和 slave现在创建基本的复制只剩下最后一步了 ：将 slave 定向到 master，让它知道从哪里进行复制。为此，我们需要知道 master 的 4 部分信息 ：28二进制日志简介 ｜ 23y 主机名y 端口号y 具备 REPLICATION SLAVE 权限的用户账号y 该用户账号的密码在配置 master 的时候，我们已经创建了一个具备适当权限的用户账号及密码。主机名由操作系统确定，无法在 my.cnf 文件中配置，但端口号可以在 my.cnf 中分配（如果没有指定端口号，将使用默认值 3306）。创建和运行复制的最后两步是 ：使用 CHANGE MASTERTO 命令将 slave 定向到 master，然后用 START SLAVE 启动复制 ：slave&gt; CHANGE MASTER TO-&gt; MASTER_HOST = ‘master-1’,-&gt; MASTER_PORT = 3306,-&gt; MASTER_USER = ‘repl_user’,-&gt; MASTER_PASSWORD = ‘xyzzy’;Query OK, 0 rows affected (0.00 sec)slave&gt; START SLAVE;Query OK, 0 rows affected (0.15 sec)恭喜！你已经建立了第一个 master 与 slave 之间的复制。如果你在 master 的数据库上做一些改动，例如创建新表并填充数据，将发现这些变更都会复制到 slave。试试吧！建立一个测试数据库（如果还没有的话），再创建一些表，然后添加一些数据到表中，看看这些变更是否会复制到 slave 中。注意， MASTER_HOST 参数的值可以是主机名或 IP 地址。如果是主机名，则可以通过调用gethostname(3) 得到对应的 IP 地址，即通过域名查找来解析主机名，其结果与配置有关。配置域名解析的步骤不在本书讨论的范围内。二进制日志简介复制过程需要使用二进制日志（binary log，或者 binlog），它记录了服务器数据库上的所有变更。你需要理解二进制日志是如何控制复制过程或解决问题的，所以本节我们将介绍一些背景知识。图 3-2 展示了复制架构示意图，图中包括 master、二进制日志和 slave，其中 slave 通过二进制日志获取 master 上的变更。我们将在第 8 章详细阐述复制架构。当某条语句即将执行结束时，将在二进制日志的末尾写入一条记录，同时通知语句解析器语句已经执行完毕。2924 ｜ 第3章 MySQL复制原理图3-2：二进制日志在复制中的作用通常只有即将执行完毕的语句才会被写入二进制日志，但是在一些特殊情况下可能会写入其他信息，包括语句的附加信息或者直接代替语句被写入。不久你就会知道这么做的原因，但是目前我们假设只有执行的语句才会写入二进制日志。二进制日志记录了什么二进制日志的作用是记录数据库中表的更改，然后用于复制和 PITR（即时恢复，将在第15 章中讨论），另外少数审计情况下也会用到。注意，二进制日志只包括数据库的改动，所以对那些不改变数据的语句则不会写入二进制日志。从传统意义上说，MySQL 复制记录了产生变化的 SQL 语句，称为基于语句的复制（statement-based replication）。由于基于语句的复制会在 slave 上重新执行语句，如果master 和 slave 的上下文环境不完全一致的话，可能导致 slave 上的结果与 master 不同。所以在 5.1 版本中，MySQL 还提供了基于行的复制（row-based replication）。相比基于语句的复制，基于行的复制将每一条记录记为二进制日志中的一行。基于行的复制不仅更加方便，而且有时候速度更快。考虑一个含有多表连接或 WHERE 条件的复杂更新，看看这两种复制有什么不同。你真正需要知道的是更新后数据的状态，而不是像基于语句的复制那样把所有的逻辑都在 slave上重新执行。另一方面，如果某个更新改变了 10 000 行，你可能宁愿只记录这个语句，而不是像基于行的复制那样去记录 10 000 个单独的改动。我们将在第 8 章涉及基于行的复制，介绍它的实现和使用。下面的例子重点讲解基于语句的复制，这样更容易理解数据库的执行。30二进制日志简介 ｜ 25观察复制的动作用上一节中的复制例子，我们来看一些简单语句的 binlog 事件。先使用命令行客户端连接 master，然后执行一些命令获取二进制日志 ：master&gt; CREATE TABLE tbl (text TEXT);Query OK, 0 rows affected (0.04 sec)master&gt; INSERT INTO tbl VALUES (“Yeah! Replication!”);Query OK, 1 row affected (0.00 sec)master&gt; SELECT * FROM tbl;+——————–+| text |+——————–+| Yeah! Replication! |+——————–+1 row in set (0.00 sec)master&gt; FLUSH LOGS;Query OK, 0 rows affected (0.28 sec)FLUSH LOGS 命令强制轮换（rotate）二进制日志，从而得到一个“完整的”二进制日志文件。使用 SHOW BINGLOG EVENTS 命令进一步查看该文件，如示例 3-4 所示。示例3-4：检查二进制日志中有哪些事件master&gt; SHOW BINLOG EVENTS\G*** 1. row ***Log_name: mysql-bin.000001Pos: 4Event_type: Format_descServer_id: 1End_log_pos: 107Info: Server ver: 5.5.34-0ubuntu0.12.04.1-log, Binlog ver: 4*** 2. row ***Log_name: mysql-bin.000001Pos: 107Event_type: QueryServer_id: 1End_log_pos: 198Info: use test; CREATE TABLE tbl (text TEXT)*** 3. row ***Log_name: mysql-bin.000001Pos: 198Event_type: Query3126 ｜ 第3章 MySQL复制原理Server_id: 1End_log_pos: 266Info: BEGIN*** 4. row ***Log_name: mysql-bin.000001Pos: 266Event_type: QueryServer_id: 1End_log_pos: 374Info: use test; INSERT INTO tbl VALUES (“Yeah! Replication!”)*** 5. row ***Log_name: mysql-bin.000001Pos: 374Event_type: XidServer_id: 1End_log_pos: 401Info: COMMIT /* xid=188 /*** 6. row ***Log_name: mysql-bin.000001Pos: 401Event_type: RotateServer_id: 1End_log_pos: 444Info: mysql-bin.000002;pos=46 rows in set (0.00 sec)这个二进制日志包含 6 个事件 ：一个格式描述事件、三个查询事件，一个 XID 事件，以及一个日志轮换（rotate）事件。查询事件用于描述如何将数据库上执行的语句写入二进制日志，XID 事件用于事务管理，而格式描述事件和日志轮换事件则用于在服务器内部管理二进制日志。第 8 章将详细讨论这些事件，这里我们先简单看一下每个事件所包含的字段。Event_type这是事件的类型。这里我们已经看到了三种类型，但还有很多类型。事件的类型表明什么样的信息会被传送给 slave。目前在 MySQL 5.1.18 到 5.5.33 版本中，一共有 27种事件类型（其中有些事件是不使用的，但是为了向后兼容而保留了），到 5.6.12 版本已经有 35 种事件类型了。这个范围是可扩展的，需要的话可以添加新的事件类型。Server_id这是创建事件的服务器的 ID。Log_name这是用来存储事件的文件名。一个事件只能存储在一个文件中，永远不能跨两个文件。32二进制日志简介 ｜ 27Pos这是事件在文件中的开始位置，即事件的第一个字节。End_log_pos这是事件在文件中的结束位置，也是下一个事件的开始位置。这个位置比事件的最后一个字节高一位，因此事件的字节范围为 Pos 到 End_log_pos － 1 。通过计算End_log_pos － Pos 可以得到这个事件的长度。Info这是关于事件信息的可读文本。不同的事件会显示不同的信息，不过至少可以通过查询事件来知道它所包含的语句。前两个字段 Log_name 和 Pos 组成了事件的二进制日志位置（binlog position），用于标识事件的地点或位置。除了以上字段以外，每个事件还包括很多其他信息，例如时间戳，即从纪元（用经典的 UNIX 时间格式表示，例如 1970-01-01 00:00:00 UTC）开始的秒数。二进制日志的结构和内容前面讲过，二进制日志并不是一个单独的文件，而是由一系列易于管理的（例如在不影响新日志的情况下移除旧的日志）文件组成的。二进制日志包括一组存储实际内容的二进制日志文件和一个用来跟踪二进制日志文件存储位置的二进制日志索引文件。图 3-3给出了二进制日志的组织结构。图3-3：二进制日志的结构有一个二进制日志文件是活动二进制日志文件（active binlog file），即当前正在被写入的文件（通常也从这个文件读取）。每个二进制日志文件都以格式描述事件（format description event）开始，以日志轮换事3328 ｜ 第3章 MySQL复制原理件（rotate event）结束。格式描述日志事件包括产生该文件的服务器版本号、服务器及二进制日志的信息等。日志轮换事件包含下一个二进制日志文件的名称，以告知二进制日志继续写入哪个文件。每个二进制日志文件中有多个二进制日志事件，各个事件之间相互独立，同时也是构成二进制日志的基本单位。格式描述日志事件还有一个标记，标记二进制日志文件是否正常关闭。如果正在写入二进制日志文件，则设置该标记 ；如果文件关闭，则清除该标记。这样就可以检测出在崩溃事件中损坏的二进制日志文件，并允许通过复制进行恢复。如果在 master 上执行其他语句，你会发现一件奇怪的事情——看不到二进制日志中的变化 ：master&gt; INSERT INTO tbl VALUES (“What’s up?”);Query OK, 1 row affected (0.00 sec)master&gt; SELECT * FROM tbl;+——————–+| text |+——————–+| Yeah! Replication! || What’s up? |+——————–+1 row in set (0.00 sec)master&gt; SHOW BINLOG EVENTS\Gsame as before新事件哪去了？我们已经知道，二进制日志由若干文件组成，而 SHOW BINLOG EVENTS 语句只显示第一个二进制日志文件的内容。这与大多数用户的期望相反，他们想看的是活动二进制日志文件的内容。如果第一个二进制日志的文件名是 master-bin.000001（这个文件包含前面显示的事件），你可以使用下面的命令查看下一个二进制日志文件（这里即文件 master-bin.000002）中的事件 ：master&gt; SHOW BINLOG EVENTS IN ‘master-bin.000002’\G*** 1. row ***Log_name: mysql-bin.000002Pos: 4Event_type: Format_descServer_id: 1End_log_pos: 107Info: Server ver: 5.5.34-0ubuntu0.12.04.1-log, Binlog ver: 434二进制日志简介 ｜ 29*** 2. row ***Log_name: mysql-bin.000002Pos: 107Event_type: QueryServer_id: 1End_log_pos: 175Info: BEGIN*** 3. row ***Log_name: mysql-bin.000002Pos: 175Event_type: QueryServer_id: 1End_log_pos: 275Info: use test; INSERT INTO tbl VALUES (“What’s up?”)*** 4. row ***Log_name: mysql-bin.000002Pos: 275Event_type: XidServer_id: 1End_log_pos: 302Info: COMMIT / xid=196 /4 rows in set (0.00 sec)你可能已经注意到在示例 3-4 中，二进制日志以日志轮换事件结尾， Info 字段包含下一个二进制日志文件名和事件的开始位置。使用 SHOW MASTER STATUS 命令查看当前正在写入的是哪个二进制日志文件 ：master&gt; SHOW MASTER STATUS\G** 1. row ***File: master-bin.000002Position: 205Binlog_Do_DB:Binlog_Ignore_DB:1 row in set (0.00 sec)查看二进制日志以后，停止并重置 slave，然后删除表 ：master&gt; DROP TABLE tbl;Query OK, 0 rows affected (0.00 sec)slave&gt; STOP SLAVE;Query OK, 0 rows affected (0.08 sec)slave&gt; RESET SLAVE;Query OK, 0 rows affected (0.00 sec)3530 ｜ 第3章 MySQL复制原理接着，删除表，然后重置 master 刷新 ：master&gt; DROP TABLE tbl;Query OK, 0 rows affected (0.00 sec)master&gt; RESET MASTER;Query OK, 0 rows affected (0.04 sec)RESET MASTER 命令删除了所有二进制日志文件并清空了二进制日志索引文件。 RESETSLAVE 命令删除了 slave 上复制用的所有文件，重新开始。无论是 RESET MASTER 还是 RESET SLAVE 都要求没有活动的复制正在运行。因此 ：y 执行 RESET MASTER 命令（在 master 上）时，确保没有 slave 连接到该 master。y 执行 RESET SLAVE 命令（在 slave 上）时，先执行 STOP SLAVE 命令，确保 slave 上没有活动的复制。本章涵盖了大多数基本事件，而完整详细的事件列表请参考 MySQL 内部手册（http://bit.ly/mysql-manual）。建立新 slave既然你已经对二进制日志有所了解，下面我们要解决之前创建 slave 的过程中存在的一个基本问题。前面配置 slave 时，我们并没有说明复制从哪里开始，所以 slave 将从头开始读取 master 上的二进制日志。如果 master 已经运行了一段时间，这显然不是个好方法：不仅会在 slave 上大量重放事件，还可能导致有些日志无法获取，因为它们可能由于安全原因存储在其他地方，master 上也没有这些日志信息（第 15 章介绍备份和 PITR 时将进一步讨论这个）。所以我们需要另一种方法来建立新的 slave（又称自举 slave），而不是从头开始复制。这里 CHANGE MASTER TO 命令有两个有用的参数，即： MASTER_LOG_FILE 和 MASTER_LOG_POS 。（从 MySQL 5.6 开始，又出现了另一种更简便的方式来指定这些位置，包括全局事务标识符，GTID 等，更多内容参见第 8 章。）使用这些参数指定 master 开始发送事件的binlog 位置，而不是从头开始。向 CHANGE MASTER TO 命令添加上述参数，按照以下步骤建立新的 slave ：1． 配置新的 slave。36建立新slave ｜ 312． 备份 master （或者备份已经复制了 master 的 slave）。参见第 15 章中的常用备份技术。3． 记下该备份相应的binlog位置（即产生master当前状态的最后一个事件所在的位置）。4． 在新 slave 上恢复备份。参见第 15 章中的常用恢复技术。5． 配置 slave 从这个 binlog 位置开始复制。根据第 2 步使用的是 master 还是 slave，处理过程略有差异。我们先看只有一个服务器且作为 master 运行时，如何引导新 slave，这个过程称为克隆 master。克隆 master 是指获取服务器的快照，通常通过创建备份来完成。服务器的备份技术有很多，但本章仅使用较为简单的技术，即运行 mysqldump 来创建逻辑备份。其他备份技术包括 ：通过复制数据库文件创建物理备份，诸如 MySQL 企业备份工具的在线备份技术，以及使用 Linux 的 LVM（Logical Volume Manager，逻辑卷管理器）进行卷快照等。这些技术将在第 15 章进行详细介绍，并讨论它们各自的优点。克隆 master虽然 mysqldump 工具可以一步完成所有步骤，但为了解释必要的操作，这里我们将单独执行每个步骤。本节后面会提供一个更紧凑的版本。如图 3-4 所示，克隆 master 首先要创建 master 的备份。由于 master 可能正在运行，而且缓存中有很多表，所以需要刷新（flush）所有表并锁定数据库，防止在检查 binlog 位置之前数据库发生改变。使用 FLUSH TABLES WITH READ LOCK 命令来完成 ：master&gt; FLUSH TABLES WITH READ LOCK;Query OK, 0 rows affected (0.02 sec)图3-4：克隆master来创建新的slave一旦数据库被锁定，就可以创建备份，并记录 binlog 位置了。注意，这时不应该断开服3732 ｜ 第3章 MySQL复制原理务器连接，因为那会导致锁被释放。由于 master 没有任何改动， SHOW MASTER STATUS命令将正确返回当前二进制日志文件及其 binlog 位置。我们将在第 8 章详细讨论 SHOWMASTER STATUS 和 SHOW MASTER LOGS 命令。master&gt; SHOW MASTER STATUS\G*** 1. row ***File: master-bin.000042Position: 456552Binlog_Do_DB:Binlog_Ignore_DB:1 row in set (0.00 sec)下一个事件的写入位置是 master-bin.000042 : 456552 ，这就是复制的起点，这个位置点之前的所有东西都在备份里。记下 binlog 位置后就可以创建备份了。创建数据库备份最简单的方法是用 mysqldump ：$ mysqldump –all-databases –host=master-1 &gt;backup.sql有了可靠的 master 副本，就可以为数据库中的表解锁，允许数据库继续处理查询。master&gt; UNLOCK TABLES;Query OK, 0 rows affected (0.23 sec)接下来，在 slave 上使用 mysql 实用工具恢复备份 ：$ mysql –host=slave-1 &lt;backup.sql已经在 slave 上恢复了 master 的备份，现在可以启动 slave 了。利用前面记下的 master的 binlog 位置，使用 CHANGE MASTER TO 命令配置 slave，然后启动 slave ：slave&gt; CHANGE MASTER TO-&gt; MASTER_HOST = ‘master-1’,-&gt; MASTER_PORT = 3306,-&gt; MASTER_USER = ‘slave-1’,-&gt; MASTER_PASSWORD = ‘xyzzy’,-&gt; MASTER_LOG_FILE = ‘master-bin.000042’,-&gt; MASTER_LOG_POS = 456552;Query OK, 0 rows affected (0.00 sec)slave&gt; START SLAVE;Query OK, 0 rows affected (0.25 sec)mysqldump 可以自动执行前面的所有步骤。要对 master 服务器上的所有数据库进行逻辑备份，输入 ：38建立新slave ｜ 33$ mysqldump –host=master -all-databases \ –master-data=1 &gt;backup-source.sql–master-data=1 选项使 mysqldump 产生 CHANGE MASTER TO 语句，其参数为二进制日志文件及其位置（可通过 SHOW MASTER STATUS 得到）。然后就可以在 slave 上恢复备份了 ：$ mysql –host=slave-1 &lt;backup-source.sql注意，只有克隆 master 的时候能用 –master-data=1 自动执行 CHANGE MASTER TO 语句。后面克隆 slave 的时候，这些步骤都要分开执行。恭喜！现在你已经克隆了 master，并建立和运行了一个新 slave。根据 master 的负载情况，你可能需要 slave 从前面记录的位置开始同步，这比从头开始容易得多。根据备份需要的时间长短不同，可能有大量的数据需要同步，所以，在将 slave 联机（online）之前，首先要仔细阅读第 6 章的“数据的一致性管理”一节。克隆 slave只要有一个 slave 连在 master 上，就可以使用这个 slave 创建新的 slave，而不需要再离线（offline）master 了。如果数据库很大或访问量较高，那么停机时间可能会相当长，因为既要考虑创建备份的时间又要考虑 slave 同步的时间。克隆 slave 的过程如图 3-5 所示，与克隆 master 基本相同，区别在于如何找到 binlog 位置。另外，需要注意你克隆的那个 slave 同时还在执行从 master 的复制。图3-5：克隆slave以创建一个新的slave首先，必须在备份前停止 slave，保证 slave 上不再有变化发生。如果创建备份时复制仍3934 ｜ 第3章 MySQL复制原理在进行，而在备份期间数据库又发生了变化，这时就会得到不一致的备份映像。但是，如果使用某种在线备份方法，如 MySQL 企业备份工具，则不需要在创建备份前停止slave。停止 slave 是这样的 ：original-slave&gt; STOP SLAVE;Query OK, 0 rows affected (0.20 sec)slave 停止以后，就可以像从前一样刷新数据表，然后创建备份。创建了 slave 的备份（而不是 master 的备份）后，使用 SHOW SLAVE STATUS 命令（而不是 SHOW MASTER STATUS ）来确定从哪里开始复制。该命令会输出很多内容，第 8 章将详细介绍。如果要获得master 二进制日志中 slave 即将执行的下一个事件的位置，请注意 Relay_Master_Log_File 和 Exec_Master_Log_Pos 字段的值。original-slave&gt; SHOW SLAVE STATUS\G…Relay_Master_Log_File: master-bin.000042…Exec_Master_Log_Pos: 546632创建备份，然后在新 slave 上恢复备份以后，将复制的起点配置为从这个位置开始，然后启动新的 slave ：new-slave&gt; CHANGE MASTER TO-&gt; MASTER_HOST = ‘master-1’,-&gt; MASTER_PORT = 3306,-&gt; MASTER_USER = ‘slave-1’,-&gt; MASTER_PASSWORD = ‘xyzzy’,-&gt; MASTER_LOG_FILE = ‘master-bin.000042’,-&gt; MASTER_LOG_POS = 546632;Query OK, 0 rows affected (0.19 sec)new-slave&gt; START SLAVE;Query OK, 0 rows affected (0.24 sec)克隆 master 和克隆 slave 只有一些细节上的区别，这意味着我们的 Python 程序库可以将这两者合并成一个过程，即在源服务器上创建备份从而创建新的 slave，然后将这个新slave 连接到 master。创建备份的常见方法是调用 FLUSH TABLES WITH READ LOCK ，然后在 MySQL 服务器被读锁锁住的时候创建一份数据库文件的副本。这通常比 mysqldump 快很多，但是在InnoDB 中使用 FLUSH TABLES WITH READ LOCK 是不安全的！40建立新slave ｜ 35FLUSH TABLES WITH READ LOCK 会锁住表，阻止新事务发生，但后台仍然有一些 FLUSHTABLES WITH READ LOCK 阻止不了的活动在继续进行。使用下面的方法可安全地创建 InnoDB 数据表的备份 ：y 关闭服务器，然后复制文件。如果数据库很大，最好采取这种方法，因为这时使用 mysqldump 进行数据恢复会很慢。y 执行 FLUSH TABLES WITH READ LOCK （前面已经介绍过）命令后，使用mysqldump 工具。读锁保证读取数据的时候不会产生变更。如果有大量数据要读的话，数据库可能长时间处于被锁的状态。注意，使用 –single-transaction选项也可以获得一致的快照，但只对 InnoDB 表有效。更多内容参见第 15 章的“mysqldump 工具”一节。y 执行 FLUSH TABLES WITH READ LOCK 锁定数据库后，执行某种快照方案，例如LVM（Linux 平台）或者 ZFS（Zettabyte File System）。y 使用 MySQL 企业备份工具（或 XtraBackup）做 MySQL 联机备份。克隆操作的脚本Python 程序库实现克隆 master 的方法很简单，使用一个 Server 对象代表 master，然后从这个 master 上复制数据库即可。使用 clone 函数即可实现，见示例 3-6。克隆 slave 的过程类似，但它是在一台服务器上创建备份，然后新 slave 连接到另一台服务器进行复制。同时支持 master 和 slave 的克隆操作很容易，只需要使用两个参数 ：source 参数指定从哪里创建备份， use_master 参数指出备份恢复后 slave 需要连接的服务器。 clone 方法的调用格式是这样的 ：clone(slave = slave[1], source = slave[0], use_master = master)下面要写一些实用工具函数来实现克隆功能，这些函数在其他地方也可以派上用场。示例 3-5 用到了如下函数 ：fetch_master_pos从 master 获取 binlog 位置（即 master 即将写入二进制日志的下一个事件的位置）。fetch_slave_pos从 slave 获取 binlog 位置（即从 master 读取的下一个事件的位置）。replicate_from需要提供的参数包括 slave、master 及 binlog 位置，将 slave 定向到 master，并从给定的 binlog 位置开始复制。4136 ｜ 第3章 MySQL复制原理replicate_from 函数从 master 上读取 repl_user 字段获取复制用户的用户名和密码。但Server 类的定义中并没有该字段，它是服务器注入 Master 角色时添加的字段。示例3-5：获取服务器的master和slave位置的功能函数_CHANGE_MASTER_TO = “””CHANGE MASTER TOMASTER_HOST=%s, MASTER_PORT=%s,MASTER_USER=%s, MASTER_PASSWORD=%s,MASTER_LOG_FILE=%s, MASTER_LOG_POS=%s”””def replicate_from(slave, master, position):slave.sql(_CHANGE_MASTER_TO, (master.host, master.port,master.repl_user.name,master.repl_user.passwd,position.file, position.pos))def fetch_master_pos(server):result = server.sql(“SHOW MASTER STATUS”)return Position(server.server_id, result[“File”], result[“Position”])def fetch_slave_pos(server):result = server.sql(“SHOW SLAVE STATUS”)return Position(server.server_id, result[“Relay_Master_Log_File”],result[“Exec_Master_Log_Pos”])这些都是创建 clone 函数所需要的函数。如果要克隆 slave，应用程序传递一个单独的use_master 参数，让 clone 函数将新 slave 定向到该 master 做复制。如果要克隆 master，应用程序则忽略这个 use_master 参数，让 clone 函数使用“source”服务器作为 master。创建服务器备份的方法有很多，示例 3-6 仅选择了一种方法，即使用 mysqldump 创建服务器的逻辑备份。稍后我们将演示如何将这个备份过程通用化，使得无论采用任何备份方法都可以使用相同的基本代码建立新 slave。示例3-6：克隆master或Slave的函数def clone(slave, source, use_master = None):from subprocess import callbackup_file = open(server.host + “-backup.sql”, “w+”)if master is not None:source.sql(“STOP SLAVE”)lock_database(source)if master is None:position = fetch_master_position(source)else:position = fetch_slave_position(source)call([“mysqldump”, “–all-databases”, “–host=’%s’” % source.host],42执行常见的复制任务 ｜ 37stdout=backup_file)if master is not None:start_slave(source)backup_file.seek() # Rewind to beginningcall([“mysql”, “–host=’%s’” % slave.host], stdin=backup_file)if master is None:replicate_from(slave, source, position)else:replicate_from(slave, master, position)start_slave(slave)执行常见的复制任务每个常见的复制案例，包括横向扩展（scale out）、热备份（hot standby）等，都有其实现细节和可能的陷阱。下面将向读者展示如何执行某些任务，以及如何使 Python 程序库支持这些任务。本节中的例子省略了密码。配置某些控制服务器的账户时，可以设置只允许某些控制部署的特定主机访问（通过创建类似 mats@’192.168.2.136’ 这样的账户），或者也可以给这些命令设置密码。报表大多数企业需要大量的例行报告，包括已售物品的周报表，开支和收入的月报表，以及大量的数据挖掘报表，以发现某些趋势或为营销部门识别重点群体等。在 master 上运行这些查询会很麻烦。数据挖掘查询可能需要大量的计算资源，拖慢正常操作，而结果却发现不值得那么做，比如把左撇子作为重点群体。此外，这些报表通常不是很紧急（与处理日常事务相比），所以没有必要尽快创建报表。换句话说，这些报表对时间要求不严格，即使一个小时不够，花两个小时完成也没什么关系。更好的办法是，使用一个空闲的服务器（或者两个，如果真有那么多报表需求的话），搭建一个到 master 的复制。如果需要做报表的话，就停止复制，执行报表程序，然后再重启复制，这样完全不会干扰 master。报表往往需要精确的间隔时间，如汇总当天所有的销售额，需要在适当的时候停止复制，而不至于将第二天的销售额也计入前一天的报表。然后，没有特定日期或时间的事件发生，就无法停止 slave，所以必须得想其他的方法。4338 ｜ 第3章 MySQL复制原理假设每天做一次报表，包括所有从午夜 12 点到下一个午夜 12 点的交易。需要在午夜 12点停止报表 slave，确保 12 点以后 slave 上不再有新的事件执行而 12 点以前的所有事件都已经执行完毕。我们并不想手动执行此操作，所以考虑如何使这个过程自动化。可按照以下步骤执行 ：1． 12 点前，也可能是 12 点前 5 分钟，停止报表 slave，确保不会再从 master 接收事件。2． 12 点后，检查 master 上的二进制日志，找到 12 点前记录的最后一个事件。显然，如果在 12 点之前进行这一步操作，可能无法得到当天的所有事件。3． 记录该事件的 binlog 位置，然后启动 slave。4． 直到 slave 同步到这个位置后停止。第一个问题是如何正确地调度任务。调度任务的方法很多，与操作系统有关。这里我们不会详细讨论这个问题，但你可以在本章后面的“在 UNIX 上任务调度”一节中看到如何在类 UNIX 操作系统（如 Linux）中调度任务。停止 slave 很简单，执行 STOP SLAVE 命令，然后在 slave 停止后记录 binlog 位置 ：slave&gt; STOP SLAVE;Query OK, 0 rows affected (0.25 sec)slave&gt; SHOW SLAVE STATUS\G…Relay_Master_Log_File: capulet-bin.000004…Exec_Master_Log_Pos: 24561 row in set (0.00 sec)其他三个步骤要在实际报表开始前执行，通常作为实际报表脚本的一部分。在描述脚本之前，我们先考虑每个步骤是怎样执行的。调用 mysqlbinlog 命令读取二进制日志的内容。这一点后面会详细介绍，第二步中使用了这个工具。mysqlbinlog 命令提供了两个选项，用于部分读取二进制日志，即 –start-datetime 和 –stop-datetime 。因此，要获得从停止 slave 时刻到 12 点期间的所有事件，可以使用以下命令 ：$ mysqlbinlog –force –read-from-remote-server –host=reporting.bigcorp.com –start-datetime=’2009-09-25 23:55:00’–stop-datetime=’2009-09-25 23:59:59’ binlog files事件中存储的时间戳是指语句开始执行的时间戳，而不是它写入二进制日志的时间戳。44执行常见的复制任务 ｜ 39–stop-datetime 选项说明在指定 date/time 后的第一个时间戳时刻停止产生事件。可能有些事件，它们在 date/time 之前开始执行，但却在 date/time 后才写入二进制日志，这样的事件不包括在内。由于这时 master 正在写二进制日志，需要提供 –force 选项。否则，mysqlbinlog 无法读取已打开的二进制日志。这个命令需要提供一组 binlog 文件作为参数。由于这些文件的名称取决于配置选项，所以只能从服务器上获取这些文件名。然后，要搞清楚mysqlbinlog 命令需要哪些 binlog 文件。使用 SHOW BINARY LOGS 命令可以很容易地获取binlog 文件名列表 ：master&gt; SHOW BINARY LOGS;+——————–+———–+| Log_name|File_size |+——————–+———–+| capulet-bin.000001 | 24316 || capulet-bin.000002 | 1565 || capulet-bin.000003 | 125 || capulet-bin.000004 | 2749 |+——————–+———–+4 rows in set (0.00 sec)本例只有 4 个 binlog 文件，但其实 binlog 文件可以有很多。在停止 slave 前扫描这么多文件只是浪费时间，所以最好能减少需要读取的文件数量，以便确定 slave 停止的正确位置。由于第 1 步中已经记下了 binlog 位置，由此可知 slave 停止运行时的 binlog 文件名，然后将该文件名及其后面所有的文件名作为 mysqlbinlog 实用工具的输入。通常输入参数只有一个文件（或者有两个，比如在关闭 slave 之后、启动报表事件之前的二进制日志轮换时）。当使用 mysqlbinlog 命令解析少数几个 binlog 文件时，将输出事件相关的文本信息。$ mysqlbinlog –force –read-from-remote-server –host=reporting.bigcorp.com –start-datetime=’2009-09-25 23:55:00’–stop-datetime=’2009-09-25 23:59:59’ capulet-bin.000004/!40019 SET @@session.max_insert_delayed_threads=0/;/!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0/;DELIMITER /!/; at 4#090909 22:16:25 server id 1 end_log_pos 106 Start: binlog v 4, server v…ROLLBACK/!/;...4540 ｜ 第3章 MySQL复制原理 at 2495#090929 23:58:36 server id 1 end_log_pos 2650 Query thread_id=27 exe…SET TIMESTAMP=1254213690/!/;SET /!/;INSERT INTO message_board(user, message)VALUES (‘mats@sun.com’, ‘Midnight, and I’m bored’)/!/;有趣的是，最后一个事件的 end_log_pos 参数（本例中该值为 2650），就是 12 点后的下一个事件即将被写入的位置。如果注意观察前面的命令输出结果，你会发现我们并不知道这个字节位置指向哪个binlog 文件，而 mysqlbinlog 需要指定一个文件来查找这个事件。如果 mysqlbinlog 命令的参数是单个文件，显然就用这个文件查找 ；但如果参数是两个文件，则必须确定当天最后一个事件在哪个文件里。观察含有 end_log_pos 的那行，还会看到事件类型信息。每个 binlog 文件都是以格式描述事件开始，这些事件会出现在前面的命令输出结果中。检查这些事件，就可以确定要查找的事件的位置。如果有两个格式描述事件，则该事件在第二个文件中 ；如果只有一个格式描述事件，则在第一个文件中。报表工作开始前的最后一步是启动复制，然后在正确的位置停止它，即午夜 12 点以后的事件写入位置（即将写入或已被写入）。可以使用不太常用的命令 START SLAVE UNTIL来完成。该命令的参数包括 master 日志文件，以及 slave 停止时对应的 master 日志位置。一旦 slave 到达指定位置，就会自动停止。report&gt; START SLAVE UNTIL-&gt; MASTER_LOG_POS=’capulet-bin.000004’,-&gt; MASTER_LOG_POS=2650;Query OK, 0 rows affected (0.18 sec)与 STOP SLAVE 命令（不含 UNTIL ）一样， START SLAVE UNTIL 命令也会立即返回，但是如果 slave 已到达停止位置则不再返回。所以，只要 slave 还在运行，在 STOP SLAVEUNTIL 之后发出的命令仍会继续执行。使用 MASTER_POS_WAIT 函数等待 slave 到达停止位置，该函数会阻塞执行直到 slave 到达指定位置。report&gt; SELECT MASTER_POS_WAIT(‘capulet-bin.000004’, 2650);Query OK, 0 rows affected (231.15 sec)现在 slave 在当天最后一个事件处停止了，报表过程可以开始分析数据和生成报告了。46执行常见的复制任务 ｜ 41使用 Python 处理报表使用 Python 进行自动化报表处理是很简单的。示例 3-7 给出了在适当的时候停止报表的代码。fetch_remote_binlog 函数通过 mysqlbinlog 命令从远程服务器读取二进制日志。将文件内容作为迭代器返回，遍历文件中的各行。还可以提供一个文件列表以优化读取。还可以指定开始的日期 / 时间和结束的日期 / 时间，以限制返回结果的日期 / 时间范围。这些都会作为参数传递给 mysqlbinlog 程序。find_datetime_position 函数逐行扫描 binlog 文件直到找到 end_log_pos ，同时记录观察到的开始事件个数。该函数还联系报表服务器，以确定何时停止读取 binlog 文件，然后联系 master 获取 binlog 文件，并确定从哪个 binlog 文件开始扫描。示例3-7：在指定时间前运行复制的Python代码def fetch_remote_binlog(server, binlog_files=None,start_datetime=None, stop_datetime=None):from subprocess import Popen, PIPEif not binlog_files:binlog_files = [row[“Log_name”] for row in server.sql(“SHOW BINARY LOGS”)]command = [“mysqlbinlog”,“–read-from-remote-server”,“–force”,“–host=%s” % (server.host),“–user=%s” % (server.sql_user.name)]if server.sql_user.passwd:command.append(“–password=%s” % (server.sql_user.passwd))if start_datetime:command.append(“–start-datetime=%s” % (start_datetime))if stop_datetime:command.append(“–stop-datetime=%s” % (stop_datetime))return iter(Popen(command + binlog_files, stdout=PIPE).stdout)def find_datetime_position(master, report, start_datetime, stop_datetime):from itertools import dropwhilefrom mysql.replicant import Positionimport reall_files = [row[“Log_name”] for row in master.sql(“SHOW BINARY LOGS”)]stop_file = report.sql(“SHOW SLAVE STATUS”)[“Relay_Master_Log_File”]files = list(dropwhile(lambda file: file != stop_file, all_files))lines = fetch_remote_binlog(server, binlog_files=files,4742 ｜ 第3章 MySQL复制原理start_datetime=start_datetime,stop_datetime=stop_datetime)binlog_files = 0last_epos = Nonefor line in lines:m = re.match(r”#\d{6}\s+\d?\d:\d\d:\d\d\s+”r”server id\s+(?P\d+)\s+”r”end_log_pos\s+(?P\d+)\s+”r”(?P\w+)”, line)if m:if m.group(“type”) == “Start”:binlog_files += 1if m.group(“type”) == “Query”:last_epos = m.group(“epos”)return Position(files[binlog_files-1], last_epos)现在你可以使用这些函数在真正执行报表任务之前同步报表服务器。master.connect()report.connect()pos = find_datetime_position(master, report,start_datetime=”2009-09-14 23:55:00”,stop_datetime=”2009-09-14 23:59:59”)report.sql(“START SLAVE UNTIL MASTER_LOG_FILE=%s, MASTER_LOG_POS=%s”,(pos.file, pos.pos))report.sql(“DO MASTER_POS_WAIT(%s,%s)”, (pos.file, pos.pos))..code for reporting..可见，复制工作是非常简单的。这个例子涉及了一些关键概念，我们将在后面讨论横向扩展的时候用到它们，包括如何在正确的时间启动和停止 slave，如何获取 binlog 位置信息或怎样使用标准工具实现，以及如何整合得出自动化解决方案以满足特定需要。在 UNIX 上调度任务为了确保在午夜 12 点前停止 slave，然后在 12 点后启动报表，最简单的方法就是建立一个 cron(8) 作业，向 slave 发送停止运行的命令然后启动报表脚本。例如，下面的 crontab(5) 作业可以保证 slave 在午夜 12 点前停止，12 点后运行报表脚本让 slave 前滚（roll forward），比如说，12 点 05 分。这里我们假设 stop_slave 脚本用于停止 slave， daily_report 脚本用于运行日报表（首先要同步报表服务器，如前所述）。48小结 ｜ 43 stop reporting slave five minutes before midnight, every day55 23 * * * $HOME/mysql_control/stop_slave Run reporting script five minutes after midnight, every day5 0 * * * $HOME/mysql_control/daily_report这些脚本默认放在一个名为 reporttab 的 crontab 文件中，使用 crontab reporttab 命令可以安装这个 crontab 文件。在 Windows 上调度任务打开“运行”（Windows 键＋ R）对话框，输入 taskschd.msc，打开任务计划程序（TaskScheduler）。根据安全设置及 Windows 版本不同，可能会弹出用户账户控制（UAC）对话框，单击“继续”按钮。在“操作”菜单中选择“创建基本任务”，将会创建一个由时间触发的任务。该指令会打开“创建基本任务向导”，其中包含一些创建简单任务的步骤。第一步是为任务命名，并提供一个可选的描述。然后单击“下一步”按钮。第二个页面指定任务的频率。有很多控制任务何时运行的选项，包括：一次、每天、每周、当前用户登录时，或者当指定事件被记录时。选择完后单击“下一步”按钮。根据选择的频率不同，第三个页面继续指定相应的触发细节（例如日期和时间）。设置完触发器后单击“下一步”按钮。第四个页面设置任务被触发时执行什么操作，包括“启动程序”、“发送电子邮件”或者“显示消息”。选择其中一项，单击“下一步”按钮进入下一个页面。根据刚才的选择出现相应的页面，以设置具体的操作。例如，如果选择“启动程序”项，你可能要输入程序或脚本的文件名，添加参数及该任务从哪里开始等。一旦所有信息填写完毕，单击“下一步”按钮，最后一个页面是对任务的重新检查。如果一切都没问题，单击“完成”按钮，任务就被创建了。如果需要返回前面的页面更改设置，则单击“上一步”按钮。如果选中“当单击完成时，打开此任务属性的对话框”项，可更改任务属性。小结本章介绍了 MySQL 复制，包括为什么要使用复制，以及如何建立复制。我们还简单介绍了二进制日志。下一章将进一步研究二进制日志。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8章-用栈和队列来构造灵巧的代码]]></title>
    <url>%2F2019%2F06%2F30%2F%E7%AC%AC8%E7%AB%A0-%E7%94%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E6%9D%A5%E6%9E%84%E9%80%A0%E7%81%B5%E5%B7%A7%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么栈和队列都是处理临时数据的灵活工具？ 栈的数据结构是什么样的？应用场景有哪些？ 队列的数据结构是什么样的？应用场景有哪些？ 本章涵盖： 栈 栈实战 队列 队列实战 迄今为止，我们对数据结构的讨论都集中于它们在各种操作上表现出的性能。但其实，掌握多种数据结构还有助于简化代码，提高可读性。 本章你将会学习两种新的数据结构：栈和队列。事实上它们并不是全新的东西，只不过是多加了一些约束条件的数组而已。但正是这些约束条件为它们赋予了巧妙的用法。 具体一点说，栈和队列都是处理临时数据的灵活工具。在操作系统、打印任务、数据遍历等各种需要临时容器才能构造出美妙算法的场景，它们都大有作为。 处理临时数据就像是点餐。在菜做好并送到客人手上之前，订单是有用的，但过后，你无须保留那张订单。临时数据就是一些处理完便不再有用的信息，因此没有保留的必要。此外，就像出菜时应先出给早下单的客人，你可能还得注意数据按什么顺序去处理。栈和队列就正好能把数据按顺序处理，并在处理完成后将其抛弃。 栈栈存储数据的方式跟数组一样，都是将元素排成一行。只不过它还有以下 3条约束。 只能在末尾插入数据。 只能读取末尾的数据。 只能移除末尾的数据。 你可以将栈看成一叠碟子：你只能看到最顶端那只碟子的碟面，其他都看不到。另外，要加碟子只能往上加，不能往中间塞，要拿碟子只能从上面拿，不能从中间拿（至少你不应该这么做）。绝大部分计算机科学家都把栈的末尾称为栈顶，把栈的开头称为栈底。 尽管这些约束看上去令人很拘束，但很快你就会发现它们带来的好处。 我们先从一个空栈开始演示。 往栈里插入数据，也叫作压栈。你可以想象把一个碟子压在其他碟子上的画面。 首先，将5压入栈中。 这没什么特别的，就如往数组插入数据一样平常。 接着，将3压入栈中。 再将0压入栈中。 注意，每次压栈都是把数据加到栈顶（也就是栈的末尾）。如果想把0插入到栈底或中间，那是不允许的，因为这就是栈的特性：只能在末尾插入数据。 从栈顶移除数据叫作出栈。这也是栈的限制：只能移除末尾的数据。 来把栈中的一些数据弹出。 首先，弹出0。 现在剩下两个元素，5和3。 接着，弹出3。 这就剩下5了。 压栈和出栈可被形容为LIFO（last in，first out）后进先出。解释起来就是最后入栈的元素，会最先出栈。就像无心向学的学生，最迟到校的总是他，最早回家的也是他。 栈实战栈很少用于需要长期保留数据的场景，却常用于各种处理临时数据的算法。 下面我们来写一个初级的JavaScript分析器--一种用来检查JavaScript代码的语法是否正确的工具。因为JavaScript的语法规则很多，所以它可以做得很复杂。简单起见，我们就只专注于检查括号的闭合情况吧，包括圆括号、方括号、花括号，这些地方搞错的话是很令人郁闷的。 在写之前，先分析一下括号的语法错误会有哪些情况。分类就是以下3种。 首先是有左括号没有右括号的情况。 1(var x = 2; 这种归为第1类。 接着是没有左括号但有右括号的情况。 1var x = 2;) 这种归为第2类。 还有第3类，右括号类型与其前面最近的左括号不匹配，例如： 1(var x = [1, 2, 3)]; 此例中，虽然圆括号和方括号都左右成对出现，但位置不对，右圆括号前面最近的竟是左方括号。 那么怎样才能实现一种能检查一行代码里括号写得对不对的算法呢？用栈就好办了。 先准备一个空栈，然后从左至右读取代码的每一个字符，并执行以下规则。 (1) 如果读到的字符不是任一种括号（圆括号、方括号、花括号），就忽略它，继续下一个。 (2) 如果读到左括号，就将其压入栈中，意味着后面需要有对应的右括号来做闭合。 (3) 如果读到右括号，就查看栈顶的元素，并做如下分析。 如果栈里没有任何元素，也就是遇到了右括号但没有左括号，即第2类语法错误。 如果栈里有数据，但与刚才读到的右括号类型不匹配，那就是第3类语法错误。 如果栈顶元素是匹配的左括号，则表示它已经闭合。那么就可以将其弹出，因为已经不需要再记住它了。(4) 如果一行代码读完，栈里还留有数据，那就表示存在左括号，没有右括号与之匹配，即第1类语法错误。 让我们用以下代码作为例子来演示一遍。 备好一个空栈之后，就可以开始从左至右读取代码的每个字符了。 第1步：首先是第一个字符，它是一个左圆括号。 第2步：因为它是一个左括号，所以将其压入栈中。 接下来的var x = ，没有一个是括号，因此会被忽略。 第3步：遇到一个左花括号。 第4步：将其压入栈中。 然后忽略y:。 第5步：遇到一个左方括号。 第6步：同样把它压入栈中。 然后忽略1, 2, 3 。 第7步：这时我们第一次看到了右括号，是一个右方括号。 第8步：于是检查栈顶的元素，发现那是一个左方括号。因为刚才读到的右方括号能与其配对，所以将左方括号弹出。 第9步：继续，下一个读到的是右花括号。 第10步：检查栈里的最后一个元素，刚好是可以配对的左花括号。于是将其弹出。 第11步：读到一个右圆括号。 第12步：检查栈里的最后一个元素，刚好是可以配对的左圆括号。于是将其弹出，剩下一个空栈。 至此，代码读完了，栈也空着，所以我们的分析器可以定论，这段代码在括号方面没有语法错误。 以下是上述算法的Ruby实现。Ruby的数组自带push和pop方法，是在数组结尾插入和删除元素的便捷调用。只使用这两个方法的话，数组便形同于栈。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Linter attr_reader :error def initialize # 用一个普通的数组来当作栈 @stack = [] end def lint(text) # 循环读取文本的每个字符 text.each_char.with_index do |char, index| if opening_brace?(char) # 如果读到左括号，则将其压入栈中 @stack.push(char) elsif closing_brace?(char) if closes_most_recent_opening_brace?(char) # 如果读到右括号，并且它与栈顶的左括号匹配， # 则将栈顶弹出 @stack.pop else # 如果读到右括号，但它与栈顶的左括号不匹配 @error = "Incorrect closing brace: #&#123;char&#125; at index #&#123;index&#125;" return end end end if @stack.any? # 如果读完所有字符后栈不为空，就表示文中存在着没有相应右括号的左括号 @error = "#&#123;@stack.last&#125; does not have a closing brace" end end private def opening_brace?(char) ["(", "[", "&#123;"].include?(char) end def closing_brace?(char) [")", "]", "&#125;"].include?(char) end def opening_brace_of(char) &#123;")" =&gt; "(", "]" =&gt; "[", "&#125;" =&gt; "&#123;"&#125;[char] end def most_recent_opening_brace @stack.last end def closes_most_recent_opening_brace?(char) opening_brace_of(char) == most_recent_opening_brace endend 如果这样使用的话： 123linter = Linter.newlinter.lint("( var x = &#123; y: [1, 2, 3] &#125; )")puts linter.error 因为该段代码语法正确，所以不会有错误信息打印出来。然而，要是不小心调转了最后两个字符： 123linter = Linter.newlinter.lint("( var x = &#123; y: [1, 2, 3] ) &#125;")puts linter.error 就会出现以下信息。 1Incorrect closing brace: ) at index 25 如果丢掉最后那个右括号： 123linter = Linter.newlinter.lint("( var x = &#123; y: [1, 2, 3] &#125;")puts linter.error 就会出现如下的报错。 1( does not have a closing brace 在刚才的例子中，栈被巧妙地用来跟踪那些还没有配对的左括号。到了下一章，我们会类似地用栈去跟踪函数的调用，那也是递归的核心思想。 当数据的处理顺序要与接收顺序相反时（LIFO），用栈就对了。像文字处理器的“撤销”动作，或网络应用程序的函数调用，你应该都会需要栈来实现。 队列队列对于临时数据的处理也十分有趣，它跟栈一样都是有约束条件的数组。区别在于我们想要按什么顺序去处理数据，而这个顺序当然是要取决于具体的应用场景。 你可以将队列想象成是电影院排队。排在最前面的人会最先离队进入影院。套用到队列上，就是首先加入队列的，将会首先从队列移出。因此计算机科学家都用缩写“FIFO”（first in, first out）先进先出，来形容它。 与栈类似，队列也有3个限制（但内容不同）。 只能在末尾插入数据（这跟栈一样）。 只能读取开头的数据（这跟栈相反）。 只能移除开头的数据（这也跟栈相反）。 下面来看看它是怎么运作的，先准备一个空队列。 首先，插入5（虽然栈的插入就叫压栈，但队列的插入却没有固定的叫法，一般可以叫放入、加入、入队）。 然后，插入9。 接着，插入100。 目前为止，队列表现得还跟栈一样，但要是移除数据的话，就会跟栈反着来了，因为队列是从开头移除数据的。 想移除数据，得先从5开始，因为开头就是它。 接着，移除9。 这样一来，队列就只剩下100了。 队列实战队列应用广泛，从打印机的作业设置，到网络应用程序的后台任务，都有队列的存在。 假设你正在用Ruby编写一个简单的打印机接口，以接收网络上不同计算机的打印任务。利用Ruby数组的push 方法，将数据加到数组末尾，以及 shift方法，将数据从数组开头移除。 你可以这样来编写接口类。 123456789101112131415161718192021class PrintManager def initialize @queue = [] end def queue_print_job(document) @queue.push(document) end def run while @queue.any? # Ruby 的 shift 方法可移出并返回数组的第一个元素 print(@queue.shift) end end private def print(document) # 让打印机去打印文档（为了演示，暂时先打到终端上） puts document endend 然后这样使用它。 12345print_manager = PrintManager.newprint_manager.queue_print_job("First Document")print_manager.queue_print_job("Second Document")print_manager.queue_print_job("Third Document")print_manager.run 接着打印机就会按3份文档的接收顺序来把它们打印出来。 123First DocumentSecond DocumentThird Document 尽管这个例子把打印机的工作方式写得很抽象，简化了细节，但其中对队列基本用法的描述是真实的，以此为基础去构建真正的打印系统是可行的。 队列也是处理异步请求的理想工具--它能保证请求按接收的顺序来执行。此外，它也常用于模拟现实世界中需要有序处理事情的场景，例如飞机排队起飞、病人排队看医生。 总结如你所见，栈和队列是能巧妙解决各种现实问题的编程工具。 掌握了栈和队列，就解锁出了下一个目标：学习基于栈的递归。递归也是其他高级算法的基础，我们将会在本书余下的部分讲解它们。 数组与数据结构 在强类型编程语言中，有专用的数据结构解决方案。通常是创建一个容器，在这个容器中可以存储任意类型的数据，并且可以根据容器中存储的数据决定容器的容量，达到可以变长的容器结构，比如链表、堆栈和队列等都是数据结构中常用的形式。在PHP中，通常都是使用数组来完成其它语言使用数据结构才能完成的工作。它是弱类型语言，在同一个数组中就可以存储多种类型的数据，而且php中的数组没有长度限制，数组存储数据的容量还可以根据里面元素个数的增减自动调整。 1、使用数组实现堆栈 堆栈是数据结构的一种实现形式，数据存储时采用“先进后出”的数据结构。在php中，将数组当作一个栈使用array_push()和array_pop()两个函数即可完成数据的进栈和出栈操作。 12--&gt;array_push():将一个或多个单元压入数组末尾（入栈），然后返回新组的长度。--&gt;array_pop():将数组最有一个单元弹出数组（出栈） 2、使用数组实现队列 队列是数据结构的一种实现形式，数据存储时采用“先进先出”的数据结构。在php中，将数组当作一个栈使用array_push()和array_shift()两个函数即可完成数据的队列操作。 12--&gt;array_shift():将数组开头的单元移出数组，然后返回被删元素值。--&gt;array_shift():在数组开头插入一个或多个单元]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7章-查找迅速的散列表]]></title>
    <url>%2F2019%2F06%2F30%2F%E7%AC%AC7%E7%AB%A0-%E6%9F%A5%E6%89%BE%E8%BF%85%E9%80%9F%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.散列表是一种什么数据结构？优势在哪里？2.为什么查找值只要一步？3.什么是散列？什么是散列函数？4.散列函数需要满足什么条件？5.散列表是如何存储数据的？为什么会产生冲突？6.分离链接法是怎么解决冲突的？7.散列表的效率取决于什么因素？8.什么是负载因子？理想的负载因子是多少？ 本章涵盖： 1.探索散列表 2.用散列函数来做散列 3.一个好玩又赚钱的同义词典 4.处理冲突 5.找到平衡 试想你在写一个快餐店的点单程序，准备实现一个展示各种食物及相应价格的菜单。你可能会用数组来做（当然这没问题）。 1menu = [ ["french fries", 0.75], ["hamburger", 2.5], ["hot dog", 1.5], ["soda", 0.6] ] 该数组由一些子数组构成，每个子数组包含两个元素。第一个元素是表示食物名称的字符串，第二个元素是该食物的价格。 就如第2章学到的，在无序的数组里查找某种食物的价格，得用线性查找，需要O(N)步。 有序数组则可以用二分查找，只需要O(log N)步。 尽管O(log N)也不错，但我们可以做得更好。事实上，可以好很多。到了本章结尾，你会掌握一种名为散列表的数据结构，只用O(1)步就能找出数据。理解此数据结构的原理以及其适用场景，你就能依靠其快速查找的能力来应对各种状况。 探索散列表大多数编程语言都自带散列表这种能够快速读取的数据结构。但在不同的语言中，它有不同的名字，除了散列表，还有散列、映射、散列映射、字典、关联数组。散列就是hash。 以下便是用Ruby的散列表来实现的菜单。 1menu = &#123; "french fries" =&gt; 0.75, "hamburger" =&gt; 2.5, "hot dog" =&gt; 1.5, "soda" =&gt; 0.6 &#125; 散列表由一对对的数据组成。一对数据里，一个叫作键，另一个叫作值。键和值应该具有某种意义上的关系。如上例，”french fries”是键，0.75是值，把它们组成一对就表示“炸薯条的价格为75美分”。 在Ruby中，查找一个键所对应的值，语法是： 1menu["french fries"] 这会返回值0.75。 在散列表中查找值的平均效率为O(1)，因为只要一步。下面来看看为什么。 用散列函数来做散列还记得你小时候创建和解析密文时用的密码吗？ 例如以下这种字母和数字的简单转化方式。 A = 1B = 2C = 3D = 4E = 5 以此类推。 由此可得，ACE会转化为135，CAB会转化为312，DAB会转化为412，BAD会转化为214。 将字符串转为数字串的过程就是散列，其中用于对照的密码，就是散列函数。 当然散列函数不只是这一种，例如对各字母匹配的数字求和的过程，也可以作为散列函数。 按此函数来做的话，BAD就是7，过程如下。 第1步：BAD转成214。 第2步：把每一位数字相加，2 + 1 + 4 = 7。 散列函数也可以是对各字母匹配的数字求积的过程。这样的话，BAD就会得出8。 第1步：BAD转成214。 第2步：把每一位数字相乘，2 × 1 × 4 = 8。 本章剩余部分将会采用最后一种散列函数。虽然现实世界中的散列函数比这复杂得多，但以简单的乘法函数为例会比较易懂。 一个散列函数需满足以下条件才有效：每次对同一字符串调用该散列函数，返回的都应是同一数字串。如果每次都返回不一样的结果，那就无效。 例如，计算过程中使用随机数或当前时间的函数就不是有效的散列函数。这种函数会将BAD一下转成12，一下又转成106。 我们刚才的乘法函数就只会把BAD转成8。因为B总是2，A总是1，D总是4，2 × 1 × 4总会是8，不可能有其他输出。 注意，经由此函数转换，DAB也会得到8，跟BAD一样。这确实会带来一些问题，我们之后会说明。 认识了散列函数，就可以进一步学习散列表的运作了。 一个好玩又赚钱的同义词典假设工作之余，你还一个人秘密研发着一款将要征服世界的软件。那是一个同义词典，它叫Quickasaurus。你相信它势必一鸣惊人，因为它只会返回一个最常用的同义词，而不是像其他词典那样，返回所有的同义词。 因为每个词都有一个同义词，所以正好作为散列表的用例。毕竟，散列表就是一堆成对的元素。下面我们马上来开发。 该词典可以用一个散列表来表示。 1thesaurus = &#123;&#125; 散列表可以看成是一行能够存储数据的格子，就像数组那样。每个格子都有对应的编号，如下所示。 现在往散列表里加入我们的第一条同义词。 1thesaurus["bad"] = "evil" 散列表变成了下面这样。 1&#123;"bad" =&gt; "evil"&#125; 再看看散列表是如何存储数据的。 首先，计算机用散列函数对键进行计算。为了方便演示，这里我们依然使用之前提及的那个乘法函数。 1BAD = 2 * 1 * 4 = 8 “bad”的散列值为8，于是计算机将”evil”放到第8个格子里。 接着，我们再试另一对键值。 1thesaurus["cab"] = "taxi" 同样地，计算机要计算散列值。 1CAB = 3 * 1 * 2 = 6 因其结果为6，所以将”taxi”放到第6格。 再多加一对试试。 1thesaurus["ace"] = "star" ACE的散列值为15（ACE = 1 × 3 × 5 = 15），于是”star”被放到第15格。 现在，用代码来表示这个散列表的话，就是这样： 1&#123;"bad" =&gt; "evil", "cab" =&gt; "taxi", "ace" =&gt; "star"&#125; 既然散列表词典建好了，那就来看看从里面查词时会发生什么吧。假设现在要查”bad”的同义词，写成代码的话，如下所示。 1thesaurus["bad"] 收到命令后，计算机就会进行如下两步简单的操作。 (1)计算这个键的散列值：BAD = 2 × 1 × 4 = 8。 (2)由于结果是 8，因此去到第8格并返回其中的值。在本例中，该值为 “evil” 。 这下你应该明白为什么从散列表里读取数据只需O(1)了吧，因为其过程所花的时间是恒定的。它总是先计算出键的散列值，然后根据散列值跳到对应的格子去。 现在总算理解为什么我们的快餐店菜单用散列表会比用数组要快了。当要查询某种食物的价格时，如果是用数组，那么就得一个格子一个格子地去找，直至找到为止。无序数组需要O(N)，有序数组需要O(log N)。但用散列表的话，我们就能够以食物作为键来做O(1)的查找。这就是散列表的好处。 处理冲突不过，散列表也会带来一些麻烦。 继续同义词典的例子：把下面这条同义词也加到表里，会发生什么呢？ 1thesaurus["dab"] = "pat" 首先，计算散列值。 1DAB = 4 * 1 * 2 = 8 然后，将”pat”放进第8个格子。 噢，第8格已经是”evil”了，这的确不好（evil）。 往已被占用的格子里放东西，会造成冲突。幸好，我们有解决办法。 一种经典的做法就是分离链接。当冲突发生时，我们不是将值放到格子里，而是放到该格子所关联的数组里。 现在仔细观察该散列表的冲突位置。 因为要放入”pat”的第8格，已经存在”evil”了，于是我们将第8格的内容换成一个数组。 该数组又以子数组构成，每个子数组含两个元素，第一个是被检索的词，后一个是其相应的同义词。 下面运行一遍”dab”的查找过程，执行： 1thesaurus["dab"] 计算机就会按如下步骤执行。(1)计算散列值DAB = 4 × 1 × 2 = 8。(2)读取第8格，发现其中不是一个单独的值，而是一个数组。(3)于是线性地在该数组中查找，检查每个子数组的索引0位置，如果碰到要找的词（”dab”），就返回该子数组的索引1的值。 再图形化地演示一次。 求得DAB的散列值为8，于是计算机读取第8格。 因为第8格里面是一个数组，所以对该数组进行线性查找。首先是第1格，它又是一个数组，于是查看这个子数组的索引0。 它并非我们要找的词（”dab”），于是跳到下一格。 这一格的子数组的索引0正是”dab”，因此其索引1的值就是我们要找的同义词（”pat”）。 若散列表的格子含有数组，因为要在这些数组上做线性查找，所以步数会多于1。如果数据都刚好存在同一个格子里，那么查找就相当于在数组上进行。因此散列表的最坏情况就是O(N)。 为了避免这种情况，散列表的设计应该尽量减少冲突，以便查找都能以O(1)完成。 接着，我们就来看一下现实中的散列表是如何做到的。 找到平衡归根到底，散列表的效率取决于以下因素。 要存多少数据。 有多少可用的格子。 用什么样的散列函数。 前两点很明显。如果要放的数据很多，格子却很少，就会造成大量冲突，导致效率降低。但为什么和散列函数本身也有关系呢？我们这就来看看。 假设你准备用一个散列值总是落在1至9之间的散列函数，例如，将字母转成其对应的序号，然后一直相加，直至结果只剩一位数字的函数。 就像这样：PUT = 16 + 21 + 20 = 57因为57不止一位数字，于是将57拆成5 + 7。5 + 7 = 1212也不止一位数字，于是拆成1 + 2。1 + 2 = 3最终，PUT的散列值为3。因为这种计算逻辑，该散列函数只会返回1到9的数字。 再回到散列表的样子。如果是用刚才的散列函数，那么该散列表的10到16号格子就都用不上了，数据只会被放到1到9的格子里。 所以，一个好的散列函数，应当能将数据分散到所有可用的格子里去。 如果一个散列表只需要保存5个值，那么它应该多大，以及采用什么散列函数呢？ 要是散列表只有5个格子，那么散列函数需要算出1到 5的散列值。但就算我们想保存的值也只有5个，冲突还是很可能发生，因为散列值只有5种可能。 然而，如果散列表有100个格子，散列函数的结果为1到100之间的数，存5个值进去时发生冲突的可能性就小得多，因为落入的格子有100种可能。 尽管100个格子能很好地避免冲突，但只用来放5个值的话，就太浪费空间了。 这就是使用散列表时所需要权衡的：既要避免冲突，又要节约空间。 要想解决这个问题，可参考计算机科学家研究出的黄金法则：每增加7个元素，就增加10个格子。 如果要保存14个元素，那就得准备20个格子，以此类推。 数据量与格子数的比值称为负载因子。把这个术语代入刚才的理论，就是：理想的负载因子是0.7（7个元素/10个格子）。 如果你一开始就将7个元素放进散列表，那么计算机应该会创建出一个含有10个格子的散列表。随着你添加元素，计算机也会添加更多的格子来扩展这个散列表，并改变散列函数，使新数据能均匀地分布到新的格子里去。 幸运的是，一般编程语言都自带散列表的管理机制，它会帮你决定散列表的大小、散列函数的逻辑以及扩展的时机。既然你已经理解了散列表的原理，那么在处理一些问题时你就可以用它取代数组，利用其O(1)的查找速度来提升代码性能。 一个实例散列表有各种用途，但目前我们只考虑用它来提高算法速度。 第1章我们学习了基于数组的集合--一种能保证元素不重复的数组。每次往其中插入新元素时，都要先做一次线性查找来确定该元素是否已存在（如果是无序数组）。 如果要在一个大集合上进行多次插入，效率将会下降得很快，因为每次插入都需要O(N)。 很多时候，我们都可以把散列表当成集合来用。 把数组作为集合的话，数据是直接放到格子里的。用散列表时，则是将数据作为键，值可以为任何形式，例如数字1，或者布尔值true也行。 假设在Javascript里建立了如下所示的散列表。 1var set = &#123;&#125;; 并加入一些数据。 123set["apple"] = 1;set["banana"] = 1;set["cucumber"] = 1; 这样每次插入新值，都只需花O(1)的时间，而不是线性查找的O(N)。即使数据已存在时也是这个速度。 1set["banana"] = 1; 再次插入”banana”时，我们并不需要检查它存在与否，因为即使存在，也只是将其对应的值重写成1。 散列表确实非常适用于检查数据的存在性。第4章我们讨论过如何在Javascript 里检查一个数组有没有重复数据。一开始的方案如下所示。 1234567891011121314function hasDuplicateValue(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; for(var j = 0; j &lt; array.length; j++) &#123; if(i !== j &amp;&amp; array[i] == array[j]) &#123; return true; &#125; &#125; &#125; return false;&#125; 当时我们说了，该嵌套循环的效率是O(N2)。 于是有了第二个O(N)的方案，不过它只能处理数据全为非负整数的数组。如果数组含有其他东西，例如字符串，那怎么办呢？ 使用类似的逻辑，但换成散列表（在Javascript里叫作对象），就可以处理字符串了。 12345678910111213141516function hasDuplicateValue(array) &#123; var existingValues = &#123;&#125;; for(var i = 0; i &lt; array.length; i++) &#123; if(existingValues[array[i]] === undefined) &#123; existingValues[array[i]] = 1; &#125; else &#123; return true; &#125; &#125; return false;&#125; 这种方法也是O(N)，其中的existingValues不是数组而是散列表，用字符串作为键（索引）是没有问题的。 假设我们要做一个电子投票机，投票者可以投给现有的候选人，也可以推荐新的候选人。因为会在选举的最后统计票数，我们可以将票保存在一个数组里，每投一票就将其插入到末尾。 12345var votes = [];function addVote(candidate) &#123; votes.push(candidate);&#125; 最终数组就会变得很长。 1["Thomas Jefferson", "John Adams", "John Adams", "Thomas Jefferson", "John Adams", ...] 这样插入很快，只有O(1)。 那点票的效率又如何呢？因为票都在数组里，所以我们会用循环来遍历它们，并用一个散列表来记录每人的票数。 12345678910111213141516function countVotes(votes) &#123; var tally = &#123;&#125;; for(var i = 0; i &lt; votes.length; i++) &#123; if(tally[votes[i]]) &#123; tally[votes[i]]++; &#125; else &#123; tally[votes[i]] = 1; &#125; &#125; return tally;&#125; 不过这样需要O(N)，也太慢了！ 不如换种方式，一开始就用散列表来收集票数。 123456789101112131415161718var votes = &#123;&#125;;function addVote(candidate) &#123; if(votes[candidate]) &#123; votes[candidate]++; &#125; else &#123; votes[candidate] = 1; &#125;&#125;function countVotes() &#123; return votes;&#125; 这样一来，投票是O(1)，并且因为投票时就已经在计数，所以已完成了点票的步骤。 总结高效的软件离不开散列表，因为其O(1)的读取和插入带来了无与伦比的性能优势。 到现在为止，我们探讨各种数据结构时都只考虑了性能。但你知道有些数据结构的优点并不在于性能吗？下一章就研究两种能帮助改善代码可读性和可维护性的数据结构。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章-乐观地调优]]></title>
    <url>%2F2019%2F06%2F30%2F%E7%AC%AC6%E7%AB%A0-%E4%B9%90%E8%A7%82%E5%9C%B0%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 插入排序的第二层为什么是while循环？ 插入排序包含4种步骤：移除、比较、平移和插入。各需要多少步？ 用Python和C#实现插入排序。 冒泡排序、选择排序、插入排序都需要双循环吗？ 本章涵盖： 1.插入排序 2.插入排序实战 3.插入排序的实现 4.插入排序的效率 5.平均情况 之前我们衡量一个算法的效率时，都是着眼于它在最坏情况下需要多少步。原因很简单，连最坏的情况都做足准备了，其他情况自然不在话下。 然而，本章会告诉你最坏情况不是唯一值得考虑的情况。全面分析各种情况，能帮助你为不同场景选择适当的算法。 插入排序我们已经学过两种排序算法：冒泡排序和选择排序。虽然它们的效率都是O(N2)，但其实选择排序比冒泡排序快一倍。现在来学第三种排序算法--插入排序。你会发现，顾及最坏情况以外的场景将是多么有用。 插入排序包括以下步骤。 (1)在第一轮里，暂时将索引1（第2格）的值移走，并用一个临时变量来保存它。这使得该索引处留下一个空隙，因为它不包含值。 在之后的轮回，我们会移走后面索引的值。 (2)接着便是平移阶段，我们会拿空隙左侧的每一个值与临时变量的值进行比较。 如果空隙左侧的值大于临时变量的值，则将该值右移一格。 随着值右移，空隙会左移。如果遇到比临时变量小的值，或者空隙已经到了数组的最左端，就结束平移阶段。 (3)将临时移走的值插入当前空隙。 (4)重复第(1)至(3)步，直至数组完全有序。 插入排序实战下面尝试对[4, 2, 7, 1, 3]数组运用插入排序。 第1轮先从索引1开始，其值为2。 准备工作：暂时移走2，并将其保存在变量temp_value中。图中被移到数组上方的就是temp_value。 第1步：比较4与temp_value中的2。 第2步：因为4大于2，所以把4右移。 于是空隙移到了数组最左端，没有其他值可以比较了。 第3步：将temp_value插回数组，完成第一轮。 开始第2轮。 准备工作：暂时移走索引2的值，并保存到temp_value中。于是temp_value等于7。 第4步：比较4与temp_value 。 4小于7，所以无须平移。因为遇到了小于temp_value的值，所以平移阶段直接结束。 第5步：将temp_value插回到空隙中，结束第2轮。 开始第3轮。 准备工作：暂时移走1，并将其保存到temp_value中。 第6步：比较7与temp_value。 第7步：7大于1，于是将7右移。 第8步：比较4与temp_value。 第9步：4大于1，于是也要将4右移。 第10步：比较2与temp_value。 第11步：2比较大，所以将2右移。 第12步：空隙到了数组最左端，因此我们将temp_value插进去，结束这一轮。 开始第4轮。 准备工作：暂时移走索引4的值3，保存到temp_value中。 第13步：比较7和temp_value。 第14步：7更大，于是将7右移。 第15步：比较4与temp_value 。 第16步：4大于3，所以将4右移。 第17步：比较2与temp_value。2小于3，于是平移阶段完成。 第18步：把temp_value插回到空隙。 至此整个数组都排好序了。 插入排序的实现以下是插入排序的Python实现。 12345678910def insertion_sort(array): for index in range(1, len(array)): position = index temp_value = array[index] while position &gt; 0 and array[position - 1] &gt; temp_value: array[position] = array[position - 1] position = position - 1 array[position] = temp_value 让我们来一步步地讲解。我会先摘出代码片段，然后给出解释。 1for index in range(1, len(array)): 首先，发起一个从索引1开始的循环来遍历数组。变量 index保存的是当前索引。 12position = indextemp_value = array[index] 接着，给position赋值为index，给temp_value赋值为index所指的值。 123while position &gt; 0 and array[position - 1] &gt; temp_value: array[position] = array[position - 1] position = position - 1 然后在内部发起一个while循环，以检查position左侧的值是否大于temp_value。若是，则用array[position] = array[position - 1]将该值右移一格，并将position减1。然后继续检查新position左侧的值是否大于temp_value……如此重复，直至遇到的值比temp_value小。 1array[position] = temp_value 最后，将temp_value放回到数组的空隙中。 插入排序的效率插入排序包含4种步骤：移除、比较、平移和插入。要分析插入算法的效率，就得把每种步骤都统计一遍。 首先看看比较。每次拿temp_value跟空隙左侧的值比大小就是比较。 在数组完全逆序的最坏情况下，我们每一轮都要将temp_value左侧的所有值与temp_value比较。因为那些值全都大于temp_value，所以每一轮都要等到空隙移到最左端才能结束。 在第一轮，temp_value为索引1的值，由于temp_value左侧只有一个值，所以最多进行一次比较。到了第二轮，最多进行两次比较，以此类推。到最后一轮时，就要拿temp_value以外的所有值与其进行比较。换言之，如果数组有N个元素，则最后一轮中最多进行N - 1次比较。 因而可以得出比较的总次数为：1 + 2 + 3 + … + N - 1次。 对于有 5个元素的数组，最多需要：1 + 2 + 3 + 4 = 10次比较。 对于有 10个元素的数组，最多需要：1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45次比较。 （对于有20个元素的数组，最多需要190次比较，以此类推。） 由此可发现一个规律：对于有N个元素的数组，大约需要N2/2次比较（102/2是50，202/2是200）。 接下来看看其他几种步骤。 我们每次将值右移一格，就是平移操作。当数组完全逆序时，有多少次比较就要多少次平移，因为每次比较的结果都会使你将值右移。 把最坏情况下的比较步数和平移步数相加。N2/2次比较 + N2/2次平移 = N2步 temp_value的移除跟插入在每一轮里都会各发生一次。因为总是有N - 1轮，所以可以得出结论：有N - 1次移除和N - 1次插入。 把它们都相加。 N2比较和平移的合计 + N - 1次移除 + N - 1次插入 = N2 + 2N - 2步 我们已经知道大O有一条重要规则--忽略常数，于是你可能会将其简化成O(N2 + N)。 不过，现在来学习一下大O的另一条重要规则： 大O只保留最高阶的N。 换句话说，如果有个算法需要N4 + N3 + N2 + N步，我们就只会关注其中的N4，即以O(N4)来表示。为什么呢？ 请看下表。 N N2 N3 N4 2 4 8 16 5 25 125 625 10 100 1000 10000 100 10000 1000000 1000000000 1000 1000000 1000000000 1000000000000 随着N的变大，N4的增长越来越抛离其他阶。当N为1000时，N4就比N3大了1000倍。因此，我们只关心最高阶的N。 所以在插入排序的例子中，O(N2 + N)还得进一步简化成O(N2)。 你会发现，在最坏的情况里，插入排序的时间复杂度跟冒泡排序、选择排序一样，都是O(N2)。 不过上一章曾指出，虽然冒泡排序和选择排序都是O(N2)，但选择排序实际上是N2/2步，比N2步的冒泡排序更快。乍一看，你可能会觉得插入排序跟冒泡排序一样，因为它们都是O(N2)，其实插入排序是N2 + 2N - 2步。 如果本书到此为止，你或许会认为比冒泡排序和插入排序快一倍的选择排序是三者中最优的，但事情并没有这么简单。 平均情况确实，在最坏情况里，选择排序比插入排序快。但是我们还应该考虑平均情况。 为什么呢？ 所谓平均情况，就是那些最常遇见的情况。最坏情况和最好情况都是不常见的。看下面这个钟形的曲线。 最好情况和最坏情况很少发生。现实世界里，最常出现的是平均情况。 这是很有道理的。你设想一个随便洗乱的数组，出现完全升序或完全降序的可能性有多大？ 最可能出现的情况应该是随机分布。 下面试试在各种场景中测试插入排序。 完全降序的最坏情况之前已经见过，它每一轮都要比较和平移所遇到的值（这两种操作合计N2步）。 对于完全升序的最好情况，因为所有值都已在其正确的位置上，所以每一轮只需要一次比较，完全不用平移。 但若是随机分布的数组，你就可能要在一轮里进行比较并平移所有数据、部分数据，或无须平移。回头看看之前步骤分解的例子，可以发现在第 1、3轮，我们比较并平移了所有遇到的数据。在第4轮，我们只对部分数据进行了操作。在第2轮，则没有平移，只有一次比较。 最坏情况是所有数据都要比较和平移；最好情况是每轮一次比较、零次平移；对于平均情况，总的来看，是比较和平移一半的数据。 如果说插入排序的最坏情况需要N2步，那么平均情况就是N2/2步。尽管最终大O都会写成O(N2)。 来看一些具体的例子。 最好情况就像[1 ,2, 3, 4]，已经预先排好序。用同样的数据，最坏情况就是[4, 3, 2, 1] 。 平均情况，则如[1, 3, 4, 2] 。 这里的最坏情况需要6次比较和6次平移，共12步。平均情况需要4次比较和2次平移，共6步。最好情况是3次比较、0次平移。 可以看到插入排序的性能在不同场景中差异很大。最坏、平均、最好情况，分别需要N2、N2/2、N步。 这是由于有些轮次需要比较temp_value左侧的所有值，有些轮次却因为遇到了小于temp_value的值而提早结束。 3种情况的步数如下图所示。 再跟选择排序对比一下。选择排序是无论何种情况，最坏、平均、最好，都要N2/2步。 因为这个算法没有提早结束某一轮的机制，不管遇到什么，每一轮都得比较所选索引右边的所有值。 那么哪种算法更好？选择排序还是插入排序？答案是：看情况。对于平均情况（数组里的值随机分布），它们性能相近。如果你确信数组是大致有序的，那么插入排序比较好。如果是大致逆序，则选择排序更快。如果你无法确定数据是什么样，那就算是平均情况了，两种都可以。 一个实例假设你在写一个Javascript应用，你需要找出其中两个数组的交集。所谓交集，就是两个数组都有的值所组成的集合。举个例子，[3, 1, 4, 2]和[4, 5, 3, 6]的交集为[3, 4]，因为两个数组都有3和4。 Javascript并没有自带求交集的函数，因此我们只能自己写一个。以下是其中一种写法。 1234567891011121314function intersection(first_array, second_array)&#123; var result = []; for (var i = 0; i &lt; first_array.length; i++) &#123; for (var j = 0; j &lt; second_array.length; j++) &#123; if (first_array[i] == second_array[j]) &#123; result.push(first_array[i]); &#125; &#125; &#125; return result;&#125; 它运用了一个简单嵌套循环。外部循环用来遍历第一个数组，并在每遇到一个值时，就发起内部循环去检查第二个数组有没有值与其相同。 此算法有两种步骤：比较和插入。也就是将两个数组的所有值相互比较，并把相同的值插入到result 。插入的步数微不足道，因为即使两个数组完全一致，步数也不过是其中一个数组的数据量。所以这里主要考虑的是比较。 要是两个数组同样大小，那么比较需要N2步。这是因为数组一的每个值，都要与数组二的每个值进行对比。于是，两个数据量都为5的数组，最终会比较25次。这种算法效率为O(N 2)。 （如果数组大小不一，比如说分别含N、M个元素，那么此过程的步数就是O(N × M)，但简单起见，就当它们大小一样吧。） 那能不能改进一下呢？ 这就是为什么我们不能只考虑最坏情况的原因了。以现在的intersection函数的实现，无论遇到什么情况都是O(N2)的，不管你输入的两个数组完全不同还是完全相同。 如果两个数组真的没有交集，那你别无选择，只能检查完每个值才能确定。 但若是二者有交集，我们其实不用拿数组一的每个值去跟数组二的每个值对比。下面我就来解释为什么。 在以上例子中，一旦找到一个共有的值（8），那就没必要跑完内部循环了。再跑下去是为了检查什么呢？既然知道数组二中也存在数组一的那个值这就够了。 要改进的话，加一个命令就可以。 12345678910111213141516function intersection(first_array, second_array)&#123; var result = []; for (var i = 0; i &lt; first_array.length; i++) &#123; for (var j = 0; j &lt; second_array.length; j++) &#123; if (first_array[i] == second_array[j]) &#123; result.push(first_array[i]); break; &#125; &#125; &#125; return result;&#125; break可以中断内部循环，节省步数和时间。 这样的话，在没有交集的最坏情况下，我们仍然要做N2次比较；在数组完全一样的最好情况下，就只需要N次比较；在数组不同但有部分重复的平均情况下，步数会介于N到N2之间。 其性能提升是很明显的，因为在最初的实现里，无论什么情况，步数都是N2。 总结懂得区分最好、平均、最坏情况，是为当前场景选择最优算法以及给现有算法调优以适应环境变化的关键。记住，虽然为最坏情况做好准备十分重要，但大部分时间我们面对的是平均情况。 下一章我们会学习一种跟数组类似的数据结构，它的一些特点使其在某些场景中的性能优于数组。就像现在你得根据需求选择合适的算法，数据结构的性能也有差异，你也需要为此做出选择。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第10章：输入和飞行控制]]></title>
    <url>%2F2019%2F06%2F29%2F%E7%AC%AC10%E7%AB%A0%EF%BC%9A%E8%BE%93%E5%85%A5%E5%92%8C%E9%A3%9E%E8%A1%8C%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在大体上对场景进行了布局后，就可以添加基本的游戏玩法了。在本章中，将开始构建一个让飞船在太空中移动的系统。 输入这个游戏中使用两种不同的输入：一个虚拟摇杆，让玩家提供方向输入，用来确定飞行的方向；一个按钮，指示玩家是否想要发射飞船的激光束。 别忘了，恰当地测试触摸屏游戏输入的唯一方法是在触摸屏上进行测试。为了能够在不构建到设备的情况下测试游戏，需要使用Unity Remote应用。 添加摇杆我们首先创建摇杆。摇杆由两个可见的组件构成：一个较大的方形控制区域，位于画布的左下角，以及一个较小的“手柄”，位于该方形控制区域的中心。当用户把手指放到该控制区域中时，摇杆将调整自己的位置，使手柄正位于手指的下方，并仍然处在中心的位置。当手指移动时，手柄将随之移动。按照下面的步骤开始构建输入系统。 （1）创建控制区域。打开GameObject菜单，选择UI-&gt;Panel。将新面板命名为Joystick。 首先将其设为方形，放到屏幕的左下角。将锚点设为Lower Left。接下来，将该面板的宽度和高度均设为250。 （2）向控制区域添加图片。将Image组件的Source Image设置改为Pad精灵。 （3）创建手柄。 （4）添加VirtualJoyStick脚本。 （5）配置摇杆。（6）测试摇杆。 输入管理器飞行控制指示器（1）创建Indicator容器。 （2）创建原型Indicator。（3）创建文本标签。（4）添加代码。（5）连接距离标签。（6）将原型转换为预设。 Indicator Manager（1）创建Indicator Manager。（2）添加IndicatorManager脚本。（3）设置Indicator Manager。（4）选择空间站。（5）为其添加SpaceStation脚本。（6）运行游戏。 小结]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity移动游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章-用或不用大O来优化代码]]></title>
    <url>%2F2019%2F06%2F29%2F%E7%AC%AC5%E7%AB%A0-%E7%94%A8%E6%88%96%E4%B8%8D%E7%94%A8%E5%A4%A7O%E6%9D%A5%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 选择排序算法是怎么样的？是两层循环吗？用js实现选择排序算法。 选择排序的步骤可分为两类：比较和交换，次数分别是什么样？ 选择排序比冒泡排序快在哪里？ 选择排序的效率如何？ 为什么两种算法的大O记法完全一样，但实际上其中一个比另一个要快得多？ 大O记法忽略常数是什么意思？ 本章涵盖： 1.选择排序 2.选择排序实战 3.选择排序的实现 4.选择排序的效率 5.忽略常数 6.大O的作用 大O是一种能够比较算法效率，并告诉我们在特定环境下应采用何种算法的伟大工具。但我们不能完全依赖于它。因为有时候即使两种算法的大O记法完全一样，但实际上其中一个比另一个要快得多。 本章我们就来学习如何分辨那些效率貌似一样的算法，从而选出较快的那个。 选择排序上一章分析了冒泡排序算法，其效率是O(N2)。现在我们再来探索另一种排序算法，选择排序，并将它跟冒泡排序对比一下。 选择排序的步骤如下。 (1)从左至右检查数组的每个格子，找出值最小的那个。在此过程中，我们会用一个变量来记住检查过的数字的最小值（事实上记住的是索引，但为了看起来方便，下图就直接写出数值）。如果一个格子中的数字比记录的最小值还要小，就把变量改成该格子的索引，如图所示。 (2)知道哪个格子的值最小之后，将该格与本次检查的起点交换。第1次检查的起点是索引0，第2次是索引1，以此类推。下图展示的是第一次检查后的交换动作。 (3)重复第(1)(2)步，直至数组排好序。 选择排序实战以数组[4,2,7,1,3]为例，步骤如下。 开始第1轮检查。 首先读取索引0。根据此算法的定义，它是目前遇到的最小值（因为现在只检查了一个格子），于是记下其索引。 第1步：将索引1的值2与目前的最小值4进行比较。 2比4还要小，于是将目前的最小值改为2。 第2步：再与下一个值做比较。因为7大于2，所以最小值还是2。 第3步：将1和目前的最小值做比较。 1比2还要小，于是目前的最小值更新为1。 第4步：比较3和目前的最小值1。因为现在已经走到数组尽头了，所以可以断定1是整个数组的最小值。 第5步：本次检查的起点是索引0，不管那里的值是什么，我们都应该将最小值1换到那里。 现在1就排到正确的位置上了。 可以开始第2轮检查了。 准备工作：因为索引0的值已符合其排位，所以这一轮从下一个格子开始，即索引1，其值为2，也是目前本轮所遇到的最小值。 第6步：将7跟目前的最小值2进行比较。因为2小于7，所以最小值仍为2。 第7步：将4跟目前的最小值2进行比较。因为2小于4，所以最小值仍为2。 第8步：将3跟目前的最小值2进行比较。因为2小于3，所以最小值仍为2。 又走到数组尽头了。本轮不需要做任何交换，2已在其正确位置上。于是第2轮检查结束，现在数组如下图所示。 开始第3轮检查。 准备工作：从索引2起，其值为7。于是本轮目前最小值为7。 第9步：比较4与7。 将4记为目前的最小值。 第10步：遇到3，它比4还小。 于是3成了目前的最小值。 第11步：到数组尽头了，将3跟本轮起点7进行交换。 于是3排到正确位置上了。 虽然我们可以看到现在整个数组都有序了，但计算机是看不到的，它只会继续第4轮检查。 准备工作：此轮检查从索引3开始，其值4是目前的最小值。 第12步：比较4和7。 4仍为最小值，而且它也处于本轮起点，因此无须任何交换。 因为最后一个格子左侧的那些值都已在各自的正确位置上，所以最后一格也必然正确，于是排序结束。 选择排序的实现以下是用Javascript写的选择排序。 123456789101112131415161718192021function selectionSort(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; var lowestNumberIndex = i; for(var j = i + 1; j &lt; array.length; j++) &#123; if(array[j] &lt; array[lowestNumberIndex]) &#123; lowestNumberIndex = j; &#125; &#125; if(lowestNumberIndex != i) &#123; var temp = array[i]; array[i] = array[lowestNumberIndex]; array[lowestNumberIndex] = temp; &#125; &#125; return array;&#125; 让我们来一行行地分析。我会先摘出代码片段，然后给出解释。 1for(var i = 0; i &lt; array.length; i++) &#123;&#125; 这个外层的循环代表每一轮检查。在一轮检查之初，我们会先记住目前的最小值的索引。 1var lowestNumberIndex = i; 因此每轮开始时lowestNumberIndex都会是该轮的起点索引i 。注意我们实际上记录的是最小值的索引，而非最小值本身。于是，第1轮开始时最小值的索引是0，到第2轮则是1，以此类推。 1for(var j = i + 1; j &lt; array.length; j++) &#123;&#125; 此行代码发起一个以i + 1开始的内层循环。 123if(array[j] &lt; array[lowestNumberIndex]) &#123; lowestNumberIndex = j;&#125; 循环内逐个检查数组未排序的格子，若遇到比之前记录的本轮最小值还小的格子值，就将lowestNumberIndex更新为该格子的索引。 内层循环结束时，会得到未排序数值中最小值的索引。 12345if(lowestNumberIndex != i) &#123; var temp = array[i]; array[i] = array[lowestNumberIndex]; array[lowestNumberIndex] = temp;&#125; 然后再看看这个最小值是否已在正确位置，即该索引是否等于i 。如果不是，就将i所指的值与最小值交换。 选择排序的效率选择排序的步骤可分为两类：比较和交换，也就是在每轮检查中把未排序的值跟该轮已遇到的最小值做比较，以及将最小值与该轮起点的值交换以使其位置正确。 在之前5个元素的例子里，我们总共进行了10次比较。每轮分别如下。 第#轮 #次比较 1 4 2 3 3 2 4 1 于是 4 + 3 + 2 + 1 = 10 次比较。 推广开来，若有N个元素，就会有(N - 1) + (N - 2) + (N - 3) + … + 1次比较。 但每轮的交换最多只有1次。如果该轮的最小值已在正确位置，就无须交换，否则要做1次交换。相比之下，冒泡排序在最坏情况（完全逆序）时，每次比较过后都要进行1次交换。 下表为冒泡排序和选择排序的并列对比。 N个元素 冒泡排序最多要#步 选择排序最多要#步 5 20 14(10次比较 + 4次交换) 10 90 54(45次比较 + 9次交换) 20 380 199(180次比较 + 19次交换) 40 1560 819(780次比较 + 39次交换) 80 6320 3239(3160次比较 + 79次交换) 从表中可以清晰地看到，选择排序的步数大概只有冒泡排序的一半，即选择排序比冒泡排序快一倍。 忽略常数但有趣的是，选择排序的大O记法跟冒泡排序是一样的。 还记得我们说过，大O记法用来表示步数与数据量的关系。所以你可能会以为步数约为N2的一半的选择排序，其大O会写成O(N2/2)，以表示N个元素需要N2/2步。如下表所示。 N个元素 N2/2 选择排序最多要#步 5 52 / 2 = 12.5 14 10 102 / 2 = 50 54 20 202 / 2 = 200 199 40 402 / 2 = 800 819 80 802 / 2 = 3200 3239 但事实上，选择排序的大O记法为O(N2)，跟冒泡排序一样。这是因为大O记法的一条重要规则我们至今还没提到： 大O记法忽略常数。 换一种不那么数学的表达方式，就是：大O记法不包含一般数字，除非是指数。 如刚才的例子，严格来说本应为O(N2/2)，最终得写成O(N2)。类似地，O(2N)要写成O(N)；O(N/2)也写成O(N)；就算是比O(N)慢100倍的O(100N)，也要写成O(N)。 速度相差100倍的两种算法，它们的大O记法却一样，这或许会让人觉得大O没什么意义。就像同为O(N)的选择排序和冒泡排序，其实前者比后者快1倍，要在二者之中挑选，无疑是用选择排序。 那么，大O还凭什么值得我们学习呢？ 大O的作用尽管不能比较冒泡排序和选择排序，大O还是很重要的，因为它能够区分不同算法的长期增长率。当数据量达到一定程度时，O(N)的算法就会永远快过O(N2)，无论这个O(N)实际上是O(2N)还是O(100N)。即使是O(100N)，这个临界点也是存在的。（第3章在比较一个 100步的算法与O(N)算法时，也提过这个概念，不过这次我们会用另一个例子来讲解。） 下图为O(N)和O(N2)的对比。 此图在上一章里出现过。它显示了不管数据量是多少，O(N)总是快过O(N2)。 在第二幅图中，我们看到当数据量少于某个值时，O(N2)是比O(100N)要快的，但过了这个值之后，O(100N)便反超O(N2)，并一直保持优势。 这就是大O记法忽略常数的原因。大O记法只表明，对于不同分类，存在一临界点，在这一点之后，一类算法会快于另一类，并永远保持下去。至于这个点在哪里，大O并不关心。 因此，不需要写成O(100N)，归类到O(N)就好了。 同样地，在数据量增大到某个点时，O(log N)便会永远超越O(N)，即使该O(log N)算法的实际步数为O(2log N)。 所以大O是极为有用的工具，当两种算法落在不同的大O类别时，你就很自然地知道应该选择哪种。因为在大数据的情况下，必然存在一临界点使这两种算法的速度永远区分开来。 不过，本章的主要结论是即使两种算法的大O记法一样，但实际速度也可能并不一样。虽然选择排序比冒泡排序快1倍，但它们的大O记法都是O(N2)。因此，大O记法非常适合用于不同大O分类下的算法的对比，对于大O同类的算法，我们还需要进一步的解析才能分辨出具体差异。 一个实例假设你要写一个Ruby程序，从一个数组里取出间隔的元素，来组成新的数组。你可能会用数组的each_with_index方法来做如下遍历。 123456789def every_other(array) new_array = [] array.each_with_index do |element, index| new_array &lt;&lt; element if index.even? end return new_arrayend 它迭代原数组的每一个元素，如果元素索引值为偶数，则将该元素插入到新数组里。 分析其中步骤，会发现它们可分为两种：一种是读取数组元素，另一种是插入元素到新数组。 因为要读取数组的每一个元素，所以读取有N步。插入则只有N/2步，因为只有间隔的元素才被放到新数组里。从技术上来说，N次读取加N/2次插入，这算法的效率应该是O(N+(N/2))，或者是O(1.5N)。但因为大O记法要把常数丢掉，所以只写成O(N)。 此算法虽然能达到效果，但我们还是要再审视一下它有没有提升的空间。事实上，有。 与其迭代每个元素并检查它们的索引是否为偶数，不如只读取数组中间隔的元素。 123456789def every_other(array) new_array = [] index = 0 while index &lt; array.length new_array &lt;&lt; array[index] index += 2 end return new_arrayend 这种做法的while循环会跳过间隔的元素，因此避免了检查每个元素。结果就是有N个元素，会有N/2次读取，N/2次插入。它跟第一种做法一样，记为O(N)。 然而，第一种做法实际有1.5N步，比只有N步的第二种明显要慢。虽然第一种的写法在Ruby界更为惯用，但如果要处理的数据量庞大，不妨尝试第二种，以获得性能的飞升。 总结现在我们已经掌握了一些非常强大的算法分析手法。我们能够使用大O去判断各种算法的效率，即便两种算法的大O记法一样，也知道如何对比它们。 不过在对比算法时，还需要考虑一个重要因素。至今我们关注的都是最坏情况下算法会跑得多慢，但其实最坏情况并不总会发生。没错，我们遇到的大都是平均情况。下一章，我们会学习怎样顾及所有情况。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章-运用大O来给代码提速]]></title>
    <url>%2F2019%2F06%2F26%2F%E7%AC%AC4%E7%AB%A0-%E8%BF%90%E7%94%A8%E5%A4%A7O%E6%9D%A5%E7%BB%99%E4%BB%A3%E7%A0%81%E6%8F%90%E9%80%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 冒泡排序为什么叫冒泡排序？冒泡排序的大O记法是什么？为什么？ 冒泡排序的执行步骤是哪两步？图是什么样的？也叫作什么？ 嵌套循环算法的效率是怎么样的？ 检查数组中是否有重复值怎么进行线性解决？ 本章涵盖： 冒泡排序 冒泡排序实战 冒泡排序的实现 冒泡排序的效率 二次问题 线性解决 大O记法能客观地衡量各种算法的时间复杂度，是比较算法的利器。我们也试过用它来对比二分查找和线性查找的步数差异，发现二分查找的步数为O(log N)，比线性查找的O(N)快得多。 然而，写代码的时候并不总有这样明确的二选一，更多时候你可能就直接采用首先想到的那种算法了。不过有了大O的话，你就可以与其他常用的算法比较，然后问自己：“我的算法跟它们相比，是快还是慢？” 如果你通过大O发现自己的算法比其他的要慢，你就应该退一步，好好想想怎样优化它，才能使它变成更快的那种大O。虽然并不总有提升空间，但在确定编码之前多加考虑还是好的。 本章我们会写些代码来解决一个实际问题，并且会用大O来测量算法的性能，然后看看是否能对算法做些修改，使得性能提升。（剧透：能。） 冒泡排序但在讨论实际问题之前，先来学习一种新的时间复杂度。我们会从计算机科学的经典算法之一开始阐述。 排序算法是计算机科学中被广泛研究的一个课题。历时多年，它发展出了数十种算法，这些算法都着眼于一个问题： 如何将一个无序的数字数组整理成升序？ 你会在本章以及下一章看到这些算法。起初我们会学习一些“简单排序”，它们很好懂，但效率不如其他排序算法。 冒泡排序是一种很基本的排序算法，步骤如下。 (1)指向数组中两个相邻的元素（最开始是数组的头两个元素），比较它们的大小。 (2)如果它们的顺序错了（即左边的值大于右边），就互换位置。 如果顺序已经是正确的，那这一步就什么都不用做。 (3)将两个指针右移一格。 重复第(1)步和第(2)步，直至指针到达数组末尾。 (4)重复第(1)至(3)步，直至从头到尾都无须再做交换，这时数组就排好序了。 这里被重复的第(1)至(3)步是一个轮回，也就是说，这个算法的主要步骤被“轮回”执行，直到整个数组的顺序正确。 冒泡排序实战下面来举一个完整的例子。假设要对[4, 2, 7, 1, 3]进行排序。它现在是无序的，我们的目标是产生一个包含相同元素、升序的数组。 开始第1次轮回。 数组一开始如下图所示。 第1步：首先，比较4和2。如图可见它们的顺序是错的。 第2步：交换它们的位置。 第3步：比较4和7。 它们的顺序正确，所以不用做什么交换。 第4步：比较7和1。 第5步：顺序错误，于是进行交换。 第6步：比较7和3。 第7步：顺序错误，于是进行交换。 因为我们一直把较大的元素换到右边，所以现在最右侧的7正处于其正确位置上。我将那个格子用虚线圈起来了。 这也正是此种算法名为冒泡排序的原因：每一次轮回过后，未排序的值中最大的那个都会“冒”到正确的位置上。 因为刚才那次轮回做了不止一次的交换，所以得继续轮回。 下面来第2次轮回。 此时7已经在正确的位置上了。 第8步：从比较2和4开始。 它们已经按顺序排好了，所以直接进行下一步。 第9步：比较4和1。 第10步：它们的顺序错误，于是交换。 第11步：比较4和3。 第12步：顺序错误，进行交换。 因为7已经在上一次轮回里排好了，所以无须比较4和7。此外，4移到了正确的位置，本次轮回结束。因为这次轮回也做了不止一次的交换，所以得继续轮回。 下面来第3次轮回。 第13步：比较2和1。 第14步：顺序错误，进行交换。 第15步：比较2和3。 顺序正确，不用交换。 这时3也“冒”到其正确位置了。因为这次轮回做了不止一次的交换，所以还要继续。 于是开始第4次轮回。 第 16步：比较1和2。 顺序正确，不用交换。而且剩下的元素也都排好序了，轮回结束。 因为刚才的轮回没有任何交换，可知整个数组都已排好序。 冒泡排序的实现以下是用Python写的冒泡排序。 1234567891011121314def bubble_sort(list): unsorted_until_index = len(list) - 1 sorted = False while not sorted: sorted = True for i in range(unsorted_until_index): if list[i] &gt; list[i+1]: sorted = False list[i], list[i+1] = list[i+1], list[i] unsorted_until_index = unsorted_until_index - 1list = [65, 55, 45, 35, 25, 15, 10]bubble_sort(list)print list 让我们来一行行地分析。我会先摘出代码片段，然后给出解释。 1unsorted_until_index = len(list) - 1 变量unsorted_until_index表示“该索引之前的数据都没排过序”。一开始整个数组都是没排过序的，所以此变量赋值为数组的最后一个索引。 1sorted = False 另外还有一个sorted变量，被用来记录数组是否已完全排好序。当然一开始它应该是False 。 12while not sorted: sorted = True 接着是一个while循环，除非数组排好了序，不然它不会停下来。然后，我们先将sorted初步设置为True。当发生任何交换时，我们会将其改为False。如果在一次轮回里没有做过交换，那么sorted就确定为True，我们知道数组已排好序了。 1234for i in range(unsorted_until_index): if list[i] &gt; list[i+1]: sorted = False list[i], list[i+1] = list[i+1], list[i] 在while循环里，还有一个for循环会迭代未排序元素的索引值。此循环中，我们会比较相邻的元素，如果有顺序错误，就会进行交换，并将sorted改为False 。 1unsorted_until_index = unsorted_until_index - 1 到了这一行，就意味着一次轮回结束了，同时该次轮回中冒泡到右侧的值处于正确位置。因为unsorted_until_index所指的位置已放上了正确的元素，所以减1，以便下一次轮回能略过该位置。 一次while 循环就是一次轮回，循环会持续直至sorted确定为True 。 冒泡排序的效率冒泡排序的执行步骤可分为两种。 比较：比较两个数看哪个更大。 交换：交换两个数的位置以使它们按顺序排列。 先看看冒泡排序要进行多少次比较。 回顾之前那个5个元素的数组，你会发现在第1次轮回我们为4对元素进行了4次比较。 到了第2次轮回，则只做了3次比较。这是因为第 1次轮回已经确定了最后一个格子的元素，所以不用再比较最后两个元素了。 第3次轮回，只比较2次；第4次，只比较1次。 算起来就是： 4 + 3 + 2 + 1 = 10 次比较。 推广到N个元素，需要 (N - 1) + (N - 2) + (N - 3) + … + 1次比较。 分析过比较之后，再来看看交换。 如果数组不只是随机打乱，而是完全反序，在这种最坏的情况下，每次比较过后都得进行一次交换。因此10次比较加10次交换，总共20步。 现在把两种步骤放在一起来看。一个含有10个元素的数组，需要： 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 45次比较，以及45次交换，共90步。 20个元素的话，就是： 19 + 18 + 17 + 16 + 15 + 14 + 13 + 12 + 11 + 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 190次比较，以及190次交换，共380步。 效率太低了。元素量呈倍数增长，步数却呈指数增长，如下表所示。 ** N个元素 ** ** 最多步数 ** 5 20 10 90 20 380 40 1560 80 6320 再看仔细一点，你会发现随着N的增长，步数大约增长为N2 。 N个元素 最多步数 N2 5 20 25 10 90 100 20 380 400 40 1560 1600 80 6320 6400 因此描述冒泡排序效率的大O记法，是O(N2)。 规范一些来说：用O(N2)算法处理N个元素，大约需要N2步。 O(N2)算法是比较低效的，随着数据量变多，其步数也剧增，如下图所示。 注意O(N2)代表步数的曲线非常陡峭，O(N)的则只呈对角线状。 最后一点：O(N2)也被叫作二次时间。 二次问题假设你正在写一个JavaScript应用，它要检查数组中是否有重复值。 首先想到的做法可能是类似下面的嵌套for循环。 12345678910function hasDuplicateValue(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; for(var j = 0; j &lt; array.length; j++) &#123; if(i !== j &amp;&amp; array[i] == array[j]) &#123; return true; &#125; &#125; &#125; return false;&#125; 此函数用var i来遍历数组元素。每当i指向下一元素时，我们又发起第二个for循环，用var j来遍历数组元素，并在这第二个循环过程中检查i和j两个位置的值是否相同。若相同，则表示数组有重复值。如果两层循环都没遇到重复值，则最终返回false，以示数组没有重复值。 虽然可以这么做，但它的效率高吗？既然我们学过一点大O记法，那么就试试用大O来评价一下这个函数吧。 记住，大O测量的是步数与数据量的关系。因此，我们要测的就是：给hasDuplicateValue函数传入一个含有N个元素的数组，最坏情况下需要多少步才能完成。 要回答这个问题，得先搞清楚这个函数有哪些步骤，以及其最坏情况是什么。 该函数只有一种步骤，就是比较。它重复地比较i和j所指的值，看它们是否相等，以判断数组有没有重复值。最坏的情况就是没有重复，这将使我们跑遍内外两层循环，比较完所有i、j组合，才返回false 。 由此可知N个元素要比较N2次。因为外层循环需要N步来遍历数组，而这里的每1步，又会发起内层循环去用N步遍历数组。所以N步乘以N步等于N2步，此函数为一个O(N2)算法。 想要证明的话，还可以往函数里添加一些跟踪步数的代码。 12345678910111213function hasDuplicateValue(array) &#123; var steps = 0; for(var i = 0; i &lt; array.length; i++) &#123; for(var j = 0; j &lt; array.length; j++) &#123; steps++; if(i !== j &amp;&amp; array[i] == array[j]) &#123; return true; &#125; &#125; &#125; console.log(steps); return false;&#125; 执行hasDuplicateValue([1,2,3])的话，你会看到Javascript console输出9，表示9次比较。3个元素需要9次比较，这个函数是O(N2)的经典例子。 毫无疑问，嵌套循环算法的效率就是O(N2)。一旦看到嵌套循环，你就应该马上想到O(N2)。 虽然hasDuplicateValue是我们目前唯一想到的解决方法，但在确定采用之前，应意识到它的O(N2)意味着低效。当遇到低效的算法时，我们都应该花些时间思考下有没有更快的做法。 特别是当数据量巨大的时候，优化不足的应用甚至可能会突然挂掉。尽管这可能已经是最佳方案，但你还是要确认一下。 线性解决以下是hasDuplicateValue的另一种实现，它没有嵌套循环。看看它是否会比之前的更加高效。 1234567891011function hasDuplicateValue(array) &#123; var existingNumbers = []; for(var i = 0; i &lt; array.length; i++) &#123; if(existingNumbers[array[i]] === undefined) &#123; existingNumbers[array[i]] = 1; &#125; else &#123; return true; &#125; &#125; return false;&#125; 此实现只有一个循环，并将迭代过程中遇到的数字用数组existingNumbers记录下来。其记录方法很有趣：每发现一个新的数字，就以其为索引找出existingNumbers中对应的格子，将其赋值为1。 举个例子，如果参数array为[3,5,8]，那么循环结束时， existingNumbers就会变成以下这样。 1[undefined, undefined, undefined, 1, undefined, 1, undefined, undefined, 1] // 第一次索引为3,5,8的时候和undefined比较是相等的，所以赋值为1。0,1,2,4等索引没有赋值，所以是undefined 里面那些1的位置为索引3、5、8，因为array包含的这些数字已被发现。 不过，在将1赋值到对应的索引上之前，还得先检查索引上是否已有1。如果有，那就意味着这个数字曾经遇到过，也就是传入的数组有重复值。 为了确定这一新算法的时间复杂度符合哪种大O，我们得考察其最坏情况下需要多少步。与上一算法类似，此算法的主要步骤也是比较。读取existingNumbers上某索引的值，并与undefined比较，代码如下。 1if(existingNumbers[array[i]] === undefined) （其实除了比较，我们还要对existingNumbers进行插入，但这无关紧要，原因会在下一章进行讲解。） 同样，最坏的情况就是无重复，因为你得跑完整个循环才能发现。 可见N个元素就要N次比较。因为这里只有一个循环，数组有多少个元素，它就要迭代多少次。要证明这个猜想，可以用JavaScript console来打印步数。 1234567891011121314function hasDuplicateValue(array) &#123; var steps = 0; var existingNumbers = []; for(var i = 0; i &lt; array.length; i++) &#123; steps++; if(existingNumbers[array[i]] === undefined) &#123; existingNumbers[array[i]] = 1; &#125; else &#123; return true; &#125; &#125; console.log(steps); return false;&#125; 执行hasDuplicateValue([1,2,3])的话，你会看到输出为 3，跟元素个数一致。 因此其大O记法是O(N)。 我们知道O(N)远远快于O(N2)，所以采用第二种算法能极大地提升hasDuplicateValue 的效率。如果这个程序处理的数据量很大，那么性能差别是很明显的（其实第二种算法有一个缺点，不过我们在最后一章才会讲到）。 总结毫无疑问，熟悉大O记法能使我们发现低效的代码，有助于我们挑选出更快的算法。然而，偶尔也会有两种算法的大O相同，但实际上二者快慢不一的情况。下一章我们就来学习当大O记法太过粗略的时候，如何识别两种算法的效率高低。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章-大O记法]]></title>
    <url>%2F2019%2F06%2F26%2F%E7%AC%AC3%E7%AB%A0-%E5%A4%A7O%E8%AE%B0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是大O记法？解答的是什么样的问题？ O(1)是什么意思？有哪些算法是O(1)？ O(N)是什么意思？哪些算法是O(N)？ O(1)和O(N)分别又叫做什么？ 线性查找的最好情况是O(1)，最坏情况是O(N)如何理解？大O记法一般都是指最坏情况如何理解？ 二分查找的大O记法是什么样的？也叫作什么？ 什么是对数和指数？ O(log N)算法是什么意思？ O(1)、O(log N)、O(N)的效率比较是什么样的？在图中如何表示？ 本章涵盖： 大O：数步数 常数时间与线性时间 同一算法，不同场景 第三种算法 对数 解释O(log N) 从之前的章节中我们了解到，影响算法性能的主要因素是其所需的步数。 然而，我们不能简单地把一个算法记为“22步算法”，把另一个算法记为“400步算法”，因为一个算法的步数并不是固定的。以线性查找为例，它的步数等于数组的元素数量。如果数组有22个元素，线性查找就需要22步；如果数组有400个元素，线性查找就需要400步。 量化线性查找效率的更准确的方式应该是：对于具有N个元素的数组，线性查找最多需要N步。当然，这听起来很啰唆。 为了方便表达数据结构和算法的时间复杂度，计算机科学家从数学界借鉴了一种简洁又通用的方式，那就是大O记法。这种规范化语言使得我们可以轻松地指出一个算法的性能级别，也令学术交流变得简单。 掌握了大O记法，就掌握了算法分析的专业工具。 虽说大O记法源于数学领域，但接下来我们不会讲解任何数学术语，只介绍跟计算机科学相关的部分。并且，我们会循序渐进，先用简单的词汇来解释它，然后在接下来的三章中将其构建完善。大O记法不复杂，但我们还是分成了几个章节来细述，使其更容易理解。 大O：数步数为了统一描述，大O不关注算法所用的时间，只关注其所用的步数。 第1章介绍过，数组不论多大，读取都只需1步。用大O记法来表示，就是： O(1) 很多人将其读作“大O1”，也有些人读成“1数量级”。我一般读成“O1”。虽然大O记法有很多种读法，但写法只有一种。 O(1)意味着一种算法无论面对多大的数据量，其步数总是相同的。就像无论数组有多大，读取元素都只要1步。这1步在旧机器上也许要花20分钟，而用现代的硬件却只要1纳秒。但这两种情况下，读取数组都是1步。 其他也属于O(1)的操作还包括数组末尾的插入与删除。之前已证明，无论数组有多大，这两种操作都只需1步，所以它们的效率都是O(1)。 下面研究一下大O记法如何描述线性查找的效率。回想一下，线性查找在数组上要逐个检查每个格子。在最坏情况下，线性查找所需的步数等于格子数。即如前所述：对于N个元素的数组，线性查找需要花N步。 用大O记法来表示，即为： O(N) 我将其读作“O N”。 若用大O记法来描述一种处理一个N元素的数组需花N步的算法的效率，很简单，就是O(N)。 ** 数学解释 **前面提过，本书要采用一种易于理解的方式来讨论大O。当然这不是唯一的方式，如果你去上传统的大学算法课程，老师很可能从数学角度来介绍大O。因为大O本就是一个数学概念，所以人们经常用数学词汇介绍它，比如说“大O记法可用来描述一个函数的增长率的上限”，或者“如果函数g(x)的增长速度不比函数f(x)快，那么就称g属于O(f)”。大家数学背景不同，所以这些说法可能对你有意义，也可能没什么帮助。有了这本书，你不需要了解太多数学知识，就可以理解大O。 常数时间与线性时间从O(N)可以看出，大O记法不只是用固定的数字（如22、440）来表示算法的步数，而是基于要处理的数据量来描述算法所需的步数。或者说，大O解答的是这样的问题：当数据增长时，步数如何变化？ O(N)算法所需的步数等于数据量，意思是当数组增加一个元素时，O(N)算法就要增加1步。而O(1)算法无论面对多大的数组，其步数都不变。 下图展示了这两种时间复杂度。 从图中可以看出，O(N)呈现为一条对角线。当数据增加一个单位时，算法也随之增加一步。也就是说，数据越多，算法所需的步数就越多。O(N)也被称为线性时间。 相比之下，O(1)则为一条水平线，因为不管数据量是多少，算法的步数都恒定。所以，O(1)也被称为常数时间。 因为大O主要关注的是数据量变动时算法的性能变化，所以你会发现，即使一个算法的恒定步数不是1，它也可以被归类为O(1)。假设有个算法不能1步完成，而要花3步，但无论数据量多大，它都需要3步。如果用图形来展示，该算法应该是这样： 因为不管数据量怎样变化，算法的步数都恒定，所以这也是常数时间，也可以表示为O(1)。虽然从技术上来说它需要3步而不是1步，但大O记法并不纠结于此。简单来说，O(1)就是用来表示所有数据增长但步数不变的算法。 如果说只要步数恒定，3步的算法也属于O(1)，那么恒为100步的算法也属于O(1)。虽然100步的算法在效率上不如1步的算法，但如果它的步数是恒定的，那么它还是比O(N)更高效。 为什么呢？如图所示。 对于元素量少于100的数组，O(N)算法的步数会少于100步的O(1)算法。当元素刚好为100个时，两者的步数同为100。而一旦超过100个元素，注意，O(N)的步数就多于O(1)。 因为数据量从这个临界点开始，直至无限，O(N)都会比O(1)花更多步数，所以总体上来说，O(N)比O(1)低效。 这对于步数恒为1000000的O(1)算法来说也是一样的。当数据量一直增长时，一定会到达一个临界点，使得O(N)算法比O(1)算法低效，而且这种落后的状况会持续到数据量无限大的时候。 同一算法，不同场景之前的章节我们提到，线性查找并不总是O(N)的。当要找的元素在数组末尾，那确实是O(N)。但如果它在数组开头，1步就能找到的话，那么技术上来说应该是O(1)。所以概括来说，线性查找的最好情况是O(1)，最坏情况是 O(N)。 虽然大O可以用来表示给定算法的最好和最坏的情景，但若无特别说明，大O记法一般都是指最坏情况。因此尽管线性查找有O(1)的最好情况，但大多数资料还是把它归类为O(N)。 这种悲观主义其实是很有用的：知道各种算法会差到什么程度，能使我们做好最坏打算，以选出最适合的算法。 第三种算法上一章我们学到：在同一个有序数组里，二分查找比线性查找要快。下面就来看看如何用大O记法描述二分查找。 它不能写成O(1)，因为二分查找的步数会随着数据量的增长而增长。它也不能写成O(N)，因为步数比元素数量要少得多，正如之前我们看到的，包含100个元素的数组只要7步就能找完。 看来，二分查找的时间复杂度介于O(1)和O(N)之间。 好了，二分查找的大O记法是：O(log N) 我将其读作“O log N”。归于此类的算法，它们的时间复杂度都叫作对数时间。 简单来说，O(log N)意味着该算法当数据量翻倍时，步数加1。这确实符合之前章节我们所介绍的二分查找。下面我们先整理一下至今学到的东西，之后马上就解释采取这种记法的原因。 到这里我们所提过的3种时间复杂度，按照效率由高到低来排序的话，会是这样：O(1)O(log N)O(N) 下图为它们三者的对比。 注意O(log N)曲线的微弯，使其效率略差于O(1)，却远胜于O(N)。 若想理解这种时间复杂度为什么是O(log N)，我们得先学习一下对数。如果你对这个数学概念已经很熟悉了，那么可以跳过下一节。 对数让我们来研究下为什么二分查找之类的算法被记为O(log N)，到底log是什么？ log即是对数（logarithm）。注意，虽然它的英文看起来和读起来都跟算法（algorithm）很像，但它与算法无关。 对数是指数的反函数，所以我们先回顾一下指数。 23等于：2 × 2 × 2结果为 8。 log28 则将上述计算反过来，它意思是：要把 2乘以自身多少次，才能得到8。因为需要3次，所以，log28 = 3。 再来一个例子。 26可以解释为：2 × 2 × 2 × 2 × 2 × 2 = 64因为2要乘以自身6次才得到64，所以，log264 = 6。 不过以上都是教科书式的定义，我打算换一种更形象和更易于理解的方式来解释。 log2 8可以表达为：将8不断地除以2直到1，需要多少个2。8 / 2 / 2 / 2 = 1（注：按照从左到右的顺序计算。） 或者说，将8不断地除以2，要除多少次才能到1呢？答案是3，所以，log28 = 3。 类似地，log264可以解释为：将64除以2多少次，才能得到1。64 / 2 / 2 / 2 / 2 / 2 / 2 = 1 因为这里有6个2，所以，log264 = 6。 现在你应该明白对数是怎么回事了，那么O(log N)就很好懂了。 解释O(log N)现在回到大O记法。当我们说O(log N)时，其实指的是O(log2N)，不过为了方便就省略了2而已。 你应该还记得O(N)代表算法处理N个元素需要N步。如果元素有8个，那么这种算法就需要8步。 O(log N)则代表算法处理N个元素需要log2N步。如果有8个元素，那么这种算法需要3步，因为log28 = 3。 从另一个角度来看，如果要把8个元素不断地分成两半，那么得拆分3次才能拆到只剩1个元素。 这正是二分查找所干的事情。它就是不断地将数组拆成两半，直至范围缩小到只剩你要找的那个元素。 简单来说，O(log N)算法的步数等于二分数据直至元素剩余1个的次数。 下表是O(N)和O(log N)的效率对比。 N个元素 *O(N) * O(log N) 8 8 3 16 16 4 32 32 5 64 64 6 128 128 7 256 256 8 512 512 9 1024 1024 10 每次数据量翻倍时，O(N)算法的步数也跟着翻倍，O(log N)算法却只需加 1。 后面的章节我们还会学到除了这3种时间复杂度以外的算法。不过现在，我们还是先把已经学会的实践到日常的代码中。 实例以下是打印列表所有元素的典型Python代码。 123things = ['apples', 'baboons', 'cribs', 'dulcimers']for thing in things: print "Here's a thing: %s" % thing 它的效率要怎么用大O记法来表示呢？ 首先，这是一个算法的例子。虽然它并没有多么厉害，但不管一段代码做什么事情，技术上来说它都是一个算法--因为它是解决某种问题的一个独特的过程。在此例中，问题是打印列表的所有元素，而算法是在for循环中使用print 。 为了得出它的大O记法，我们需要分析这个算法的步数。这段代码的主要部分--for循环会走4步，因为列表总共有4个元素。 然而，此过程不一定总是这样。如果列表有10个元素，那么for循环就会是10步。因为这里for的步数等于元素数量，所以整个算法的效率是O(N)。 再来一个例子，这是大家都知道的最基础的代码。 1print('Hello world!') 它永远都只会是1步，所以是O(1)。 以下的例子是代码判断一个数字是否为质数。 12345def is_prime(number): for i in range(2, number): if number % i == 0: return Falsereturn True 它接受一个参数，名为number ，然后用一个for 循环来测试number除以2到number之间的数，看是否有余数。如果没有，则number非质数，可以马上返回False。但如果一直测到number除以number的前一个数都有余数，那么它就是一个质数，最后会返回True。 此算法的效率为O(N)。它不以数组为参数，而是用一个数字。如果is_prime传入的是7，那么for循环就要差不多走7次（准确来说是5步，因为是从2开始，直到该数字的前一个数）。如果是101，那就循环差不多101次。因为步数与参数的大小一致，所以它的效率是O(N)。 总结学会大O记法，我们在比较算法时就有了一致的参考系。有了它，我们就可以在现实场景中测量各种数据结构和算法，写出更快的代码，更轻松地应对高负荷的环境。 下一章会用一个实际的例子，让你看到大O记法如何帮助我们显著地提高代码的性能。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章-算法为何重要]]></title>
    <url>%2F2019%2F06%2F26%2F%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BD%95%E9%87%8D%E8%A6%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 有序数组和普通数组在线性查找方面有什么不同？ 有序数组还可以使用什么查找方法？为什么普通数组无法使用？ 有序数组在插入方面和普通数组有什么区别？谁快谁慢？ 用Python或Ruby代码实现线性查找和二分查找。 本章涵盖： 有序数组 查找有序数组 二分查找 二分查找与线性查找 上一章我们学习了两种数据结构，并明白了选择合适的数据结构将会显著地提升代码的性能。即使是像数组和集合这样相似的两种数据结构，在高负荷的运行环境下也会表现得天差地别。 在本章，你将会发现，就算数据结构确定了，代码的速度也还会受另一重要因素影响，那就是算法。 算法这个词听起来很深奥，其实不然。它只是解决某个问题的一套流程。准备一碗麦片的流程也可以说是一种算法，它包含以下4步（对我来说是4步吧）。 (1) 拿个碗。(2) 把麦片倒进碗里。(3) 把牛奶倒进碗里。(4) 把勺子放到碗里。 在计算机的世界里，算法则是指某项操作的过程。上一章我们研究了4种主要操作，包括读取、查找、插入和删除。这一章我们还是会经常提到它们，而且一种操作可能会有不止一种做法。 也就是说，一种操作会有多种算法的实现。我们很快会看到不同的算法能使代码变快或者变慢——高负载时甚至慢到停止工作。不过，现在先来认识一种新的数据结构：有序数组。它的查找算法就不止一种，我们将会学习如何选出正确的那种。 有序数组有序数组跟上一章讨论的数组几乎一样，唯一区别就是有序数组要求其值总是保持有序（你猜对了）。即每次插入新值时，它会被插入到适当的位置，使整个数组的值仍然按顺序排列。常规的数组则并不考虑是否有序，直接把值加到末尾也没问题。 以数组[3, 17, 80, 202]为例。 假设这是个常规的数组，你准备将75插入，那就可以把它放到尾端，如下所示。 如上一章所述，计算机只要1步就能完成这种操作。 但如果这是一个有序数组，你就必须要找到一个适当的位置，使插入75之后整个数组依然有序。 做起来可不像说的那么简单。整个过程不可能一步完成，因为计算机需要先找出那个适当的位置，然后将其及以后的值右移来腾出空间给75。下面就来介绍分解的步骤。 先回顾一下原始的数组。 第1步：检查索引0的值，看75应该在它的左边还是右边。 因为75大于3，所以75应该在它右边的某个位置。而具体的位置，目前还是不能确定，于是，再检查下一个格子。 第2步：检查下一格的值。 因为75大于17，所以继续。 第3步：检查下一格的值。 这次是80，大于75。因为这是第一次遇到大于75的值，可想而知，必须把75放在80的左侧以使整个数组维持有序。但要在这里插入75，还得先将它的位置空出来。 第4步：将最后一个值右移。 第5步：将倒数第二个值右移。 第6步：终于可以把75插入到正确的位置上了。 可以看到，往有序数组中插入新值，需要先做一次查找以确定插入的位置。这是它跟常规数组的关键区别（在性能方面）之一。 虽然插入的性能比不上常规数组，但在查找方面，有序数组却有着特殊优势。 查找有序数组上一章介绍了常规数组的查找方式：从左至右，逐个格子检查，直至找到。这种方式称为线性查找。 接下来看看有序数组的线性查找跟常规数组有何不同。 设一个常规数组[17,3,75,202,80]，如果想在里面查找22（其实并不存在），那你就得逐个元素去检查，因为22可能在任何一个位置上。要想在到达末尾之前结束检查，那么所找的值必须在末尾之前出现。 然而对于有序数组来说，即便它不包含要找的值，我们也可以提早停止查找。假设要在有序数组[3,17,75,80,202]里查找22，我们可以在查到75的时候就结束，因为22不可能出现在75的右边。 以下是用Ruby语言实现的有序数组线性查找。 1234567891011121314def linear_search(array, value) # 遍历数组的每一个元素 array.each do |element| # 如果这个元素等于我们要找的值，则将其返回 if element == value return value # 如果这个值大于我们要找的值，则提早退出循环 elsif element &gt; value break end end # 如果没找到，则返回空值 return nilend 因此，有序数组的线性查找大多数情况下都会快于常规数组。除非要找的值是最后那个，或者比最后的值还大，那就只能一直查到最后了。 只看到这里的话，可能你还是不会觉得两种数组在性能上有什么巨大区别。 这是因为我们还没释放算法的潜能。这是接下来就要做的。 至今我们提到的查找有序数组的方法就只有线性查找。但其实，线性查找只不过是查找算法的其中一种而已。这种逐个格子检查直至找到为止的过程，并不是查找的唯一途径。 有序数组相比常规数组的一大优势就是它可以使用另一种查找算法。此种算法名为二分查找，它比线性查找要快得多。 二分查找你小时候或许玩过这样一种猜谜游戏（或者现在跟你的小孩玩过）：我心里想着一个1到100之间的数字，在你猜出它之前，我会提示你的答案应该大一点还是小一点。 你应该凭直觉就知道这个游戏的策略。一开始你会先猜处于中间的50，而不是1。为什么？ 因为不管我接下来告诉你更大或是更小，你都能排除掉一半的错误答案！ 如果你说50，然后我提示要再大一点，那么你应该会选75，以排除掉剩余数字的一半。如果在75之后我告诉你要小一点，你就会选62或63。总之，一直都猜中间值，就能不断地缩小一半的范围。 下面来演示这个过程，但仅以1到10为例。 这就是二分查找的通俗描述。 有序数组相比常规数组的一大优势就是它除了可以用线性查找，还可以用二分查找。常规数组因为无序，所以不可能运用二分查找。 为了看出它的实际效果，假设有一个包含9个元素的有序数组。计算机不知道每个格子的值，如下图所示。 然后，用二分查找来找出7，过程如下。 第1步：检查正中间的格子。因为数组的长度是已知的，将长度除以 2，我们就可以跳到确切的内存地址上，然后检查其值。 值为9，可推测出7应该在其左边的某个格子里。而且，这下我们也排除了一半的格子，即9右边的那些（以及9本身）。 第2步：检查9左边的那些格子的最中间那个。因为这里最中间有两个，我们就随便挑了左边的。 它的值为4，那么7就在它的右边了。由此4左边的格子也就排除了。 第3步：还剩两个格子里可能有7。我们随便挑个左边的。 第4步：就剩一个了。（如果还没有，那就说明这个有序数组里真的没有7。） 终于找到7了，总共4步。是的，这个有序数组要是用线性查找也会是4步，但稍后你就会见识到二分查找的强大。 以下是二分查找的Ruby实现。 1234567891011121314151617181920212223242526272829def binary_search(array, value) # 首先，设定下界和上界，以限定所查之值可能出现的区域。 # 在开始时，以数组的第一个元素为下界，以最后一个元素为上界 lower_bound = 0 upper_bound = array.length - 1 # 循环检查上界和下界之间的最中间的元素 while lower_bound &lt;= upper_bound do # 如此找出最中间的格子之索引 #（无须担心商是不是整数，因为 Ruby 总是把两个整数相除所得的小数部分去掉） midpoint = (upper_bound + lower_bound) / 2 # 获取该中间格子的值 value_at_midpoint = array[midpoint] # 如果该值正是我们想查的，那就完事了。 # 否则，看你是要往上找还是往下找，来调整下界或上界 if value &lt; value_at_midpoint upper_bound = midpoint - 1 elsif value &gt; value_at_midpoint lower_bound = midpoint + 1 elsif value == value_at_midpoint return midpoint end end # 当下界超越上界，便知数组里并没有我们所要找的值 return nilend 二分查找与线性查找对于长度太小的有序数组，二分查找并不比线性查找好多少。但我们来看看更大的数组。 对于拥有100个值的数组来说，两种查找需要的最多步数如下所示。 线性查找：100步 二分查找：7步 用线性查找的话，如果要找的值在最后一个格子，或者比最后一格的值还大，那么就得查遍每个格子。有100个格子，就是100步。 二分查找则会在每次猜测后排除掉一半的元素。100个格子，在第一次猜测后，便排除了50个。 再换个角度来看，你就会发现一个规律。 长度为3的有序数组，二分查找所需的最多步数是2。 若长度翻倍，变成7（以奇数为例会方便选择正中间的格子，于是我们把长度翻倍后又增加了一个数），则最多步数会是3。 若再翻倍（并加1），变成15个元素，那么最多步数会是4。 规律就是，每次有序数组长度乘以2，二分查找所需的最多步数只会加1。 这真是出奇地高效。 相反，在3个元素的数组上线性查找，最多要3步，7个元素就最多要7步，100个元素就最多要 100步，即元素有多少，最多步数就是多少。数组长度翻倍，线性查找的最多步数就会翻倍，而二分查找则只是增加1步。 这种规律可以用下图来展示。 如果数组变得更大，比如说10000个元素，那么线性查找最多会有10000步，而二分查找最多只有 14步。再增大到1000000个元素，则线性查找最多有1000 000步，二分查找最多只有20步。 不过还要记住，有序数组并不是所有操作都比常规数组要快。如你所见，它的插入就相对要慢。衡量起来，虽然插入是慢了一些，但查找却快了许多。还是那句话，你得根据应用场景来判断哪种更合适。 总结关于算法的内容就是这些。很多时候，计算一样东西并不只有一种方法，换种算法可能会极大地影响程序的性能。 同时你还应意识到，世界上并没有哪种适用于所有场景的数据结构或者算法。你不能因为有序数组能使用二分查找就永远只用有序数组。在经常插入而很少查找的情况下，显然插入迅速的常规数组会是更好的选择。 如之前所述，比较算法的方式就是比较各自的步数。 下一章，我们将会学习如何规范地描述数据结构和算法的时间复杂度。有了这种通用的表达方式，就能更容易地观察出哪种算法符合我们的实际需求。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章-数据结构为何重要]]></title>
    <url>%2F2019%2F06%2F25%2F%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%BA%E4%BD%95%E9%87%8D%E8%A6%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 数据结构是什么？为什么重要？举几个数据结构。 内存是什么样子的？ 数组读取为什么快？ 什么是线性查找？在含有N个元素的数组上进行线性查找最多要多少步呢？ 一个含有N个元素的数组，其插入数据的最好情况会花费多少步？最坏呢？ 一个含有N个元素的数组，其删除数据的最好情况会花费多少步？最坏呢？ 什么是时间复杂度？ 本章涵盖： 基础数据结构：数组 读取 查找 插入 删除 集合：一条规则决定性能 总结 哪怕只写过几行代码的人都会发现，编程基本上就是在跟数据打交道。计算机程序总是在接收数据、操作数据或返回数据。不管是求两数之和的小程序，还是管理公司的企业级软件，都运行在数据之上。 数据是一个广义的术语，可以指代各种类型的信息，包括最基本的数字和字符串。在经典的“Hello World!”这个简单程序中，字符串“Hello World!”就是一条数据。事实上，无论是多么复杂的数据，我们都可以将其拆成一堆数字和字符串来看待。 数据结构则是指数据的组织形式。看看以下代码。 12345x = "Hello!"y = "How are you"z = "today?"print(x + y + z) 这个非常简单的程序把3条数据串成了一句连贯的话。如果要描述该程序中的数据结构，我们会说，这里有3个独立的变量，分别引用着3个独立的字符串。 但数据结构不只是用于组织数据，它还极大地影响着代码的运行速度。因为数据结构不同，程序的运行速度可能相差多个数量级。如果你写的程序要处理大量的数据，或者要让数千人同时使用，那么你采用何种数据结构，将决定它是能够运行，还是会因为不堪重负而崩溃。 一旦对各种数据结构有了深刻的理解，并明白它们对程序性能方面的影响，你就能写出快速而优雅的代码，从而使软件运行得快速且流畅。当然，你的编程技能也会更上一层楼。 本章接下来将会分析两种数据结构：数组和集合。它们从表面上看好像差不多，但通过即将介绍的分析工具，你将会观察到它们在性能上的差异。 基础数据结构：数组数组是计算机科学中最基本的数据结构之一。如果你用过数组，那么应该知道它就是一个含有数据的列表。它有多种用途，适用于各种场景，下面就举个简单的例子。 一个允许用户创建和使用购物清单的食杂店应用软件，其源代码可能会包含以下的片段。 1array = ["apples", "bananas", "cucumbers", "dates", "elderberries"] 这就是一个数组，它刚好包含5个字符串，每个代表我会从超市买的食物。 此外，我们会用一些名为索引的数字来标识每项数据在数组中的位置。 在大多数的编程语言中，索引是从0算起的，因此在这个例子中，“apples”的索引为0，“elderberries”的索引为4，如下所示。 若想了解某个数据结构（例如数组）的性能，得分析程序怎样操作这一数据结构。 一般数据结构都有以下4种操作（或者说用法）。 读取：查看数据结构中某一位置上的数据。对于数组来说，这意味着查看某个索引所指的数据值。例如，查看索引2上有什么食品，就是一种读取。 查找：从数据结构中找出某个数据值的所在。对于数组来说，这意味着检查其是否包含某个值，如果包含，那么还得给出其索引。例如，检查“dates”是否存在于食品清单之中，给出其对应的索引，就是一种查找。 插入：给数据结构增加一个数据值。对于数组来说，这意味着多加一个格子并填入一个值。例如，往购物清单中多加一项“figs”，就是一种插入。 删除：从数据结构中移走一个数据值。对于数组来说，这意味着把数组中的某个数据项移走。例如，把购物清单中的“bananas”移走，就是一种删除。 本章我们将会研究这些操作在数组上的运行速度。 同时，我们也将学到本书的第一个重要理论：操作的速度，并不按时间计算，而是按步数计算。 为什么呢？ 因为，你不可能很绝对地说，某项操作要花5秒。它在某台机器上要跑5秒，但换到一台旧一点的机器，可能就要多于5秒，而换到一台未来的超级计算机，运行时间又将显著缩短。所以，受硬件影响的计时方法，非常不可靠。 然而，若按步数来算，则确切得多。如果A操作要5步，B操作要500步，那么我们可以很肯定地说，无论是在什么样的硬件上对比，A都快过B。因此，衡量步数是分析速度的关键。 此外，操作的速度，也常被称为时间复杂度。在本书中，我们会提到速度、时间复杂度、效率、性能，但它们其实指的都是步数。 事不宜迟，我们现在就来探索上述4种操作方式在数组上要花多少步。 读取首先看看读取，即查看数组中某个索引所指的数据值。 这只要一步就够了，因为计算机本身就有跳到任一索引位置的能力。在 [“apples”, “bananas”, “cucumbers”, “dates”, “elderberries”]的例子中，如果要查看索引2的值，那么计算机就会直接跳到索引2，并告诉你那里有“cucumbers”。 计算机为什么能一步到位呢？原因如下。 计算机的内存可以被看成一堆格子。下图是一片网格，其中有些格子有数据，有些则是空白。 当程序声明一个数组时，它会先划分出一些连续的空格子以备使用。换句话说，如果你想创建一个包含5个元素的数组，计算机就会找出5个排成一行的空格子，将其当成数组。 内存中的每个格子都有各自的地址，就像街道地址，例如大街123号。不过内存地址就只用一个普通的数字来表示。而且，每个格子的内存地址都比前一个大1，如下图所示。 购物清单数组的索引和内存地址，如下图所示。 计算机之所以在读取数组中某个索引所指的值时，能直接跳到那个位置上，是因为它具备以下条件。 (1)计算机可以一步就跳到任意一个内存地址上。（就好比，要是你知道大街123号在哪儿，那么就可以直奔过去。） (2)数组本身会记有第一个格子的内存地址，因此，计算机知道这个数组的开头在哪里。 (3)数组的索引从0算起。 回到刚才的例子，当我们叫计算机读取索引3的值时，它会做以下演算。 (1)该数组的索引从0算起，其开头的内存地址为1010。 (2)索引3在索引0后的第3个格子上。 (3)于是索引3的内存地址为1013，因为1010 + 3 = 1013。 当计算机一步跳到1013时，我们就能获取到“dates”这个值了。 所以，数组的读取是一种非常高效的操作，因为它只要一步就好。一步自然也是最快的速度。这种一步读取任意索引的能力，也是数组好用的原因之一。 如果我们问的不是“索引3有什么值”，而是“”dates”在不在数组里”，那么这就需要进行查找操作了。下面我们就来看看。 查找如前所述，对于数组来说，查找就是检查它是否包含某个值，如果包含，还得给出其索引。那么，我们就试试在数组中查找“dates”要用多少步。 对于我们人来说，可以一眼就看到这个购物清单上的“dates”，并数出它的索引为3。但是，计算机并没有眼睛，它只能一步一步地检查整个数组。 想要查找数组中是否存在某个值，计算机会先从索引0开始，检查其值，如果不匹配，则继续下一个索引，以此类推，直至找到为止。 我们用以下图来演示计算机如何从购物清单中查找“dates”。 首先，计算机检查索引0。 因为索引0的值是“apples”，并非我们所要的“dates”，所以计算机跳到下一个索引上。 索引1也不是“dates”，于是计算机再跳到索引2。 但索引2的值仍不匹配，计算机只好再跳到下一格。 啊，真是千辛万苦，我们找到“dates”了，它就在索引3那里。自此，计算机不用再往后跳了，因为结果已经得到。 在这个例子中，因为我们检查了4个格子才找到想要的值，所以这次操作总计是4步。 这种逐个格子去检查的做法，就是最基本的查找方法--线性查找。第2章我们还会学习另一种查找方法。 但在那之前，我们再思考一下，在数组上进行线性查找最多要多少步呢？ 如果我们要找的值刚好在数组的最后一个格子里（如本例的elderberries），那么计算机从头到尾检查每个格子，会在最后才找到。同样，如果我们要找的值并不存在于数组中，那么计算机也还是得查遍每个格子，才能确定这个值不在数组中。 于是，一个5格的数组，其线性查找的步数最大值是5，而对于一个500格的数组，则是500。 以此类推，一个N格的数组，其线性查找的最多步数是N（N可以是任何自然数）。 可见，无论是多长的数组，查找都比读取要慢，因为读取永远都只需要一步，而查找却可能需要多步。 接下来，我们再研究一下插入，准确地说，是插入一个新值到数组之中。 插入往数组里插入一个新元素的速度，取决于你想把它插入到哪个位置上。 假设我们想要在购物清单的末尾插入“figs”。那么只需一步。因为之前说过了，计算机知道数组开头的内存地址，也知道数组包含多少个元素，所以可以算出要插入的内存地址，然后一步跳到那里插入就行了。图示如下。 但在数组开头或中间插入，就另当别论了。这种情况下，我们需要移动其他元素以腾出空间，于是得花费额外的步数。 例如往索引2处插入”figs”，如下所示。 为了达到目的，我们必须先把“cucumbers”、“dates”和“elderberries”往右移，以便空出索引2。而这也不是一步就能移好，因为我们首先要将“elderberries”右移一格，以空出位置给“dates”，然后再将“dates”右移，以空出位置给“cucumbers”，下面来演示这个过程。 第1步：“elderberries”右移。 第2步：“date”右移。 第3步：“cucembers”右移。 第4步：至此，可以在索引2处插入“figs”了。 如上所示，整个过程有4步，开始3步都是在移动数据，剩下1步才是真正的插入数据。 最低效（花费最多步数）的插入是插入在数组开头。因为这时候需要把数组所有的元素都往右移。 于是，一个含有N个元素的数组，其插入数据的最坏情况会花费N + 1步。即插入在数组开头，导致N次移动，加上一次插入。 最后要说的“删除”，则相当于插入的反向操作。 删除数组的删除就是消掉其某个索引上的数据。 我们找回最开始的那个数组，删除索引2上的值，即“cucumbers”。 第1步：删除“cucumbers”。 虽然删除“cucumbers”好像一步就搞定了，但这带来了新的问题：数组中间空出了一个格子。因为数组中间是不应该有空格的，所以，我们得把“dates”和“elderberries”往左移。 第2步：将”dates”左移。 第3步：将”elderberries”左移。 结果，整个删除操作花了3步。其中第1步是真正的删除，剩下的2步是移数据去填空格。 所以，删除本身只需要1步，但接下来需要额外的步骤将数据左移以填补删除所带来的空隙。 跟插入一样，删除的最坏情况就是删掉数组的第一个元素。因为数组不允许空元素，当索引0空出，那么剩下的所有元素都要往左移去填空。 对于含有5个元素的数组，删除第一个元素需要1步，左移剩余的元素需要4步。而对于500个元素的数组，删除第一个元素需要1步，左移剩余的元素需要499步。可以推出，对于含有N个元素的数组，删除操作最多需要N步。 既然学会了如何分析数据结构的时间复杂度，那就可以开始探索各种数据结构的性能差异了。了解这些非常重要，因为数据结构的性能差异会直接造成程序的性能差异。 下一个要介绍的数据结构是集合，它跟数组似乎很像，甚至让人以为就是同一种东西。然而，我们将会看到它跟数组在性能上是有区别的。 集合：一条规则决定性能来看看另一种数据结构：集合。它是一种不允许元素重复的数据结构。 其实集合是有不同形式的，但现在我们只讨论基于数组的那种。这种集合跟数组差不多，都是一个普通的元素列表，唯一的区别在于，集合不允许插入重复的值。 要是你想往集合[“a”, “b”, “c”]再插入一个“b”，计算机是不会允许的，因为集合中已经有“b”了。 集合就是用于确保数据不重复。 如果你要创建一个线上电话本，你应该不会希望相同的号码出现两次吧。如果这个电话本程序用集合来处理，那就不会搞出这种麻烦了。 总之，集合就是一个带有“不允许重复”这种简单限制的数组。而该限制也导致它在4种基本操作中有1种与数组性能不同。 下面就来分析读取、查找、插入和删除在基于数组的集合上表现如何。 集合的读取跟数组的读取完全一样，计算机只要一步就能获取指定索引上的值。如之前解释的那样，这是因为计算机知道集合开头的内存地址，所以能够一步跳到集合的任意索引。 集合的查找也跟数组的查找无异，需要N步去检查某个值在不在集合当中。删除也是，总共需要N步去删除和左移填空。 但插入就不同了。先看看在集合末尾的插入。对于数组来说，末尾插入是最高效的，它只需要1步。 而对于集合，计算机得先确定要插入的值不存在于其中--因为这就是集合：不允许重复值。于是每次插入都要先来一次查找。 假设我们的购物清单是一个集合--用集合还是不错的，毕竟你不会想买重复的东西。如果当前集合是[“apples”, “bananas”, “cucumbers”, “dates”, “elderberries”]，然后想插入“figs”，那么就需要做一次如下的查找。 第1步：检查索引0有没有“figs”。 没有，不过说不定其他索引会有。为了在真正插入前确保它不存在于任何索引上，我们继续。 第2步：检查索引1。 第3步：检查索引2。 第4步：检查索引3。 第5步：检查索引4。 直到检查完整个集合，才能确定插入“figs”是安全的。于是，到最后一步。 第6步：在集合末尾插入“figs”。 在集合的末尾插入也属于最好的情况，不过对于一个含有5个元素的集合，你仍然要花6步。因为，在最终插入的那一步之前，要把5个元素都检查一遍。 换句话说，在N个元素的集合中进行插入的最好情况需要N+1步--N步去确认被插入的值不在集合中，加上最后插入的1步。 最坏的情况则是在集合的开头插入，这时计算机得检查N个格子以保证集合不包含那个值，然后用N步来把所有值右移，最后再用1步来插入新值。总共2N+1步。 这是否意味着因为它的插入比一般的数组慢，所以就不要用了呢？当然不是。在需要保证数据不重复的场景中，集合是非常重要的。但如果没有这种需求，那么选择插入比集合快的数组会更好一些。具体哪种数据结构更合适，当然要根据你的实际应用场景而定。 总结理解数据结构的性能，关键在于分析操作所需的步数。采取哪种数据结构将决定你的程序是能够承受住压力，还是崩溃。本章特别讲解了如何通过步数分析来判断某种应用该选择数组还是集合。 不同的数据结构有不同的时间复杂度，类似地，不同的算法（即使是用在同一种数据结构上）也有不同的时间复杂度。既然我们已经学会了时间复杂度的分析方法，那么现在就可以用它来对比各种算法，找出能够发挥代码极限性能的那个。这正是下一章所要讲的。 数组、集合（无重复数组）、有序数组、链表、散列表都是数据结构，但是某些语言只自带了一种或几种，像PHP有数组，如果要使用其他数据结构，需要自己定义。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引的本质]]></title>
    <url>%2F2019%2F06%2F25%2F%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。 我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 看一个例子： 图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理 相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用 二叉查找在O(log2n)的复杂度内获取到相应数据。 虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。 B-Tree和B+Tree目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。 B-Tree为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构： d为大于1的一个正整数，称为B-Tree的度。h为一个正整数，称为B-Tree的高度。每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。所有叶节点具有相同的深度，等于树高h。key和指针互相间隔，节点两端是指针。一个节点中的key从左到右非递减排列。所有节点组成树结构。每个指针要么为null，要么指向另外一个节点。如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。图2是一个d=2的B-Tree示意图。 由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对 相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下： 1234567891011121314BTree_Search(node, key)&#123; if(node == null) return null; foreach(node.key) &#123; if(node.key[i] == key) return node.data[i]; if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node); &#125; return BTree_Search(point[i+1]-&gt;node);&#125; data = BTree_Search(root, my_key); 关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。 另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本 文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找 到相应的资料进行阅读。 B+TreeB-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。 与B-Tree相比，B+Tree有以下不同点： 每个节点的指针上限为2d而不是2d+1。内节点不存储data，只存储key；叶子节点不存储指针。图3是一个简单的B+Tree示意。 由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。 一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。 带有顺序访问指针的B+Tree一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。 如图4所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高 区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点， 极大提到了区间查询效率。 这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。 为什么使用B-Tree（B+Tree）上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消 耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂 度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索 引的效率。 主存存取原理目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。 image 图5 从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。 主存的存取过程如下： 当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。 写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。 这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。 磁盘存取原理上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。 图6是磁盘的整体结构示意图。 image 图6 一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责 存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何 时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。 图7是磁盘结构的示意图。 image 图7 盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。 当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个 扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然 后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。 局部性原理与磁盘预读由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁 盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放 入内存。这样做的理论依据是计算机科学中著名的局部性原理： 当一个数据被用到时，其附近的数据也通常会马上被使用。 程序运行期间所需要的数据通常比较集中。 由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。 预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存 储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统 会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。 B-/+Tree索引的性能分析到这里终于可以分析B-/+Tree索引的性能了。 上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系 统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B- Tree还需要使用如下技巧： 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。 B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。 综上所述，用B-Tree作为索引结构效率是非常高的。 而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。 上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小： dmax = floor(pagesize / (keysize + datasize + pointsize)) (pagesize – dmax &gt;= pointsize) 或 dmax = floor(pagesize / (keysize + datasize + pointsize)) – 1 (pagesize – dmax &lt; pointsize) floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。 这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.你有没有见过委托或匿名方法，具体是什么？ 什么是委托？可以认为委托是持有一个或多个方法的对象。但是委托可以执行，这时候委托会执行它“持有”的方法。 声明委托类型委托也是一种类型，就好像类是类型一样。委托类型必须在被用来创建变量以及类型的对象之前声明。委托类型的声明语法如下： 委托类型的声明看上去与方法的声明很类似，有返回类型和参数列表。返回类型和参数列表执行了委托可以接受的方法的形式。 上面图中声明制定了MyDel类型的委托只会接受不返回值并且有单个int参数的方法。 委托类型声明在3个方面与方法声明不同。委托类型声明： 以delegate关键字开头 没有方法主体 不需要在类内部声明，因为它是类型声明 创建委托对象委托是引用类型，因此有引用和对象。在委托类型声明后，可以声明变量并创建类型的而对象。使用委托类型声明变量的语法如下： 给委托赋值如下的代码可以给委托赋值： 12345678910111213141516171819using UnityEngine;public class Test : MonoBehaviour &#123; public delegate void MyDel(int x); MyDel _delVar; void Start () &#123; _delVar = PrintNumber; // 赋值 _delVar(10); // 调用 &#125; void PrintNumber(int x) &#123; Debug.Log(x); &#125;&#125; 给委托赋值时，可以直接将方法名赋值给委托类型的变量，但是要保证方法的参数列表和返回值和委托类型一致。 委托除了能接受一个方法，还能接收多个方法。 可以使用+=运算符给委托变量增加方法。可以使用-=运算符从委托中移除方法。 123_delVar += PrintNumber1;_delVar += PrintNumber2;_delVar -= PrintNumber1; 调用委托调用委托和调用方法一样简单，比如上面的代码中，调用委托只需要将委托变量作为方法名，直接调用即可。 如果一个委托中有多个方法，则每个方法都会被调用。 调用带返回值的委托如果委托有返回值并且在调用列表中有一个以上的方法，会发生下面的情况： 调用列表中最后一个方法返回的值就是委托调用返回的值 调用列表中所有其它方法的返回值都会被忽略 匿名方法上面我们看过了使用实例方法来初始化委托。对于这种情况，方法本身也可以被其他代码显式调用。 但是如果方法只会被使用一次，除了创建委托语法的需要，没有必要创建独立的具名方法（包含方法名的方法）。匿名方法可以让我们创建没有方法名的方法。 如下面的代码： 123456789101112public delegate void MyDel(int x);MyDel _delVar;void Start ()&#123; _delVar += delegate(int x) &#123; Debug.Log(x); &#125;; _delVar(10);&#125; 这个代码和之前给委托赋值小节的代码效果相同。 使用匿名方法我们可以在如下地方使用匿名方法： 声明委托变量时作为初始化表达式。 组合委托时再赋值语句的右边。 给方法传委托类型的参数时。 匿名方法的语法匿名方法表达式的语法包含如下组成部分： delegate关键字 参数列表，如果没有参数可以省略 语句块，包含匿名方法的具体代码 返回类型匿名方法不需要显式声明返回类型。但是在方法体内必须返回一个与委托的返回类型相同的返回值。如果委托有void类型的返回值，匿名方法就不能返回值。 例如在下面的代码中，委托的返回类型是int。匿名方法的实现代码也必须在代码路径中返回int。 123456789public delegate int MyDel(int x);MyDel _delVar;void Start ()&#123; _delVar += delegate(int x) &#123; return x * 2; &#125;; _delVar(10);&#125; 参数匿名方法的参数列表必须在以下方面与委托匹配： 参数数量 参数类型及位置 修饰符 有些时候可以通过使圆括号为空或省略圆括号来简化匿名方法的参数列表，但必须满足以下两个条件： 委托的参数列表不包含任何out参数 匿名方法不使用任何参数 Lambda表达式上面我们学到了匿名方法，已经简化了不少的代码量，但是在C# 3.0中引入的Lambda表达式功能，进一步简化了语法。Lambda表达式可以完全替代匿名方法这一特性。 比如在匿名方法中，delegate这一关键字其实有些多余，因为编译器已经知道我们在将方法赋值给委托。 我们可以很容易地通过如下步骤把匿名方法转换为Lambda表达式： 删除delegate关键字 在参数列表和匿名方法主体之间放上Lambda运算符=&amp;gt ;，这个运算符读作goes to。 上图展示了lambda表达式如何一步步简化匿名方法，最后一种只有原匿名方法1/4的代码量，更简洁，更容易理解。 上图中简化的过程如下： 编译器还可以从委托的声明中知道委托参数的类型，因此Lambda表达式允许我们省略类型参数，如le2的赋值代码。 带有类型的参数列表称为显式类型 省略类型的参数列表称为隐式类型 如果只有一个隐式类型参数，可以省略参数列表的圆括号，如le3的赋值代码所示。 Lambda表达式允许表达式的主体是语句块或表达式。如果语句块仅包含一个返回语句，我们可以将语句块替换为return关键字后的表达式，如le4的赋值代码所示。 有关Lambda表达式的参数列表的要点如下： Lambda表达式参数列表中的参数必须在参数数量、类型和位置上与委托匹配 表达式的参数列表中的参数不一定需要包含类型（隐式类型），但如果委托有ref或out参数，此时必须注明类型。 如果只有一个参数，并且是隐式类型，可以省略圆括号，否则必须有括号。 如果没有参数，必须使用一组空的圆括号。 总结 委托是持有一个或多个方法的对象。但是委托可以执行，这时候委托会执行它“持有”的方法。 Lambda表达式可以完全替代匿名方法，所以建议使用Lambda表达式这一更简洁的语法。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xLua热更新3之生成代码]]></title>
    <url>%2F2019%2F06%2F24%2FxLua%E7%83%AD%E6%9B%B4%E6%96%B03%E4%B9%8B%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.如何创建一个空表？ 之前提到了生成代码的问题，是不是对这个概念很陌生？生成代码从广义上来说就是通过程序来生成代码。在xLua中也是如此，下面来看看在xLua中具体是什么。 xLua生成代码什么是生成代码？生成代码是xLua支持的lua和C#间交互技术之一，这种技术通过生成两者间的适配代码来实现交互，性能较好，是 推荐的方式。xLua可以自动生成配置好的代码，后面会有介绍。 另一种交互技术是反射，这种方式对安装包的影响更少，可以在性能要求不高或者对安装包大小很敏感的场景下使用。 应该什么时候生成代码？开发期不建议生成代码，可以避免很多由于不一致导致的编译失败，以及生成代码本身的编译等待。 发布手机版本前必须执行生成代码，建议做成自动化的流程。 做性能调优，性能测试前必须执行生成代码，因为生成和不生成性能的区别还是很大的。 如何生成代码？生成代码的过程是自动化的，xLua提供了相关的脚本进行生成。 入口是下图的菜单栏： 但是xLua需要首先知道生成哪些代码，这就涉及到xLua的配置了。 xLua的配置xLua所有的配置都支持三种方式：打标签；静态列表；动态列表。 配置有两必须两建议： 列表方式均必须是static的字段/属性 列表方式均必须放到一个static类 建议不用标签方式 建议列表方式配置放Editor目录（如果是Hotfix配置【后面会讲】，而且类位于Assembly-CSharp.dll之外的其它dll，必须放Editor目录） ** 打标签 ** xLua用白名单来指明生成哪些代码，而白名单通过attribute来配置，比如你想从lua调用c#的某个类，希望生成适配代码，你可以为这个类型打一个LuaCallCSharp标签： 1234[LuaCallCSharp]public class A&#123;&#125; 该方式方便，但在il2cpp下会增加不少的代码量，不建议使用。 ** 静态列表 ** 有时我们无法直接给一个类型打标签，比如系统API，没源码的库，或者实例化的泛化类型，这时你可以在一个静态类里声明一个静态字段，该字段的类型除BlackList和AdditionalProperties之外只要实现了IEnumerable就可以了（这两个例外后面具体会说），然后为这字段加上标签： 123456[LuaCallCSharp]public static List&lt;Type&gt; mymodule_lua_call_cs_list = new List&lt;Type&gt;()&#123; typeof(GameObject), typeof(Dictionary&lt;string, int&gt;),&#125;; 这个字段需要放到一个静态类里头，建议放到Editor目录 。 ** 动态列表 ** 声明一个静态属性，打上相应的[Hotfix]标签即可。 12345678910[Hotfix]public static List&lt;Type&gt; by_property&#123; get &#123; return (from type in Assembly.Load("Assembly-CSharp").GetTypes() where type.Namespace == "XXXX" select type).ToList(); &#125;&#125; Getter是代码，你可以实现很多效果，比如按名字空间配置，按程序集配置等等。 这个属性需要放到一个静态类里头，建议放到Editor目录 。 配置Attribute** XLua.LuaCallCSharp ** 1234[LuaCallCSharp]public class A&#123;&#125; 一个C#类型加了这个配置，xLua会生成这个类型的适配代码（包括构造该类型实例，访问其成员属性、方法，静态属性、方法），否则将会尝试用性能较低的反射方式来访问。 一个类型的扩展方法（Extension Methods）加了这配置，也会生成适配代码并追加到被扩展类型的成员方法上。 xLua只会生成加了该配置的类型，不会自动生成其父类的适配代码，当访问子类对象的父类方法，如果该父类加了LuaCallCSharp配置，则执行父类的适配代码，否则会尝试用反射来访问。 反射访问除了性能不佳之外，在il2cpp下还有可能因为代码剪裁而导致无法访问，后者可以通过下面介绍的ReflectionUse标签来避免。 XLua.ReflectionUse1234[ReflectionUse]public class A&#123;&#125; 一个C#类型类型加了这个配置，xLua会生成link.xml阻止il2cpp的代码剪裁。 对于扩展方法，必须加上LuaCallCSharp或者ReflectionUse才可以被访问到。 建议所有要在Lua访问的类型，要么加LuaCallCSharp，要么加上ReflectionUse，这才能够保证在各平台都能正常运行。 XLua.BlackList如果你不要生成一个类型的一些成员的适配代码，你可以通过这个配置来实现。 标签方式比较简单，对应的成员上加就可以了。 由于考虑到有可能需要把重载函数的其中一个重载列入黑名单，配置方式比较复杂，类型是List，对于每个成员，在第一层List有一个条目，第二层List是个string的列表，第一个string是类型的全路径名，第二个string是成员名，如果成员是一个方法，还需要从第三个string开始，把其参数的类型全路径全列出来。 例如下面是对GameObject的一个属性以及FileInfo的一个方法列入黑名单： 12345[BlackList]public static List&lt;List&lt;string&gt;&gt; BlackList = new List&lt;List&lt;string&gt;&gt;() &#123; new List&lt;string&gt;()&#123;"UnityEngine.GameObject", "networkView"&#125;, new List&lt;string&gt;()&#123;"System.IO.FileInfo", "GetAccessControl", "System.Security.AccessControl.AccessControlSections"&#125;,&#125;; XLua.DoNotGen指明一个类里的部分函数、字段、属性不生成代码，通过反射访问。 只能标注Dictionary&lt;type, list&gt;的field或者property。key指明的是生效的类，value是一个列表，配置的是不生成代码的函数、字段、属性的名字。 和ReflectionUse的区别是： ReflectionUse指明的是整个类； 当第一次访问一个函数（字段、属性）时，ReflectionUse会把整个类都wrap，而DoNotGen只wrap该函数（字段、属性），换句话DoNotGen更lazy一些； 和BlackList的区别是： BlackList配了里面指定的类型就不能在lua中用了； BlackList能指明某重载函数，DoNotGen不能。 XLua.CSharpCallLua如果希望把一个lua函数适配到一个C# delegate（一类是C#侧各种回调：UI事件，delegate参数，比如List:ForEach；另外一类场景是通过LuaTable的Get函数指明一个lua函数绑定到一个delegate）。或者把一个lua table适配到一个C# interface，该delegate或者interface需要加上该配置。 XLua.GCOptimize一个C#纯值类型（注：指的是一个只包含值类型的struct，可以嵌套其它只包含值类型的struct）或者C#枚举值加上了这个配置。xLua会为该类型生成gc优化代码，效果是该值类型在lua和c#间传递不产生（C#）gc alloc，该类型的数组访问也不产生gc。 除枚举之外，包含无参构造函数的复杂类型，都会生成lua table到该类型，以及改类型的一维数组的转换代码，这将会优化这个转换的性能，包括更少的gc alloc。 XLua.AdditionalProperties这个是GCOptimize的扩展配置，有的时候，一些struct喜欢把field写成私有的，通过property来访问field，这时就需要用到该配置（默认情况下GCOptimize只对public的field打解包）。 标签方式比较简单，配置方式复杂一点，要求是Dictionary&lt;type, list&gt;类型，Dictionary的Key是要生效的类型，Value是属性名列表。 下面是生成期配置，必须放到Editor目录下** CSObjectWrapEditor.GenPath ** 12[CSObjectWrapEditor.GenPath]public static string Path = Application.streamingAssetsPath; 配置生成代码的放置路径，类型是string。如果不配置默认生成在”Assets/XLua/Gen/“下。 ** CSObjectWrapEditor.GenCodeMenu ** 123[CSObjectWrapEditor.GenCodeMenu]public static void Method()&#123;&#125; 该配置用于生成引擎的二次开发，一个无参数函数加了这个标签，在执行”XLua/Generate Code”菜单时会触发这个函数的调用。 总结xLua也给出了一份常用的xLua的配置，可以在这个基础上根据自己的项目做修改。地址是：https://github.com/Tencent/xLua/blob/master/Assets/XLua/Editor/ExampleConfig.cs]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xLua热更新2之Lua调用C#]]></title>
    <url>%2F2019%2F06%2F24%2FxLua%E7%83%AD%E6%9B%B4%E6%96%B02%E4%B9%8BLua%E8%B0%83%E7%94%A8C%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.如何创建一个空表？ 之前学习了C#调用lua，更多的时候，都是调用DoString(“require ‘byfile’”)然后放到lua代码中去处理了，那就意味着会有更多的lua调用C#的情况。 Lua调用C创建C#对象在C#这样new一个对象： 1var newGameObj = new UnityEngine.GameObject(); 对应到Lua是这样： 1local newGameObj = CS.UnityEngine.GameObject() 基本上是类似的，区别是： lua里没有new关键字； 所有C#相关的都放到CS下，包括构造函数，静态成员属性、方法； 如果有多个构造函数呢？xlua支持重载，比如你要调用GameObject的带一个string参数的构造函数，这么写： 1local newGameObj2 = CS.UnityEngine.GameObject('helloworld') 访问C#静态属性，方法** 读静态属性 ** 1CS.UnityEngine.Time.deltaTime ** 写静态属性 ** 1CS.UnityEngine.Time.timeScale = 0.5 ** 调用静态方法 ** 1CS.UnityEngine.GameObject.Find('helloworld') 小技巧：如果需要经常访问的类，可以先用局部变量引用后访问，除了减少敲代码的时间，还能提高性能： 12local GameObject = CS.UnityEngine.GameObjectGameObject.Find('helloworld') 访问C#成员属性，方法** 读成员属性 ** 1testobj.DMF ** 写成员属性 ** 1testobj.DMF = 1024 ** 调用成员方法 ** 注意：调用成员方法，第一个参数需要传该对象，建议用冒号语法糖，如下 1testobj:DMFunc() 静态方法直接用点即可，成员方法需要用冒号语法糖。 ** 父类属性，方法 ** xlua支持（通过派生类）访问基类的静态属性，静态方法，（通过派生类实例）访问基类的成员属性，成员方法 123456print(DerivedClass.BSF)--读基类静态属性DerivedClass.BSF = 2048--写基类静态属性DerivedClass.BSFunc();--基类静态方法print(testobj.BMF)--读基类成员属性testobj.BMF = 4096--写基类成员属性testobj:BMFunc()--基类方法调用 ** 参数的输入输出属性（out，ref） ** Lua调用测的参数处理规则：C#的普通参数算一个输入形参，ref修饰的算一个输入形参，out不算，然后从左往右对应lua 调用测的实参列表； Lua调用测的返回值处理规则：C#函数的返回值（如果有的话）算一个返回值，out算一个返回值，ref算一个返回值，然后从左往右对应lua的多返回值。 比如C#的方法如下： 123456789101112public double ComplexFunc(Param1 p1, ref int p2, out string p3, Action luafunc, out Action csfunc)&#123; Debug.Log("P1 = &#123;x=" + p1.x + ",y=" + p1.y + "&#125;,p2 = " + p2); luafunc(); p2 = p2 * p1.x; p3 = "hello " + p1.y; csfunc = () =&gt; &#123; Debug.Log("csharp callback invoked!"); &#125;; return 1.23;&#125; lua中对应的调用方法为： 1234local ret, p2, p3, csfunc = testobj:ComplexFunc(&#123;x=3, y = 'john'&#125;, 100, function() print('i am lua callback')end)print('ComplexFunc ret:', ret, p2, p3, csfunc) ** 重载方法 ** 直接通过不同的参数类型进行重载函数的访问，例如： 12testobj:TestFunc(100)testobj:TestFunc('hello') 将分别访问整数参数的TestFunc和字符串参数的TestFunc。 注意：xlua只一定程度上支持重载函数的调用，因为lua的类型远远不如C#丰富，存在一对多的情况，比如C#的int，float，double都对应于lua的number，上面的例子中TestFunc如果有这些重载参数，第一行将无法区分开来，只能调用到其中一个（生成代码中排前面的那个） ** 操作符 ** 支持的操作符有：+，-，*，/，==，一元-，&lt;，&lt;=， %，[] 比如C#中如下代码： 123456public static DerivedClass operator +(DerivedClass a, DerivedClass b)&#123; DerivedClass ret = new DerivedClass(); ret.DMF = a.DMF + b.DMF; return ret;&#125; lua中支持的操作符如下： 1print('(testobj + testobj2).DMF = ', (testobj + testobj2).DMF) ** 参数带默认值的方法 ** 和C#调用有默认值参数的函数一样，如果所给的实参少于形参，则会用默认值补上。 C#代码： 1234public void DefaultValueFunc(int a = 100, string b = "cccc", string c = null)&#123; UnityEngine.Debug.Log("DefaultValueFunc: a=" + a + ",b=" + b + ",c=" + c);&#125; lua代码： 12testobj:DefaultValueFunc(1)testobj:DefaultValueFunc(3, 'hello', 'john') ** 可变参数方法 ** 对于C#的如下方法： 1void VariableParamsFunc(int a, params string[] strs) 可以在lua里头这样调用： 1testobj:VariableParamsFunc(5, 'hello', 'john') ** 使用Extension methods ** 在C#里定义了，lua里就能直接使用。 C#代码： 123456789101112131415161718[LuaCallCSharp]public static class DerivedClassExtensions&#123; public static int GetSomeData(this DerivedClass obj) &#123; Debug.Log("GetSomeData ret = " + obj.DMF); return obj.DMF; &#125; public static int GetSomeBaseData(this BaseClass obj) &#123; Debug.Log("GetSomeBaseData ret = " + obj.BMF); return obj.BMF; &#125; public static void GenericMethodOfString(this DerivedClass obj) &#123; obj.GenericMethod&lt;string&gt;(); &#125;&#125; lua代码： 123print(testobj:GetSomeData()) print(testobj:GetSomeBaseData()) --访问基类的Extension methodstestobj:GenericMethodOfString() --通过Extension methods实现访问泛化方法 ** 泛型（模版）方法 ** 不直接支持，可以通过Extension methods功能进行封装后调用。如上面代码中GenericMethodOfString方法所示。 ** 枚举类型 ** 枚举值就像枚举类型下的静态属性一样。 1testobj:EnumTestFunc(CS.Tutorial.TestEnum.E1) 上面的EnumTestFunc函数参数是Tutorial.TestEnum类型的。 枚举类支持__CastFrom方法，可以实现从一个整数或者字符串到枚举值的转换，例如： 12CS.Tutorial.TestEnum.__CastFrom(1)CS.Tutorial.TestEnum.__CastFrom('E1') ** delegate使用（调用，+，-） ** C#的delegate调用：和调用普通lua函数一样，注意此处调用是用点. +操作符：对应C#的+操作符，把两个调用串成一个调用链，右操作数可以是同类型的C# delegate或者是lua函数。 -操作符：和+相反，把一个delegate从调用链中移除。 Ps：delegate属性可以用一个luafunction来赋值。 12345678testobj.TestDelegate('hello') --直接调用local function lua_delegate(str) print('TestDelegate in lua:', str)endtestobj.TestDelegate = lua_delegate + testobj.TestDelegate --combine，这里演示的是C#delegate作为右值，左值也支持testobj.TestDelegate('hello')testobj.TestDelegate = testobj.TestDelegate - lua_delegate --removetestobj.TestDelegate('hello') ** event ** 比如testobj里头有个事件定义是这样：public event Action TestEvent; 增加事件回调 1testobj:TestEvent('+', lua_event_callback) 移除事件回调 1testobj:TestEvent('-', lua_event_callback) ** 64位整数支持 ** Lua53版本64位整数（long，ulong）映射到原生的64未整数，而luajit版本，相当于lua5.1的标准，本身不支持64位，xlua做了个64位支持的扩展库，C#的long和ulong都将映射到userdata： 支持在lua里头进行64位的运算，比较，打印 支持和lua number的运算，比较 要注意的是，在64扩展库中，实际上只有int64，ulong也会先强转成long再传递到lua，而对ulong的一些运算、比较，xLua采取和java一样的支持方式，提供一组API，详情请看API文档：https://github.com/Tencent/xLua/blob/master/Assets/XLua/Doc/XLua_API.md#%E6%97%A0%E7%AC%A6%E5%8F%B764%E4%BD%8D%E6%94%AF%E6%8C%81。 Lua53 vs Luajit 的区别我们在218学习过。 ** C#复杂类型和table的自动转换 ** 对于一个有无参构造函数的C#复杂类型，在lua侧可以直接用一个table来代替，该table对应复杂类型的public字段有相应字段即可，支持函数参数传递，属性赋值等，例如： C#下B结构体（也支持class）定义如下： 12345678910public struct A&#123; public int a;&#125;public struct B&#123; public A b; public double c;&#125; 某个类有成员函数如下： 1void Foo(B b) 在lua可以这么调用 1obj:Foo(&#123;b = &#123;a = 100&#125;, c = 200&#125;) ** 获取类型（相当于C#的typeof） ** 比如要获取UnityEngine.ParticleSystem类的Type信息，可以这样 1typeof(CS.UnityEngine.ParticleSystem) ** 强制转换 ** lua没类型，所以不会有强类型语言的强制转换。 但是某些情况下，比如：告诉xlua要用指定的生成代码去调用一个对象，有的时候第三方库对外暴露的是一个interface或者抽象类，实现类是隐藏的，这样我们无法对实现类进行代码生成。该实现类将会被xlua识别为未生成代码而用反射来访问，如果这个调用是很频繁的话还是很影响性能的，这时我们就可以把这个interface或者抽象类加到生成代码，然后指定用该生成代码来访问： 1cast(calc, typeof(CS.Tutorial.Calc)) 上面就是指定用CS.Tutorial.Calc的生成代码来访问calc对象。 总结使用lua访问C#代码的变化不大，需要注意里面几点： 如果需要经常访问的类，可以先用局部变量引用后访问，除了减少敲代码的时间，还能提高性能 xlua只一定程度上支持重载函数的调用，因为lua的类型远远不如C#丰富，存在一对多的情况，比如C#的int，float，double都对应于lua的number，无法区分 委托调用的时候需要用.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xLua热更新1之C#调用Lua]]></title>
    <url>%2F2019%2F06%2F24%2FxLua%E7%83%AD%E6%9B%B4%E6%96%B01%E4%B9%8BC-%E8%B0%83%E7%94%A8Lua%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.如何创建一个空表？ 前面学习了lua编程，使用xLua热更新的时候，很多代码都是使用lua来编写的。但是到目前为止我们学习的内容都还很孤立，C#代码是C#代码，lua代码是lua代码，那么他们之间怎么联系在一起呢？ C#访问Lua有时候，需要在C#中访问Lua中的数据或者函数，那怎么做呢？ 下面例子中用到的lua代码如下： 12345678910111213141516171819202122232425string script = @" a = 1 b = 'hello world' c = true d = &#123; f1 = 12, f2 = 34, 1, 2, 3, add = function(self, a, b) print('d.add called') return a + b end &#125; function e() print('i am e') end function f(a, b) print('a', a, 'b', b) return 1, &#123;f1 = 1024&#125; end function ret_e() print('ret_e called') return e end"; 访问全局变量LuaEnv.Global中有个模版Get方法，可指定返回的类型。获取一个全局基本数据类型使用这个方法即可。 12345luaenv = new LuaEnv();luaenv.DoString(script);Debug.Log("_G.a = " + luaenv.Global.Get&lt;int&gt;("a"));Debug.Log("_G.b = " + luaenv.Global.Get&lt;string&gt;("b"));Debug.Log("_G.c = " + luaenv.Global.Get&lt;bool&gt;("c")); 那如果访问非基本数据类型，比如table怎么办呢？ 访问table访问table需要将lua table转换成C#中的数据结构，有几种方式： 映射到普通class或struct 【推荐】映射到一个interface 更轻量级的by value方式：映射到Dictionary&lt;&gt;，List&lt;&gt; 另外一种by ref方式：映射到LuaTable类 ** 1.映射到class或struct ** 定义一个class或struct，有对应于table的字段的public属性，而且有无参数构造函数即可。 代码如下： 12345678public class DClass&#123; public int f1; public int f2;&#125;DClass d = luaenv.Global.Get&lt;DClass&gt;("d");//映射到有对应字段的class，by valueDebug.Log("_G.d = &#123;f1=" + d.f1 + ", f2=" + d.f2 + "&#125;"); table的属性可以多于或者少于class的属性。可以嵌套其它复杂类型。 ** 要注意的是，这个过程是值拷贝，如果class比较复杂代价会比较大。而且修改class的字段值不会同步到table，反过来也不会。 ** 可以通过把类型加到GCOptimize生成降低这个功能的开销。 ** GCOptimize ** 一个C#纯值类型（注：指的是一个只包含值类型的struct，可以嵌套其它只包含值类型的struct）或者C#枚举值加上了这个配置，xLua会为该类型生成gc优化代码，效果是该值类型在lua和c#间传递不产生（C#）gc alloc，该类型的数组访问也不产生gc。 除枚举之外，包含无参构造函数的复杂类型，都会生成lua table到该类型，以及生成该类型的一维数组的转换代码，这将会优化这个转换的性能，包括更少的gc alloc。 示例代码如下： 123456[GCOptimize]public struct DClass&#123; public int f1; public int f2;&#125; ** 2. 映射到interface【推荐】 ** 这种方式依赖于生成代码（如果没生成代码会抛InvalidCastException异常），代码生成器会生成这个interface的实例，如果get一个属性，生成代码会get对应的table字段，如果set属性也会设置对应的字段。甚至可以通过interface的方法访问lua的函数。 123456789101112[CSharpCallLua] // 最简单的一种添加到生成代码的方式public interface ItfD&#123; int f1 &#123; get; set; &#125; int f2 &#123; get; set; &#125; int add(int a, int b);&#125;ItfD d3 = luaenv.Global.Get&lt;ItfD&gt;("d"); //映射到interface实例，引用传递，这个要求interface加到生成列表，否则会返回null，建议使用该用法d3.f2 = 1000;Debug.Log("_G.d = &#123;f1=" + d3.f1 + ", f2=" + d3.f2 + "&#125;");Debug.Log("_G.d:add(1, 2)=" + d3.add(1, 2)); ** 什么是生成代码？ ** xLua支持的lua和C#间交互技术之一，这种技术通过生成两者间的适配代码来实现交互，性能较好，是推荐的方式。 另一种交互技术是反射，这种方式对安装包的影响更少，可以在性能要求不高或者对安装包大小很敏感的场景下使用。 xLua相对于其他lua解决方案的一个很大优势就是：** 编辑器下无需生成代码，开发更轻量。 ** 应该什么时候生成代码？如何生成代码呢？这个是一个比较大的话题，我们后面再详细讨论。 ** 3.映射到Dictionary&lt;&gt;，List&lt;&gt; ** 不想定义class或者interface的话，可以考虑用这个，前提table下key和value的类型都是一致的。这种也是值拷贝的方式。 12345Dictionary&lt;string, double&gt; d1 = luaenv.Global.Get&lt;Dictionary&lt;string, double&gt;&gt;("d");//映射到Dictionary&lt;string, double&gt;，by valueDebug.Log("_G.d = &#123;f1=" + d1["f1"] + ", f2=" + d1["f2"] + "&#125;, d.Count=" + d1.Count);List&lt;double&gt; d2 = luaenv.Global.Get&lt;List&lt;double&gt;&gt;("d"); //映射到List&lt;double&gt;，by valueDebug.Log("_G.d.len = " + d2.Count); ** 4.映射到LuaTable类 ** 这种方式好处是不需要生成代码，但也有一些问题，比如慢，比方式2要慢一个数量级，比如没有类型检查。这种方式是引用传递。 12LuaTable d4 = luaenv.Global.Get&lt;LuaTable&gt;("d");//映射到LuaTable，by refDebug.Log("_G.d = &#123;f1=" + d4.Get&lt;int&gt;("f1") + ", f2=" + d4.Get&lt;int&gt;("f2") + "&#125;"); 访问全局function访问全局的function仍然是用Get方法，不同的是类型映射。 ** 1.映射到delegate【建议】 ** 这种是建议的方式，性能好很多，而且类型安全。缺点是要生成代码（如果没生成代码会抛InvalidCastException异常）。 delegate要怎样声明呢？ 对于function的每个参数就声明一个输入类型的参数。 多返回值要怎么处理？从左往右映射到c#的输出参数，输出参数包括返回值，out参数，ref参数。 参数、返回值类型支持哪些呢？都支持，各种复杂类型，out，ref修饰的，甚至可以返回另外一个delegate。 delegate的使用就更简单了，直接像个函数那样用就可以了。 1234567891011Action e = luaenv.Global.Get&lt;Action&gt;("e");//映射到一个delgate，要求delegate加到生成列表，否则返回null，建议用法e();FDelegate f = luaenv.Global.Get&lt;FDelegate&gt;("f");DClass d_ret;int f_ret = f(100, "John", out d_ret);//lua的多返回值映射：从左往右映射到c#的输出参数，输出参数包括返回值，out参数，ref参数Debug.Log("ret.d = &#123;f1=" + d_ret.f1 + ", f2=" + d_ret.f2 + "&#125;, ret=" + f_ret);GetE ret_e = luaenv.Global.Get&lt;GetE&gt;("ret_e");//delegate可以返回更复杂的类型，甚至是另外一个delegatee = ret_e();e(); ** 2.映射到LuaFunction ** 这种方式的优缺点刚好和第一种相反。 使用也简单，LuaFunction上有个变参的Call函数，可以传任意类型，任意个数的参数，返回值是object的数组，对应于lua的多返回值。 12LuaFunction d_e = luaenv.Global.Get&lt;LuaFunction&gt;("e");d_e.Call(); 总结访问lua全局数据时，特别是table以及function，代价比较大，建议尽量少做，比如在初始化时把要调用的lua function获取一次（映射到delegate）后，保存下来，后续直接调用该delegate即可，table也类似。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua编程9之模块]]></title>
    <url>%2F2019%2F06%2F23%2FLua%E7%BC%96%E7%A8%8B9%E4%B9%8B%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.如何创建一个模块？2.私有函数如何声明？3.return tab1必须和模块同一名称吗？4.如何引用一个模块？别名如何使用？5.原生lua文件加载路径如何查看？6.xLua加载方式是怎样的？建议的加载Lua脚本方式是什么？7.什么是自定义Loader？如何自定义Loader？ 用Lua写代码不可能把所有代码都写一个文件里，不同文件之间如何引用呢？Lua中也有模块的机制，类似C#中封装的命名空间。 Lua 模块模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。 Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。以下为创建自定义模块 module.lua，文件代码格式如下： 123456789101112131415161718192021-- 文件名为 module.lua-- 定义一个名为 module 的模块module = &#123;&#125;-- 定义一个常量module.constant = "这是一个常量"-- 定义一个函数function module.func1() io.write("这是一个公有函数！\n")endlocal function func2() print("这是一个私有函数！")endfunction module.func3() func2()endreturn module 由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。 上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用. require 函数Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。例如： 1require("&lt;模块名&gt;") 或者 1require "&lt;模块名&gt;" 执行 require 后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。 1234567-- test_module.lua 文件-- module 模块为上文提到到 module.luarequire("module")print(module.constant)module.func3() 以上代码执行结果为： 12这是一个常量这是一个私有函数！ 或者给加载的模块定义一个别名变量，方便调用： 12345678-- test_module2.lua 文件-- module 模块为上文提到到 module.lua-- 别名变量 mlocal m = require("module")print(m.constant)m.func3() 以上代码执行结果为： 12这是一个常量这是一个私有函数！ ** 标准Lua中的加载机制 ** 对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。 require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。 在lua中可以使用print (package.path)来查看当前的搜索路径。 我的打印出来是这样的： 12345678C:\Program Files\Unity\Hub\Editor\2018.3.6f1\Editor\lua\?.lua;C:\Program Files\Unity\Hub\Editor\2018.3.6f1\Editor\lua\?\init.lua;C:\Program Files\Unity\Hub\Editor\2018.3.6f1\Editor\?.lua;C:\Program Files\Unity\Hub\Editor\2018.3.6f1\Editor\?\init.lua;C:\Program Files\Unity\Hub\Editor\2018.3.6f1\Editor\..\share\lua\5.3\?.lua;C:\Program Files\Unity\Hub\Editor\2018.3.6f1\Editor\..\share\lua\5.3\?\init.lua;.\?.lua;.\?\init.lua 那么调用 require(“module”) 时就会尝试从搜索路径中从前到后的顺序去搜索lua文件。 如果找过目标文件，则会调用 package.loadfile 来加载模块。否则，就会去找 C 程序库。 C 程序库搜索的文件路径是从全局变量 package.cpath 获取，而这个变量则是通过环境变量 LUA_CPATH 来初始。 搜索的策略跟上面的一样，只不过现在换成搜索的是 so 或 dll 类型的文件。如果找得到，那么 require 就会通过 package.loadlib 来加载它。 xLua中的模块加载xLua中require实际上是调一个个的loader去加载，有一个成功就不再往下尝试，全失败则报文件找不到。 在xLua中，模块加载在Unity有些因地制宜的loader。目前xLua除了原生的loader外，还添加了从Resource和StreamingAssets（从StreamingAssets加载已被标记弃用，不建议使用）加载的loader，需要注意的是因为Resource只支持有限的后缀，放Resources下的lua文件得加上txt后缀，比如文件名需要命名成module.lua.txt。 可以从xLua的LuaEnv.cs的第108行看到： 12AddSearcher(StaticLuaCallbacks.LoadFromResource, 4);AddSearcher(StaticLuaCallbacks.LoadFromStreamingAssetsPath, -1); 建议的加载Lua脚本方式是：整个程序就一个DoString(“require ‘main’”)，然后在main.lua中require加载其它脚本。 要是我的Lua文件是下载回来的，或者某个自定义的文件格式里头解压出来，或者需要解密等等，怎么办？xLua的自定义Loader可以满足这些需求。 ** 自定义Loader ** 在xLua加自定义loader是很简单的，只涉及到一个接口： 12public delegate byte[] CustomLoader(ref string filepath);public void LuaEnv.AddLoader(CustomLoader loader) 通过AddLoader可以注册个回调，该回调参数是字符串，lua代码里头调用require时，参数将会透传给回调，回调中就可以根据这个参数去加载指定文件，如果需要支持调试，需要把filepath修改为真实路径传出。 该回调返回值是一个byte数组，如果为空表示该loader找不到，否则则为lua文件的内容。 有了这个就简单了，所有你自己的流程都可以处理。比如： 123456789luaenv.AddLoader((ref string filename) =&gt; &#123; if (filename == "InMemory") &#123; string script = "return &#123;ccc = 9999&#125;"; return System.Text.Encoding.UTF8.GetBytes(script); &#125; return null; &#125;);luaenv.DoString("print('InMemory.ccc=', require('InMemory').ccc)"); 完整示例见XLua\Tutorial\LoadLuaScript\Loader]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua编程8之面向对象]]></title>
    <url>%2F2019%2F06%2F23%2FLua%E7%BC%96%E7%A8%8B8%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.如何创建一个空表？ 之前学习了table，Lua中table很重要的一个功能就是实现面向对象的架构。因为lua本身并不是面向对象的语言，但是通过table可以实现。 Lua 面向对象面向对象编程（Object Oriented Programming，OOP）是一种非常流行的计算机编程架构。 以下几种编程语言都支持面向对象编程：C# C++ Java Objective-C Ruby 面向对象特征1）** 封装 ** ：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。 2）** 继承 ** ：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。 3）** 多态 ** ：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。 4）** 抽象 ** ：抽象(Abstraction)是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。 Lua 中面向对象我们知道，对象由属性和方法组成。LUA中最基本的结构是table，所以需要用table来描述对象的属性。 lua中的function可以用来表示方法。那么LUA中的类可以通过table + function模拟出来。 Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。 但是如果直接使用table仍然会存在大量的问题，见如下代码： 123456Account = &#123;balance = 0&#125;function Account.withdraw(v) Account.balance = Account.balance - vend--下面是测试调用函数Account.withdraw(100.00) 在上面的withdraw函数内部依赖了全局变量Account，一旦该变量发生改变，将会导致withdraw不再能正常的工作，如： 12a = Account; Account = nila.withdraw(100.00) --将会导致访问空nil的错误。 这种行为明显的违反了面向对象封装性和实例独立性。要解决这一问题，我们需要给withdraw函数在添加一个参数self，等价于C#中的this，见如下修改： 1234567function Account.withdraw(self, v) self.balance = self.balance - vend--下面是基于修改后代码的调用：a1 = AccountAccount = nila1.withdraw(a1, 100.00) --正常工作 针对上述问题，Lua提供了一种更为便利的语法，即将点(.)替换为冒号(:)，这样可以在定义和调用时均隐藏self参数，如: 12345function Account:withdraw(v) self.balance = self.balance - vend--调用代码可改为：a:withdraw(100.00) ** 一个简单实例 **以下简单的类包含了三个属性： area, length 和 breadth，printArea方法用于打印计算结果： 123456789101112131415161718-- Meta classRectangle = &#123;area = 0, length = 0, breadth = 0&#125;-- 派生类的方法 newfunction Rectangle:new (o,length,breadth) o = o or &#123;&#125; setmetatable(o, self) self.__index = self self.length = length or 0 self.breadth = breadth or 0 self.area = length*breadth; return oend-- 派生类的方法 printAreafunction Rectangle:printArea () print("矩形面积为 ",self.area)end ** 创建对象 ** 创建对象是为类的实例分配内存的过程。每个类都有属于自己的内存并共享公共数据。 1r = Rectangle:new(nil,10,20) 内存在对象初始化时分配。 ** 访问属性 **我们可以使用点号(.)来访问类的属性： 1print(r.length) ** 访问成员函数 **我们可以使用冒号 : 来访问类的成员函数： 1r:printArea() ** 完整实例 **以下我们演示了 Lua 面向对象的完整实例： 12345678910111213141516171819202122-- Meta classShape = &#123;area = 0&#125;-- 基础类方法 newfunction Shape:new (o,side) o = o or &#123;&#125; setmetatable(o, self) self.__index = self side = side or 0 self.area = side*side; return oend-- 基础类方法 printAreafunction Shape:printArea () print("面积为 ",self.area)end-- 创建对象myshape = Shape:new(nil,10)myshape:printArea() 执行以上程序，输出结果为： 1面积为 100 ** Lua 继承 **继承是指一个对象直接使用另一对象的属性和方法。可用于扩展基础类的属性和方法。 以下演示了一个简单的继承实例： 1234567891011121314151617 -- Meta classShape = &#123;area = 0&#125;-- 基础类方法 newfunction Shape:new (o,side) o = o or &#123;&#125; setmetatable(o, self) self.__index = self side = side or 0 self.area = side*side; return oend-- 基础类方法 printAreafunction Shape:printArea () print("面积为 ",self.area)end 接下来的实例，Square 对象继承了 Shape 类: 123456789Square = Shape:new()-- 派生类的new方法function Square:new (o,side) o = o or Shape:new(o,side) setmetatable(o, self) self.__index = self return oend ** 完整实例 **以下实例我们继承了一个简单的类，来扩展派生类的方法，派生类中保留了继承类的成员变量和方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 -- Meta classShape = &#123;area = 0&#125;-- 基础类方法 newfunction Shape:new (o,side) o = o or &#123;&#125; setmetatable(o, self) self.__index = self side = side or 0 self.area = side*side; return oend-- 基础类方法 printAreafunction Shape:printArea () print("面积为 ",self.area)end-- 创建对象myshape = Shape:new(nil,10)myshape:printArea()Square = Shape:new()-- 派生类方法 newfunction Square:new (o,side) o = o or Shape:new(o,side) setmetatable(o, self) self.__index = self return oend-- 派生类方法 printAreafunction Square:printArea () print("正方形面积为 ",self.area)end-- 创建对象mysquare = Square:new(nil,10)mysquare:printArea()Rectangle = Shape:new()-- 派生类方法 newfunction Rectangle:new (o,length,breadth) o = o or Shape:new(o) setmetatable(o, self) self.__index = self self.area = length * breadth return oend-- 派生类方法 printAreafunction Rectangle:printArea () print("矩形面积为 ",self.area)end-- 创建对象myrectangle = Rectangle:new(nil,10,20)myrectangle:printArea() 执行以上代码，输出结果为： 123面积为 100正方形面积为 100矩形面积为 200 总结刚刚学习了如何在lua中通过table模拟面向对象编程。Lua中的继承虽然可以通过metetable模拟出来，但是不推荐用，只模拟最基本的对象大部分时间够用了。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua编程7之metatable]]></title>
    <url>%2F2019%2F06%2F23%2FLua%E7%BC%96%E7%A8%8B7%E4%B9%8Bmetatable%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.如何创建一个空表？ 在 Lua table 中可以访问对应的key来得到value值，但是却无法对两个 table 进行操作。要实现两个table的操作就要使用Lua提供的元表(Metatable)，元表允许我们改变table的行为，每个行为关联了对应的元方法。 Lua元表Lua中每一个值都有metatable。metatable是一个普通的table，定义了一个值在特定情况下的操作。你可以通过修改值的metatable来修改这些操作。 在Lua代码中，只能设置table的元表，若要设置其它类型值的元表，则必须通过C代码来完成。 table和userdata可以有各自独立的元表，而其它数据类型的值则共享其类型所属的单一元表。缺省情况下，table在创建时没有元表。 任何table都可以作为任何值的元表，而一组相关的table也可以共享一个通用的元表，此元表将描述了它们共同的行为。一个table甚至可以作为它自己的元表，用于描述其特有的行为。 例如，使用元表我们可以定义Lua如何计算两个table的相加操作a+b。 当Lua试图对两个表进行相加时，先检查两者之一是否有元表，之后检查是否有一个叫__add的字段，若找到，则调用对应的值。__add等字段其对应的值（往往是一个函数或是table）就是** 元方法 ** ，前面有两个下划线。 有两个很重要的函数来处理元表： setmetatable(table,metatable): 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。 getmetatable(table): 返回对象的元表(metatable)。 以下实例演示了如何对指定的表设置元表： 123mytable = &#123;&#125; -- 普通表 mymetatable = &#123;&#125; -- 元表setmetatable(mytable,mymetatable) -- 把 mymetatable 设为 mytable 的元表 以上代码也可以直接写成一行： 1mytable = setmetatable(&#123;&#125;,&#123;&#125;) 以下为返回对象元表： 1getmetatable(mytable) -- 这会返回mymetatable 算术类的元方法在下面的示例代码中，将用table来表示集合，并且有一些函数用来计算集合的并集和交集等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Set = &#123;&#125;local metatable = &#123;&#125; --元表--根据参数列表中的值创建一个新的集合function Set.new(l) local set = &#123;&#125; --将所有由该方法创建的集合的元表都指定到metatable setmetatable(set, metatable) for _, v in ipairs(l) do set[v] = true end return setend--取两个集合并集的函数function Set.union(a, b) local res = Set.new &#123;&#125; for k in pairs(a) do res[k] = true end for k in pairs(b) do res[k] = true end return resend--取两个集合交集的函数function Set.intersection(a, b) local res = Set.new &#123;&#125; for k in pairs(a) do res[k] = b[k] end return resendfunction Set.tostring(set) local l = &#123;&#125; for e in pairs(set) do l[#l + 1] = e end return "&#123;" .. table.concat(l, ", ") .. "&#125;"endfunction Set.print(s) print(Set.tostring(s))end--最后将元方法加入到元表中，这样当两个由Set.new方法创建出来的集合进行--加运算时，将被重定向到Set.union方法，乘法运算将被重定向到Set.intersectionmetatable.__add = Set.unionmetatable.__mul = Set.intersection--下面为测试代码s1 = Set.new &#123;10, 20, 30, 50&#125;s2 = Set.new &#123;30, 1&#125;s3 = s1 + s2Set.print(s3)Set.print(s3 * s1)--输出结果为：--&#123;1, 30, 10, 50, 20&#125;--&#123;30, 10, 50, 20&#125; 在元表中，每种算术操作符都有对应的字段名，对应的操作列表如下：(注意：__是两个下划线) ** 模式 ** ** 描述 ** __add 对应的运算符 ‘+’. __sub 对应的运算符 ‘-‘. __mul 对应的运算符 ‘*’. __div 对应的运算符 ‘/‘. __mod 对应的运算符 ‘%’. __unm 对应的运算符 ‘-‘. __concat 对应的运算符 ‘..’. __eq 对应的运算符 ‘==’. __lt 对应的运算符 ‘&lt;’. __le 对应的运算符 ‘&lt;=’. 对于上面的示例代码，我们在算术运算符的两侧均使用了table类型的操作数。那么如果为s1 = s1 + 8，Lua是否还能正常工作呢？答案是肯定的，因为Lua定位元表的步骤为，如果第一个值有元表，且存在__add字段，那么Lua将以这个字段为元方法，否则会再去查看第二个值否是有元表且包含__add字段，如果有则以此字段为元方法。最后，如果两个值均不存在元方法，Lua就引发一个错误。然而对于上例中的Set.union函数，如果执行s1 = s1 + 8将会引发一个错误，因为8不是table对象，不能基于它执行pairs方法调用。为了得到更准确的错误信息，我们需要给Set.union函数做如下的修改，如： 1234567function Set.union(a,b) if getmetatable(a) ~= metatable or getmetatable(b) ~= metatable then error("attempt to 'add' a set with a non-set value") end --后面的代码与上例相同。 ... ...end 关系类的元方法元表还可以指定关系操作符的含义，元方法分别为__eq(等于)、__lt(小于)和__le(小于等于)，至于另外3个关系操作符，Lua没有提供相关的元方法，可以通过前面3个关系运算符的取反获得。 ** 模式 ** ** 描述 ** __eq 对应的运算符 ‘==’. __lt 对应的运算符 ‘&lt;’. __le 对应的运算符 ‘&lt;=’. 与算术类的元方法不同，关系类的元方法不能应用于混合的类型。 示例如下： 12345678910111213141516171819202122232425262728Set = &#123;&#125;local metatable = &#123;&#125;function Set.new(l) local set = &#123;&#125; setmetatable(set,metatable) for _, v in ipairs(l) do set[v] = true end return setendmetatable.__le = function(a,b) for k in pairs(a) do if not b[k] then return false end end return trueendmetatable.__lt = function(a,b) return a &lt;= b and not (b &lt;= a) endmetatable.__eq = function(a,b) return a &lt;= b and b &lt;= a end--下面是测试代码：s1 = Set.new&#123;2,4&#125;s2 = Set.new&#123;4,10,2&#125;print(s1 &lt;= s2) --trueprint(s1 &lt; s2) --trueprint(s1 &gt;= s1) --trueprint(s1 &gt; s1) --false 库定义的元方法除了上述基于操作符的元方法外，Lua还提供了一些针对框架的元方法，如print函数总是调用tostring来格式化其输出。如果当前对象存在__tostring元方法时，tostring将用该元方法的返回值作为自己的返回值，如： 1234567891011121314151617181920212223242526Set = &#123;&#125;local metatable = &#123;&#125;function Set.new(l) local set = &#123;&#125; setmetatable(set,metatable) for _, v in ipairs(l) do set[v] = true end return setendfunction Set.tostring(set) local l = &#123;&#125; for e in pairs(set) do l[#l + 1] = e end return "&#123;" .. table.concat(l,", ") .. "&#125;";endmetatable.__tostring = Set.tostring--下面是测试代码：s1 = Set.new&#123;4,5,10&#125;print(s1) --&#123;5,10,4&#125; 函数setmetatable和getmetatable也会用到元表中的一个字段(__metatable)，用于保护元表，如： 1234mt.__metatable = "not your business"s1 = Set.new&#123;&#125;print(getmetatable(s1)) --此时将打印"not your business"setmetatable(s1,&#123;&#125;) --此时将输出错误信息："cannot change protected metatable" 从上述代码的输出结果即可看出，一旦设置了__metatable字段，getmetatable就会返回这个字段的值，而setmetatable将引发一个错误。 table访问的元方法算术类和关系类运算符的元方法都为各种错误情况定义了行为，它们不会改变语言的常规行为。但是Lua还提供了一种可以改变table行为的方法。有两种可以改变的table行为：查询table及修改table中不存在的字段。 ** __index 元方法 ** 这是 metatable 最常用的键（key）。 当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的__index键。如果__index包含一个表，Lua会在表中查找相应的键。 例如： 1234other = &#123; foo = 3 &#125; t = setmetatable(&#123;&#125;, &#123; __index = other &#125;) print(t.foo) -- 3print(t.bar) -- nil 如果__index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。 __index 元方法查看表中元素是否存在，如果不存在，返回结果为 nil；如果存在则由 __index 返回结果。 1234567891011mytable = setmetatable(&#123;key1 = "value1"&#125;, &#123; __index = function(mytable, key) if key == "key2" then return "metatablevalue" else return nil end end&#125;)print(mytable.key1,mytable.key2) 实例输出结果为： 1value1 metatablevalue 实例解析： mytable 表赋值为 {key1 = “value1”}。 mytable 设置了元表，元方法为 __index。 在mytable表中查找 key1，如果找到，返回该元素，找不到则继续。 在mytable表中查找 key2，如果找到，返回 metatablevalue，找不到则继续。 判断元表有没有__index方法，如果__index方法是一个函数，则调用该函数。 元方法中查看是否传入 “key2” 键的参数（mytable.key2已设置），如果传入 “key2” 参数返回 “metatablevalue”，否则返回 mytable 对应的键值。 我们还可以将以上代码简单写成： 12mytable = setmetatable(&#123;key1 = "value1"&#125;, &#123; __index = &#123; key2 = "metatablevalue" &#125; &#125;)print(mytable.key1,mytable.key2) 如果想在访问table时禁用__index元方法，可以通过函数rawget(table,key)完成。通过该方法并不会加速table的访问效率。 ** 总结 ** Lua查找一个表元素时的规则，其实就是如下3个步骤: 在表中查找，如果找到，返回该元素，找不到则下一步 判断该表是否有元表，如果没有元表，返回nil，有元表则下一步 判断元表有没有__index方法，如果__index方法为nil，则返回nil；如果__index方法是一个表，则重复1、2、3；如果__index方法是一个函数，则返回该函数的返回值。 ** __newindex 元方法 **__newindex 元方法用来对表更新，__index则用来对表访问 。 当你给表的一个缺少的索引赋值，解释器就会查找__newindex元方法：如果存在则调用这个函数而不进行赋值操作。 以下实例演示了 __newindex 元方法的应用： 12345678910mymetatable = &#123;&#125;mytable = setmetatable(&#123;key1 = "value1"&#125;, &#123; __newindex = mymetatable &#125;)print(mytable.key1)mytable.newkey = "新值2"print(mytable.newkey,mymetatable.newkey)mytable.key1 = "新值1"print(mytable.key1,mymetatable.key1) 以上实例执行输出结果为： 123value1nil 新值2新值1 nil 以上实例中表设置了元方法__newindex，在对新索引键（newkey）赋值时（mytable.newkey = “新值2”），会调用元方法，而不进行赋值。而如果对已存在的索引键（key1），则会进行赋值，而不调用元方法 __newindex。 以下实例使用了 rawset 函数来更新表： ** rawset (table, index, value) ** 将table[index]的值直接设为value，不调用__newindex元方法。 1234567891011121314mytable = setmetatable( &#123;key1 = "value1"&#125;, &#123; __newindex = function(mytable, key, value) rawset(mytable, key, '"' .. value .. '"') end &#125;)mytable.key1 = "new value"mytable.key2 = 4print(mytable.key1, mytable.key2) 以上实例执行输出结果为： 1new value "4" 总结从本文中可以知道元表可以很好的简化我们的代码功能，所以了解 Lua 的元表，可以让我们写出更加简单优秀的 Lua 代码。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua编程6之table]]></title>
    <url>%2F2019%2F06%2F23%2FLua%E7%BC%96%E7%A8%8B6%E4%B9%8Btable%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.如何初始化表并指定值？2.a和b指向同一个table1，a设置为nil，b还可以访问table1的元素吗？3.table.concat、table.insert、table.remove、table.sort的含义分别是什么？4.#为什么得不到正确的table长度？ Lua中有一个非常重要的数据结构，就是Table，几乎所有高级语法的实现都离不开Table，就像C#中的类一样重要。 Lua table(表)table 是 Lua 的一种数据结构，用来创建不同的数据类型，如：数组、字典等。 Lua table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。 Lua table 是不固定大小的，你可以根据自己需要进行扩容。 Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 例如string.format表示使用”format”来索引table string。 table(表)的构造构造器是创建和初始化表的表达式。表是Lua特有的功能强大的东西。最简单的构造函数是{}，用来创建一个空表。可以直接初始化数组: 123456789-- 初始化表mytable = &#123;&#125;-- 指定值mytable[1]= "Lua"-- 移除引用mytable = nil-- lua 垃圾回收会释放内存 当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都指向同一个内存。如果 a 设置为 nil ，则 b 同样能访问 table 的元素。如果没有指定的变量指向a，Lua的垃圾回收机制会清理相对应的内存。 以下实例演示了以上的描述情况： 12345678910111213141516171819202122232425262728-- 简单的 tablemytable = &#123;&#125;print("mytable 的类型是 ",type(mytable))mytable[1]= "Lua"mytable["wow"] = "修改前"print("mytable 索引为 1 的元素是 ", mytable[1])print("mytable 索引为 wow 的元素是 ", mytable["wow"])-- alternatetable和mytable的是指同一个 tablealternatetable = mytableprint("alternatetable 索引为 1 的元素是 ", alternatetable[1])print("mytable 索引为 wow 的元素是 ", alternatetable["wow"])alternatetable["wow"] = "修改后"print("mytable 索引为 wow 的元素是 ", mytable["wow"])-- 释放变量alternatetable = nilprint("alternatetable 是 ", alternatetable)-- mytable 仍然可以访问print("mytable 索引为 wow 的元素是 ", mytable["wow"])mytable = nilprint("mytable 是 ", mytable) 以上代码执行结果为： 123456789mytable 的类型是 tablemytable 索引为 1 的元素是 Luamytable 索引为 wow 的元素是 修改前alternatetable 索引为 1 的元素是 Luamytable 索引为 wow 的元素是 修改前mytable 索引为 wow 的元素是 修改后alternatetable 是 nilmytable 索引为 wow 的元素是 修改后mytable 是 nil Table 操作以下列出了 Table 操作常用的方法： table.concat (table [, sep [, start [, end]]]):concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。 table.insert (table, [pos,] value):在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾. table.maxn (table)指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(Lua5.2之后该方法已经不存在了，我们自定义一个函数实现) table.remove (table [, pos])返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。 table.sort (table [, comp])对给定的table进行升序排序。 ** 实例 **接下来我们来看下这几个方法的实例。 ** Table 连接 **我们可以使用 concat() 方法来连接两个 table: 123456789fruits = &#123;"banana","orange","apple"&#125;-- 返回 table 连接后的字符串print("连接后的字符串 ",table.concat(fruits))-- 指定连接字符print("连接后的字符串 ",table.concat(fruits,", "))-- 指定索引来连接 tableprint("连接后的字符串 ",table.concat(fruits,", ", 2,3)) 执行以上代码输出结果为： 123连接后的字符串 bananaorangeapple连接后的字符串 banana, orange, apple连接后的字符串 orange, apple ** 插入和移除 **以下实例演示了 table 的插入和移除操作: 12345678910111213fruits = &#123;"banana","orange","apple"&#125;-- 在末尾插入table.insert(fruits,"mango")print("索引为 4 的元素为 ",fruits[4])-- 在索引为 2 的键处插入table.insert(fruits,2,"grapes")print("索引为 2 的元素为 ",fruits[2])print("最后一个元素为 ",fruits[5])table.remove(fruits)print("移除后最后一个元素为 ",fruits[5]) 执行以上代码输出结果为： 1234索引为 4 的元素为 mango索引为 2 的元素为 grapes最后一个元素为 mango移除后最后一个元素为 nil ** Table 排序 **以下实例演示了 sort() 方法的使用，用于对 Table 进行排序： 1234567891011fruits = &#123;"banana","orange","apple","grapes"&#125;print("排序前")for k,v in ipairs(fruits) do print(k,v)endtable.sort(fruits)print("排序后")for k,v in ipairs(fruits) do print(k,v)end 执行以上代码输出结果为： 12345678910排序前1 banana2 orange3 apple4 grapes排序后1 apple2 banana3 grapes4 orange ** Table 最大值 ** table.maxn 在 Lua5.2 之后该方法已经不存在了，我们定义了 table_maxn 方法来实现。 以下实例演示了如何获取 table 中的最大值： 123456789101112131415function table_maxn(t) local mn=nil; for k, v in pairs(t) do if(mn==nil) then mn=v end if mn &lt; v then mn = v end end return mnendtbl = &#123;[1] = 2, [2] = 6, [3] = 34, [26] =5&#125;print("tbl 最大值：", table_maxn(tbl))print("tbl 长度 ", #tbl) 执行以上代码输出结果为： 12tbl 最大值： 34tbl 长度 3 注意：当我们获取 table 的长度的时候无论是使用 # 还是 table.getn 其都会在索引中断的地方停止计数，而导致无法正确取得 table 的长度。 可以使用以下方法来代替： 1234567function table_leng(t) local leng=0 for k, v in pairs(t) do leng=leng+1 end return leng;end 总结table的花式用法有很多，基于table可以实现各种各样的结构和功能。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua编程5之函数]]></title>
    <url>%2F2019%2F06%2F23%2FLua%E7%BC%96%E7%A8%8B5%E4%B9%8B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.编程中最重要的是什么？2.描述一下函数的两种用途。3.如何指定为局部函数？4.函数可以返回多个值吗？如何返回？5.foo = function(x) return 2 * x end 如何调用？6.Lua中实参和形参的数量不一致如何处理？7.可变参数是什么意思？如何使用？动手实现print(“平均值为”,average(10,5,3,4,5,6)) 编程中最重要的就是如何提高代码的复用，最基础的方法就是提取函数。今天就来看看Lua中如何编写函数。 Lua函数在Lua中，函数是对语句和表达式进行抽象的主要方法。既可以用来处理一些特殊的工作，也可以用来计算一些值。 Lua 提供了许多的内建函数，你可以很方便的在程序中调用它们，如print()函数可以将传入的参数打印在控制台上。 Lua 函数主要有两种用途： 完成指定的任务，这种情况下函数作为调用语句使用；（例如print） 计算并返回值，这种情况下函数作为赋值语句的表达式使用。（例如add()） 函数定义Lua 编程语言函数定义格式如下： 1234optional_function_scope function function_name( argument1, argument2, argument3..., argumentn) function_body return result_params_comma_separatedend 解析： optional_function_scope: 该参数是可选的，指定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。 function_name: 指定函数名称。 argument1, argument2, argument3…, argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。 function_body: 函数体，函数中需要执行的代码语句块。 result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。类似C#中的元组。 在声明Lua函数时，可以直接给出所谓的函数名，如： 1function foo(x) return 2 * x end 我们同样可以使用下面这种更为简化的方式声明Lua中的函数，类似C#中的匿名方法，如： 1foo = function(x) return 2 * x end ** 实例 **以下实例定义了函数 max()，参数为 num1, num2，用于比较两值的大小，并返回最大值： 1234567891011121314--[[ 函数返回两个值的最大值 --]]function max(num1, num2) if (num1 &gt; num2) then result = num1; else result = num2; end return result; end-- 调用函数print("两值比较最大值为 ",max(10,4))print("两值比较最大值为 ",max(5,6)) 以上代码执行结果为： 12两值比较最大值为 10两值比较最大值为 6 Lua 中我们可以将函数作为参数传递给函数，如下实例： 123456789101112myprint = function(param) print("这是打印函数 - ##",param,"##")endfunction add(num1,num2,functionPrint) result = num1 + num2 -- 调用传递的函数参数 functionPrint(result)endmyprint(10)-- myprint 函数作为参数传递add(2,5,myprint) 以上代码执行结果为： 12这是打印函数 - ## 10 ##这是打印函数 - ## 7 ## 函数调用在Lua中函数的调用方式和C#语言基本相同，如：print(“Hello World”)和a = add(x, y)。 唯一的差别是，如果函数只有一个参数，并且该参数的类型为字符串常量或table的构造器，那么圆括号可以省略，如print “Hello World”和f {x = 20, y = 20}。 Lua为面对对象式的调用也提供了一种特殊的语法–冒号操作符。表达式o.foo(o,x)的另一种写法是o:foo(x)。冒号操作符使调用o.foo时将o隐含的作为函数的第一个参数。 需要说明的是，** Lua中实参和形参的数量可以不一致 ** ，一旦出现这种情况，Lua的处理规则等同于多重赋值，即实参多于形参，多出的部分被忽略，如果相反，没有被初始化的形参的缺省值为nil。 多返回值Lua函数可以返回多个结果值，比如string.find，其返回匹配串”开始和结束的下标”（如果不存在匹配串返回nil）。 12s, e = string.find("hello world", "wo") print(s, e) -- 7 8 Lua函数中，在return后列出要返回的值的列表即可返回多值，如： 12345678910111213function maximum (a) local mi = 1 -- 最大值索引 local m = a[mi] -- 最大值 for i,val in ipairs(a) do if val &gt; m then mi = i m = val end end return m, miendprint(maximum(&#123;8,10,23,12,5&#125;)) 以上代码执行结果为： 123 3 可变参数Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 … 表示函数有可变的参数。 12345678function add(...) local s = 0 for i, v in ipairs&#123;...&#125; do --&gt; &#123;...&#125; 表示一个由所有变长参数构成的数组 s = s + v end return s end print(add(3,4,5,6,7)) ---&gt;25 我们可以将可变参数赋值给一个变量。 例如，我们计算几个数的平均值： 1234567891011function average(...) result = 0 local arg=&#123;...&#125; --&gt; arg 为一个表，局部变量 for i,v in ipairs(arg) do result = result + v end print("总共传入 " .. #arg .. " 个数") return result/#argendprint("平均值为",average(10,5,3,4,5,6)) 以上代码执行结果为： 12总共传入 6 个数平均值为 5.5 我们也可以通过 select(“#”,…) 来获取可变参数的数量: 1234567891011function average(...) result = 0 local arg=&#123;...&#125; for i,v in ipairs(arg) do result = result + v end print("总共传入 " .. select("#",...) .. " 个数") return result/select("#",...)endprint("平均值为",average(10,5,3,4,5,6)) 以上代码执行结果为： 12总共传入 6 个数平均值为 5.5 有时候我们可能需要几个固定参数加上可变参数，固定参数必须放在变长参数之前: 123456function fwrite(fmt, ...) ---&gt; 固定的参数fmt return io.write(string.format(fmt, ...)) endfwrite("hongiu\n") ---&gt;fmt = "hongiu", 没有变长参数。 fwrite("%d%d\n", 1, 2) ---&gt;fmt = "%d%d", 变长参数为 1 和 2 输出结果为： 12hongiu12 通常在遍历变长参数的时候只需要使用{…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select(‘#’, …) 或者select(n, …) select(‘#’, …) 返回可变参数的长度 select(n, …) 用于访问 n 到 select(‘#’,…) 的参数 调用select时，必须传入一个固定实参selector(选择开关)和一系列变长参数。如果selector为数字n,那么select返回它的第n个可变实参，否则只能为字符串”#”,这样select会返回变长参数的总数。例子代码： 12345678910do function foo(...) for i = 1, select('#', ...) do --&gt;获取参数总数 local arg = select(i, ...); --&gt;读取参数 print("arg", arg); end end foo(1, 2, 3, 4); end 输出结果为： 1234arg 1arg 2arg 3arg 4]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua编程4之表达式和语句]]></title>
    <url>%2F2019%2F06%2F23%2FLua%E7%BC%96%E7%A8%8B4%E4%B9%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.如何创建一个空表？ 学习了数据类型和变量之后，就可以开始写代码的表达式，然后进一步写语句了。 Lua表达式算术操作符Lua支持常规算术操作符有：二元的“+”、“-”、“*”、“/”、“^”(指数)、“%”(取模)，一元的“-”(负号)。所有这些操作符都可用于实数。 然而需要特别说明的是取模操作符(%)，Lua中对该操作符的定义为： 1a % b == a - floor(a / b) * b 由此可以推演出x % 1的结果为x的小数部分，而x - x % 1的结果则为x的整数部分。类似的，x - x % 0.01则是x精确到小数点后两位的结果。 关系操作符Lua支持的关系操作符有：&gt;、&lt;、&gt;=、&lt;=、==、~ =（不等于），所有这些操作符的结果均为true或false。 操作符==用于相等性测试，操作符~ =用于不等性测试。这两个操作符可以应用于任意两个值。如果两个值的类型不同，Lua就认为他们不等。nil值只与其自身相等。 对于table、userdata和函数，Lua是通过引用进行比较的。也就是说，只有当他们引用同一个对象时，才视为相等。如： 1234567a = &#123;&#125;a.x = 1a.y = 0b = &#123;&#125;b.x = 1b.y = 1c = a 其结果是a == c，但a ~ = b。对于字符串的比较，Lua是按照字符次序比较的。 逻辑操作符Lua支持的逻辑操作符有：and、or和not。 与条件控制语句一样，所有的逻辑操作符都将false和nil视为假，其他的结果均为真。 和其他大多数语言一样，Lua中的and和or都使用“短路原则”。 短路原则：逻辑运算时，如果已经计算的表达式已经可以得出最终结果，就不对后面的表达式继续计算。(表达式1）and (表达式2) 如果表达式1为假，则表达式2不会进行运算，即表达式2“被短路”(表达式1）or (表达式2) 如果表达式1为真，则表达式2不会进行运算，即表达式2“被短路” 在Lua中有一种惯用写法x = x or v，它等价于：if not x then x = v end。 这里还有一种基于“短路原则”的惯用写法，如： 1234x = 10y = 9max = (x &gt; y) and x or yprint(max) -- 10 这等价于C#语言中max = (x &gt; y) ? x : y。 字符串连接昨天已经提到了字符串连接操作符(..)，这里再给出一些简单的示例。 12print("Hello " .. "World) -- Hello Worldprint(0 .. 1) --01 即使连接操作符的操作数为数值类型，在执行时Lua仍会将其自动转换为字符串。 table构造器构造器用于构建和初始化table的表达式。这是Lua特有的表达式，也是Lua中最有用、最通用的机制之一。 其中最简单的构造器是空构造器{}，用于创建空table。 我们通过构造器还可以初始化数组，如： 123456789101112days = &#123;"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"&#125;for i = 1,#days do print(days[i])end--输出结果为--Sunday--Monday--Tuesday--Wednesday--Thursday--Friday--Saturday 从输出结果可以看出，days在构造后会将自动初始化，其中days[1]被初始化为”Sunday”，days[2]为”Monday”，以此类推。 Lua中还提供了另外一种特殊的语法用于初始化记录风格的table。如：a = { x = 10, y = 20 }，其等价于：a = {}; a.x = 10; a.y = 20 在实际编程时我们也可以将这两种初始化方式组合在一起使用，如： 123456789101112polyline = &#123;color = "blue", thickness = 2, npoints = 4, &#123;x = 0, y = 0&#125;, &#123;x = 10, y = 0&#125;, &#123;x = -10, y = 1&#125;, &#123;x = 0, y = 1&#125; &#125;print(polyline["color"]);print(polyline[2].x)print(polyline[4].y)--输出结果如下：--blue--10--1 除了以上两种构造初始化方式之外，Lua还提供另外一种更为通用的方式，如： 12345opnames = &#123; ["+"] = "add", ["-"] = "sub", ["*"] = "mul", ["/"] = "div"&#125;print(opnames["+"])i = 20; s = "-"a = &#123; [i + 0] = s, [i + 1] = s .. s, [i + 2] = s..s..s &#125;print(a[22]) 对于table的构造器，还有两个需要了解的语法规则，如： 1a = &#123; [1] = "red", [2] = "green", [3] = "blue", &#125; 这里需要注意最后一个元素的后面仍然可以保留逗号(,)，这一点类似于C语言中的枚举。 1a = &#123;x = 10, y = 45; "one", "two", "three" &#125; 可以看到上面的声明中同时存在逗号,和分号;两种元素分隔符，这种写法在Lua中是允许的。我们通常会将分号;用于分隔不同初始化类型的元素，如上例中分号之前的初始化方式为记录初始化方式，而后面则是数组初始化方式。 Lua语句赋值语句Lua中的赋值语句和其它编程语言基本相同，唯一的差别是Lua支持“多重赋值”，如：a, b = 10, 2 * x，其等价于a = 10; b = 2 * x。 然而需要说明的是，Lua在赋值之前需要先计算等号右边的表达式，在每一个表达式都得到结果之后再进行赋值。因此，我们可以这样写变量交互：x,y = y,x。 如果等号右侧的表达式数量少于左侧变量的数量，Lua会将左侧多出的变量的值置为nil，如果相反，Lua将忽略右侧多出的表达式。 局部变量与块Lua中的局部变量定义语法为：local i = 1，其中local关键字表示该变量为局部变量。和全局变量不同的是，局部变量的作用范围仅限于其所在的程序块。Lua中的程序可以为控制结构的执行体、函数执行体或者是一个程序块，如： 下面的x变量仅在while循环内有效。 12345while i &lt;= x do local x = i * 2 print(x) i = i + 1end 和其它编程语言一样，如果有可能尽量使用局部变量，以免造成全局环境的变量名污染。同时由于局部变量的有效期更短，这样垃圾收集器可以及时对其进行清理，从而得到更多的可用内存。 流程控制Lua中提供的控制语句和其它大多数开发语言所提供的基本相同，因此这里仅仅是进行简单的列举。然后再给出差异部分的详细介绍。如： ** if then else ** 12345if a &lt; 0 then b = 0else b = 1end ** if elseif else then ** 1234567if a &lt; 0 then b = 0elseif a == 0 then b = 1else b = 2end ** while ** 123456local i= 1while a[i] do print(a[i]) i = i + 1end ** repeat ** 类似C#中的while…do 1234repeat line = io.read()until line ~= "" --直到until的条件为真时结束。print(line) ** for ** 123for var=begin,last,step do --如果没有step变量，begin的缺省步长为1。 i = i + 1end 需要说明的是，for循环开始处的三个变量begin、last和step，如果它们是表达式的返回值，那么该表达式将仅执行一次。再有就是不要在for的循环体内修改变量var的值，否则会导致不可预知的结果。 ** foreach ** 1234567for i, v in ipairs(a) do --ipairs是Lua自带的系统函数，返回遍历数组的迭代器。 print(v)endfor k in pairs(t) do --打印table t中的所有key。 print(k)end 见如下示例代码： 123456789101112131415161718days = &#123;"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" &#125;revDays = &#123;&#125;for k, v in ipairs(days) do revDays[v] = kendfor k in pairs(revDays) do print(k .. " = " .. revDays[k])end--输出结果为：--Saturday = 7--Tuesday = 3--Wednesday = 4--Friday = 6--Sunday = 1--Thursday = 5--Monday = 2 ** break **和C#语言循环中的break语义完全相同，即跳出最内层循环。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua编程3之变量]]></title>
    <url>%2F2019%2F06%2F23%2FLua%E7%BC%96%E7%A8%8B3%E4%B9%8B%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.a, b, c = 0 a和b和c的值分别是多少？2.多值赋值的两种常用场景是什么？3.局部变量的作用域是什么？使用局部变量的两个好处是什么？4.全局变量_G是什么类型？有什么作用？5.全局环境存在什么问题？ Lua变量变量在使用前，必须在代码中进行声明，即创建该变量。 编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区，用于存储变量的值。 Lua变量有三种类型：全局变量、局部变量、表中的域。 Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用local显式声明为局部变量。 局部变量的作用域为从声明位置开始到所在语句块结束。 变量的默认值均为nil。 12345678910111213141516171819-- test.lua 文件脚本a = 5 -- 全局变量local b = 5 -- 局部变量function joke() c = 5 -- 全局变量 local d = 6 -- 局部变量endjoke()print(c,d) --&gt; 5 nildo local a = 6 -- 局部变量 b = 6 -- 对局部变量重新赋值 print(a,b); --&gt; 6 6endprint(a,b) --&gt; 5 6 执行以上实例输出结果为： 1235 nil6 65 6 赋值语句赋值是改变一个变量的值和改变表域的最基本的方法。 12a = "hello" .. "world"t.n = t.n + 1 Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。 1a, b = 10, 2*x -- 等价于a=10; b=2*x 遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值： 12x, y = y, x -- swap 'x' for 'y'a[i], a[j] = a[j], a[i] -- swap 'a[i]' for 'a[j]' 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略： 12a. 变量个数 &gt; 值的个数 按变量个数补足nilb. 变量个数 &lt; 值的个数 多余的值会被忽略 例如： 12345678a, b, c = 0, 1print(a,b,c) --&gt; 0 1 nila, b = a+1, b+1, b+2 -- value of b+2 is ignoredprint(a,b) --&gt; 1 2a, b, c = 0print(a,b,c) --&gt; 0 nil nil 上面最后一个例子是一个常见的错误情况，注意：如果要对多个变量赋值必须依次对每个变量赋值。 12a, b, c = 0, 0, 0print(a,b,c) --&gt; 0 0 0 多值赋值经常用来交换变量，或将函数调用返回给变量： 1a, b = f() f()返回两个值，第一个赋给a，第二个赋给b。 应该尽可能的使用局部变量，有两个好处： 避免命名冲突。 访问局部变量的速度比全局变量更快。 索引对 table 的索引使用方括号 []。Lua 也提供了 . 操作。 123t[i]t.i -- 当索引为字符串类型时的一种简化写法gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用 例如： 1234books = &#123;&#125;books["key"] = "大话Unity"print(books["key"]) -- 大话Unityprint(books.key) -- 大话Unity 全局变量Lua将其所有的全局变量保存在一个普通的table中，这个table被称为“环境”。它被保存在全局变量_G中。 Lua中的全局变量不需要声明就可以使用。尽管很方便，但是一旦出现笔误就会造成难以发现的错误。 非全局环境全局环境存在一个问题，即修改它将影响到程序的所有部分。Lua 5为此做了一些改进，新的特征可以支持每个函数拥有自己独立的全局环境，而由该函数创建的闭包函数将继承该函数的全局变量表。这里我们可以通过setfenv函数来改变一个函数的环境，该函数接受两个参数，一个是函数名，另一个是新的环境table。第一个参数除了函数名本身，还可以指定为一个数字，以表示当前函数调用栈中的层数。数字1表示当前函数，2表示它的调用函数，以此类推。 见如下代码： 123456789101112a = 1setfenv(1,&#123;&#125;)print(a)--输出结果为：--[[LuaException: byfile.lua:3: attempt to call a nil value (global 'print')stack traceback: byfile.lua:3: in main chunk [C]: in function 'require' [string "chunk"]:1: in main chunk--]] 为什么得到这样的结果呢？因为print和变量a一样，都是全局表中的字段，而新的全局表是空的，所以print调用将会报错。 为了解决这个副作用，我们可以让原有的全局表_G作为新全局表的内部表，在访问已有全局变量时，可以直接转到_G中的字段，而对于新的全局字段，则保留在新的全局表中。这样即便是函数中的误修改，也不会影响到其他用到全局变量_G的地方。见如下代码： 下面代码中用到了元表的概念，可以后面学过以后再回来看 1234567891011a = 1local newgt = &#123;&#125; --新环境表setmetatable(newgt,&#123;__index = _G&#125;)setfenv(1,newgt)print(a) --输出1a = 10print(a) --输出10print(_G.a) --输出1_G.a = 20print(a) --输出10 最后给出的示例是函数环境变量的继承性。见如下代码： 123456789101112function factory() return function() return a endenda = 3f1 = factory()f2 = factory()print(f1()) --输出3print(f2()) --输出3setfenv(f1,&#123;a = 10&#125;)print(f1()) --输出10print(f2()) --输出3 总结在lua中要尽量少用全局变量，多使用局部变量，需要记住的是：** 变量默认都是全局变量，局部变量需要加local关键字。 **]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua编程2之数据类型]]></title>
    <url>%2F2019%2F06%2F23%2FLua%E7%BC%96%E7%A8%8B2%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.nil 的“删除”作用怎么理解？如何删除table里的一个值？2.怎么比较一个变量是否为nil？3.数字零和空字符串为真吗？假有哪些？4.如何表示块字符串？如何避免误解析的发生？5.显式转换函数有哪些？6.如何计算字符串的长度？7.如何构建数组？第一个索引是0吗？table会固定长度吗？8.a = {} a[1000] = 1 和table.maxn()之间有什么关系？9.function和int类型一样怎么理解？C#中的delegate，class和int一样怎么理解？10.lua中如何进行字符串连接？11.Lua将nil作为界定数据结尾的标志会导致什么问题？ 数据类型Lua是一种动态类型的语言，变量本身没有类型，只有值拥有类型。Lua语言本身没有提供类型定义的语法，每个值都“携带”了它自身的类型信息。 在Lua中有8种基础类型，分别是：nil、boolean、number、string、userdata、function、thread和table。 ** 数据类型 ** ** 描述 ** nil 这个最简单，只有值nil属于该类型，表示一个无效值（在条件表达式中相当于false）。 boolean 包含两个值：false和true。 number 表示双精度类型的实浮点数 string 字符串由一对双引号或单引号来表示 function 由 C 或 Lua 编写的函数 userdata 表示任意存储在变量中的C数据结构 thread 表示执行的独立线路，用于执行协同程序 table Lua 中的表（table）其实是一个“关联数组”（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过“构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。 我们可以通过type函数获得变量的类型信息，该类型信息将以字符串的形式返回。如： 123456print(type("hello world")) --stringprint(type(10.4)) --numberprint(type(print)) --functionprint(type(true)) --booleanprint(type(nil)) --nilprint(type(type(X))) --string nil（空）nil是一种类型，它只有一个值nil，它的主要功能是区别其他任何值。就像之前所说的，一个全局变量在第一次赋值前的默认值的默认值就是nil，将nil赋予一个全局变量等同于删除它。Lua将nil用于表示一种“无效值”的情况，类似C#中的null。 例如打印一个没有赋值的变量，便会输出一个 nil 值： 1print(type(a)) -- nil 对于全局变量和 table，nil 还有一个“删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉，如下面代码： 123456789tab1 = &#123; key1 = "val1", key2 = "val2", "val3" &#125;for k, v in pairs(tab1) do print(k .. " - " .. v)endtab1.key1 = nilfor k, v in pairs(tab1) do print(k .. " - " .. v)end nil 作比较时应该加上双引号 “”： 123type(X) --niltype(X)==nil --falsetype(X)=="nil" --true type(X)==nil 结果为 false 的原因是因为 type(type(X))==string。 boolean（布尔）boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是“假”，其他的都为“真”，如数字零和空字符串也为真，这点需要注意。 123456789print(type(true))print(type(false))print(type(nil))if false or nil then print("至少有一个是 true")else print("false 和 nil 都为 false!")end 以上代码执行结果如下： 1234booleanbooleannilfalse 和 nil 都为 false! number（数字）Lua 默认只有一种 number 类型 – double（双精度）类型（默认类型可以修改 luaconf.h 里的定义），以下几种写法都被看作是 number 类型： 123456print(type(2))print(type(2.2))print(type(0.2))print(type(2e+1))print(type(0.2e-1))print(type(7.8263692594256e-06)) Lua中没有专门的类型表示整数。 string（字符串）字符串由一对双引号或单引号来表示。 12string1 = "this is string1"string2 = 'this is string2' Lua支持和C语言类似的字符转义序列，见下表： ** 转义符 ** ** 描述 ** \a 响铃 \b 退格 \n 换行 \r 回车 \t 水平Tab \ 反斜杠 &quot; 双引号 &#39; 单引号 也可以用 2 个方括号 “[[]]” 来表示”一块”字符串，这个时候会禁用里面的转义字符。 123456789html = [[&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="http://www.runoob.com/"&gt;菜鸟教程&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;]]print(html) 如果两个方括号中包含这样的内容：a = b[c[i]]，这样将会导致Lua的误解析，因此在这种情况下，我们可以将其改为[===[ 和 ]===]的形式，从而避免了误解析的发生。 在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字，这和C#中的加号会进行字符串拼接不同: 1234567891011print("2" + 6) --8.0print("2" + "6") --8.0print("2 + 6") -- 2 + 6print("-2e2" * "6") -- -1200.0print("error" + 1)--[[stdin:1: attempt to perform arithmetic on a string valuestack traceback: stdin:1: in main chunk [C]: in ? --]] 以上代码中”error” + 1执行报错了，** 字符串连接应该使用的是 .. **，如： 12print("a" .. 'b') --abprint(157 .. 428) --157428 尽管Lua提供了这种自动转换的功能，为了避免一些不可预测的行为发生，特别是因为Lua版本升级而导致的行为不一致现象。鉴于此，还是应该尽可能使用显式的转换，如字符串转数字的函数tonumber()，或者是数字转字符串的函数tostring()。对于前者，如果函数参数不能转换为数字，该函数返回nil。如： 1234567line = "150.56"n = tonumber(line)if n == nil then error(line .. " is not a valid number")else print(n * 2)end 使用 # 来计算字符串的长度，放在字符串前面，如下实例： 123len = "hello world"print(#len) --11print(#"hello world") --11 table（表）在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表: 12345-- 创建一个空的 tablelocal tbl1 = &#123;&#125;-- 直接初始表local tbl2 = &#123;"apple", "pear", "orange", "grape"&#125; Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以为任意类型(nil除外)。类似C#中的Dictionary的Key-Value结构。 12345678a = &#123;&#125;a["key"] = "value"key = 10a[key] = 22a[key] = a[key] + 11for k, v in pairs(a) do print(k .. " : " .. v)end 脚本执行结果为： 12key : value10 : 33 不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。 1234local tbl = &#123;"apple", "pear", "orange", "grape"&#125;for key, val in pairs(tbl) do print("Key", key)end 脚本执行结果为： 1234Key 1Key 2Key 3Key 4 table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。 1234567a3 = &#123;&#125;for i = 1, 10 do a3[i] = ienda3["key"] = "val"print(a3["key"])print(a3["none"]) 脚本执行结果为： 12valnil 在Lua中还提供了另外一种方法用于访问table中的值，见如下示例： 123a.x = 10 --等同于a["x"] = 10print(a.x) --等同于print(a["x"])print(a.y) --等同于print(a["y"]) 由于数组实际上仍为一个table，所以对于数组大小的计算需要留意某些特殊的场景，如： 12a = &#123;&#125;a[1000] = 1 在上面的示例中，数组a中索引值为1–999的元素的值均为nil。而Lua则将nil作为界定数据结尾的标志。当一个数组含有“空隙”时，即中间含有nil值，长度操作符#会认为这些nil元素就是结尾标志。当然这肯定不是我们想要的结果。因此对于这些含有“空隙”的数组，我们可以通过函数table.maxn()返回table的最大正数索引值。如： 123a = &#123;&#125;a[1000] = 1print(table.maxn(a)) -- 输出1000 function（函数）在Lua中，函数可以存储在变量中，可以通过参数传递其它函数，还可以作为其它函数的返回值。这种特性使语言具有了极大的灵活性。 12345678910function factorial1(n) if n == 0 then return 1 else return n * factorial1(n - 1) endendprint(factorial1(5))factorial2 = factorial1print(factorial2(5)) 脚本执行结果为： 12120120 function 可以以匿名函数（anonymous function）的方式通过参数传递: 12345678910111213function testFun(tab,fun) for k ,v in pairs(tab) do print(fun(k,v)); endendtab=&#123;key1="val1",key2="val2"&#125;;testFun(tab,function(key,val)--匿名函数 return key.."="..val;end); 脚本执行结果为： 12key1 = val1key2 = val2 thread（线程）在 Lua 里，thread代表了单独线程的执行，并且用来实现lua里的协程（coroutine），类似Unity中的协程。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。 Lua的线程和操作系统的线程并不相关。Lua的协程支持所有的操作系统，即使那些不支持线程的操作系统也支持协程。 userdata（自定义类型）userdata 是一种用户自定义数据，提供了将任意外部数据（通常是 struct 和 指针）存储在lua变量中的能力。一个userdata代表了一块内存数据。 有两种userdata，一种是full userdata，是lua管理的一个对象，拥有一块内存区域；还有一种叫light userdata，是一个指针。 在Lua中除了赋值和比较，没有其他针对userdata预先定义的操作，通常使用metatable对full userdata定义操作。userdata的值无法在lua中创建或者修改，只能通过C语言API，这也保证了和宿主程序数据的一致性。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua编程1]]></title>
    <url>%2F2019%2F06%2F23%2FLua%E7%BC%96%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.LuaEnv luaenv = new LuaEnv();是什么意思？2.luaenv.DoString(“CS.UnityEngine.Debug.Log(‘hello world’)”);是什么意思？3.luaenv.DoString(“require ‘byfile’”);是什么意思？4.luaenv.dispose是什么意思？5.以下划线(_)开头，后面紧随多个大写字母（_VERSION）的变量有什么含义？6.C#中使用哪个命名空间？7.建议的加载Lua脚本方式是？8.直接访问未初始化的全局变量会报错吗？ 由于这节课我们会用到xLua的Example和Tutorial，在开始之前需要你将xLua的整个Github源码下载或者Clone下来。https://github.com/Tencent/xLua 下载以后，使用Unity打开下载的源码，xLua的示例代码在Assets\XLua\Examples中，xLua的教程在Assets\XLua\Tutorial中。 Hello World学习一切新事物从Hello World入手。那么xLua的Hello World是什么呢？ 该例子位于Assets\XLua\Examples\01_Helloworld。 123456789101112using UnityEngine;using XLua;public class Helloworld : MonoBehaviour &#123; void Start () &#123; LuaEnv luaenv = new LuaEnv(); luaenv.DoString("CS.UnityEngine.Debug.Log('hello world')"); luaenv.Dispose(); &#125;&#125; 上面的代码，就是执行了一句lua代码CS.UnityEngine.Debug.Log(‘hello world’)，来打印出hello world。 执行后Console窗口 我们来逐行分析一下Start中的代码：第一行LuaEnv luaenv = new LuaEnv();，创建了一个lua环境，类似一个运行时环境，用来解析、执行lua代码。 第2行luaenv.DoString();是用于执行lua代码字符串。 第3行luaenv.Dispose();用于释放这个lua环境。 到这呢，我们已经学会了整个环境如何搭建以及如何执行lua代码了。但是通过字符串执行代码总归还是不够方便，我们下面再看看如何加载文件并执行文件中的lua代码。 从文件加载Lua文件从文件加载Lua代码文件，用lua的require函数即可，比如： 完整代码见XLua\Tutorial\LoadLuaScript\ByFile 12345678910111213141516171819202122232425262728293031using UnityEngine;using System.Collections;using XLua;namespace Tutorial&#123; public class ByFile : MonoBehaviour &#123; LuaEnv luaenv = null; // Use this for initialization void Start() &#123; luaenv = new LuaEnv(); luaenv.DoString("require 'byfile'"); &#125; // Update is called once per frame void Update() &#123; if (luaenv != null) &#123; luaenv.Tick(); &#125; &#125; void OnDestroy() &#123; luaenv.Dispose(); &#125; &#125;&#125; lua中的require有些像C#中的using。实际上是调一个个的加载器loader，来加载一个一个模块/代码文件。与using不同的是，require加载进来后会将代码执行一次。 xlua除了lua原生的loader外，还添加了从Resource加载的loader，所以上面的代码可以加载Resources目录下的byfile.lua.txt文件并执行。 需要注意的是因为Resource只支持有限的后缀，放Resources下的lua文件得加上txt后缀。 建议的加载Lua脚本方式是：整个程序就一个DoString(“require ‘main’”)，然后在main.lua加载其它脚本（类似lua脚本的命令行执行：lua main.lua）。 此外很多时候热更新肯定是需要从服务器上下载lua代码执行，这个后面再说。 下面开始学习lua的语法。后面学习中，如果没有特殊说明，代码会写在上面的byfile.lua.txt文件中，并使用XLua\Tutorial\LoadLuaScript\ByFile场景运行测试。 Lua编程Lua是一门非常简洁的语言，也没有过多复杂的语法，学习起来很容易上手。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热更新之xLua]]></title>
    <url>%2F2019%2F06%2F22%2F%E7%83%AD%E6%9B%B4%E6%96%B0%E4%B9%8BxLua%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.Lua有哪两种作用？2.如何安装xLua？ Unity热更新有两大流派，C#派和lua派，那lua派是啥样的呢？ lua是一门历史悠久的脚本语言，从端游那个年代就被广泛应用在游戏开发中，所以到了现在的手游时代，有很多团队也让lua技术再次发展了起来。 Lua语言Lua 是一个小巧的脚本语言，于1993年开发。 Lua设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译运行。Lua并没有提供强大的库，因为它的定位就是作为嵌入的脚本语言，所以Lua不适合开发独立应用程序。Lua有一个同时进行的JIT项目，提供在特定平台上的即时编译功能。 Lua脚本可以很容易的被C/C++代码调用，也可以反过来调用C/C++的函数，这使得Lua在应用程序中可以被广泛应用，特别是在端游阶段，游戏几乎都是使用C/C++开发的，lua给游戏开发带来了极大的便利性。 不仅仅作为扩展脚本，lua也可以作为普通的配置文件，代替XML、JSON、ini等文件格式，并且很容易理解和维护。Lua由标准C编写而成，代码简洁优美，几乎在所有操作系统和平台上都可以编译运行。一个完整的Lua解释器不过200k，在目前所有脚本引擎中，Lua的速度是最快的。这一切都决定了Lua是作为嵌入式脚本的最佳选择。 Lua之所以在游戏开发中这么受欢迎，也是因为它的优点：(1)语言优美、轻巧 (2)性能优良、速度快 (3)可扩展性强。 Unity与LuaUnity中的Lua也一直在发展，目前Unity中比较流行的几个Lua框架有： xLua uLua sLua 其中xLua是腾讯团队开发维护的一个框架，广泛应用在腾讯系的手游中，也是目前最受认可以及使用比较多的一个框架。 相对于我们之前学过的ILRuntime呢，lua也有一些优势和弱势。 Lua的优势： 技术更为成熟 成功的商业案例更多 Lua的劣势： 需要开发团队掌握Lua 可能需要维护C#和lua两套代码 后面我们会以目前最为主流的xLua来进行学习。 xLuaxLua为Unity、.Net、Mono等C#环境增加Lua脚本编程的能力，借助xLua，这些Lua代码可以方便的和C#相互调用。 ** xLua的突破 ** xLua在功能、性能、易用性都有不少突破，这几方面分别最具代表性的是： 可以运行时把C#实现（方法，操作符，属性，事件等等）替换成lua实现，也就是热补丁功能； 出色的GC优化，自定义struct，枚举在Lua和C#间传递无C# gc alloc； 编辑器下无需生成代码，开发更轻量； 下载下载地址为：https://github.com/Tencent/xLua/releases 可以选择最新的zip下载： 上面图中可以看到xLua有几个不同的版本，有什么区别呢？ xLua有两个版本，分别集成了lua5.3和luajit，一个项目只能选择其一。这两个版本C#代码是一样的，不同的是Plugins部分。 &emsp;&emsp;xlua：此版本集成的是lua5.3，lua5.3的特性更丰富些，比如支持原生64位整数，支持苹果bitcode，支持utf8等。出现问题因为是纯c代码，也好定位。比起luajit，lua对安装包的影响也更小。 &emsp;&emsp;xlua_luajit：此版本集成的是luajit，luajit胜在性能，如果其jit不出问题的话，可以比lua高一个数量级。目前luajit作者不打算维护luajit，在找人接替其维护，后续发展不太明朗。 &emsp;&emsp;xlua_general：用于通用的.Net或Mono环境，可以在非Unity环境中使用。 目前lua53版本使用较多，所以xLua工程Plugins目录下默认配套是lua53版本，我们后面学习中也会使用这个版本。 安装安装非常简单，新建一个Unity工程。 打开zip包，你会看到一个Assets目录，这目录就对应Unity工程的Assets目录，保持这目录结构放到你的Unity工程。 拖到空白处覆盖现在的Assets目录]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七个方法让你的Unity项目更条理]]></title>
    <url>%2F2019%2F06%2F19%2F%E4%B8%83%E4%B8%AA%E6%96%B9%E6%B3%95%E8%AE%A9%E4%BD%A0%E7%9A%84Unity%E9%A1%B9%E7%9B%AE%E6%9B%B4%E6%9D%A1%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Unity性能优化 -脚本篇]]></title>
    <url>%2F2019%2F06%2F19%2FUnity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E8%84%9A%E6%9C%AC%E7%AF%87%2F</url>
    <content type="text"><![CDATA[最近开始进行Unity性能优化的工作，主要分为三类：CPU、GPU和内存。由于我们游戏的核心战斗是计算密集型，所以主要是受限于CPU。CPU的优化又分为渲染和脚本，本文将着重于脚本优化。 一般来说，优化必须要知道性能热点在哪里，而知道性能热点则需要在目标设备去进行深度的profile。如果不进行profile，而是靠臆测去进行优化，往往会事倍功半，甚至适得其反。 本文所讲述的是已经经过验证的，通用的优化方法和思路，可以为大家节约一些profile时间。以下将从Unity API、C#、Lua、数据结构和算法等方面来详细阐述优化建议。 Unity APIGameObject.GetComponentUnity是基于组合的开发方式，所以GetComponent是一个高频使用的函数。每次调用GetComponent时，Unity都要去遍历所有的组件来找到目标组件。每次都去查找是不必要的耗费，我们可以通过缓存的方式来避免这些不必要的开销。 其中Transform是我们用到最多的组件，GameObject内部提供了一个.transform来获取此组件。然而经过测试（2017.2.1p1）我们发现缓存的效率依然是最高的。所以若要经常访问一个特定组件，将其缓存。 private Transform m_transform;void Awake() { m_transform = transform;} void Start () { // 缓存的m_transform，耗时49ms for (int i = 0; i &lt; 1000000; i++) m_transform.position = Vector3.one; // 内部属性transform，耗时77ms for (int i = 0; i &lt; 1000000; i++) transform.position = Vector3.one; // 采用GetComponent，耗时102ms for (int i = 0; i &lt; 1000000; i++) GetComponent&lt;Transform&gt;().position = Vector3.one;} GameObject.FindGameObject.Find会遍历当前所有的GameObject来返回名字相符的对象。所以当游戏内对象很多时，这个函数将很耗时。 可以通过缓存的方法，在Start或Awake时缓存一次找到的对象，在后续使用中使用缓存的对象而非继续调用GameObject.Find。 或者采用GameObject.FindWithTag来寻找特定标签的对象。如果能在一开始就确定好对象，可以通过Inspector注入的方式，将对象直接拖到Inspector中，从而避免了运行时的查找。 Camera.mainCamera.main用来返回场景中的主相机，Unity内部是通过GameObject.FindWithTag来查找tag为MainCamera的相机。 当需要频繁访问主相机时，我们可以将其缓存以获得性能提升。 private Camera m_mainCamera;void Awake() { m_mainCamera = Camera.main;} void Start () { // 直接使用Camera.main，耗时164ms for (int i = 0; i &lt; 1000000; i++) Camera.main.transform.position = Vector3.zero; // 采用缓存，耗时74ms for (int i = 0; i &lt; 1000000; i++) m_mainCamera.transform.position = Vector3.zero;} GameObject.tagGameObject.tag常用来比较对象的tag，但是直接采用.tag ==来进行对比的话，每一帧会产生GC Alloc。通过GameObject.CompareTag来进行比较则可以避免掉这些GC，但是前提是比较的tag需在Tag Manager中定义。 // 46Bytes GC Alloc Per Framebool x = tag == “xxxxx”; // No GC Alloc, But Need to Define Tags in Tag Managerbool y = CompareTag(“xxxxx”); MonoBehaviourMonoBehaviour提供了很多内部的调用方法，诸如Update、Start和Awake等等，它们使用起来很方便，只要在一个继承了MonoBehaviour的脚本中定义了Update函数，Unity便会在每一帧去执行这个函数，具体的执行顺序见：Execution Order of Event Functions。 然而当有大量的MonoBehaviour的Update需要执行时，在profiler中可以看到它们的耗时很高。因为在MonoBehaviour内部调用Update时需要做一系列检查，如下图所示： Update调用耗时 我们可以自建一个MonoBehaviour管理器，里面维护一个List，然后将这些需要调用Update的MonoBehaviour扔进List中，并将它们的Update函数改成其他名字，比如MonoUpdate。然后在这个管理器的Update函数中循环遍历所有的MonoBehaviour调用它们的MonoUpdate。结果可以获得数量级上的提升，如下所示： 1万次调用差别 详细原理请阅读：10000 Update() calls。 Transform.SetPositionAndRotation每次调用Transform.SetPosition或Transform.SetRotation时，Unity都会通知一遍所有的子节点。 当位置和角度信息都可以预先知道时，我们可以通过Transform.SetPositionAndRotation一次调用来同时设置位置和角度，从而避免两次调用导致的性能开销。 Animator.Set…Animator提供了一系列类似于SetTrigger、SetFloat等方法来控制动画状态机。例如：m_animator.SetTrigger(“Attack”)是用来触发攻击动画。然而在这个函数内部，“Attack”字符串会被hash成一个整数。如果我们需要频繁触发攻击动画，我们可以通过Animator.StringToHash来提前进行hash，来避免每次的hash运算。 // Hash once, use everywhere!private static readonly int s_Attack = Animator.StringToHash(“Attack”);m_animator.SetTrigger(s_Attack); Material.Set…与Animator类似，Material也提供了一系列的设置方法用于改变Shader。例如：m_mat.SetFloat(“Hue”, 0.5f)是用来设置材质的名为Hue的浮点数。同样的我们可以通过Shader.PropertyToID来提前进行hash。 // Hash once, use everywhere!private static readonly int s_Hue = Shader.PropertyToID(“Hue”);m_mat.SetFloat(s_Hue, 0.5f); Vector Math如果需要比较距离，而非计算距离，用SqrMagnitude来替代Magnitude可以避免一次耗时的开方运算。 在进行向量乘法时，有一点需要注意的是乘法的顺序，因为向量乘比较耗时，所以我们应该尽可能的减少向量乘法运算。 // 耗时：73msfor (int i = 0; i &lt; 1000000; i++) Vector3 c = 3 * Vector3.one * 2; // 耗时：45msfor (int i = 0; i &lt; 1000000; i++) Vector3 c = 3 * 2 * Vector3.one; 可以看出上述的向量乘法的结果完全一致，但是却有显著的耗时差异，因为后者比前者少了一次向量乘法。所以，应该尽可能合并数字乘法，最后再进行向量乘。 CoroutineCoroutine是Unity用来实现异步调用的机制，如果对其不够了解可以参考我之前写的文章：对Unity中Coroutines的理解。 当需要实现一些定时操作时，有些同学可能会在Update中每帧进行一次判断，假设帧率是60帧，需要定时1秒调用一次，则会导致59次无效的Update调用。 用Coroutine则可以避免掉这些无效的调用，只需要yield return new WaitForSeconds(1f);即可。当然这里的最佳实践还是用一个变量缓存一下new WaitForSeconds(1f)，这样省去了每次都new的开销。 SendMessageSendMessage用来调用MonoBehaviour的方法，然而其内部采用了反射的实现机制，时间开销异常大，需要尽量避免使用。 可以用事件机制来取代它。 Debug.Log众所周知，输出Log是一件异常耗时，而且玩家感知不到的事情。所以应该在正式发布版本时，将其关闭。 Unity的Log输出并不会在Release模式下被自动禁用掉，所以需要我们手动来禁用。我们可以在运行时用一行代码来禁用Log的输出：Debug.logger.logEnabled = false;。 不过最好采用条件编译标签Conditional封装一层自己的Log输出，来直接避免掉Log输出的编译，还可以省去Log函数参数传递和调用的开销。具体可以参见：Unity3D研究院之在发布版本屏蔽Debug.log输出的Log。 C#反射反射是一项异常耗时的操作，因为其需要大量的有效性验证而且无法被编译器优化。 而且反射在iOS下还可能存在不能通过AOT的情况，所以我们应该尽量避免使用反射。 我们可以自己建立一个字符串-类型的字典来代替反射，或者采用delegate的方式来避免反射。 内存分配（栈和堆）在C#中，内存分配有两种策略，一种是分配在栈(Stack)上，另一种是分配在堆(Heap)上。 在栈上分配的对象都是拥有固定大小的类型，在栈上分配内存十分高效。 在堆上分配的对象都是不能确定其大小的类型，由于其内存大小不固定，所以经常容易产生内存碎片，导致其内存分配相对于栈来说更为低效。 值类型和引用类型在C#中，数据可以分为两种类型：值类型(Value Type)和引用类型(Reference Type)。 值类型包括所有数字类型、Bool、Char、Date、所有Struct类型和枚举类型。其类型的大小都是固定，它们都在栈上进行内存分配。 引用类型包括字符串、所有类型的数组、所有Class以及Delegate，它们都在堆上进行内存分配。 Stack &amp; Heap 装箱装箱(Boxing)指的是将值类型转换为引用类型，而拆箱(UnBoxing)的是将引用类型转换为值类型。 Stack &amp; Heap 从上图我们可以发现装箱和拆箱存在着从栈到堆的互指以及堆内存的开辟，所以它们本质是一项非常耗时的操作，我们应该尽量避免之。 Mono之前的foreach导致每帧的GC Alloc，本质也是因为装箱和拆箱导致的，此问题已经在Unity5.6后被修复。 垃圾回收我们在堆上分配的内存，其实是由垃圾回收器（Garbage Collector）来负责回收的。垃圾回收算法异常耗时，因为它需要遍历所有的对象，然后找到没有引用的孤岛，将它们标记为「垃圾」，然后将其内存回收掉。 频繁的垃圾回收不仅很耗时，还会导致内存碎片的产生，使得下一次的内存分配变得更加困难或者干脆无法分配有效内存，此时堆内存上限会往上翻一倍，而且无法回落，造成内存吃紧。 所以我们应该极力避免GC Alloc，即需要控制堆内存的分配。 字符串字符串连接会导致GC Alloc，例如string gcalloc = “GC” + “Alloc”会导致”GC”变成垃圾，从而产生GC Alloc。又比如：string c = string.Format(“one is {0}”， 1)，也会因为一次装箱操作（数字1被装箱成字符串”1”）而产生额外的GC Alloc。 所以如果字符串连接是高频操作，应该尽量避免使用+来进行字符串连接。C#提供了StringBuilder类来专门进行字符串的连接。 IL2CPPI2LCPP是Unity提供的将C#的IL码转换为C++代码的服务，由于转成了C++，所以其最后会转换成汇编语言，直接以机器语言的方式执行，而不需要跑在.NET虚拟机上，所以提高了性能。同时由于IL的反编译较为简单，转换成C++后，也会增加一定的反汇编难度。 IL2CPP的C++代码虽然是自动生成的，但是其中间的某些过程也可以被人为操纵，从而达到提升性能的目的。 Sealed修饰在C#中，虚函数的调用会比直接调用开销更大，我们可以用sealed修饰符来修饰掉那些确保不会被继承的类或函数。 具体详情可以参考：IL2CPP Optimizations: Devirtualization。需要注意的是，在最新的Unity版本中，这一项优化已经失效。 避免自动判空在自动转换的C++代码中，IL2CPP默认会对所有Nullable的变量做判空。其实在某些你非常确定参数不为空的场合，这种检测实际上是不必要的。 具体步骤是复制Il2CppSetOptionAttribute.cs文件到你的Assets目录下，然后在类或者函数定义上加一个修饰语句[Il2CppSetOption(Option.NullChecks, false)]即可以禁用整个类或者函数的判空检测。 避免数组越界检测同理，IL2CPP也会默认对所有数组的读写做越界检测，我们可以通过修饰语句[Il2CppSetOption(Option.ArrayBoundsChecks, false)]来将其禁用。 具体可以参考：https://docs.unity3d.com/Manual//IL2CPP-CompilerOptions.html Lua我之前写过一篇有关于纯Lua性能优化的文章：编写高性能的Lua代码，以下是一些摘抄和补充。 localLua的默认变量都是全局变量，必须要加上local修饰才能变成局部变量。 局部变量相对于全部变量有以下几点好处： 1. 读写更快 2. 可以避免不经意的全局变量名污染 3. 在作用域结束时，会被自动标记为垃圾，避免了内存泄漏 所以，虽然Lua的默认变量声明都是全局变量，我们还是应该将其用local修饰为局部变量。 tableLua中的表内部分为两部分：hash部分和array部分。当创建一个空表时，这两个部分都会默认初始化空间为0。随着内容的不断填充，会不断触发rehash。rehash是一次非常耗时的操作，所以应尽量避免之。 如果同时需要创建较多的小表，我们可以通过预先填充表以避免rehash。 string与C#类似，在Lua中的字符串连接的代价也很高昂，但是与C#提供了StringBuilder不同，Lua没有提供类似的原生解决方案。 不过我们可以用table来作为一个buffer，然后使用table.concat(buffer, ‘’)来返回最终连接的字符串。 与C#交互关于与C#的交互，不同的Lua解决方案有不同的策略，但是有些基本的点都是一样的。 首先，关于MonoBehaviour的三大Update的桥接，最佳策略是通过一个管理器继承MonoBehaviour的Update，然后将其派发给Lua端，然后Lua端所有的Update都注册于这个管理器当中。这样可以避免了多次Lua与C#的桥接交互，可以大量节省时间。 其次，需要考虑GC问题，默认的struct比如Vector3传递到Lua中都需要经历一次装箱操作，会带来额外的GC Alloc，可以采用特殊配置的方式将其避免。XLua的方案可以参考：XLua复杂值类型（struct）gc优化指南。 最后，通用的优化思路可以参考用好Lua+Unity，让性能飞起来——Lua与C#交互篇，作者针对实例做了较为详尽的分析。 数据结构容器类型容器应该针对不同的使用场合进行选择，主要看使用场合哪种操作的频率较高。例如： 经常需要进行随机下标访问的场合，优先选择数组（Array）或列表（List）经常需要进行查找的场合，优先选择字典（Dictionary）经常需要插入或删除的场合，优先选择链表（LinkedList）还有一些特殊的数据结构，适用于特殊的使用场合。例如： 不能存在相同元素的，可以选择HashSet需要后进先出的，用来优化递归函数调用的，可以选择Stack需要先进先出的，可以选择Queue对象池对象池（Object Pool）可以避免频繁的对象生成和销毁。游戏对象的生成，首先需要开辟内存，其次还可能会引起GC Alloc，最后还可能会引发磁盘I/O。频繁的销毁对象会引发严重的内存碎片，使得堆内存的分配更加困难。 所以在有大量对象需要重复生成和销毁时，一定要采用对象池来缓存好创建的对象，等到它们无需使用时，不需要将其销毁，而是将其放入对象池中，可以免去下次的生成。 public class ObjectPool where T : new(){ private Stack objs; public ObjectPool(){ objs = new Stack&lt;T&gt;(); } // 获取对象池里的对象 public T GetObject(){ T obj = objs.Count &gt; 0 ? objs.Pop() : new T(); return obj; } // 回收对象池里的对象 public void ReturnObject(T obj){ if (obj != null) objs.Push(obj); }} 空间划分在计算空间碰撞或者寻找最近邻居时，如果空间很庞大，需要参与计算的对象太多的情况下，用两层循环逐个遍历去计算的复杂度为平方级。 我们可以借助于空间划分的数据结构来使复杂度降低到N*Log(N)。四叉树一般用来划分2D空间，八叉树一般用来划分3D空间，而KD树则是不限空间维度。 我之前写过一篇介绍KD树的原理和优化的文章：KD树的应用与优化，内容比较详尽，大家可以去读一读。 算法循环循环的使用非常常见，也非常容易成为性能热点。我们应该尽量避免在循环内进行耗时或无效操作，尤其是这个循环在每帧的Update调用中时。 void Update() { for (int i = 0; i &lt; count; i++) if (condition) excuteFunc(i);} 以上的循环遍历中，无论condition为真或者为假，循环都会执行count次，若condition为假，则相当于白跑了count次。 void Update() { if (condition) for (int i = 0; i &lt; count; i++) excuteFunc(i);} 将判断条件提出循环外，则可以避免白跑了的问题。 另一个需要注意的是小心多重循环的顺序问题，应该尽量把遍历次数较多的循环放在内层。 void Start(){ // 耗时：37ms for (int i = 0; i &lt; 1000000; i++) for (int j = 0; j &lt; 2; j++) int k = i * j; // 耗时：13ms for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 1000000; j++) int k = i * j;} 当内外层循环数有较多数量级上的差别时，将忙的循环放在内层性能更高，因为其避免了更多次内层循环计数器初始化的调用。 数学运算开方运算，三角函数这些都是耗时的数学运算，应尽量避免之。 像之前提到的，如果只是单纯比较距离而不是计算距离的话，就可以用距离的平方来表示，可以节约掉一次耗时的开方运算。 三角运算可以通过简单的向量运算来规避之，具体可以参考我之前写的文章：向量运算在游戏开发中的应用和思考。 又比如如果经常需要除一个常数，比如用万分位整数来表示小数需要经常除10000，可以改成乘0.0001f，可以规避掉较乘法更为耗时的除法运算。 大雾，实际验算证明，现代的编译器会对此进行优化，所以没有必要为此牺牲可读性。很多时候还是要先测算再去写代码会比较好。 缓存我最喜欢的一种优化思路就是缓存。缓存的本质就是用空间换时间。例如之前在Unity API中提到的很多耗时的函数，都可以用缓存来提升性能。 包括对象池，也是缓存技术的一种。针对于需要依赖复杂运算而且后续要经常用到值，我们便可将其缓存起来，以避免后续的计算，从而获取性能提升。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unity3D中的委托、事件和单例]]></title>
    <url>%2F2019%2F06%2F19%2FUnity3D%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98%E3%80%81%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.2.3. 来源：Unity3D中的委托、事件和单例 在此，将演示多人协同工作时怎样去创建委托、事件和单例。这篇教程是针对Unity3D来写的，但也同样适用于所有采用C#或.NET的应用。 在判断一些事件或者动作是否发生的时候总是会去写很多布尔类型的声明。我通过协程和一些其他函数来监听这些事件以及返回值。如果你也发现自己是这样做的，那么尽快停止吧！ 单例 如果你不知道什么是单例，你或许真的不知道。单例是不能实例化或者复制的脚本。它是，额…单一的。 我建议在游戏中当某样东西不需要被多次复制的时候使用单例。比如存储系统。典型的例子是玩家只需要一个存储系统，所以我们并不想调用它的多个实例，我们只需要一个。当我们调用它时，我们想要确认当前它到底存不存在。 有很多创建单例的方法，但下面这个方法使用率最高因为它很简单… 这里我写了一个Clicker的类并把它添加到我的摄像机上。这个类控制了我用光线投射向3D场景中发送的所有点击事件。 在其他脚本中使用DoSomething函数的时候只需要这样简单的调用… 这样就减少了一系列静态方法和变量的调用，而我们只是添加了一个实例而已！ 委托和事件？ 委托可以被理解为一个引用指向一个对象或者方法。当它被调用时，就会通知所有引用了该委托的方法。 所以，先说重要的… 定义委托和方法 名称为OnClickEvent的委托传递一个GameObject类型的参数用来让我们定义它是来自什么游戏对象。然后我们定义一个OnClick事件，当委托被调用时调用它。 现在，在同样的脚本里，我们需要调用委托并传递GameObject。我通过光线投射完成了调用… 正如你看到的那样，如果射线接触到场景中的物体并且我们点击了鼠标，那么就成功的调用了事件并传递了该物体。 最后，我们必须做的是在其他脚本中注册该委托并实现相关调用。为此，我创建了一个叫GoldPile的类。 在Awake()函数中，我们定义了监听事件，并指定了本地方法OnClick。OnClick函数并不要求和委托函数同名，但同名也是可以的。 注意：在此之前我们为Clicker类添加了一个单例。这样就允许我们这样使用：Clicker.Instance 正如你所看到的那样，我们也在点击的时候创建了OnClick()函数并传递了GameObject。 注意：你必须这样使用if(g == gameObject),否则，它将会在场景中隐藏其他实例的相关方法…这就是为什么我们为该引用传递GameObject的原因！ 现在，如果你需要的话可以在你游戏中的任何脚本里添加这个方法。但别忘了在Awake()函数中定义方法和委托。]]></content>
  </entry>
  <entry>
    <title><![CDATA[插值]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%8F%92%E5%80%BC%2F</url>
    <content type="text"><![CDATA[lerp函数就是线性插值用的，lerp(a,b,mixValue)返回的值，就是a*(1-mixValue)+b*mixValue 简单的例子：汽车8点出发，10点到达200公里外的目的地，可以用插值算法大概知道汽车在8点半的时候的位置。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相机、渲染和场景-相机和曲线]]></title>
    <url>%2F2019%2F06%2F16%2F%E7%9B%B8%E6%9C%BA%E3%80%81%E6%B8%B2%E6%9F%93%E5%92%8C%E5%9C%BA%E6%99%AF-%E7%9B%B8%E6%9C%BA%E5%92%8C%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[相机、渲染和场景-相机震动]]></title>
    <url>%2F2019%2F06%2F16%2F%E7%9B%B8%E6%9C%BA%E3%80%81%E6%B8%B2%E6%9F%93%E5%92%8C%E5%9C%BA%E6%99%AF-%E7%9B%B8%E6%9C%BA%E9%9C%87%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.相机震动效果是什么？实现的思路是什么？2. 对于格斗、射击以及动作类游戏，相机震动效果十分重要，展现了碰撞、危险、打斗、动态以及激动人心的效果，并表示为一种动力学反馈的形式。相机震动的实现方法多种多样，但均会涉及相机位置的变化，即通过某种“随机”功能使该位置在最小值和最大值之间变化。有时，震动效果较为剧烈，而某些时候，震动则通过阻尼功能呈现为平滑状态，进而生成一种缓慢的浮动效果。如下示例代码可绑定至任意相机上，并以此创建震动效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using UnityEngine;using System.Collections;public class CameraShake : MonoBehaviour&#123; private Transform ThisTransform = null; // Total time for shaking in seconds public float ShakeTime = 2.0f; // Shake amount - distance to offset in any direction public float ShakeAmount = 3.0f; // Speed of camera moving to shake points public float ShakeSpeed = 2.0f; void Start() &#123; // Get transform component ThisTransform = GetComponent&lt;Transform&gt;(); // Start shaking StartCoroutine(Shake()); &#125; // Shake camera public IEnumerator Shake() &#123; // Store original camera position Vector3 OrigPosition = ThisTransform.localPosition; // Count elapsed time (in seconds) float ElapsedTime = 0.0f; // Repeat for total shake time while(ElapsedTime &lt; ShakeTime) &#123; // Pick random point on unit sphere Vector3 RandomPoint = OrigPosition + Random.insideUnitSphere * ShakeAmount; // Update Position ThisTransform.localPosition = Vector3.Lerp(ThisTransform.localPosition, RandomPoint, Time.deltaTime * ShakeSpeed); // Break for next frame yield return null; // Update time ElapsedTime += Time.deltaTime; &#125; // Restore camera position ThisTransform.localPosition = OrigPosition; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity脚本设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D数学之向量2]]></title>
    <url>%2F2019%2F06%2F14%2F3D%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%90%91%E9%87%8F2%2F</url>
    <content type="text"></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D数学之向量1]]></title>
    <url>%2F2019%2F06%2F14%2F3D%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%90%91%E9%87%8F1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.在Unity中看下Vector类的API，看看和这些向量的运算怎么对应上 坐标系之间的转换涉及到两个方面：平移和旋转。今天我们先来学习一下和平移相关的向量。 向量Vector对Vector这个词你应该不陌生，Unity中经常用得到position就是Vector3类型。那究竟什么是向量呢？ 向量的数学定义向量与标量向量是一个既有大小又有方向的量，比如速度、位移等。标量是一个只有大小，没有方向的量，比如速率、长度等。 向量的维度向量的维度就是向量包含的“数”的数目。向量可以有任意正数维，也包括一维（标量可以认为是一维向量）。 向量的几何定义从几何意义上说，向量是有大小和方向的有向线段。 向量的大小就是向量的长度（模）。向量有非负的长度。 向量的方向描述了空间中向量的指向。 向量的形式2D向量 2D向量 这个2D向量看起来就像一支箭，对吗？这是用图形描述向量的标准形式，因为向量定义的两个要素——大小和方向都被包含在其中。有时候需要引用向量的头和尾，如上图所示，箭头A是向量的末端（向量“结束”于此），箭尾O是向量的“开始”。 位置与位移向量在哪儿？实际上，这不是一个恰当的问题。因为向量没有位置，只有大小和方向。这听起来不可思议，但其实日常生活中很多量有大小和方向，却没有位置。例如： 位移：“向前走三步”，这句话好像是关于位置的，但其实句子中使用的量表示的是相对位移，而不是绝对位置。这个相对位移由大小（三步）和方向（向前）构成，所以它能用向量表示。 速度：“我们以50英里每小时的速度向北行驶”。这句话描述了一个量，它有大小（50英里每小时）和方向（北），但没有具体位置。“50英里每小时的速度向北”能用向量表示。 注意，位移、速度与距离、速率是完全不同的两种定义。位移和速度是向量，包含方向，而距离和速率是标量，不指明任何方向。 因为向量能描述事物间的位移和相对差异，所以它能用来描述相对位置：“我的房子位于从这儿向东的第四个胡同”。不能认为向量有绝对位置，当你想像一个向量，一个箭头时，记住：只有箭头的长度和方向是有意义的，不包括位置。 因为向量是没有位置的，所以能在图的任何地方表示，只要方向和长度的表示正确即可。我们经常会利用向量的这个优点，将向量平移到图中更有用的点。 向量与点的区别“点”有位置，但没有实际的大小或厚度。上面学习了向量有大小和方向，但没有位置。所以使用“点”和“向量”的目的完全不同。“点point”描述位置，而“向量vector”描述位移。 向量能够用来描述位移，当然也包括相对位置。点用来描述位置。任何描述位置的方法都是相对的，那么我们必须承认点也是相对的。它们和确定其坐标的原点相关。这导出了点和向量的关系。 对于任意x，y，下图展示了点（x，y）是怎样和向量[x，y]相关的。 从原点开始，按向量[x, y]所代表的位移移动，总是会到达点(x, y)所代表的位置。也可以说，向量[x, y]描述了原点到点(x, y)的位移量。 这看起来很明显，重要的是要理解点和向量在概念上完全不同，而在数学上却是等价的。点和向量的这种令人迷惑的关系对初学者来说可能是个障碍，但现在对你来说应该已经不是问题了。思考位置时，想象一个点，思考位移时，想象一个向量和一个箭头。 许多情况下，位移是从原点开始的，点和向量间的区别很清楚。但我们还要经常对付一些和原点不相关的量，这种情况下，认识到这是一些箭头而不是点很重要。时刻记住，在任意一点都能用从原点开始的向量来表达。 在Unity中，很多量都是用Vector3这一类型表示的，但是要区分你是当作点（比如位置position），还是当作向量（比如方向）在使用。 向量运算符号约定在书本等印刷体中，不同类型的量一般使用下面的符号约定： 标量，用斜体的小写罗马或希腊字母表示，如a，b，x，y，z，θ，λ 向量，用小写黑粗体字母表示，如a，b，u，v，q，r 矩阵，用大写黑粗体字母表示，如A，B，M，R 还一种常用的手写约定是，用符号上面加一个箭头来表示向量。 向量手写表示方法 向量手写表示方法 零向量零向量非常特殊，因为它是唯一大小为零的向量。零向量也是唯一一个没有方向的向量。 虽然在图中表示零向量用的是一个点，但是认为零向量就是一个点并不准确，因为零向量没有定义某个位置。应该认为零向量表示的是“没有位移”，就像标量零表示的是“没有数量”一样。 在Unity中零向量通常用于Vector类型变量的初始化或者重置。 负向量要得到任意维向量的负向量，只需要简单地将向量地每个分量都变负即可。 向量变负，将得到一个和原向量大小相等，方向相反的向量。 在Unity中可以直接在Vector类型的变量前加负号变成负向量。负向量通常用于求出一个方向的相反方向。比如transform中有forward表示物体的z轴朝向，但是没有类似back的属性，这时候可以用-forward获得。 向量大小（长度或模）前面讨论过，向量有大小和方向。你可能已经注意到了，大小和方向都没有在向量中明确地表示出来。 如2D向量[3，4]的大小既不是3，也不是4，而是5。因为向量的大小没有明确表示，所以需要计算。向量大小也常被称作向量的长度或模。 运算法则在线性代数中，向量的大小用向量两边加双竖线表示，这和标量的“绝对值”在标量两边加单竖线表示类似。这种记法和n维向量大小的计算公式如下： ||v|| = \sqrt { v_1^2+v_2^2+ ··· + v_{n-1}^2+v_n^2 }∣∣v∣∣=v12 +v22 +⋅⋅⋅+vn−12 +vn2 在Unity中如果仅仅比较两个向量的大小，可以使用sqrMagnitude，这个属性不会计算最后的开平方，可以大大提高计算速度。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D数学之矩阵]]></title>
    <url>%2F2019%2F06%2F14%2F3D%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.在Unity中看下Matrix类的API，看看和这些矩阵的运算结果是什么样子 矩阵是3D数学的重要基础。它主要用来描述两个坐标系统间的关系，通过定义一种运算而将一个坐标系中的向量转换到另一个坐标系中。如果不写shader的话，可能还用到的比较少，但是矩阵是咱们后续会学的shader的基础知识。 矩阵在线性代数中，矩阵就是以行和列形式组织的矩形数字块。回忆前面曾将向量定义为一维数组，矩阵也能像那样定义为二维数组（“二维数组”中的“二”来自它们是行和列的事实，不要和2D向量或矩阵混淆）。向量是标量的数组，矩阵则是向量的数组。 矩阵的维度和记法前面我们把向量的维度定义为它所包含的数的个数，与之类似，矩阵的维度被定义为它包含了多少行和多少列。一个m × n矩阵有m行、n列。 上图中的矩阵展示了矩阵的标准记法。将数字排列成一个方块，用方括号括起来。注意，有些地方可能用圆括号而不是方括号来包围这个方块。 这m × n个数称为矩阵A的元素，数a_{ij}a ij 位于矩阵A的第i行第j列，m×n矩阵A也记作A_{mn}A mn。 方阵行数和列数相同的矩阵称作方阵，这个概念非常重要，在图形学中主要使用2×2、3×3、4×4方阵。 方阵的对角线元素就是方阵中行号和列号相同的元素。例如，3×3矩阵MM的对角线元素为m_{11}m11 ，m_{22}m22 ，m_{33}m33 。其他元素均为非对角线元素。简单地说，方阵的对角线元素就是方阵对角线上的元素。 如果所有非对角线元素都为0，那么称这种矩阵为对角矩阵，例如： 单位矩阵是一种特殊的对角矩阵。n维单位矩阵记作I_nIn ，是n×n矩阵，对角线元素为1，其他元素为0。例如，3×3单位矩阵； 单位矩阵非常特殊，因为它是矩阵的乘法单位元（后面讨论矩阵乘法）。其基本性质是用任意一个矩阵乘以单位矩阵，都将得到原矩阵。所以，在某种意义上，单位矩阵对矩阵的作用就犹如1对于标量的作用。 向量是特殊的矩阵矩阵的行数和列数可以是任意正整数，当然也包括1。我们已经见过一行或一列的矩阵了——向量。一个n维向量能被当作1×n矩阵或n×1矩阵。1×n矩阵称作行向量，n×1矩阵称作列向量。行向量平着写，列向量则竖着写，例如： 直到现在，这两种记法都是混合使用的。其实，在几何意义上它们是一样的，绝大多数情况下它们的区别也不重要。但是，因为即将介绍的一些原因，混合使用向量和矩阵时，必须特别注意向量到底是行向量还是列向量。 转置考虑一个m × n矩阵MM，转置记作M^TMT ，是一个n × m矩阵，它的列由MM的行组成。可以从另一方面理解，M^T_{ij}MijT = M_{ji}Mji ，即沿着矩阵的对角线翻折。 对于向量来说，转置将使行向量变成列向量，使列向量成为行向量。 有两条非常简单但很重要的关于矩阵转置的推论： 对于任意矩阵MM 从另一方面来说，将一个矩阵转置后，再转置一次，便会得到原矩阵。这条法则对向量也适用。 对于在意对角矩阵DD，都有D^TDT =DD，包括单位矩阵II也如此。 标量和矩阵的乘法矩阵MM能和标量kk相乘，结果是一个和MM维数相同的矩阵。矩阵和标量相乘的记法如下所示，标量经常写在左边、不需要写乘号。这种乘法法则很直观，即用kk乘以MM中的每个元素。 矩阵乘法不是所有的矩阵都可以相乘，两个矩阵相乘有一些条件：矩阵AA的列数和矩阵BB的行数相等。 矩阵乘法计算如下：记r×n矩阵AA与n×c矩阵B的积r×c矩阵ABAB为CC。CC的任意元素C_{ij}Cij 等于AA的第ii行向量与BB的第jj列向量的点乘结果。正式定义为： 这个看起来有些复杂，可以看一下下面的动图来加深理解。 矩阵乘法.gif 矩阵乘法有一些注意事项： 任意矩阵MM乘以方阵SS，不管从哪边乘，都将得到与原矩阵大小相同的矩阵。当然，前提是假定乘法有意义。如果SS是单位矩阵，结果将是原矩阵MM，即： 这就是I被称为单位矩阵的缘故 这就是I被称为单位矩阵的缘故 矩阵乘法不满足交换律，即 矩阵乘法满足结合律，即 矩阵乘法也满足与标量或向量的结合律，即： 矩阵积的转置相当于先转置矩阵然后以相反的顺序乘： 矩阵的几何解释一般来说，方阵能描述任意线性变换。线性变换保留了直线和平行线，而原点没有移动。线性变换保留直线的同时，其他的几何性质如长度、角度、面积和体积可能就被变换改变了。从非技术意义上说，线性变换可能“拉伸”坐标系，但不会“弯曲”或“卷折”坐标系。下面是一组非常有用的变换： 旋转 缩放 投影 镜象 仿射 后面将介绍上述各变换的细节。现在，我们主要解释矩阵和它所代表的变换之间的关系。 矩阵是怎样变换向量的向量在几何上能被解释成一系列与轴平行的位移。如，向量[1，-3，-4]能被解释成位移1，0，0]，随后位移0，-3，0]，最后位移[0，0，4]。 依据三角形法则，这个位移序列可以理解为向量的加法。 一般来说，任意向量vv都能写为“扩展”形式： 另一种略有差别的形式为： 右边的单位向量就是x，y，z轴，可以理解为向量的每个坐标都表明了平行于相应坐标轴的有向位移。 如果将p、g、rp、g、r分别定义为指向+x，+y，+z方向的单位向量： 现在，向量v就被表示成向量p，q，r的线性变换了。向量p，q，r称作基向量。这里基向量是笛卡尔坐标轴，但事实上，一个坐标系能用任意3个基向量定义，当然这三个向量要线性无关（不在一个平面上，互相垂直）。以p，q，r为行构建一个3×3矩阵\textbf{M}M，可得到如下公式： 用一个向量乘以该矩阵，可以得到： 这和前面计算转换后的v的等式相同。我们发现关键点是:如果把矩阵的行解释为坐标系的基向量，那么乘以该矩阵就相当于执行了一次坐标转换。若有aM = b，我们就可以说，M将a转换到b。 从这一点看，术语“转换”和“乘法”是等价的。 坦率地说，矩阵并不神秘，它只是用一种紧凑的方式来表达坐标转换所需的数学运算。进一步，用线性代数操作矩阵，是一种进行简单转换或导出更复杂转换的简便方法。 总结 Unity中也有矩阵Matrix对应的类，虽然用到的较少，但是需要了解。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Unity中使用protobuf]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%9C%A8Unity%E4%B8%AD%E4%BD%BF%E7%94%A8protobuf%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.把之前的聊天系统的消息写成一个proto文件，然后编译成C#代码放到Unity中，试试如何序列化和反序列化。 上次我们已经可以把.proto文件编译生成的C#代码放到Unity中，并解决了报错，那么这些生成的代码如何在Unity中使用呢？ 生成代码解析上次课我们使用protobuf的编译器生成了一个Addressbook.cs代码，一起来看下这个代码里都有什么东西： 一个静态的 AddressbookReflection 类，包含protobuf消息的元数据。 一个AddressBook类包含一个只读的People属性。 一个Person类，包含Name， Id, Email 和 Phones属性。 一个PhoneNumber类，包含在静态的Person.Types类中。 一个 PhoneType枚举，也包含在Person.Types类中。 建议你浏览一下生成的代码，如果你想知道更多生成代码的细节，可以查看google的protobuf的文档：https://developers.google.com/protocol-buffers/docs/reference/csharp-generated proto中的大部分类型，你都可以当作是C#原生的类型。唯一需要注意的是，repeated字段是只读的，你可以从集合中添加或者移除元素，但是你不能使用其他的集合替换现在的这个集合。repeated字段的集合类型是RepeatedField，类似List，但是提供了一些额外的便捷方法，比如Add方法的参数支持集合。 生成代码的使用创建一个Person实例的代码示例如下： 1234567891011121314151617using BigTalkUnity.AddressBook;using UnityEngine;using static BigTalkUnity.AddressBook.Person.Types;public class Test : MonoBehaviour&#123; void Start() &#123; Person john = new Person &#123; Id = 1234, Name = "John Doe", Email = "jdoe@example.com", Phones = &#123; new Person.Types.PhoneNumber &#123; Number = "555-4321", Type = PhoneType.Home &#125; &#125; &#125;; &#125;&#125; 注意上面的using static是C# 6引入的一个语法，可以用来引用静态类型。否则在使用时需要写冗长的前缀代码： 12345678// C# 6之前需要这么写：Person john = new Person&#123; Id = 1234, Name = "John Doe", Email = "jdoe@example.com", Phones = &#123; new Person.Types.PhoneNumber &#123; Number = "555-4321", Type = Person.Types.PhoneType.HOME &#125; &#125;&#125;; 序列化那么如何把一个ProtoBuf的message类序列化成所需要的数据呢？这里面有几种方法。 写入Stream 转为ByteString二进制串/byteArray二进制数组 转为Json字符串12345678910111213141516171819202122232425262728293031323334using BigTalkUnity.AddressBook;using UnityEngine;using static BigTalkUnity.AddressBook.Person.Types;using Google.Protobuf;using System.IO;public class Test : MonoBehaviour&#123; void Start() &#123; Person john = new Person &#123; Id = 1234, Name = "John Doe", Email = "jdoe@example.com", Phones = &#123; new Person.Types.PhoneNumber &#123; Number = "555-4321", Type = PhoneType.Home &#125; &#125; &#125;; // 写入stream using (var output = File.Create("john.dat")) &#123; john.WriteTo(output); &#125; // 转为json字符串 var jsonStr = john.ToString(); // 转为bytestring var byteStr = john.ToByteString(); // 转为byte数组 var byteArray = john.ToByteArray(); &#125;&#125; 解析既然可以把protobuf的对象序列化成字节数组或者json字符串，那么如何反序列化解析出来呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using BigTalkUnity.AddressBook;using UnityEngine;using static BigTalkUnity.AddressBook.Person.Types;using Google.Protobuf;using System.IO;public class Test : MonoBehaviour&#123; void Start() &#123; Person john = new Person &#123; Id = 1234, Name = "John Doe", Email = "jdoe@example.com", Phones = &#123; new Person.Types.PhoneNumber &#123; Number = "555-4321", Type = PhoneType.Home &#125; &#125; &#125;; // 写入stream using (var output = File.Create("john.dat")) &#123; john.WriteTo(output); &#125; // 转为json字符串 var jsonStr = john.ToString(); // 转为bytestring var byteStr = john.ToByteString(); // 转为byte数组 var byteArray = john.ToByteArray(); // 1. 从stream中解析 using (var input = File.OpenRead("john.dat")) &#123; john = Person.Parser.ParseFrom(input); &#125; // 2. 从字节串中解析 john = Person.Parser.ParseFrom(byteStr); // 3. 从字节数组中解析 john = Person.Parser.ParseFrom(byteArray); // 4. 从json字符串解析 john = Person.Parser.ParseJson(jsonStr); &#125;&#125; 总结protobuf的用法有些类似之前使用过的XML或者Json，但是序列化出来的字节数更少，更适合在网络传输中使用。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译proto]]></title>
    <url>%2F2019%2F06%2F14%2F%E7%BC%96%E8%AF%91proto%2F</url>
    <content type="text"><![CDATA[思考并回答以下： 把之前的聊天系统的消息写成一个proto文件，然后编译成C#代码放到Unity中。 如何编译.proto文件到C#代码，然后导入到Unity工程中？ 写好proto文件之后，就可以使用protobuf提供的工具，将.proto文件编译成对应编程语言的代码文件了。 将.proto编译成代码定义好了proto文件之后，就可以使用protobuf提供的编译器，将proto文件编译成你想要的编程语言的代码。 首先需要下载proto的编译器程序protoc，地址是：https://github.com/protocolbuffers/protobuf/releases 下载对应操作系统的protoc即可，在这我下载的是protoc win64版本。 下载好之后，我们需要用到压缩包里面bin目录下的protoc.exe。同时压缩包里还包含了protobuf自带的一些常用proto的定义，如果你的proto文件中引用了这些定义，也要解压出来。 对于我们上节课定义的addressbook.proto，将压缩包中bin\protoc.exe放到同一目录，将include\google也放到同一目录，使用以下命令进行编译： protoc.exe –csharp_out=. Person.proto 完整的编译命令如下： protoc -I=$SRC_DIR –csharp_out=$DST_DIR $SRC_DIR/addressbook.proto其中-I等价于–proto_path，指定了编译时包含的目录，用于解析proto文件中的import指令，查找对应.proto文件所在的位置。 其中–csharp_out指定了将proto编译成C#的代码，如果你需要在别的编程语言中使用proto，可以将proto文件编译到对应语言，具体参数可以使用protoc -h查看。 最后一个参数是编译输出的文件的位置。 使用编译出的代码文件编译完成后我们就得到了一个C#文件，是不是放到Unity工程中就直接能用了呢？ 如果直接将C#文件放到Unity工程中，会有报错。根据报错的提示可以看出来，是少引用了google的相关代码或者dll？ google并没有提供这个dll的预编译版本，所以想要解决这个问题，有几个方式： 使用protobuf的C#源码，直接放到Unity工程中：https://github.com/protocolbuffers/protobuf/tree/master/csharp/src/Google.Protobuf) 用protobuf的C#源码自行编译dll 使用neget中的dll 在这我们直接使用源码： 下载release（https://github.com/protocolbuffers/protobuf/releases）中的这个源码后，将protobuf-3.7.1\csharp\src中的Google.Protobuf目录直接全部放到Unity工程中即可。 在这我们用的是Unity2018.3的版本，默认.Net运行时是4.x，如果你使用了旧版本（2017-2018.2）的Unity，需要手动切换到4.x的运行时或使用支持.Net3.5的protobuf非官方版本（https://github.com/bitcraftCoLtd/protobuf3-for-unity）。 proto在Unity中的编译插件每次修改、编译proto文件还是挺麻烦的，有没有什么好办法？这时候就需要一些额外的工具，工具就是为了提高生产效率而生的。在Github上有这么一个工具，可以在你修改proto文件时自动编译：https://github.com/5argon/protobuf-unity。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[proto文件语法]]></title>
    <url>%2F2019%2F06%2F13%2Fproto%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考题1.把之前的聊天系统的消息写成一个proto文件试试。 之前我们简要了解了protobuf的工作流，第一步就是要定义.proto文件，今天我们来看看这个.proto的语法具体是什么。 .proto语法举个简单的地址簿的例子，从文件读写联系人的信息。每一个联系人有姓名、ID、email和电话。 比如下面这个地址簿的addressbook.proto文件： .proto文件头首先需要定义一个指定是proto3版本的标志位。如果没有定义这个标志，默认认为你使用proto2版本。然后可选使用一个package声明，避免不同工程间的名称冲突。 1234syntax = "proto3";package bigtalkunity;import "google/protobuf/timestamp.proto"; 同时也可以引用其他.proto中定义的message。上面我们就是引用了protobuf中带的timestamp类型。注意引用的路径。 将.proto生成C#代码时，如果没有指定csharp_namespace字段，自动生成的类的命名空间就是package的名称。但是如果指定了下面的字段，就会生成到对应的命名空间中。 1option csharp_namespace = "BigTalkUnity.AddressBook"; 定义message类型下一步就可以定义具体的message了。 一个.proto文件中可以包含多个message。一个message包含了一个或多个包含类型的字段。简单数据类型包括bool，int32，float，double，string等，同时也可以嵌套其他message类型作为字段的类型。 1234567891011121314151617181920212223242526272829message Person &#123; string name = 1; int32 id = 2; // Unique ID number for this person. string email = 3; enum PhoneType &#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; string number = 1; PhoneType type = 2; &#125; repeated PhoneNumber phones = 4; google.protobuf.Timestamp last_updated = 5;&#125;// Our address book file is just one of these.message AddressBook &#123; repeated Person people = 1;&#125; 上面的消息中，Person消息包含了PhoneNumber消息，AddressBook又包含了Person消息，消息可以嵌套消息。 你也可以设置枚举enum类型，用于提前定义的数值列表。 ** 字段规则 ** .proto中可以包含的数据类型以及和C#的对应关系如下： ** .proto Type ** ** 备注 ** ** C# Type ** double double float float int32 使用变长编码。对于负数效率不高，如果字段可能有负值，使用sint32 int int64 使用变长编码。对于负数效率不高，如果字段可能有负值，使用sint64 long uint32 使用变长编码 uint uint64 使用变长编码 ulong sint32 使用变长编码，有符号的整形数值。编码负数时比int32效率高 int sint64 使用变长编码，有符号的整形数值。编码负数时比int64效率高 long fixed32 总是4字节。如果值经常大于228，效率比uint32高。 uint fixed64 总是8字节。如果值经常大于256，效率比uint32高。 ulong sfixed32 总是4字节。 int sfixed64 总是8字节。 long bool bool string 必须是UTF-8或7-bit ASCII编码的文本。 string bytes 可以包含任意长度的字节 ByteString 消息字段可以是以下一种： 可选字段：一个消息中可以有0个或1个这个字段的数据，不能超过1个 repeated：重复字段，这个字段可以把包含任意数量（包含0）的数据，并且顺序会保留。 ** 字段编号 ** 每个字段后面的“=1”，“=2”是字段的唯一编号，用于二进制的编码，一旦消息投入使用，这个编号就不应该再修改。1-15编号使用一个字节（这个字节包含编号和数据类型），16-2047的会使用2个字节。所以基于优化的角度考虑，常用字段尽量放到1-15标记中，并且为后续的扩展预留。重复字段中的每个元素都需要重新编码标记号，因此重复字段特别适合此优化。 可以使用的编号最小是1，最大是2^29-1，也就是536,870,911。19000-19999之间的编号不能使用，因为是protobuf内部保留使用。 * 注释 **在.proto文件中使用注释和C#中类似，单行注释使用//，多行注释使用/\ … */。 ** 枚举 **当你定义一个message类型时，你可能想让一个字段只能是预设的某些值，这时候可以用枚举类型。 123456enum PhoneType&#123; MOBILE = 0; HOME = 1; WORK = 2;&#125; 枚举中第一个值必须是0，这是因为：** 必须有一个值为0，作为enum的默认值** 0值必须是枚举中的第一个元素，为了兼容proto2。 enum的值必须是32bit的整数，不建议使用负数。enum既可以定义在message中，也可以单独定义。 ** 使用其他message类型 ** 你可以使用其他消息类型作为字段的类型，类似C#中的类或结构体。 123456message PhoneNumber&#123; string number = 1; PhoneType type = 2;&#125;repeated PhoneNumber phones = 4; 更新.proto文件注意事项如果现有的消息类型不再满足你的所有需求 - 例如，你希望消息格式具有额外的字段 - 但你仍然希望使用使用旧格式创建的代码，请不要担心！在不破坏任何现有代码的情况下更新消息类型非常简单。请记住以下规则： 请勿更改任何现有字段的字段编号。 如果添加新字段，则使用“旧”消息格式按代码序列化的任何消息仍可由新生成的代码进行解析。你应该记住这些元素的默认值，以便新代码可以正确地与旧代码生成的消息进行交互。同样，你的新代码创建的消息可以由旧代码解析：旧的二进制文件在解析时只是忽略新字段。 只要在更新的消息类型中不再使用字段编号，就可以删除字段。你可能希望重命名该字段，可能添加前缀“OBSOLETE_”，或者保留字段编号，以便你的未来用户.proto不会意外地重复使用该号码。 int32，uint32，int64，uint64，和bool都是兼容的-这意味着你可以改变这些类型到另一个类型而不破坏向前或向后兼容。如果从网络中解析出一个不适合相应类型的数字，你将获得与在C #中将该数字强制转换为该类型相同的效果（例如，如果将64位数字作为int32读取，它将被截断为32位）。 sint32并且sint64彼此兼容但与其他整数类型不兼容。 string bytes中只要是有效的UTF-8字节，它们是兼容的。 bytes如果字节包含消息的编码版本，则兼容嵌入消息。 fixed32与sfixed32兼容，fixed64与sfixed64兼容。 enum与int32，uint32，int64，和uint64兼容（注意，如果他们不符合类型将被截断）。但请注意，在反序列化消息时，客户端代码可能会以不同方式对待它们：例如，enum消息中将保留未识别的proto3 类型，但在反序列化出来的消息如何表示它，是依赖于编程语言的。Int字段总是保留它们的值。 总结编写.proto文件其实和C#中定义类或结构体很相似。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[protobuf简介]]></title>
    <url>%2F2019%2F06%2F13%2Fprotobuf%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.protobuf更适合用在什么场景？2.protobuf的工作流是什么样的？3.把之前的聊天系统的消息写成一个proto文件试试。 上次我们在学习如何进行数据包封包的时候说到：在网络传输时数据包需要定义好格式，这个格式就是数据在字节流中是如何排列的，有时候这种数据排列的方式也称作协议（Protocol）。自定义协议灵活性很大，但是相应的复杂度也很高，如果客户端和服务器是两种不同的语言开发的，就需要分别进行协议的编码和解码，工作量会很大。不过，还有一个Protocol Buffers可以解救我们。 Protocol Buffers简介Protocol Buffers (通常简称为protobuf) 是Google开发的一种格式，这种格式与开发语言无关、与运行平台无关，用于序列化结构数据，并且很容易扩展。这种格式可以用于通信协议、数据存储等等。你可以想一下之前学过的xml或json，和他们有些类似，但是protobuf更小、更快、更简单。 protobuf是开源的，地址如下：https://github.com/protocolbuffers/protobuf 这个是编译器的源码，用C++写的。 使用protobuf时，你只需要按照protobuf的格式要求将数据结构定义在.proto文件中一次，就可以通过protobuf的编译工具生成不同开发语言的数据结构代码（就像我们在C#中序列化/反序列化xml或json时需要定义的class类），生成的代码中还封装了数据结构的读写和序列化。 为什么要用protobuf呢？举个简单的地址簿的例子，从文件读写联系人的信息。每一个联系人有姓名、ID、email和电话。 如果使用你已经学过的知识，如何序列化和反序列化这样的数据呢？有几种方式可以实现： 1、第一种，使用我们之前学过的XML或JSON。XML和JSON的好处就是它们具有自描述性，是人类可读的，几乎所有编程语言都有成熟的开源库来序列化/反序列化它们。如果你想要和其他程序进行数据交换，XML/JSON是很好的选择。但是，XML/JSON数据所占的空间比较大（因为有很多冗余的标签、字符），同时解析速度比较慢。后面我们会具体比较XML/JSON和protobuf的区别。 2、第二种，使用.NET的二进制序列化类：System.Runtime.Serialization.Formatters.Binary.BinaryFormatter。用这种方式，一旦改变数据结构会非常麻烦，之前已有的数据可能都无法使用了，并且与其他程序进行数据交换时很麻烦。 3、第三种，使用自定义的数据格式，比如上次我们学习到的格式。这种方式简单、快速，但是不方便的就是如果在多种语言之间传输，每种语言都要写解码、编码的代码。 protocol buffers正是google开发来解决上面提到的这些问题的。protobuf拥有灵活性、高效率、自动化的特性。使用protobuf时，你只需要写一个.proto的数据结构描述文件，protobuf提供的编译器就可以自动将.proto文件编译成你想要的编程语言的代码，这些自动生成的代码里实现了编码、解码、读写这些格式数据的功能。更重要的是，protobuf格式支持后续扩展，扩展后的格式仍然可以兼容旧格式。 详细对比XML/JSON上面我们多次提到了XML/JSON，它们有类似的地方，但是也有很多不同。 相对于XML或JSON，Protocol buffers有许多优点： 序列化出来的数据更精炼 序列化出来的字节数缩小3-10倍 序列化的性能快20-100倍 数据歧义更少 可以自动生成用于访问数据结构的代码 但同样，有一些情况下proto不如XML或JSON： XML/JSON拥有人类可读性、可编辑性，但是protobuf不可以（至少原生protobuf序列化的数据不可以） XML/JSON有自描述性，但是proto的数据没有意义，除非你能拿到定义文件（.proto） 所以通常protobuf更适合使用在对数据字节数比较敏感的场景，对序列化/反序列化性能要求高的场景。比如游戏开发这种高并发、数据包的频次非常高、手游对流量敏感就是一个很适合的场景。 protobuf的工作流protobuf有两个版本，分别是proto2和proto3，后面我们学习的时候使用的都是新版的proto3，如果你后续在查找资料时发现不相同的地方，一定要确认下是哪个版本。 ** 1. 定义.proto文件 **首先你要在.ptoto文件中定义你想要传输的数据结构。.proto文件很简单：使用message来定义每一个需要序列化的数据结构，每个message里面可以定义类型和名称。 ** 2. 编译.proto文件 **使用protobuf提供的编译工具，将.proto文件编译为对应开发语言的数据结构代码。 ** 3. 在代码中序列化和解析 **在代码中将数据结构序列化成字节数组发送出去，或者将接收到的字节数组反序列化成内存中的数据。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL主从复制]]></title>
    <url>%2F2019%2F06%2F12%2FMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.2. MySQL复制的优点 横向扩展解决方案：在多个从库之间分配负载以提高性能。在此环境中，所有写入和更新都必须在主服务器上进行。但是，读取操作可以在一个或多个从站上进行。该模型可以提高写入性能（因为主设备专用于写操作），同时显著提高了越来越多的从库的读取速度。数据安全性 - 因为数据被复制到从库，并且从库可以暂停复制过程，所以可以在从站上运行备份服务而不会破坏相应的主数据。分析 - 可以在主服务器上创建实时数据，而信息的分析可以在从服务器上进行，而不会影响主服务器的性能。远程数据分发 - 您可以使用复制为远程站点创建数据的本地副本，而无需永久访问主服务器。MySQL复制的类型异步复制：主库不会等待从库的执行情况，是默认的复制模式半同步复制：使用半同步复制，在返回执行事务的会话之前对主块执行提交，直到至少一个从服务器确认已接收并记录事务的事件为止;MySQL 5.7 还支持延迟复制，使得从属服务器故意滞后于主服务器至少一段指定的时间;MySQL实现类型格式有两种核心类型的复制格式：基于语句的复制（SBR），它复制整个SQL语句，以及基于行的复制（RBR），它仅复制已更改的行。 主备通用设置主库上的设置开启二进制日志（bin_log）server-id=1如果没有设置server_id（或者默认其为0），则住服务器拒绝来自从服务器的任何连接 备库上的设置server-id=2 设置与主库不同的号，此ID用于标识组内的各个服务器，并且必须是介于1和（2 32）-1 之间的正整数若是server-id没有设置或是0，则从库会拒绝主库连接 如果这个备库只是一个备库的话，则它无需开启 bin_log 就可以实现功能，但是bin_log的可以让备库进行数据备份和崩溃恢复，还可以作为其他机器的备库。所以，强烈建议开启备库的bin_log。 创建复制用户每个从库使用MySQL的用户名和密码连接到主库，因此必须使用用户账户，该账户必须被赋予 replication slave 权限 如下此用户，就有复制权限 MySQL [nba]&gt; select user,Repl_slave_priv from mysql.user where user = ‘replicate’;+———–+—————–+| user | Repl_slave_priv |+———–+—————–+| replicate | Y |+———–+—————–+1 row in set (0.00 sec)创建用户的过程为 MySQL [nba]&gt; select user,Repl_slave_priv from mysql.user where user = ‘stephen’;+———+—————–+| user | Repl_slave_priv |+———+—————–+| stephen | N |+———+—————–+1 row in set (0.00 sec) MySQL [nba]&gt; grant replication slave on . to ‘stephen’@’%’;Query OK, 0 rows affected (0.00 sec) MySQL [nba]&gt; select user,Repl_slave_priv from mysql.user where user = ‘stephen’;+———+—————–+| user | Repl_slave_priv |+———+—————–+| stephen | Y |+———+—————–+1 row in set (0.00 sec)备库上的数据要搭建备库，首先备库上需要有现有主库的数据快照，一般使用下面两种方法实现 使用mysqldump使用mysql自带的mysqldump命令可以将整库备份出来 mysqldump -S /mysqldata/mysql.sock -uroot -pmysql –all-databases –master-data &gt; dbdump.db除了这个备份，还需要获取主二进制日志坐标，过程如下： MySQL [nba]&gt; FLUSH TABLES WITH READ LOCK;Query OK, 0 rows affected (0.01 sec) MySQL [nba]&gt; show master status\G;*** 1. row *** File: mysql-bin.000027 Position: 154 Binlog_Do_DB: test Binlog_Ignore_DB:Executed_Gtid_Set:1 row in set (0.00 sec)使用 XtraBackup全备安装了此功能之后，可以使用这个方法进行数据传输 innobackupex –defaults-file=/etc/my.cnf –user=root –password=mysql –no-timestamp /databackup在从库上新建备份目录，并把主库的全备传输到从库上 scp -r /databackup/* 192.168.56.11:/databackup应用一下全备 innobackupex –apply-log /databackup/在从库上恢复全备 innobackupex –copy-back /databackup此方法的日志位置，可以在备份目录中的xtrabackup_info文件中查看到 binlog_pos = filename ‘mysql-bin.000024’, position ‘154’搭建主从建立备库连接进行连接配置 CHANGE MASTER TO MASTER_HOST=’192.168.56.10’, MASTER_USER=’replicate’, MASTER_PASSWORD=’replicate’, MASTER_PORT=3306, MASTER_LOG_FILE=’mysql-bin.000024’, MASTER_LOG_POS=468, MASTER_CONNECT_RETRY=10;接下来，如果是使用mysqldump 使用 –skip-slave-start 启动备库导入转储文件： shell&gt;mysql &lt; fulldb.dump 启动从库线程mysql&gt;start slave;如果是使用Xtrabackup全量备份则在开启数据库后直接开启从库线程即可 半同步复制概述MySQL5.7默认的复制是异步复制，主将事物操作写到二进制文件，但是不知道从库是否或何时去应用这些日志，如果主库崩溃，则会有事物未提交到备库，就会导致数据库丢失。为了解决这个问题，我们可以使用半同步复制。 半同步复制有以下性质：若主库是半同步复制，则在主上执行事物提交的线程等待，直到至少一个半同步设备确认已收到事物的所有内容，或者直到发生超时，这也是半同步复制的’半’字的原因。若是全同步复制，则就需要全部从库收到事务的所有内容 从库只有将事物写到日志直到刷新磁盘后，从库才会确认收到全部事物 安装插件在使用半同步之前，需要先在主从上分别安装插件主库上安装插件 MySQL [(none)]&gt; install plugin rpl_semi_sync_master soname ‘semisync_master.so’;Query OK, 0 rows affected (0.04 sec) MySQL [(none)]&gt; set global rpl_semi_sync_master_enabled=on;Query OK, 0 rows affected (0.00 sec)查看是否安装成功 MySQL [(none)]&gt; show variables like ‘%semi%’;+——————————————-+————+| Variable_name | Value |+——————————————-+————+| rpl_semi_sync_master_enabled | ON | #设置为on表示开启了半同步功能| rpl_semi_sync_master_timeout | 10000 | #单位是毫秒，表示如果主库等待从库回复消息的时间超过该值，就自动切换为异步复制模式| rpl_semi_sync_master_trace_level | 32 | #它控制主库接收多少个从库写事物成功反馈，才返回成功给客户端| rpl_semi_sync_master_wait_for_slave_count | 1 | #| rpl_semi_sync_master_wait_no_slave | ON || rpl_semi_sync_master_wait_point | AFTER_SYNC | # 默认值是AFTER_SYNC，含义是主库将每个事物写入binlog,并传递给从库，刷新到中继日志，主库开始等待从库的反馈，接收到从库的回复之后，再提交事物并且返回“commit ok”结果给客户端+——————————————-+————+6 rows in set (0.01 sec)从库上安装插件 MySQL [(none)]&gt; install plugin rpl_semi_sync_slave soname ‘semisync_slave.so’;Query OK, 0 rows affected (0.01 sec) MySQL [(none)]&gt; set global rpl_semi_sync_slave_enabled=on;Query OK, 0 rows affected (0.00 sec)参数完成之后，启动从库线程 MySQL [(none)]&gt; start slave io_thread;Query OK, 0 rows affected (0.00 sec)延迟复制概述MySQL5.7 支持延迟复制，使得从库可以刻意滞后主库至少一段指定的时间，默认延迟是0秒，使用MASTER_DELAY 选项CHANGE_MASTER_TO 使用 MySQL [nba]&gt; CHANGE MASTER TO MASTER_DELAY = 20;Query OK, 0 rows affected (0.09 sec)延迟复制的意义： 防止用户在主库上出错，DBA可以将延迟的从库回滚到误操作前的时间测试延迟时系统的行为方式检查数据库很久之前的样子，而不必重新加载备份信息显示在show slave statusG 上有几个字段显示了延迟复制的信息 SQL_Delay：默认为0，显示与主库延迟的秒数SQL_Remaining_Delay：当 Slave_SQL_Running_State是Waiting until MASTER_DELAY seconds after master executed event，则此字段包含一个整数指示左延迟的秒数。在其他时候，这个参数是NULLSlave_SQL_Running_State：当前的复制的状态，一般的同步完成是Slave has read all relay log; waiting for more updates]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Roguelike]]></title>
    <url>%2F2019%2F06%2F11%2FRoguelike%2F</url>
    <content type="text"></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D/2D游戏开发从0到1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行时构建NavMesh]]></title>
    <url>%2F2019%2F06%2F10%2F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%84%E5%BB%BANavMesh%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 去动态生成一个场景，看看NavMesh是如何生成和变化的 导航系统对于动态生成的场景，就不能直接用了。但是Navigation系统有一个官方的扩展，虽然没有直接包含在Unity引擎的安装包里，但是是Unity官方提供的。 点击此链接可以查看对应的组件 在Navigation窗口中可以看到这样的链接字样，也可以打开对应的Github网站(https://github.com/Unity-Technologies/NavMeshComponents)。 NavMeshComponentNavMeshComponent给NavMesh的构建和使用提供了很多额外的控制功能，可以在运行时和编辑器中使用。 安装NavMeshComponent并没有直接包含在Unity中，需要通过这个链接（https://github.com/Unity-Technologies/NavMeshComponents）安装下载。具体的步骤是： 1、打开上面的链接2、点击图中的Release 3、选择你的Unity版本对应的NavMeshComponent版本。 4、下载解压以后，可以使用Unity打开该工程。如果要在已有的工程中使用，可以将Assets/NavMeshComponents目录复制到已有工程中。另外 Assets/Examples 目录中有示例场景。 组件介绍NavMeshComponents包含4个组件，分别是：这里我们介绍导航系统的四个组件： NavMeshSurface - 基于一种agent类型构建NavMesh。 NavMeshModifier - 基于层次结构影响NavMesh区域类型的NavMesh生成。 NavMeshModifierVolume - 根据体积影响NavMesh区域类型的NavMesh生成。 NavMeshLink - 为一个agent类型连接相同或不同的NavMesh表面。 这些组件包含了构建和使用NavMeshes的高级控制，可以用于运行时和编辑时。 NavMesh SurfaceNavMeshSurface组件用来设置针对一种agent类型的可行走的区域，并且在该区域构建NavMesh。在构建NavMesh时，会自动排除NavMeshAgent和NavMeshObstacle物体。 使用方法点击菜单栏中 GameObject &gt; AI &gt; NavMesh Surface。点击后会创建一个空物体，上面包含NavMeshSurface组件。一个场景可以包含多个NavMeshSurface物体。 也可以给任何物体添加NavMeshSurface组件，这种情况非常适合一个物体的所有子物体来构建NavMesh的情况。 属性详解Agent Type 使用这个NavMeshSurface的Agent类型。用于NavMesh的生成和寻路。 Collect Objects 用于生成NavMesh的物体。 All 所有active的物体 Volume 选中该选项时，可以在场景中编辑一个盒子，盒子所包围的物体用来生成NavMesh。 Volume选项时的包围盒 Volume选项时的包围盒 Children NavMeshSurface组件所在物体的所有active子物体。 Include Layers 可以选择用于生成NavMesh的layer。 Use Geometry 用于生成NavMesh的几何体 Render Meshes 使用物体的Mesh和Terrain数据 Physics Colliders 使用物体的Collider和Terrain数据（使用这个选项时，agent可以移动到物体边缘更近的地方） Advanced settings 高级设置Default Area 设置该NavMesh的Area Override Voxel Size 设置Voxel尺寸 Override Tile Size 为了使烘焙过程能并行处理并且内存效率更高，场景被分割成多个小块（瓦片）。NavMesh上可见的白线是瓦片的边界。默认瓦片大小为256个Voxel，这个值在内存使用效率和NavMesh分块之间提供了良好的折衷。要更改此默认瓦片大小，可以选中此复选框，然后在 Tile Size 字段中输入切片大小的体素数。 瓦片越小，NavMesh就越碎片化。这有时会导致agent走的不是最佳路径。NavMesh雕刻也在瓦片上执行。如果有很多障碍物，通常可以设置更小的瓦片尺寸（例如大约64到128个体素）来加速雕刻。如果计划在运行时烘焙NavMesh，请使用较小的瓦片大小来降低最大内存占用。 Build Height Mesh 暂不支持 NavMesh Modifier这个组件可以修改该物体及子物体的NavMesh构建属性。这个组件会影响该物体及所有的子物体。如果子物体上也有NavMesh Modifier，则该NavMesh Modifier会重写自己及其子物体的属性。 NavMesh Modifier会影响NavMesh的构建，所以如果NavMesh Modifier的属性进行了修改，需要重新构建NavMesh。 属性详解Ignore From Build 选中时该物体及其所有子物体不会被构建进NavMesh。 Override Area Type 修改该物体及其所有子物体的Area类型。 Affected Agents 该组件影响的Agents。例如，你可以针对特定的Agent排除特定的障碍物。 NavMesh Modifier Volume和NavMesh Modifier类似，但是此组件可以通过设置一个包围盒来修改包围盒中的物体的NavMesh属性。 NavMesh LinkNavMesh Link可以在两个NavMesh之间创建链接。可以是点到点的链接，也可以是缝隙之间的链接（会沿着入口边缘最近位置跨越链接）。 属性详解Agent Type 可以使用这个NavMeshLink的Agent类型。 Start Point 起点。相对于GameObject的位置。End Point 终点。相对于GameObject的位置。 Swap按钮 交换起点和终点的位置。 Align Transform按钮 将GameObject的位置移到起点和终点的中心，并且朝向终点的位置。 Width 宽度。如果为0则通过两个点连接，如果大于0通过两条线连接。 Cost Modifier 非负值时，通过这个链接的代价是Cost Modifier乘以终点的距离。 Bidirectional 双向。不勾选时只能单向寻路。 Area Type 设置该link的area类型。 总结这些基本上就是NavMesh相关组件的一些介绍和用法。可以更灵活的在运行时创建、使用NavMesh。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态障碍物/与Animator协作]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%8A%A8%E6%80%81%E9%9A%9C%E7%A2%8D%E7%89%A9-%E4%B8%8EAnimator%E5%8D%8F%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.动手试试动态障碍物和导航与Animator的协作 NavMesh烘焙只适用于静态的场景。对于动态生成、可移动的障碍物，可以通过NavMeshObstacle组件实现。 NavMeshObstacle组件NavMeshObstacle组件用于动态生成和可移动的障碍物。当障碍物移动时，NavMeshAgent会尽量躲避它。当障碍物静止时，它会在NavMesh上雕刻一个洞，类似烘焙出来的障碍物，此时Agent会重新计算寻路的路线。 Shape 障碍物的几何形状，可选项有Box和Capsule。Center 障碍物的几何形状中心相当于物体轴心的偏移。对于Box：&emsp;Size 障碍物的几何形状的尺寸。对于Capsule：&emsp;Radius 半径&emsp;Height 高度Carve 勾选此选项后，Nav Mesh Obstacle会在NavMesh中创建一个洞。 &emsp;Move Threshold 障碍物移动超过这个阈值设置的值时，Navigation系统才会更新障碍物在NavMesh上雕刻的洞。 &emsp;Time To Stationary 经过设置的时间后障碍物才会被视为静止。 &emsp;Carve Only Stationary 只在障碍物静止时才在NavMesh上雕刻一个洞。 细节Nav Mesh Obstacle可以通过两种方式影响Nav Mesh Agent在场景中的导航： ** 阻碍 **如果未启用Carve，则Nav Mesh Obstacle的默认行为类似于Collider。Agent尝试避免碰撞Nav Mesh Obstacle，当接近时，它们会与Nav Mesh Obstacle碰撞。避障行为非常简单并且半径也很短。因此Agent可能无法在复杂的Nav Mesh Obstacles环境中找到方向。此模式最适用于障碍物不断移动的情况（例如，车辆或角色）。 ** 雕刻 **当Curve启用时，静止的障碍物会在NavMesh上雕刻一个洞，移动的障碍物会是阻挡物。当障碍物在NavMesh上雕刻一个洞时，Agent能在复杂的环境中找到路。对于经常会阻碍玩家移动的障碍物（例如，集装箱或油桶），最好打开Curve，同时这些障碍物可以被玩家或其他游戏事件（如爆炸）移动。 移动Nav Mesh Obstacle当移动的距离超过Carve &gt; Move Threshold设置的距离时，Unity会将Nav Mesh Obstacle视为移动。当Nav Mesh Obstacle移动时，雕刻的洞也会移动。但是，为了减少CPU开销，只在必要时重新计算雕刻的洞。计算的结果可在下一帧更新中使用。重新计算逻辑有两个选项： 只有当Nav Mesh障碍物静止时才会雕刻 当Nav Mesh障碍物移动时雕刻 ** 只有当Nav Mesh Obstacle静止时才雕刻 **这是默认行为。要启用它，请勾选Nav Mesh Obstacle组件的Carve Only Stationary复选框。在此模式下，当障碍物移动时，雕刻的孔被移除。当障碍物停止移动并且已经静止超过“雕刻静止时间”（Carving Time To Stationary）设置的时间时，它被视为静止，并且更新雕刻的孔。当Nav Mesh障碍物移动时，Nav Mesh Agent会避免使用碰撞躲避，但不会在障碍物周围寻路。 Carve Only Stationery通常是性能方面的最佳选择，并且容易与物理系统一起使用。 ** Nav Mesh Obstacle移动时雕刻 **要启用此模式，需要取消选中Nav Mesh Obstacle组件的Carve Only Stationary复选框。如果未选中此选项，则当障碍物移动的距离超过Carving Move Threshold设置的距离时，会更新雕刻的孔。此模式适用于大型缓慢移动的障碍物（例如，步兵避开的坦克）。 注意：Nav Mesh Obstacle对NavMesh的影响存在一帧延迟。 寻路与Animator敌人的动画怎么和寻路结合呢？现在角色只会飘来飘去的，看着好吓人 人物漂移 这个问题其实要协调NavMeshAgent和Animator，如果同时使用NavMeshAgent和开启RootMotiond的Animator，会有冲突，因为两个组件都会更新物体的transform。一般有两个解决方案： Animation跟随Agent Agent跟随Animation 需要注意的是只能选取一种，让信息单向流动，否则可能会造成信息的混乱，很难调试。 Animation跟随AgentNavMeshAgent组件中有一个属性velocity，是角色移动的速度。可以用这个速度作为Animator的输入，来粗略地控制动画。这种方式比较简单，但是如果速度不匹配的话可能会造成角色的滑步。示例代码如下： 12345678910111213141516171819202122232425262728using UnityEngine;using UnityEngine.AI;[RequireComponent(typeof(NavMeshAgent))]public class EnemyMovement : MonoBehaviour&#123; public Transform Player; Animator _animator; private NavMeshAgent _agent; void Start () &#123; _animator = GetComponent&lt;Animator&gt;(); _agent = GetComponent&lt;NavMeshAgent&gt;(); &#125; void Update () &#123; _agent.SetDestination(Player.position); var velocity = _agent.desiredVelocity; // 将世界坐标的速度转换为角色本地坐标系的速度 velocity = transform.InverseTransformDirection(velocity); _animator.SetFloat('speedX', velocity.x); _animator.SetFloat('speedZ', velocity.z); &#125;&#125; Agent跟随Animation这种方式控制比较精确，但是相对复杂一些。首先要禁用掉 NavMeshAgent.updatePosition 和 NavMeshAgent.updateRotation，这样NavMeshAgent就不会控制角色的Transform进行移动。然后使用模拟的agent下一帧的位置(NavMeshAgent.nextPosition) 和当前位置animation root (Animator.rootPosition) 来计算Animator的输入参数。 示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using UnityEngine;using UnityEngine.AI;[RequireComponent(typeof(NavMeshAgent))][RequireComponent(typeof(Animator))]public class LocomotionSimpleAgent : MonoBehaviour&#123; Animator anim; NavMeshAgent agent; Vector2 smoothDeltaPosition = Vector2.zero; Vector2 velocity = Vector2.zero; void Start() &#123; anim = GetComponent&lt;Animator&gt;(); agent = GetComponent&lt;NavMeshAgent&gt;(); // 设置agent不会更新角色的位置 agent.updatePosition = false; &#125; void Update() &#123; // 根据agent模拟的下一帧的位置nextPosition，计算变化 Vector3 worldDeltaPosition = agent.nextPosition - transform.position; // 将世界位置的变化转换到物体的本地坐标系 float dx = Vector3.Dot(transform.right, worldDeltaPosition); float dy = Vector3.Dot(transform.forward, worldDeltaPosition); Vector2 deltaPosition = new Vector2(dx, dy); // 平滑处理 float smooth = Mathf.Min(1.0f, Time.deltaTime / 0.15f); smoothDeltaPosition = Vector2.Lerp(smoothDeltaPosition, deltaPosition, smooth); // 计算移动的速度 if (Time.deltaTime &gt; 1e-5f) velocity = smoothDeltaPosition / Time.deltaTime; bool shouldMove = velocity.magnitude &gt; 0.5f &amp;&amp; agent.remainingDistance &gt; agent.radius; // 更新animator的参数 anim.SetBool('move', shouldMove); anim.SetFloat('velx', velocity.x); anim.SetFloat('vely', velocity.y); // agent可能和角色出现分离的现象，通过下面的代码进行修正 if (worldDeltaPosition.magnitude &gt; agent.radius) transform.position = agent.nextPosition - 0.9f * worldDeltaPosition; &#125; void OnAnimatorMove() &#123; // 根据navmesh的高度更新角色的高度 Vector3 position = anim.rootPosition; position.y = agent.nextPosition.y; transform.position = position; &#125;&#125; 总结一般情况下用第一种方式会比较简单，第二种方式更精确一些，也更难理解]]></content>
  </entry>
  <entry>
    <title><![CDATA[NavMeshAgent]]></title>
    <url>%2F2019%2F06%2F10%2FNavMeshAgent%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.让角色在场景中寻路的步骤是什么？2.GetComponent().destination是什么意思？ NavMesh烘焙好了，接下来学习NavMeshAgent组件，让角色动起来，参与寻路的角色都需要添加这个组件。 NavMeshAgent组件场景的NavMesh烘焙好之后，就可以让角色在场景中寻路。一般的步骤如下： 1、选中或创建一个角色，在测试时可以创建一个圆柱体：GameObject &gt; 3D Object &gt; Cylinder，并设置好角色的尺寸。 2、给角色添加NavMeshAgent组件并设置组件的相关属性（简单测试时可以保持默认值） 3、现在可以通过脚本设置NavMeshAgent的目的地，示例代码如下： 123456789101112using UnityEngine;using UnityEngine.AI;public class PlayerController : MonoBehaviour &#123; private NavMeshAgent _agent; void Start () &#123; _agent = GetComponent&lt;NavMeshAgent&gt;(); _agent.destination = Vector3.one; &#125;&#125; 通过设置NavMeshAgent组件中的destination属性，可以设置角色的运动目的地。 NavMeshAgent组件属性NavMeshAgent组件主要有以下作用：1、通过NavMesh的数据进行寻路，移动到目标位置2、NavMeshAgent之间会互相躲避3、躲避动态障碍物 Agent Type Agent类型。通过Navigation窗口的Agents页签进行设置，可以设置多种类型的Agent。设置后，在组件的Agent Type属性中可以通过下拉框选择。 ** Agents设置 ** 设置Agents类型时，一般根据角色的尺寸进行分类设置。比如人形角色、巨人族、怪兽等等。 Base Offset Agent的偏移量，调整这个值让Agent能适合角色的偏移。 图中的圆柱形网格代表了Agent的尺寸及偏移 ** Steering 移动参数 **Speed 最大移动速度（m/s）Angular Speed 旋转速度（角度/秒）Acceleration 最大加速度（米/秒^2）Stopping Distance 距离目标位置为这个位置后停止运动。Auto Braking 选中时，agent在即将到达目标位置时会减速。但是有些情况应该禁用，比如agent在多个目标点之间巡逻。 ** Obstacle Avoidance 障碍躲避 **Radius 用来计算和其他障碍物和Agent碰撞的半径Height 用来计算和其他障碍物和Agent碰撞的高度Quality 障碍躲避的质量。如果场景中有很多Agent，可以降低质量来减少CPU的占用。如果将躲避设置为None，Agent不会自动躲避障碍物，会直接装上去。Priority 比当前Agent的优先级低的Agent在躲避时会被忽略。这个属性的范围是0-99，数字越小代表优先级越高。 ** Path Finding **Auto Traverse OffMesh Link 选中时会自动通过OffMeshLink的位置。如果你想要在通过这些位置时播放动画或进行特殊操作，不要勾选此选项。 Auto Repath 选中时，Agent到达部分路径的尽头时会自动尝试去找接下去的路。如果没有路径能到达目标位置，会生成一个部分路径到达目标位置的最近位置。 Area Mask NavMesh中可以给不同的位置进行分类。这个属性可以定义agent可以在哪些区域寻路。比如你可以将楼梯设置为特殊的区域类型，从而禁止一些agent使用楼梯。 Navigation Area可以给NavMesh定义多个Area（区域），每个区域也可以设置一个Cost用来指示在这个区域行走的代价。Cost越高代表这个区域越不好走，agent在寻路时会倾向寻找代价更低的路线。 比如： 有水的区域行走就会比较慢，通行Cost就会更高 门只有特定的角色才能通过，比如人类可以通过，但是僵尸就不能。 1、在Navigation窗口的Areas中设置区域类型 2、在Navigation窗口的Object中设置选中物体的Navigation Area 疑难解答Navigation系统中涉及到Agent Size的地方有三个： Navigation窗口Bake页签中的Baked Agent Size 这个Size设置仅用来设置烘焙NavMesh时所使用的Agent的尺寸，和具体的Agent无关。但是这个设置会影响NavMesh信息的生成，例如在这设置了Radius很大，那么对于小Radius的Agent就会支持不太好。所以这个Size设置时，要考虑到所有的Agent，取值要能覆盖到所有的Agent。Radius取所有Agent最小值，Height取所有Agent最小值，Slope取所有Agent最大值，Step Height取所有Agent最大值。 Navigation窗口Agents页签中的Agent Types中的Agent设置 这里面的Agent设置是针对同一类的Agent，用于Agent在NavMesh上导航时的设置，相当于在静态物体上导航时的设置。 NavMeshAgent组件中Obstacle Avoidance中的Size设置。 这个设置只会影响NavMeshAgent和其他Agent以及动态障碍物碰撞的计算。 总结导航系统本身是个很复杂的系统，Unity为了简化这个流程已经做了很多工作了]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻路导航]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%AF%BB%E8%B7%AF%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.NavMesh、NavMeshAgent组件、Off-Mesh Link组件、NavMesh Obstacle组件都是干嘛的？2.静态场景的NavMesh的烘焙步骤是什么？3.Height Mesh的作用是什么？ 寻路导航Unity中内置了寻路系统，叫Navigation（导航）。导航系统可以计算场景中可行走的区域，然后通过代码给AI设置目的地，AI会自动躲避障碍物，到达目的地。 导航系统中有几个基本的概念： &emsp;&emsp;NavMesh 是Navigation Mesh（导航网格）的简称。类似系统提前勘测的一个地图，用来记录哪些地方可以走，那些地方不能走。导航网格可以提前在编辑器中烘焙，也可以在运行时动态生成。 &emsp;&emsp;NavMeshAgent组件 通过寻路系统移动的角色需要添加这个组件。添加了NavMeshAgent组件的物体也会互相躲避。 &emsp;&emsp;Off-Mesh Link组件 用于不连续的地方，比如可以跳过去的水沟或者篱笆，可以打开的门等情况。 &emsp;&emsp;NavMesh Obstacle组件 该组件可以用于动态障碍物。标记为Navigation Static的物体在运行时是不能移动的，但是添加NavMesh Obstacle的物体，在运行时可以移动，同时角色寻路时也会躲避这个物体。但是相应的运行时会占用一定的CPU。 对于静态场景的NavMesh的烘焙，也是应用最多的情景，一般有如下几步： 1、设置需要烘焙导航网格信息的物体为Navigation Static，比如地面、墙面、大石头等物体。 2、从菜单栏Window &gt; AI &gt; Navigation打开Navigation窗口，选中Bake选项卡。 3、设置烘焙参数。** Baked Agent Size ** ，也就是参与寻路角色的尺寸，包括半径、高度、可行走的最大坡度、步幅的高度（上台阶）时使用。如果有多种Agent，需要考虑所有Agent的尺寸。** Generated Off Mesh Links ** ，寻路时对于不连续区域的处理，比如从高台跳下的高度（Drop Height），水平跳跃的距离（Jump Distance）。 4、点击Bake按钮，稍等片刻，即可看到场景中的NavMesh信息。蓝色区域就是可行走的区域。蓝色区域没有完全覆盖可行走的区域，这是因为Agent半径设置，需要给Agent和障碍物留出一定距离，以免发生穿透。 5、对于参与寻路的角色，需要给角色添加NavMeshAgent组件，通过代码动态设置Agent的目的地位置，设置后角色会自动朝目的地移动。 NavMesh烘焙设置 一个地图上可能有多种不同类型的AI，所以设置导航烘焙的时候需要考虑多种AI来烘焙地图，地图需要所有AI的信息。 ** Baked Agent Size **Agent的尺寸设置。 Agent Radius Agent半径，相当于设置角色的宽度。如果有多个Agent类型，按最小的半径设置。 Agent Height Agent高度，会影响角色钻洞等情况。如果有多个Agent类型，按最低高度设置。 Max Slope 最大坡度，角色可以爬上的最大坡。如果有多个Agent类型，按最大的坡度设置。 Step Height 步幅最大高度，比如上一个高台或者上楼梯。如果有多个Agent类型，按最大的步幅高度设置。 ** Generated Off Mesh Links **设置不连续的表面的导航信息烘焙参数。 如果想要烘焙OffMeshLink，需要先给能跳下去的物体勾选Off Mesh Link Generation。可以在Static标记中勾选： 也可以在Navagation面板的Object页签下面勾选Generate OffMeshLinks，如下图所示。 Drop Height 角色可以从高处跳下的最大距离。 Jump Distance 跳跃距离。角色可以跳跃的最远距离，用于跳过类似裂缝的位置。 设置了OffMeshLink后烘焙出来的样子 ** 注意 **如果发现烘焙后没有出现OffMeshLink，可以检查以下部分：1、是否平台的顶部尺寸太小（长或宽小于Agent Radius*2，面积小于Min Region Area），尺寸太小不会生成NavMesh2、检查平台的高度是否过高，或者Drop Height是否过小。3、两个可以跳跃的平台之间高度一致时可以互相跳，高度不一致时，只能由高平台跳到低平台上。 ** Advanced 高级设置 **Manual Voxel Size 手动设置Voxel的大小。Voxel即体素，代表了NavMesh的精度。Voxel越小NavMesh的精度越高，但是会增加烘焙的时间。Voxel减小一半，内存占用为原来的4倍，烘焙时间为原来的4倍。 Min Region Area 最小区域面积。如果一个区域表面的面积小于这个值，该区域会被忽略，不会烘焙NavMesh。 Height Mesh 勾选此选项后，会烘焙高度Mesh。高度Mesh可以让角色在物体表面寻路时高度更精确。如果不勾选此选项，物体会在可行走的区域近似表面行走（比如楼梯会近似成一个斜坡）。勾选此选项后，角色会在可行走的区域表面精确行走。但是Height Mesh会在运行时占用更多的CPU和内存，并且烘焙时间也会变长。 右边为勾选了Height Mesh的情况]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支管理策略]]></title>
    <url>%2F2019%2F06%2F06%2FGit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 这句话的说明如下：此时master分支没有做任何代码的改动。切换到master分支合并有代码改动的dev，此时默认使用Fast forward模式，git log不会有合并的信息。 12345678910$ git checkout -b cb_dev （此时在master分支）$ vim 1.txt （此时在cb_dev分支）$ git commit -am 'test'$ git checkout master$ git merge cb_dev$ git log * e429856 test* 121be0f 更新 xiaoxiaole.json* 649f161 更新 README.md* 3d02ba4 更新消消乐web版为手机预览版本 如果再把分支删了，则分支信息一点都没有了 而如果master也有改动，则是会有分支的信息的。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下–no-ff方式的git merge：首先，仍然创建并切换dev分支：$ git checkout -b devSwitched to a new branch ‘dev’ 修改readme.txt文件，并提交一个新的commit：$ git add readme.txt$ git commit -m “add merge”[dev f52c633] add merge 1 file changed, 1 insertion(+) 现在，我们切换回master：$ git checkout masterSwitched to branch ‘master’ 准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：$ git merge –no-ff -m “merge with no-ff” devMerge made by the ‘recursive’ strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。合并后，我们用git log看看分支历史：$ git log –graph（图表） –pretty（pretty）=oneline –abbrev（缩写）-commit e1e9c68 merge with no-ff|\| * f52c633 add merge|/ cf810e4 conflict fixed… 可以看到，不使用Fast forward模式，merge后就像这样： 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。所以，团队合作的分支看起来就像这样：]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git标签管理]]></title>
    <url>%2F2019%2F06%2F06%2FGit%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 ** 快照 ** 关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的映像。快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。快照的作用主要是能够进行在线数据备份与恢复。1、当存储设备发生应用故障或者文件损坏时可以进行快速的数据恢复，将数据恢复某个可用的时间点的状态。2、快照的另一个作用是为存储用户提供了另外一个数据访问通道，当原数据进行在线应用处理时，用户可以访问快照数据，还可以利用快照进行测试等工作。所有存储系统，不论高中低端，只要应用于在线系统，那么快照就成为一个不可或缺的功能。好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。那个存盘就是快照，存储了那个时间点的状态。 标签可以针对某一时间点的版本做标记，常用于版本发布。主要用来发布版本的。 标签就是跟某个commit关联起来，便于发布和查找。 步骤1、切换到某个分支上。 12345$ git branch* dev master$ git checkout masterSwitched to branch 'master' 2、然后，敲命令git tag 就可以打一个新标签：打在了最近的那一次commit上 1$ git tag v1.0 添加标签说明 1$ git tag -a v0.1 -m "version 0.1 released" 如果想打之前的commit，找历史然后再打就行了 12$ git log --pretty=oneline --abbrev-commit$ git tag v0.9 6224937 3、推送到远程 1git push origin &lt;tagname&gt; 命令git push origin –tags可以推送全部未推送过的本地标签； 4、切换到标签与切换分支命令相同，用git checkout [tagname] 5、删除标签先从本地删除： 1$ git tag -d v0.9 然后，从远程删除。删除命令也是push，但是格式如下： 1$ git push origin :refs/tags/v0.9 6、查看标签查看所有标签： 123$ git taggit show &lt;tagname&gt;查看标签信息$ git tag -l 'v1.4.2.*' 没有不同分支下tag这个概念，也就是说tag不是属于某个分支的，而是全局的tag,是对于commit编号的一个别称。 标签是为了打上版本号信息，不能乱叫，通常用：v1.0, v1.1, v2.0 …或者按发布日期：build-20150702, build-20150910 … 一般来说都是在master分支commit后打标签。 TortoiseGit]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git忽略文件权限和设置大小写敏感]]></title>
    <url>%2F2019%2F06%2F05%2FGit%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F%2F</url>
    <content type="text"><![CDATA[在发布项目到线上时，很多时候需要修改文件的权限，如果是使用git来发布的话，那么下次更新线上文件的时候就会提示文件冲突。明明文件没有修改，为什么会冲突呢？原来git把文件权限也算作文件差异的一部分。下面笔者自己做了个简单的例子来演示这种情况。 忽略文件权限修改版本库的文件的权限，然后使用diff查看下改变。 12$ chmod 777 pack.php$ git diff pack.php 可以看到git把文件权限也列入了版本管理。 git中可以加入忽略文件权限的配置，具体如下： 1$ git config core.filemode false 这样就设置了忽略文件权限。查看下配置： 1$ cat .git/config git忽略文件权限的配置这时候再更新代码就OK了。 文件所有者和所有组的修改不列入版本管理。 对文件名大小写敏感当你创建一个文件后,叫 readme.md 写入内容后 提交到线上代码仓库.然后你在本地修改文件名为 Readme.md 接着你去提交,发现代码没有变化.控制台输入git status 也不显示任何信息 那么就配置git 使其对文件名大小写敏感git config core.ignorecase false]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入认识索引]]></title>
    <url>%2F2019%2F06%2F05%2F%E6%B7%B1%E5%85%A5%E8%AE%A4%E8%AF%86%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[深入认识索引 https://mp.weixin.qq.com/s/rHPVEhacTBTJlJ44uJihFw]]></content>
  </entry>
  <entry>
    <title><![CDATA[你到底有多精通C#？]]></title>
    <url>%2F2019%2F06%2F05%2F%E4%BD%A0%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E7%B2%BE%E9%80%9AC-%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[你到底有多精通C#？ https://mp.weixin.qq.com/s/Mkz4wAY0Latf-u4KoE92Hg]]></content>
  </entry>
  <entry>
    <title><![CDATA[性能优化之分页查询]]></title>
    <url>%2F2019%2F06%2F05%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[性能优化之分页查询 https://mp.weixin.qq.com/s/0k7u5XmfL6gar--O1MuBMA]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EXPLAIN命令详解]]></title>
    <url>%2F2019%2F06%2F05%2FEXPLAIN%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.explain是干嘛用的？如何使用？ 有的应用对select语句的性能要求较高，此时单纯依靠开发者的直觉设计select语句，可能能导致“理想”与“现实”出现偏差。可以使用explain命令或desc命令分析select语句的执行计划，从而了解select语句的执行情况，进而分析select语句的性能瓶颈，然后对select语句进行重新设计或者对表结构进行重新设计（例如添加索引或者拆分表），让查询优化器能够更好地工作，提升查询性能。explain的语法格式非常简单（desc语法格式与explain的语法格式相同），如下所示： explain select语句说明 desc命令通常用于获取表结构的相关信息。而explain命令通常用于获取查询的执行计划例如，多个表进行 join 连接运算时，这些表如何连接、连接顺序如何等信息都可以通过explain命令获取。在MySQL 5.7中，使用explain命令还可以获取select、delete、insert、replace以及update等语句的执行计划。然而，一般而言，由于select语句对MySQL的性能影响较大，通常使用explain命令获取select语句的执行计划。explain命令返回了一行或者多行记录，包括了select语句中用到的各个表的信息。例如，查询姓“张”学生的信息，可以使用下面的SQL语句。使用explain对该SQL语句进行分析，如图14-68所示。 1explain select * from student where student_name like '张_'; explain命令的返回信息说明如下。● id：查询的序列号。● select_type：查询语句的类型，可以为以下任何一种。simple：简单查询语句（不使用union或子查询的查询）。primary：主查询语句 union：union中的第二个或后面的select语句。dependent union：相关子查询中的union语句，union中的第二个或后面的select语句。union result：union 的合并结果。subquery：非相关子查询中的第一个select语句。uncacheable subquery：结果集无法缓存的子查询。dependent subquery：相关子查询中的第一个select语句。derived：派生表的select语句。● table：执行该查询时所访问的数据库表。● type：表数据的访问类型。下面给出各种访问类型，按照性能从最佳类型到最坏类型进行排序。system：结果集中仅有一条记录。这是const连接类型的一个特例。const：表中有多条记录，但结果集只包含一条记录。例如比较运算符中含有主键字段或者唯一性约束字段，只查询出表的一条记录。eq_ref：最多只会有一条匹配结果。两个表进行连接运算时，一个表使用主键字段或者唯一性约束字段与另一个表连接，查询出若干条记录。除了const类型，是比较好的连接类型。 ref：两个表进行连接运算时，一个表使用普通索引与另一个表连接，查询出若干条记录。ref_or_null：两个表进行连接运算时，一个表使用普通索引与另一个表连接（这与ref类似），不同之处在于，检索时额外搜索包含null值的记录。index_merge：查询中同时使用两个（或更多）索引，然后对索引结果进行merge之后再读取表数据。在这种情况下，key字段表示使用了哪个索引，key_len字段表示使用索引时关键字的最长长度（字节数）。unique_subquery：使用了子查询，且子查询的返回结果包括主键字段或者唯一性约束字段。index_subquery：使用了子查询，且子查询使用了普通索引（不是主索引或唯一索引）。range：使用索引字段，检索给定范围的记录。在这种情况下，key字段表示使用了哪个索引。key_len字段表示使用索引时关键字的最长长度（字节数）。在该类型中，ref字段值为NULL。index：从第一个关键字开始，对索引进行顺序扫描。即便如此，index通常比ALL快，因为索引文件比数据文件小。all：对表进行全表扫描。说明检索数据时MySQL可能没有使用索引，效率会受到重大影响，应尽可能地优化select语句或者添加索引以避免此类情况的发生。fulltext：全文索引。说明从全表扫描（full table scan）、索引扫描（index scans）、范围扫描(range scans)、唯一索引查找（unique index lookups）到常量（constants）扫描，访问速度依次递增，访问的数据越来越少。● possible_keys：检索数据时可能使用到的索引，这就意味着possible_keys里面所包含的索引可能在 select 语句实际运行过程中根本没有用到。如果这个字段的值是 null，就表示没有索引被用到。这种情况下，可以检查where子句中哪些字段适合增加索引以提高查询的性能。● key：实际使用的索引。当没有任何索引被用到的时候，这个字段的值就是NULL。想让MySQL强行使用或者忽略在possible_keys 字段中的索引列表，可以在select 语句中使用关键字force index，use index或ignore index。● key_len：使用的索引关键字的长度（字节数）。当key字段的值为NULL时，索引的长度就是NULL。● ref：显示了哪些字段或者常量被用来和索引关键字匹配以从表中查询记录。● rows：返回MySQL认为在查询中应该检索的记录数。 extra：显示了查询中MySQL的附加信息。以下是这个字段的几个不同值的解释。distinct：当MySQL找到第一个匹配记录后，就不再搜索其他记录了。not exists：MySQL 能够对查询进行left join 优化，当在当前表中找到一条记录符合left join匹配标准时，就不再搜索更多的记录了。range checked for each record (index map：#)：MySQL 没找到合适的可用的索引，但是发现来自前面表的字段值已知，部分索引可以使用。using filesort：当查询中包含order by子句，而且无法利用索引完成排序操作的时候，MySQL查询优化器不得不选择相应的排序算法，在内存或者硬盘上进行排序。应尽可能地优化select语句或者添加索引以避免此类情况的发生。using index：直接从索引中取得信息，不需要从表中获取数据。这就意味着查询时的字段是索引的关键字。using temporary：MySQL需要创建临时表存储结果集以完成查询。在group by以及order by查询中比较常见。using where：如果查询不是读取表的所有数据，也不是仅仅通过索引就可以获取所有需要的数据，则会出现using where信息。 using sort_union(……), using union(……), using intersect(……)：说明如何为index_merge连接类型合并索引扫描。using index for group-by：类似于访问表的using index 方式，using index for group-by表示在进行group by或distinct查询时，分组字段也在索引中。Full scan on NULL key：子查询中的一种优化方式，主要在遇到无法通过索引访问NULL 值的时候使用。Impossible WHERE noticed after reading const tables：MySQL 查询优化器通过收集到的统计信息判断出不可能存在的结果。No tables：查询语句中使用不包含任何FROM的子句。Select tables optimized away：当使用某些聚合函数来访问某个索引字段的时候，MySQL 查询优化器会通过索引直接一次定位到所需的数据行，完成整个查询。当然，前提是在查询语句中不能有group by操作。使用下面的SQL语句在student表的student_name字段创建两个普通索引，其中name_index1索引仅仅对学生的“姓”创建了索引。然后重新使用explain命令分析两条select语句，如图14-69所示。create index name_index on student(student_name);create index name_index1 on student (student_name(1));explain select * from student where student_name like ‘张％’\Gexplain select * from student use index (name_index1) where student_name like ‘张％’\G 从图中可以分析，第一条select语句执行时使用了name_index索引检索了student表，第二条select语句由于指定使用索引name_index1，执行时使用了name_index1索引检索了student表（注意两个索引的长度key_len的值不相同）。 https://www.cnblogs.com/gomysql/p/3720123.html https://blog.csdn.net/jiadajing267/article/details/81269067 https://blog.csdn.net/wuseyukui/article/details/71512793 explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。 使用方法，在select语句前加上explain就可以了： 如： 1explain select surname,first_name from a,b where a.id=b.id; EXPLAIN列的解释table：显示这一行的数据是关于哪张表的 type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 一般来说，得保证查询至少达到range级别，最好能达到ref。possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句 key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引 key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好 ref：显示索引的哪一列被使用了，如果可能的话，是一个常数 rows：MYSQL认为必须检查的用来返回请求数据的行数 Extra：关于MYSQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢 extra列返回的描述的意义 Distinct:一旦MYSQL找到了与行相联合匹配的行，就不再搜索了 Not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了 Range checked for each Record（index map:#）:没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一 Using filesort: 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行 Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候 Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上 Where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序） system 表只有一行：system表。这是const连接类型的特殊情况 const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待 eq_ref:在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用 ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好 range:这个连接类型使用索引返回一个范围中的行，比如使用&gt;或&lt;查找东西时发生的情况 index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据） ALL:这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免 先看一个例子： mysql&gt; explain select * from t_order;+—-+————-+———+——+—————+——+———+——+——–+——-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+———+——+—————+——+———+——+——–+——-+| 1 | SIMPLE | t_order | ALL | NULL | NULL | NULL | NULL | 100453 | |+—-+————-+———+——+—————+——+———+——+——–+——-+1 row in set (0.03 sec)加上extended后之后： mysql&gt; explain extended select * from t_order;+—-+————-+———+——+—————+——+———+——+——–+———-+——-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+—-+————-+———+——+—————+——+———+——+——–+———-+——-+| 1 | SIMPLE | t_order | ALL | NULL | NULL | NULL | NULL | 100453 | 100.00 | |+—-+————-+———+——+—————+——+———+——+——–+———-+——-+1 row in set, 1 warning (0.00 sec)有必要解释一下这个长长的表格里每一列的含义： id SELECT识别符。这是SELECT的查询序列号select_typeSELECT类型,可以为以下任何一种: SIMPLE:简单SELECT(不使用UNION或子查询)PRIMARY:最外面的SELECTUNION:UNION中的第二个或后面的SELECT语句DEPENDENT UNION:UNION中的第二个或后面的SELECT语句,取决于外面的查询UNION RESULT:UNION 的结果SUBQUERY:子查询中的第一个SELECTDEPENDENT SUBQUERY:子查询中的第一个SELECT,取决于外面的查询DERIVED:导出表的SELECT(FROM子句的子查询)table输出的行所引用的表 type联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序: system:表仅有一行(=系统表)。这是const联接类型的一个特例。const:表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!eq_ref:对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。ref:对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。ref_or_null:该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。index_merge:该联接类型表示使用了索引合并优化方法。unique_subquery:该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。index_subquery:该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)range:只检索给定范围的行,使用一个索引来选择行。index:该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。ALL:对于每个来自于先前的表的行组合,进行完整的表扫描。possible_keys指出MySQL能使用哪个索引在该表中找到行 key 显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。key_len 显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。ref 显示使用哪个列或常数与key一起从表中选择行。rows 显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。filtered 显示了通过条件过滤出的行数的百分比估计值。Extra该列包含MySQL解决查询的详细信息 Distinct:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。Not exists:MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。range checked for each record (index map: #):MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。Using filesort:MySQL需要额外的一次传递,以找出如何按排序顺序检索行。Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。Using temporary:为了解决查询,MySQL需要创建一个临时表来容纳结果。Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。Using sort_union(…), Using union(…), Using intersect(…):这些函数说明如何为index_merge联接类型合并索引扫描。Using index for group-by:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。 一.select_type的说明 1.UNION: 当通过union来连接多个查询结果时，第二个之后的select其select_type为UNION。 mysql&gt; explain select * from t_order where order_id=100 union select * from t_order where order_id=200;+—-+————–+————+——-+—————+———+———+——-+——+——-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————–+————+——-+—————+———+———+——-+——+——-+| 1 | PRIMARY | t_order | const | PRIMARY | PRIMARY | 4 | const | 1 | || 2 | UNION | t_order | const | PRIMARY | PRIMARY | 4 | const | 1 | || NULL | UNION RESULT | &lt;union1,2&gt; | ALL | NULL | NULL | NULL | NULL | NULL | |+—-+————–+————+——-+—————+———+———+——-+——+——-+3 rows in set (0.34 sec)2.DEPENDENT UNION与DEPENDENT SUBQUERY: 当union作为子查询时，其中第二个union的select_type就是DEPENDENT UNION。第一个子查询的select_type则是DEPENDENT SUBQUERY。 mysql&gt; explain select * from t_order where order_id in (select order_id from t_order where order_id=100 union select order_id from t_order where order_id=200);+—-+——————–+————+——-+—————+———+———+——-+——–+————-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+——————–+————+——-+—————+———+———+——-+——–+————-+| 1 | PRIMARY | t_order | ALL | NULL | NULL | NULL | NULL | 100453 | Using where || 2 | DEPENDENT SUBQUERY | t_order | const | PRIMARY | PRIMARY | 4 | const | 1 | Using index || 3 | DEPENDENT UNION | t_order | const | PRIMARY | PRIMARY | 4 | const | 1 | Using index || NULL | UNION RESULT | &lt;union2,3&gt; | ALL | NULL | NULL | NULL | NULL | NULL | |+—-+——————–+————+——-+—————+———+———+——-+——–+————-+4 rows in set (0.03 sec)3.SUBQUERY: 子查询中的第一个select其select_type为SUBQUERY。 mysql&gt; explain select * from t_order where order_id=(select order_id from t_order where order_id=100);+—-+————-+———+——-+—————+———+———+——-+——+————-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+———+——-+—————+———+———+——-+——+————-+| 1 | PRIMARY | t_order | const | PRIMARY | PRIMARY | 4 | const | 1 | || 2 | SUBQUERY | t_order | const | PRIMARY | PRIMARY | 4 | | 1 | Using index |+—-+————-+———+——-+—————+———+———+——-+——+————-+2 rows in set (0.03 sec)4.DERIVED: 当子查询是from子句时，其select_type为DERIVED。 mysql&gt; explain select * from (select order_id from t_order where order_id=100) a;+—-+————-+————+——–+—————+———+———+——+——+————-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+————+——–+—————+———+———+——+——+————-+| 1 | PRIMARY | | system | NULL | NULL | NULL | NULL | 1 | || 2 | DERIVED | t_order | const | PRIMARY | PRIMARY | 4 | | 1 | Using index |+—-+————-+————+——–+—————+———+———+——+——+————-+2 rows in set (0.03 sec)二.type的说明 1.system，const 见上面4.DERIVED的例子。其中第一行的type就是为system，第二行是const，这两种联接类型是最快的。 2.eq_ref 在t_order表中的order_id是主键，t_order_ext表中的order_id也是主键，该表可以认为是订单表的补充信息表，他们的关系是1对1，在下面的例子中可以看到b表的连接类型是eq_ref，这是极快的联接类型。 mysql&gt; explain select * from t_order a,t_order_ext b where a.order_id=b.order_id;+—-+————-+——-+——–+—————+———+———+—————–+——+————-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+——-+——–+—————+———+———+—————–+——+————-+| 1 | SIMPLE | b | ALL | order_id | NULL | NULL | NULL | 1 | || 1 | SIMPLE | a | eq_ref | PRIMARY | PRIMARY | 4 | test.b.order_id | 1 | Using where |+—-+————-+——-+——–+—————+———+———+—————–+——+————-+2 rows in set (0.00 sec)3.ref 下面的例子在上面的例子上略作了修改，加上了条件。此时b表的联接类型变成了ref。因为所有与a表中order_id=100的匹配记录都将会从b表获取。这是比较常见的联接类型。 mysql&gt; explain select * from t_order a,t_order_ext b where a.order_id=b.order_id and a.order_id=100;+—-+————-+——-+——-+—————+———-+———+——-+——+——-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+——-+——-+—————+———-+———+——-+——+——-+| 1 | SIMPLE | a | const | PRIMARY | PRIMARY | 4 | const | 1 | || 1 | SIMPLE | b | ref | order_id | order_id | 4 | const | 1 | |+—-+————-+——-+——-+—————+———-+———+——-+——+——-+2 rows in set (0.00 sec)4.ref_or_null user_id字段是一个可以为空的字段，并对该字段创建了一个索引。在下面的查询中可以看到联接类型为ref_or_null，这是mysql为含有null的字段专门做的处理。在我们的表设计中应当尽量避免索引字段为NULL，因为这会额外的耗费mysql的处理时间来做优化。 mysql&gt; explain select * from t_order where user_id=100 or user_id is null;+—-+————-+———+————-+—————+———+———+——-+——-+————-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+———+————-+—————+———+———+——-+——-+————-+| 1 | SIMPLE | t_order | ref_or_null | user_id | user_id | 5 | const | 50325 | Using where |+—-+————-+———+————-+—————+———+———+——-+——-+————-+1 row in set (0.00 sec)5.index_merge 经常出现在使用一张表中的多个索引时。mysql会将多个索引合并在一起，如下例: mysql&gt; explain select * from t_order where order_id=100 or user_id=10;+—-+————-+———+————-+—————–+—————–+———+——+——+——————————————-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+———+————-+—————–+—————–+———+——+——+——————————————-+| 1 | SIMPLE | t_order | index_merge | PRIMARY,user_id | PRIMARY,user_id | 4,5 | NULL | 2 | Using union(PRIMARY,user_id); Using where |+—-+————-+———+————-+—————–+—————–+———+——+——+——————————————-+1 row in set (0.09 sec)6.unique_subquery 该联接类型用于替换value IN (SELECT primary_key FROM single_table WHERE some_expr)这样的子查询的ref。注意ref列，其中第二行显示的是func，表明unique_subquery是一个函数，而不是一个普通的ref。 mysql&gt; explain select * from t_order where order_id in (select order_id from t_order where user_id=10);+—-+——————–+———+—————–+—————–+———+———+——+——–+————-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+——————–+———+—————–+—————–+———+———+——+——–+————-+| 1 | PRIMARY | t_order | ALL | NULL | NULL | NULL | NULL | 100649 | Using where || 2 | DEPENDENT SUBQUERY | t_order | unique_subquery | PRIMARY,user_id | PRIMARY | 4 | func | 1 | Using where |+—-+——————–+———+—————–+—————–+———+———+——+——–+————-+2 rows in set (0.00 sec)7.index_subquery 该联接类型与上面的太像了，唯一的差别就是子查询查的不是主键而是非唯一索引。 mysql&gt; explain select * from t_order where user_id in (select user_id from t_order where order_id&gt;10);+—-+——————–+———+—————-+—————–+———+———+——+——–+————————–+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+——————–+———+—————-+—————–+———+———+——+——–+————————–+| 1 | PRIMARY | t_order | ALL | NULL | NULL | NULL | NULL | 100649 | Using where || 2 | DEPENDENT SUBQUERY | t_order | index_subquery | PRIMARY,user_id | user_id | 5 | func | 50324 | Using index; Using where |+—-+——————–+———+—————-+—————–+———+———+——+——–+————————–+2 rows in set (0.00 sec)8.range 按指定的范围进行检索，很常见。 mysql&gt; explain select * from t_order where user_id in (100,200,300);+—-+————-+———+——-+—————+———+———+——+——+————-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+———+——-+—————+———+———+——+——+————-+| 1 | SIMPLE | t_order | range | user_id | user_id | 5 | NULL | 3 | Using where |+—-+————-+———+——-+—————+———+———+——+——+————-+1 row in set (0.00 sec)9.index 在进行统计时非常常见，此联接类型实际上会扫描索引树，仅比ALL快些。 12345678mysql&gt; explain select count(*) from t_order; +----+-------------+---------+-------+---------------+---------+---------+------+--------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+---------+-------+---------------+---------+---------+------+--------+-------------+ | 1 | SIMPLE | t_order | index | NULL | user_id | 5 | NULL | 100649 | Using index | +----+-------------+---------+-------+---------------+---------+---------+------+--------+-------------+ 1 row in set (0.00 sec) 10.ALL 完整的扫描全表，最慢的联接类型，尽可能的避免。 mysql&gt; explain select * from t_order;+—-+————-+———+——+—————+——+———+——+——–+——-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+———+——+—————+——+———+——+——–+——-+| 1 | SIMPLE | t_order | ALL | NULL | NULL | NULL | NULL | 100649 | |+—-+————-+———+——+—————+——+———+——+——–+——-+1 row in set (0.00 sec)三.extra的说明 1.Distinct MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。对于此项没有找到合适的例子，求指点。 2.Not exists 因为b表中的order_id是主键，不可能为NULL，所以mysql在用a表的order_id扫描t_order表，并查找b表的行时，如果在b表发现一个匹配的行就不再继续扫描b了，因为b表中的order_id字段不可能为NULL。这样避免了对b表的多次扫描。 mysql&gt; explain select count(1) from t_order a left join t_order_ext b on a.order_id=b.order_id where b.order_id is null;+—-+————-+——-+——-+—————+————–+———+—————–+——–+————————————–+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+——-+——-+—————+————–+———+—————–+——–+————————————–+| 1 | SIMPLE | a | index | NULL | express_type | 1 | NULL | 100395 | Using index || 1 | SIMPLE | b | ref | order_id | order_id | 4 | test.a.order_id | 1 | Using where; Using index; Not exists |+—-+————-+——-+——-+—————+————–+———+—————–+——–+————————————–+2 rows in set (0.01 sec)3.Range checked for each record 这种情况是mysql没有发现好的索引可用，速度比没有索引要快得多。 mysql&gt; explain select * from t_order t, t_order_ext s where s.order_id&gt;=t.order_id and s.order_id&lt;=t.order_id and t.express_type&gt;5;+—-+————-+——-+——-+———————-+————–+———+——+——+————————————————+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+——-+——-+———————-+————–+———+——+——+————————————————+| 1 | SIMPLE | t | range | PRIMARY,express_type | express_type | 1 | NULL | 1 | Using where || 1 | SIMPLE | s | ALL | order_id | NULL | NULL | NULL | 1 | Range checked for each record (index map: 0x1) |+—-+————-+——-+——-+———————-+————–+———+——+——+————————————————+2 rows in set (0.00 sec)4.Using filesort 在有排序子句的情况下很常见的一种情况。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行。 mysql&gt; explain select * from t_order order by express_type;+—-+————-+———+——+—————+——+———+——+——–+—————-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+———+——+—————+——+———+——+——–+—————-+| 1 | SIMPLE | t_order | ALL | NULL | NULL | NULL | NULL | 100395 | Using filesort |+—-+————-+———+——+—————+——+———+——+——–+—————-+1 row in set (0.00 sec)5.Using index 这是性能很高的一种情况。当查询所需的数据可以直接从索引树中检索到时，就会出现。上面的例子中有很多这样的例子，不再多举例了。 6.Using temporary 发生这种情况一般都是需要进行优化的。mysql需要创建一张临时表用来处理此类查询。 mysql&gt; explain select * from t_order a left join t_order_ext b on a.order_id=b.order_id group by b.order_id;+—-+————-+——-+——+—————+———-+———+—————–+——–+———————————+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+——-+——+—————+———-+———+—————–+——–+———————————+| 1 | SIMPLE | a | ALL | NULL | NULL | NULL | NULL | 100395 | Using temporary; Using filesort || 1 | SIMPLE | b | ref | order_id | order_id | 4 | test.a.order_id | 1 | |+—-+————-+——-+——+—————+———-+———+—————–+——–+———————————+2 rows in set (0.00 sec)7.Using where 当有where子句时，extra都会有说明。 8.Using sort_union(…)/Using union(…)/Using intersect(…) 下面的例子中user_id是一个检索范围，此时mysql会使用sort_union函数来进行索引的合并。而当user_id是一个固定值时，请参看上面type说明5.index_merge的例子，此时会使用union函数进行索引合并。 mysql&gt; explain select * from t_order where order_id=100 or user_id&gt;10;+—-+————-+———+————-+—————–+—————–+———+——+——+————————————————+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+———+————-+—————–+—————–+———+——+——+————————————————+| 1 | SIMPLE | t_order | index_merge | PRIMARY,user_id | user_id,PRIMARY | 5,4 | NULL | 2 | Using sort_union(user_id,PRIMARY); Using where |+—-+————-+———+————-+—————–+—————–+———+——+——+————————————————+1 row in set (0.00 sec)对于Using intersect的例子可以参看下例，user_id与express_type发生了索引交叉合并。 mysql&gt; explain select * from t_order where express_type=1 and user_id=100;+—-+————-+———+————-+———————-+———————-+———+——+——+—————————————————-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+———+————-+———————-+———————-+———+——+——+—————————————————-+| 1 | SIMPLE | t_order | index_merge | user_id,express_type | user_id,express_type | 5,1 | NULL | 1 | Using intersect(user_id,express_type); Using where |+—-+————-+———+————-+———————-+———————-+———+——+——+—————————————————-+1 row in set (0.00 sec)9.Using index for group-by 表明可以在索引中找到分组所需的所有数据，不需要查询实际的表。 mysql&gt; explain select user_id from t_order group by user_id;+—-+————-+———+——-+—————+———+———+——+——+————————–+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+———+——-+—————+———+———+——+——+————————–+| 1 | SIMPLE | t_order | range | NULL | user_id | 5 | NULL | 3 | Using index for group-by |+—-+————-+———+——-+—————+———+———+——+——+————————–+1 row in set (0.00 sec)除了上面的三个说明，还需要注意rows的数值，多行之间的数值是乘积的关系，可以估算大概要处理的行数，如果乘积很大，那就很有优化的必要了。 用SQL命令查看Mysql数据库大小要想知道每个数据库的大小的话，步骤如下： 1、进入information_schema 数据库（存放了其他的数据库的信息） use information_schema; 2、查询所有数据的大小： select concat(round(sum(data_length/1024/1024),2),’MB’) as data from tables; 3、查看指定数据库的大小： 比如查看数据库home的大小 select concat(round(sum(data_length/1024/1024),2),’MB’) as data from tables where table_schema=’home’; 4、查看指定数据库的某个表的大小 比如查看数据库home中 members 表的大小 select concat(round(sum(data_length/1024/1024),2),’MB’) as data from tables where table_schema=’home’ and table_name=’members’;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自律者出众，不自律者出局]]></title>
    <url>%2F2019%2F06%2F02%2F%E8%87%AA%E5%BE%8B%E8%80%85%E5%87%BA%E4%BC%97%EF%BC%8C%E4%B8%8D%E8%87%AA%E5%BE%8B%E8%80%85%E5%87%BA%E5%B1%80%2F</url>
    <content type="text"><![CDATA[来源：自律者出众，不自律者出局 古今成大事业者，不仅要有旷世之才，更要有坚韧不拔的意志。 那些青史留名的成功人士，绝大多数都是高度自律的人。 被誉为“古今第一完人”的曾国藩，更是把自律做到了极致。 自律改变人生只有自律的人才能掌控自己的生活。 生活对每个人都是公平的，自律之人必然出众，不自律，就注定会被淘汰出局。 一个连自己都管不住的人，凭什么要求生活优待你？ 年轻时的曾国藩，也曾与千千万万个平凡的青年人一样，既没有定力，又没有能力。 不仅如此，他身上还有许许多多顽固的陋习：贪色、妄语、懒惰。 怎么看都是个资质平庸的普通人，注定成不了大器。 为了改正贪色，他下定决心记日记。他在日记中反省一天当中的过失，以此来警醒自己。 这日记一记便是几十年，与他寄给亲人的家书一道，形成了内容丰富的《曾国藩家训》，成为世人信奉的行为准则。 为了改正妄语，他听从别人的建议，每天静坐一小时，修身养性。这样的打坐，他雷打不动地坚持了一辈子。 硬生生把自己尖锐毛躁的性子打磨得处变不惊。 为了改正懒惰，他数十年如一日坚持读书。曾国藩一生无一日不读书，就算晚年读瞎一只眼，依然不曾间断。 曾国藩正是凭借极致的自律，最终实现了人生逆袭。 从天赋平常的笨小孩，变成了世人眼中的“完人”。 可见一个人只要能够做到自律，就已经走上了正确的人生轨道。 而那些放纵自我的人，就只能在生活的泥沼中苦苦挣扎。 生活就像是一场马拉松，大多数人不是倒在终点线前，而是半途而废，走到中途就已经停下了脚步。 高喊着口号说要自律的人很多，但是真正能够做到自律的人却很少。 人与人之间的差距，就是这样一点一点拉开的。 越自律，越自由王小波说：人的一切痛苦，本质上都是对自己无能的愤怒。 自律，是解决人生问题的必要条件，也是消除人生痛苦的重要手段。 只有当你尝试做到自律，在恰当的时间地点，做好自己该做的事，既不拖延，也不懈怠，你的生活才能真正受你支配。 这样来看，只有自律的人，才能获得真正的自由。 就象生活中，我们行车走路都要遵守交通规则。 人人都很自觉，道路就会畅通，行车也更自由。 人人都不自觉，道路就会拥堵，个人安全利益也都得不到保障。 放弃自律，放纵自我的人，得到的只是暂时的自由，最终将会付出惨痛的代价，损人不利己。 人生是马，自律是缰。信马由缰，必将偏离轨道，甚至会有粉身碎骨的风险。 人生是舟，自律是水。以水推舟，方能自在扬帆，驶向自己人生价值的彼岸。 越自律，越幸福。 饮食上自律，身体好；运动上自律，身材好；时间上自律，精神好；脾气上自律，人缘好。 愿我们每个人都能做到自律，修炼成理想的自我，享受着向往的生活。]]></content>
      <categories>
        <category>运动</category>
      </categories>
      <tags>
        <tag>早起</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子状态机/Animator Override Controller/State Machine Behaviour]]></title>
    <url>%2F2019%2F05%2F31%2F%E5%AD%90%E7%8A%B6%E6%80%81%E6%9C%BA-Animator-Override-Controller-State-Machine-Behaviour%2F</url>
    <content type="text"><![CDATA[今日思考题用今天新学的内容把你的状态机好好整理整理 除了使用Layer还有没有更好的组织状态的方式呢？一个Layer里面状态多的时候，会显得很乱 还可以使用Sub-State Machines，也就是子状态机，可以将一些状态放到子状态机里。 Sub-State Machines 子状态机很多时候，角色的一个行动由多个动作组成。比起使用一个动画完成这个行为，可能定义几个不同的阶段，并且给每个阶段使用一个单独的State会更合理。比如一个“稳定射击”的动作，包含蹲下、射击、站起的动作。 这样分拆的动画更利于控制，但是带来的负面影响是状态机会变得庞大、复杂、难以管理。这时候，可以使用状态机提供的子状态机的功能，将这些状态整合到一个子状态中。 创建子状态机在Animator窗口的空白处右键，在弹出菜单中选择Create Sub-State Machine。 子状态机会显示为一个细长的六边形用来和正常的state区分。 编辑子状态机双击这个子状态机可以打开它，界面会显示这个子状态机内的内容（初始会是一个空的状态机）。窗口的上方会有一个面包屑路径显示当前编辑的是哪个子状态机（子状态机内也可以再创建子状态机），点击对应的面包屑路径可以直接打开对应的位置。 子状态机内的State编辑和之前的State编辑相同。 子状态机的Transition子状态机只是从视觉上将一些状态折叠到一个子状态机中，所以如果想转换到sub-state machine时，需要选择具体转换到哪一个状态或整个状态机。 创建Transition时需要选择 选择状态时，Transition会直接转换到对应的状态。选择状态机时，相当于将Transition转换到对应状态机的Entry状态。 子状态机中有一个额外的状态名字为（Up）XXX。 这个状态代表上一层的状态机。你可以在子状态机中创建Transition转换到上一层状态机中的某个状态。 选择状态时，Transition会直接转换到对应的状态。选择状态机时，相当于将Transition转换到对应状态机的Entry状态。 Animator Override Controller可以让你在保留Animator Controller中的结构和逻辑的同时，覆盖里面的一些动画，比如你有多个角色的状态机结构逻辑都相同，但是动画不同，这时候就可以用Animator Override Controller。State Machine Behaviour是一种用脚本的形式，可以挂在State上面，会有一些回调用来处理State不同状态。 Animator Override ControllerAnimator Override Controller是Project中的一种资产，可以用来扩展已有的Animator Controller，替换Animator Controller中的动画，但是保留原Animator Controller中的结构、参数和逻辑。 例如：游戏中有很多类型的NPC（哥布林、兽人、精灵等），状态机逻辑相同，但是每种NPC有自己独特的动画。这时候你只需要创建一个基础的Animator Controller，结合使用Animator Override Controller可以创建出很多不同的变体。 创建Animator Override Controller在Project中的Create菜单中，选择Animator Override Controller。 左边是Override Controller的图标，右边是Animator Controller的图标 Animator Override Controller和Animator Controller的图标很相近，除了左下角一个是加号，一个是播放的标志。 编辑Animator Override Controller给Controller赋值 首先需要给Animator Override Controller一个基于的Animator Controller。赋值完成后，下面会显示状态机中所有的动画，这时候你可以用新的动画来覆盖原来状态机对应状态的动画。 最后Override Controller可以用于Animator组件的Controller。 注意：Avatar可能需要替换为对应模型的Avatar。 State Machine BehaviourState Machine Behaviour是一种特殊的脚本。和通用的Unity脚本（MonoBehaviours）挂到GameObject上面类似，StateMachineBehaviour可以挂到Animator Controller的State上面。可以在StateMachineBehaviour脚本中编写代码，在状态进入、离开、停留在特定的state时执行。你就不需要自己去检测状态的变化。 可能用于的场景举例： 进入、离开状态时播放音效 只在特定的状态中执行一些代码 只在特定的状态中激活特效 创建StateMachineBehaviour选中一个State，点击Inspector中的Add Behaviour按钮可以选择已有的StateMachineBehaviour或创建一个新的StateMachineBehaviour。 StateMachineBehaviour中的事件StateMachineBehaviour中有一些预定义的事件方法：OnStateMachineEnter 转换到一个StateMachine时调用。注意转换到子状态机中的状态时不会调用。OnStateMachineExit 离开StateMachine时调用。注意转换到子状态机中的状态时不会调用。OnStateEnter 进入当前State时调用OnStateExit 离开当前State时调用OnStateUpdate 处于当前状态时，每次Update都会调用（不包括Enter和Exit的两帧）OnStateMove 在MonoBehaviour.OnAnimatorMove之后调用OnStateIK 在MonoBehaviour.OnAnimatorIK之后调用 总结]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Target Matching/动画重定向]]></title>
    <url>%2F2019%2F05%2F31%2FTarget-Matching-%E5%8A%A8%E7%94%BB%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[今日思考题 用Target Matching把跳跃的动画好好调一调 绝地求生里面人物可以双手撑墙跳过一个堵墙或者窗户，想让角色的双手能恰好放到墙上，这个应该怎么做呢？ Target Matching（目标点匹配）可以使用Target Matching技术。在游戏中，经常有这种情况：角色的手或者脚需要在特定时间放在特定的位置。比如角色需要用手撑着跳过一个石头或一堵墙，或者跳起抓住房梁。Target Match就是让动画的特定片段去匹配特定的位置。 API：Animator.MatchTarget Animator.MatchTarget的方法原型为： 1public void MatchTarget(Vector3 matchPosition, Quaternion matchRotation, AvatarTarget targetBodyPart, MatchTargetWeightMask weightMask, float startNormalizedTime, float targetNormalizedTime = 1); 这个方法用来自动调节GameObject的位置和旋转。 参数的作用：matchPosition 匹配的位置matchRotation 匹配的旋转targetBodyPart 身体的部位，从AvatarTarget枚举中选择。weightMask 设置位置和旋转匹配的权重startNormalizedTime 开始匹配的时间，注意是单位化时间（动画开始位置是0，结束位置是1）。如果开始时间已经超过了当前动画的播放时间，会匹配下一次符合的时间。比如：startNormalizedTime传入0.2，但是当前已经播放到0.3，会匹配下一次循环的0.2的位置。targetNormalizedTime 最终匹配到的单位化时间。如果值大于1，可以设置特定循环数后的位置。比如2.3代表第2次循环的30%位置。 Unity会自动调整GameObject的位置和旋转来保证到特定时间时角色的特定部位能达到指定的位置和旋转。Target matching只能对Base Layer（index 0）生效。同一时间只能有一个match target生效，后续一个的match target需要等待前面的执行完成，再后续的match target会被忽略。 参数详解首先前两个参数是匹配的位置和旋转，比如要匹配墙上，那就是墙上的位置，旋转就是让手的角度贴合墙，应该可以用调IK的方式来调。 targetBodyPart的类型是一个枚举，可以用来匹配对应的位置，比如说匹配左手，那就应该传入左手。weightMask是一个结构体，可以同时设置位置和旋转的权重，这个权重的概念我们已经接触很多次了，如果为1就是完全匹配到对应的位置和旋转。 最后两个参数是开始匹配和完全匹配上的时间。比如想在特定的时间匹配到对应的位置，那么肯定不能到那个时间点一下子把动画拉过去，那样太突兀了。动画中很多的混合都是为了让动画看起来更平滑，更自然。所以除了这个匹配到的特定时间，也就是targetNormalizedTime，还需要一个开始匹配的时间startNormalizedTime。开始时间到了就开始去进行匹配混合，到targetNormalizedTime时正好精确的到达匹配的位置。 注意 Target Matching只能对Base Layer生效 动画重定向动画重定向，也就是Retargeting，比如将角色A的动画应用到没有动画的角色B上面，实现动画的重用。 要想重用动画不一定要用到Retargeting系统。如果两个角色的骨骼结构一样，那么动画其实是可以直接重用的。 那为啥还要这个Retargeting系统呢？ 虽说两个角色的骨骼结构一样，动画是可以直接重用。但是要求很严格，包括骨骼的命名、骨骼的数量、骨骼的父子结构等等要求一模一样。这种情形一般只会出现在同一个动画师手里。如果骨骼稍微有些差别，那就没办法直接重用了。 这时候就需要用到Retargeting系统了，但是需要注意的是Retargeting系统只能用于人形动画。重定向相当于将不同的骨骼结构都映射到了Unity的Avatar上面。之前我们配置过AvatarMask，和那个有点像。配置的位置就是在模型导入设置的Rig标签里 配置Avatar的入口 点击Configure可以进入配置界面，Unity会自动创建一个新场景用于Avatar的配置。 Avatar配置界面 在Mapping页面下，可以将模型的骨骼节点映射到Unity的Avatar上面对应的骨骼节点。在Musule &amp; Settings页面下可以设置每个骨骼节点可以旋转的范围，避免出现不合常理的骨骼旋转。 Retargeting系统就相当于将模型A和模型B的骨骼都映射到了一个Unity Avatar上面，这样最终都是用这个同一个Avatar来控制动画，达到重用的目的。 相当于用了一个中间件，将两个不同的东西匹配了起来。 在设置模型的Rig的时候，需要注意的是，Avatar Definition除了Create From This Model这个选项之外，还有一个选项是Copy From Other Avatar，如果两个模型的骨骼结构是一致的，可以直接使用这个Copy From Other Avatar将Avatar复制过来，就不需要再重新设置一遍了，也能节省内存。 总结这两个东西里面虽然都有Target，但是其实是两个不同的东西。Target Matching用来匹配动画到特定的位置，Retargeting系统是用来重用动画，让骨骼结构不同的动画可以复用。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D数学之坐标系]]></title>
    <url>%2F2019%2F05%2F28%2F3D%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9D%90%E6%A0%87%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.为什么要使用多坐标系？2.有哪几种坐标系？ 如果你无法阅读英文，会少很多的学习资料，很多新的技术文章和视频，包括官方的教程都是英文的。数学可能在初期用的不太多，但是很多问题，包括shader学习时需要数学知识，这些你慢慢就能体会到，所以一定要把数学的基础打好。 想把Unity学好其实不是真正的只学Unity怎么用，项目大了以后非常考验编程能力，再往深处挖掘就非常考验数学和英语的基础了。 多坐标系只要选定原点和坐标就就能在任何地方建立坐标系。但我们不能轻易做出这样的选择，而是要考虑某些具体的条件，在不同场合下可能会使用不同坐标系。 为什么要使用多坐标系？因为在不同的情况下使用不同的坐标系更加的方便。某些信息只有在特定的上下文环境中获得。 世界坐标系世界坐标系是一个特殊的坐标系，它建立了描述其他坐标系所需要的参考框架。从另一方面说，能够用世界坐标系描述其他坐标系的位置，而不能用更大的、外部的坐标系来描述世界坐标系。 关于世界坐标系的典型问题都是关于初始位置和环境的，如： 每个物体的位置和方向。 摄像机的位置和方向。 世界中每一点的地形是什么（如山丘、建筑、湖泊等）。 各物体从哪里来、到哪里去（NPC的运动策略）。 物体坐标系物体坐标系是和特定物体相关联的坐标系。每个物体都有它们独立的坐标系。 当物体移动或改变方向时，和该物体相关联的坐标系将随之移动或改变方向。例如，我们每个人都带着自己的坐标系。如果我告诉你“向前走一步”，是在向你的物体坐标系发指令（请原谅把你比作物体?）。我们并不知道你会向哪个绝对方向移动，一些人会向北，一些人向南，另外一些人向其他方。“前”、“后”、“左”、“右”这样的概念只在物体坐标系中才有意义。当某人告诉你行驶方向时，有时候他会说“向左转”而有时候会说“向东”，“向左转”是物体坐标系中的概念，“向东”则是世界坐标系中的。 物体坐标系中也能像指定方向一样指定位置。例如，我问你车上的消声器安装在哪儿，即使你住在北京，您也不能告诉我“在北京”。我问的是“在你的车里”，它在哪儿？换句话讲，我想让你告诉我消音器在汽车中的位置。 某些情况下，物体坐标系也被称作模型坐标系。因为模型顶点的坐标都是在模型坐标系中描述的。 在物体坐标系中可能会遇到的问题，如： 周围有需要互相作用的物体吗？（我要攻击它吗？） 哪个方向？在我前面吗？我左边一点？右边？（我应该向它射击还是转身就跑？） 摄像机坐标系摄像机坐标系是和观察者密切相关的坐标系。摄像机坐标系和屏幕坐标系相似，差别在于摄像机坐标系处于3D空间中而屏幕坐标系在2D平面里。摄像机坐标系能被看作是一种特殊的“物体”坐标系，该“物体”坐标系就定义在摄像机的屏幕可视区域。 摄像机坐标系中，摄像机在原点，x轴向右，z轴向前（朝向屏幕内或摄像机方向），y轴向上（不是世界的上方而是摄像机本身的上方）。 相机坐标系注意，一些书中的摄像机坐标系关于轴向的约定约定可能不同，许多图形学书中习惯使用右手华标系，z轴向外。 关于屏幕坐标系的典型问题是哪些物体应该在屏幕上绘制出来。如： 3D空间中的给定点在摄像机前方吗？ 3D空间中的给定点是在屏幕上，还是超出了摄像机平截锥体的左、右、上、下边界？（平截锥体就是摄像机能观察到的金字塔区域） 某个物体是否在屏幕上？它的部分在，或全部不在？ 两个物体，谁在前面？（该问题称作可见性检测） 要绘制任何物体，这些问题都是很关键的。 惯性坐标系为了简化世界坐标系到物体坐标系的转换，人们引入了一种新的坐标系，称作惯性坐标系，意思是在世界坐标系到物体坐标系的“半途”。 惯性坐标系的原点和物体坐标系的原点重合，但惯性坐标系的轴平行于世界坐标系的轴。 这里我们选择机器人的脚而不是机器人的中心作为机器人坐标系的原点 这里我们选择机器人的脚而不是机器人的中心作为机器人坐标系的原点 为什么要引入惯性坐标系呢？因为从物体坐标系转换到惯性坐标系只需旋转，从惯性坐标系转换到世界坐标系只需要平移。分开考虑着两件事比把它们合在一起容易得多。 总结坐标系是3D数学的基础，Unity中会经常涉及各个坐标系以及坐标系之间的转换。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模型导入设置]]></title>
    <url>%2F2019%2F05%2F28%2F%E6%A8%A1%E5%9E%8B%E5%AF%BC%E5%85%A5%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.动手改一下模型导入设置中的参数，看看有什么效果。2.模型的四个tab都有什么作用？为什么会有这四种设置？ 模型导入设置 模型导入设置 在Project窗口中选中一个模型文件后，Inspector窗口中会显示对应的导入设置。 模型导入设置中有4个Tab： 模型Tab Unity会从模型文件导入Mesh网格数据。这个Tab主要设置网格数据导入的一些设置。 骨架Tab 动画Tab 材质Tab 模型中的材质和纹理也是非常重要的信息，材质Tab中可以提取材质和纹理，调整材质的映射关系。 Model选项卡选中模型时，模型文件的导入设置会显示在Inspector窗口的Model选项卡中。这些设置影响网格及其法线。通常情况下，保留默认设置即可。 Meshes 网格 Material选项卡使用该选项卡中的属性更改Unity在导入模型时如何处理材质和纹理。 当Unity导入没有材质的模型时，会使用Unity漫反射材质。如果模型具有材质，则Unity将它们作为子资源导入。你可以使用Extract Textures按钮将嵌入纹理提取到项目中。 Import Materials 是否导入材质，如果不勾选，则会使用Unity内置的Default-Diffuse材质。 Location 如何获取材质和纹理 Use Embedded Materials：将材质球保留在模型文件中，这是Unity 2017.2及更高版本的默认选项。 Use External Materials (Legacy)：将材质球作为子资源导出。使用此选项后，会在模型文件的同级目录中生成一个Materials文件夹，材质球会被导出到该文件夹中。这是处理材质的旧方式，2017.1和之前的Unity版本会是此种方式。 使用嵌入材质在Location属性中选中Use Embedded Materials后，会显示下方的内容。 ** 小提示 **很多同学在更新了版本之后，发现材质球是灰色的无法修改，这就是因为Unity现在默认会使用嵌入材质。如果需要修改材质，需要将材质导出。 使用外部材质（旧）使用此选项时，会出现下面的选项。和上面使用嵌入材质中的On Demand Remap选项中的内容一致。 使用此选项时，Unity会自动将模型文件中嵌入的贴图导出到同级的.fbm文件夹中。对于材质，Unity会先搜索是否已经存在对应的材质，如果没有，会将材质导出到同级的Materials文件夹中。 Unity2017.2及之前的版本会默认使用此方法来处理材质。 总结模型导入的参数较多，一般使用默认的参数即可。 遇到材质球不能修改的情况，记得将模型中的嵌入材质导出。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模型导入流程]]></title>
    <url>%2F2019%2F05%2F28%2F%E6%A8%A1%E5%9E%8B%E5%AF%BC%E5%85%A5%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.模型包含哪两种信息？两种信息的含义是什么？2.什么是交换格式？有哪些？什么原生格式？有哪些？区别是什么？3.模型导入最佳实践是什么？4.贴图导入有哪两种方式？Embed Media是什么意思？5.贴图搜索规则是什么样的？ 3D场景是由各种模型组合而成的，这些模型通常使用3D建模软件进行制作。模型制作完成后，需要导入到引擎中使用。 一个模型中包含Mesh网格信息和材质信息。网格信息定义了模型的大小、形状，材质决定了模型的外观是什么颜色、有什么图案。Mesh信息可以类比成一个人的高矮胖瘦的形状轮廓，贴图材质就是ta身上穿的衣服。 模型文件格式在Unity中，我们通常使用fbx格式的模型。Unity支持两种不同类型的模型文件： 交换格式，比如fbx、obj格式。大多数的3D建模软件都能导出这种通用的格式。 建模软件的原生格式，比如3ds Max对应的.max文件。如果使用这种格式的文件，必须在电脑上安装对应的建模软件才能导入使用。Unity在导入过程中会调用建模软件将模型转换为fbx格式。 两种类型各有优缺点，下面我们比较一下。 交换格式Unity支持.fbx，.dae（Collada），.3ds，.dxf，.obj和.skp格式的文件。 优点： 可以按需导入模型的部分或全部 导出的文件通常比建模软件原生格式文件小。 建模软件都可以导出这些交换格式，所以即使Unity不直接支持你的建模软件，你也可以将模型用交换格式导入Unity中使用。 导出后，你可以将导出的3D文件（.fbx，.obj）重新导入3D建模软件，确保所有信息都已正确导出。 缺点： 修改源文件后，需要重新导出交换格式文件，然后导入Unity 由于源文件和交换格式文件是分开的，你需要管理版本的一致性 原生格式Unity可以使用以下3D建模软件的原生格式：3D Studio Max、Maya、Blender、Cinema4D、Modo、LightWave、Cheetah3D 实际上，Unity在导入这些原生格式时，会调用对应的建模软件将原生格式文件转换为.fbx文件。 优点： 如果原始模型更改，Unity会自动重新导入该文件，无需管理两个版本 缺点： 所有使用该工程的电脑上都要安装对应的3D建模软件并且保证版本一致。如果版本不一致可能会导致错误或意外行为。 原生格式文件可能因包含不必要的数据而变得臃肿。 大文件导入会很慢，因为在将模型导入到Unity中时，后台会运行对应的3D建模软件来转换成fbx文件。 在导入过程中，Unity将原生文件转换为.fbx格式。这使得难以验证.fbx数据的正确性并定位问题。 ** 注意： ** 除非在计算机上安装了相应的3D建模软件，否则保存为.ma，.mb，.max，.c4d或.blend文件的资源无法导入。这意味着在Unity项目中工作的每个人都必须安装相同版本的软件。例如，如果你使用3ds Max 2017创建ExampleModel.max并将其复制到项目中，则打开该项目的其他人也需要在其计算机上安装3ds Max 2017。 贴图导入模型的贴图有两种方式导入到Unity中： 导出fbx时选中Embed Media，将贴图嵌入到fbx文件中。这时将fbx文件导入unity后，贴图也会随之导入，但是这种方式会大幅增加fbx文件的大小，不方便工程管理（不推荐） 贴图单独导入（推荐，具体流程见下方的模型导入最佳实践） 贴图搜索规则导入模型时，模型文件的材质信息中会包含所需贴图的贴图文件名信息，Unity按照如下规则搜索匹配贴图： 1、搜索与模型文件同级的Textures目录2、搜索模型文件的所有父目录中的Textures目录（依次向上级目录直至根目录）3、搜索整个工程中的所有贴图（如果工程中有同名的贴图，可能会导致搜索匹配错误） 如上图所示，导入MainCastle模型时，会优先查找1位置的Textures文件夹，如果没有找到对应贴图，继续查找2、3处的Textures文件夹，如果还没找到就搜索整个工程的所有贴图。 模型导入最佳实践1、在3D建模软件中将模型导出为fbx格式，fbx导出时不要选择内嵌贴图（导出时不要勾选Embed Media）2、在Unity工程中创建好合适的目录结构，先将模型所需的所有贴图导入到Textures文件夹中3、再导入fbx模型文件 使用这种方式，模型导入时，搜索贴图的速度最快，可以减少导入的时间。另外不容易出现模型无法找到贴图的情况。一定要先导入贴图，再导入模型。 总结模型文件包含了网格和材质，但是不一定包含贴图。贴图作为一种文件一般是另外给出的。一定要先导入贴图，再导入模型。使用这种方式，模型导入时搜索贴图的速度最快，可以减少导入的时间。另外不容易出现模型无法找到贴图的情况。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码控制Animator]]></title>
    <url>%2F2019%2F05%2F27%2F%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6Animator%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 两种控制人物移动的方式分别是什么？ bool参数和Trigger参数的区别是什么？ Has Exit Time是干什么用的？ parameter的id是什么？如何使用？ SetFloat()函数的那个damp参数是怎么用的？ 实现人物的站立、走、跑的状态切换 代码控制AnimatorParameters之前在学Transition的时候，只用到了按播放时间切换动画（一个播完播另一个），但是更强大的功能是按参数切换动画。 把Animator类比为一个视频播放器，视频播放器在点击下一个的时候当然要能切换到下一个视频了。 Animator是视频播放器，Animation是视频。 Animator左上角有一个Parameters，可以添加一个参数，比如人物的速度。 添加一个float类型的speed参数，如果想让人物从静止状态切换到走路状态，就可以加一个transition，条件可以用speed &gt;0。 运行场景，手动改speed的值，就能看到效果。 调整Animator参数 现在人物过了一会才移动，然后又不动了。 1、这个Transition除了speed大于0这个条件，还有一个条件是Has Exit Time，就是speed&gt;0满足条件后，还需要播放完idle的动画才会切换到下一个动画，这个Has Exit Time得去掉。 2、这两个动画都应该是循环播放。 控制移动怎么用代码控制呢，比如按键盘上WASD的时候控制人物移动。 使用动画系统时，有两种控制人物移动的方式： 使用动画中的位移这种好处是：人物的脚步会跟地面贴合，不会出现滑步的问题（人物的移动距离比步子大或者小），控制简单。这种缺点是：比较依赖动画的制作，程序控制性不高。 使用代码控制人物的位移好处：可控性高。缺点：容易出现滑步，控制复杂。 ** 使用动画中的位移 ** 这种方式需要先设置两个地方： 1、物体上Animator组件的Apply Root Motion需要勾选，相当于就是把动画中的位置修改应用到物体上；2、人物的动画类型需要设置为Humanoid。 这两个地方设置好以后，再用代码去修改animator组件中的参数就行了。 设置参数的办法是使用SetInteger、SetFloat、SetBool、SetTrigger四个方法。 SetInteger、SetFloat、SetBool、SetTrigger分别对应Paramters中的Int、Float、Bool、Trigger类型。 SetInteger有两个重载： 12public void SetInteger(string name, int value);public void SetInteger(int id, int value); 对于第一个重载，第一个参数类型是string，对应的是parameter中的参数名称。第二个参数是要设置的值。 对于第二个重载，第一个参数是animator中parameter中参数的ID。什么是参数的ID？ 其他SetFloat、SetBool、SetTrigger都类似，但是唯一不同的是SetFoat还有额外的两个重载方法： 12public void SetFloat(string name, float value, float dampTime, float deltaTime);public void SetFloat(int id, float value, float dampTime, float deltaTime); 其中前两个参数和上面是类似的，不同的是后面两个参数。 dampTime 阻尼时间。deltaTime 时间增量。 难点详解1.bool参数和Trigger参数的区别是什么？ bool参数和trigger参数很像，都是代表布尔值，但是trigger参数只能被设为true，一旦被transition使用，就会自动被设为false。 bool类型一般用于持续的状态，比如角色是否趴下。而trigger一般用于使用一次就会恢复的状态，比如开枪，开枪动画播放完以后，会自动恢复到之前的动作。 2.parameter的id是什么？ 在设置parameter的时候设置的是一个字符串的名称，但是在Unity内部是有一个数字id跟它对应的，使用Animator.StringToHash这个API可以将字符串的参数名转为数字id。使用数字id的代码运行效率会稍微高一些。 3.SetFloat的那个damp是怎么用的？ damp翻译过来一般是阻尼的意思，你可以理解为缓行。这样Fload值会渐变过去，而不是一下子变成设置的Float值，这个在有些情况下很有用，比如人物的速度。玩家按下W的时候，应该是一个逐渐从0到最大速度的过程，而不应该一下从0到最大速度，这时候就可以用到damp。如果对那两个参数还不知道怎么设置，可以看一下这个公式： 总结 Animator中可以设置参数，用来控制Transition的变化 Has Exit Time也是transition切换的一个条件，只有transition的所有条件都满足时才会进行切换 在代码中可以使用Animator类中的SetXXX方法控制参数，进而控制状态的转换。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IK]]></title>
    <url>%2F2019%2F05%2F27%2FIK%2F</url>
    <content type="text"><![CDATA[今日思考题1.用IK把你人物的视角以及拿枪的手部位置实现一下 含义和用途IK是Inverse Kinematic的缩写，也就是反向动力学。是根据骨骼的终节点来推算其他父节点的位置的一种方法。比如通过手的位置推算手腕、胳膊肘的骨骼的位置。 ** 用途 ** 角色需要拿各种不同的东西，让角色的手能符合各种不同的东西的握持位置，这样就不用针对每种不同的东西单独制作动画了 角色的头的旋转，这样可以和你视角的方向一致。角色的脚的位置，这样可以让角色踩在地面跟贴合。 Unity中IK能设置的部位就是5个，分别是：头、左右手、左右脚。所以没有其他部位的IK了，常见的其实也都是这些。 设置IK头部IK 先来看看如何设置人物的头部根据视角旋转。需要用到这两个API：Animator.SetLookAtPosition和Animator.SetLookAtWeight，对应的方法为：” 1public void SetLookAtPosition(Vector3 lookAtPosition); 这个方法用来设置头部看向的位置，比如看向你左边的窗户，头就会相应的旋转。 1public void SetLookAtWeight(float weight, float bodyWeight = 0.0f, float headWeight = 1.0f, float eyesWeight = 0.0f, float clampWeight = 0.5f); 这个方法用来设置IK的权重，这个IK会和原来的动画进行混合。如果权重为1，则完全用IK的位置旋转；如果权重为0，则完全用原来动画中的位置和旋转。至少要设置第一个参数，后面的几个参数都有默认值，但是你也要了解所有参数的含义：” Weight 全局权重，后面所有参数的系数 bodyWeight 身体权重，身体参与LookAt的程度，一般是0 headWeight 头部权重，头部参与LookAt的权重，一般是1 eyesWeight 眼睛权重，眼睛参与LookAt的权重，一般是0（一般没有眼睛部分的骨骼） clampWeight 权重的限制。0代表没有限制（脖子可能看起来和断了一样），1代表完全限制（头几乎不会动，像是固定住了）。0.5代表可能范围的一半（180度）。 大智：“有了这两个方法你就可以实现头部的IK了，不过还有两点需要注意：” 1、需要勾选对应Layer的IK Pass选项（在Layer的设置里）。2、代码需要写在OnAnimatorIK这个事件方法里面。 12345void OnAnimatorIK(int layerIndex)&#123; _animator.SetLookAtPosition(pos); _animator.SetLookAtWeight(1);&#125; 上面的代码就是人物的头部看向一个位置的代码。需要注意的是这个OnAnimatorIK方法有一个参数layerIndex，这个就是对应的Layer的序号，只有勾选了IK Pass的layer才会调用到这个方法里，每个勾选了IK Pass的layer调用一次。 这样就能实现人物的头跟着视角移动了 手脚IK小新：“那手脚的IK是不是也跟这个类似的？”大智：“是的，手脚的IK是和这个类似的，不过API有些不一样，我们来看看” 12public void SetIKPosition(AvatarIKGoal goal, Vector3 goalPosition);public void SetIKRotation(AvatarIKGoal goal, Quaternion goalRotation); 设置头部时，因为头不会移动，所以只需要设置LookAt的位置，头部跟随旋转即可。但是对于手和脚，需要同时设置位置和旋转。 goal AvatarIKGoal枚举类型，包含： LeftFoot 左脚 RightFoot 右脚 LeftHand 左手 RightHand 右手 goalPosition/goalRotation IK目标位置/旋转 同样还有设置权重的API： 12public void SetIKPositionWeight(AvatarIKGoal goal, float value);public void SetIKRotationWeight(AvatarIKGoal goal, float value); goal AvatarIKGoal枚举类型value IK的权重，1代表完全使用IK值，0代表使用原动画的值 常见的设置手部IK的代码是（一般需要4行代码设置一个部位）： 12345678void OnAnimatorIK(int layerIndex)&#123; _animator.SetIKPosition(AvatarIKGoal.LeftHand, position); _animator.SetIKPositionWeight(AvatarIKGoal.LeftHand, 1); _animator.SetIKRotation(AvatarIKGoal.LeftHand, rotation); _animator.SetIKRotationWeight(AvatarIKGoal.LeftHand, 1);&#125; IK位置/旋转调节小技巧小新：“大智，这个IK的位置好难调整啊，我想让角色拿枪的手能够贴合这个枪，有没有什么简单的办法？我这调了一个多小时了，还不是特别完美。。。”大智：“调IK是个慢活，不过呢，确实有一些小技巧在里面。IK相关的代码涉及到位置和旋转，这时候不要傻傻的直接定义一个位置和旋转来手动设置，最好的办法是设置两个参照物，作为IK的位置和旋转的参考，这样只需要调这两个参照物就可以了。”小新：“对对对，这样的话就不用去修改位置和旋转的值，而是直接修改这俩参照物的位置和旋转就可以了。我来试一下。” 运行时调整IK的参考位置.gif 运行时调整IK的参考位置.gif 小新：“太棒了，这样我就能在运行时调整这个参考位置，调到一个完美的位置和角度。”小新三下五除二，就调到了一个合适的位置和角度。“调好了！”小新高兴地喊道，随即退出了Play状态。大智：“高兴早了吧？你这么就退出来了，修改的能保存下来么？”小新：“啊。。。我给忘了，那这怎么办，运行时的修改保存不下来啊。。。”大智：“快想想，我之前教过你一个小技巧，可以保存运行时的数据，不能这么快就给忘了吧？”小新：“我有印象你教过我，不过这么久一直没实际用到过，哪能记得清啊”大智：“那我再教你一遍，这次可得记好了。”小新：“一定一定，再忘了我就……我就……再问你一遍，哈哈哈哈”大智：“皮一下很开心？记好了，点击Transform组件右上角的小图标，可以Copy Component，在运行时点击，退出运行后，再点击小图标，选择Paste Component Values，这样就可以将数据粘贴回来了。” Play模式下修改了位置 Play模式下修改了位置 在Inspector的Transform的右上角，点击齿轮小图标，选择Copy Component Values 退出Play模式 在Inspector的Transform的右上角，点击齿轮小图标，选择Paste Component Values 总结有了IK，人物就能更符合游戏的需要了，而且可以根据不同的情形动态调整，人物就不会那么呆呆的了。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Root Motion]]></title>
    <url>%2F2019%2F05%2F27%2FRoot-Motion%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.试下动画加上不同的Root Motion设置以后会有什么不同的效果。” “智哥，自从用了混合树来做人物移动，腰不酸腿不疼，思路更清晰了，一口气能写12小时代码！”“哟，疗效这么好，我看你应该再码12个小时”“那也没问题，你来看看我做的这个人物的混合树是不是棒极了” 小新信心满满地打开混合树，给大智看。 “嗯，这个混合树确实做的不错，比不过你这个角色还不能用啊！”“怎么不能用了，你看这个走起来不是走的好好的么？”“你走到那个坡上去试试” 小新操作人物往坡上走，只见直接穿了进去。“哎？我好像忘了给人物加碰撞了，等我给他加上” 小新给角色加上Collider和Rigidbody组件，再次操作人物往坡上怼过去。“智哥，你看现在OK了吧?”“别急，你再下坡看看”“哎，这怎么不受重力啊，怎么不会掉下去！明明加了刚体组件啊”“这个是因为动画在控制人物的Y轴，所以才没有掉下去”“但是我不都设置Apply Root Motion了么，咋还这样呢？”“那你知道Root Motion到底是什么？”“那不就是……人物的动画会带动人物移动嘛”“这只是他的一个表现，这时候你该去好好理解下Root Motion到底是什么了，这个Unity的文档中有，你去好好看一下吧！”“好嘞” 下面是小新的学习笔记。 Root Motion首先要分清Body Transform和Root Transform。 Body Transform（身体变换）Body Transform是角色的质心（重心）。用于Mecanim系统的重定向引擎中来提供稳定的模型移动。身体朝向是角色模型在T姿势下上身和下身朝向的平均值。 Body Transform和朝向存储在Animation Clip中，这两个是Animation Clip中存储的唯二世界空间的曲线，其他的动画曲线都是以相对body transform的形式存储的。 T-Pose T姿势角色模型的胳膊向外伸直，整个身体呈T字型，一般的角色模型应该为这个姿态。 T-Pose Root Transform（根变换）Root Transform是body transform在Y平面上的投影，并且是运行时计算的。每一帧Root Transform的变化实时计算。然后Transform的变化会被应用到GameObject上从而让物体移动。 角色脚下的圆圈代表了Root Transform 调整Root Transform通过对Animation Clip的设置来控制Body Transform投影到Root Transform的结果。 可以调整的有Root Transform Rotation, Root Transform Position (Y) 和 Root Transform Position (XZ) 。基于设置，Body Transform的部分数值可以转移到Root Transform中。例如你可以选择动画中的Y曲线是Root Motion的一部分，还是Body Transform（pose）的一部分。 Root Transform Rotation用于设置Root Transform的朝向（旋转）。 Bake into Pose：选中后，角色的朝向会基于body transform（Pose）。Root Orientation会是一个常量，意味着Animation Clip不会旋转这个物体。 只有AnimationClip的开始和结束位置旋转相似的时候，才应该使用这个选项。可以通过右边的绿灯判断。通常用于向前直行的走或跑的动画。 Base Upon：可以设置动画的朝向基于的地方。 Body Orientation：动画会朝向身体正前方。这个设置适用于大多数身体朝前的动画，比如走跑跳。但是如果动画是向左或向右平移的话，会有问题。这时候可以使用下面的Offset来调节角色的朝向。 Original：有的动画师会给动画手动加上旋转，确保动画的朝向正确，这时候可以使用这个选项，一般就不用再手动调整Offset了。 Offset：基于Base Upon的设置，调整偏移量。 Root Transform Position (Y)用于设置Root Transform位置的Y轴位置。 Bake into Pose：选中后，动画的Y轴的运动会保留在Body Transform（Pose）上。Root Transform的Y轴会是一个常数（不会受动画影响变化），也就是意味着动画不会改变物体位置的Y值。右边有一个绿灯指示动画起始位置和结束位置的高度是否一致，可以看出动画是否适合使用此选项。 大多数的动画应该选中此选项，除了那些会改变物体高度的动画比如跳起、跳下这些动画。 注意：Animator.gravityWeight是由Bake Into Pose position Y控制的。选中时gravityWeight = 1，不选中时gravityWeight = 0。gravityWeight用来在state转换时进行混合。 Base Upon：和Root Transform Rotation设置类似，除了Original 或 Mass Center (Body)选项外，还有一个Feet选项。Feet选项非常适合改变物体高度的动画（不勾选Bake Into Pose）。使用Feet时，Root Transform Position Y会匹配骨骼中脚部的Y位置（更低的那个）。Feet选项可以避免混合或转换时浮空的现象。 Offset：可以设置高度的偏移量。 Root Transform Position (XZ)用于设置Root Transform位置的XZ轴位置。 Bake Into Pose：通常用于原地不动的动画（动画在XZ轴上的位置为0）。可以用来去除动画循环累计的误差，造成位置的移动。也可以通过设置Based Upon Original来强制使用动画师设置的位置，否则会使用角色的重心作为Root。 Loop PoseLoop Pose（比如混合树或Transition中的混合）会基于Root Transform。Root Transform在每帧被计算出来后，动画的位置会相对Root Transform。开始帧和结束帧的差别会被计算出来，然后分布到动画的0-100%。完全没看明白，得问大智了 Generic Root MotionGeneric和Humanoid基本是类似的，但是Generic的动画的Root Transform是手动设置的Root Node属性。 “大智，我看完Root Motion的文档了，不过还是有点云里来雾里去的，你能不能用简单的几句话说说设置Root Transform的作用是什么？”“简单来说，如果不设置Root Transform中的Bake Into Pose，动画中的曲线会影响物体的Root Transform，而勾选了Bake Into Pose以后，动画的曲线就不会影响物体的Root Transform。再直白点说，比如勾选了Root Transform Position (Y)的Bake Into Pose，那动画就不会影响物体的Y轴位置了。对于你遇到的刚体不会掉落的问题，也能解决了。” “emmm，大概能明白，我还是得去试一试看看不同的效果。第二个问题：什么是重定向？”“重定向就是把A角色做的动画用到B角色上。如果A和B两个角色的骨骼结构完全一样，那动画可以直接重用。但是如果A和B的骨骼结构不一样，但是是Humanoid类型的，可以使用Unity中的Retargeting系统，这个文档里也有，建议你先去看看。” “哦，我现在貌似还用不到，等我用到的时候去查一下。最后一个问题哈，Loop Pose的作用是什么？我看了半天也没看明白是什么意思”“看不明白很正常，文档中那个解释确实有些不太直观。这个作用是，如果一个循环动画的首尾帧有差别，选中这个选项Unity会给你插值，让首尾帧看起来是连贯的，循环起来没有缝隙，但是可能会看起来有些奇怪。不过我们使用的动画，一般动画师都会做成无缝循环的动画，所以这个选项也不经常使用。”“这么一说我就能明白很多了，看来文档也有不靠谱的时候啊” 总结文档有时确实有描述不太准确或者晦涩的时候，这时候就需要你多动手。你看这个知道的‘知’字，左边是矢，也就是箭矢，右边是口，靶子也就是目标。这个字是说：不断地练习，命中目标才是知。所以要多实践。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2D混合树]]></title>
    <url>%2F2019%2F05%2F27%2F2D%E6%B7%B7%E5%90%88%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.实现人物的前后左右走、跑的动态混合 2D混合树2D混合树可以根据2个参数进行动画混合。 最终效果展示 2D混合树有三个选项，分别是： 2D混合的3个选项 2D Simple Directional（2D简单方向）：当你的运动代表不同的方向，如“向前走”，“向后走”，“向左走”，“向右走”，或“向上瞄准”，“向下瞄准”，“左瞄“和”右瞄“。当然了，可以在(0,0)处包含一个默认动作类似“空闲站立”或“直线瞄准”。与1D混合树不同的是，2D Simple Directional不是在同一个方向上的多个动作，比如“走”和“跑”。 2D Freeform Directional（2D自由方向）：动画运用有不同的方向时，也可以使用这种混合类型：可以在同一个方向上有多个运动，例如“走”和“跑”。在Freeform Directional类型中，(0，0)位置必须包含一个默认动作，如“空闲站立”。 2D Freeform Cartesian（2D自由笛卡儿）：当混合的2个参数不代表不同的方向时使用。使用Freeform Cartesian，参数X和Y可以表示不同的概念类型，例如角速度和线速度。举个例子：“向前走不转向”，“向前跑不转向”，“向前走并右转”，“向前跑并右转”等动作。 如果角色动画包含站立、走、跑和转向，非常符合2D Freeform Cartesian这种类型。后面以2D Freeform Cartesian举例说明。 将Blend Type设置为2D Freeform Cartesian 设置Blend Type之后，首先需要两个参数控制这个Blend Tree。 在Animator中添加两个float参数：Turn和Forward分别代表转向速度和向前行进速度，然后将这两个值设置为混合树的参数（注意顺序） 添加参数 注意参数的顺序 然后点击 + &gt; Add Motion Field 添加下列动画clip到混合树动画列表。（先不管后面的值） 下面，我们可以使用Unity中提供的自动计算Pos值的功能，来自动计算混合树的阈值。 Positions详解每一个Motion都有一个自己的位置，当参数(x,y)靠近这个位置时，这个动画就会参与混合。离得越近，这个动画的比重就越大。 选中一个Motion时，图中的蓝点会有选中的状态；同样选中混合图中一个蓝点，对应的Motion也会有选中的状态。 Motion选中状态 可以拖动混合图中相应的蓝点来修改位置，也可以直接修改Motion后面的值。 Compute PositionsUnity提供了自动计算Position的功能。 通过Compute Position下拉菜单可以选择不同的计算方式： ** 属性 ** ** 功能 ** Velocity XZ 根据动画自身的速度，将velocity.x设置每个动画的Pos X，将velocity.z设置Pos Y。适合2D Simple Directional和2D Freeform Directional类型的混合树。 Speed And Angular Speed 将动画的Y轴角速度（弧度每秒）设置到Pos X，速度设置到Pos Y。适合2D Freeform Cartesian类型的混合树。 另外，还可以通过 Compute Position -&gt; X Position From 或 Compute Position -&gt; Y Position From 单独计算X或Y的值。 ** 属性 ** ** 功能 ** Speed 动画的速度 Velocity X 沿X轴的速度 Velocity Y 沿Y轴的速度 Velocity Z 沿Z轴的速度 Angular Speed (Rad) Y轴的角速度，单位是弧度/秒 Angular Speed (Deg) Y轴的角速度，单位是角度/秒 Rad 和 Deg 分别代表了弧度和角度，弧度π(3.1415…) = 360°可以根据项目的需要来选择，两种都可行，但是如果X，Y的数值相差过大的话，在混合图上显示会不便于调试。在模型的Import Settings面板可以看到动画的速度 查看动画的速度和角速度 回到我们的混合树：参考上面的内容，我们可以使用Speed And Angular Speed来计算每个Motion的位置。 选择Compute Positions中的Speed And Angular Speed 设置完后，整个混合树如下图所示： 现在我们来测试一下，看看怎么样。 设置完毕后的效果 Preview窗口中，记得一定要点击左上角的播放，动画才会实时播放看到效果。 混合的原理动画混合时，会根据X和Y两个值来确定混合的动画以及各自所占的比重。上面动图中我们可以看到，拖动红点时，可以看到不同的节点上面圆圈在发生不同的变化，圆圈的大小即这个动画所占比重的大小。 6个动画混合的效果 红点所在的位置代表了X和Y两个参数的值对应的位置。横轴是X，纵轴是Y。 Direct Blending 直接混合直接混合可以直接将animator的参数映射到混合树动画的权重。这在什么时候使用呢？如果你想用参数精确控制混合的动画，而不是通过以两个参数间接控制动画的混合。 设置一个direct混合树时，motion列表中的每一个动画需要对应一个参数，用来控制这个动画的混合权重。 难点解析“这个2D混合树中的阈值和动画中的真实速度是对应关系么？”“其实只要保持对应的相对比例就可以，并不一定要真实的速度：”1、X，Y的值和动画的实际速度没有映射关系。我们也可以将“走”的动画的Y值设置的大一些，将跑的动画设置的小一些。但是这样设置会在表现上不符合玩家的预期，感觉怪怪的。2、在手动调整时，只要点之间的相对位置保持不变，混合效果不会受太大的影响。3、但是要注意在写代码的时候，要根据调整过后值的范围来设置对应的参数。 总结想要把混合树用好，需要多去尝试一下]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混合树BlendTree]]></title>
    <url>%2F2019%2F05%2F27%2F%E6%B7%B7%E5%90%88%E6%A0%91BlendTree%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.混合树和Transition中的混合有什么区别？2.1D混合是什么意思？1D和2D有什么区别？3.每个动画有不同的权重是什么意思？ BlendTree混合树Animator中有一个功能，用来解决多个动画之间的混合，经常用于移动动画之间的混合，这个功能叫做BlendTree，混合树。 混合树和Transition中的混合不同，Transition中的混合只是在两个State转换时，在给定的时间内进行混合，避免动画切换过于突兀。而混合树中的混合，是时时刻刻进行不同程度的混合。比如你的角色有站立、走、跑三个动作，走路的速度是2m/s，跑的速度是5m/s，那你想让角色的速度是3m/s，这时候怎么办？这时候用混合树就能很简单地解决。 创建混合树在Animator窗口的空白处右键，Create State &gt; From New Blend Tree，双击这个节点可以进入混合树图。 混合树有3种类型，在右边的Blend Type中可以设置。分别为： 1D 2D Direct 1D混合1D混合树应用的情景比较少，1D混合是根据一个参数进行动画混合。 1、首先要设置用于混合的参数，也就是从Animator的Parameters中的选择一个参数。 2、添加动画：可以点击小加号按钮，或者在Blend Tree节点上右键Add Motion。点击后会在Motion列表中添加一个条目，可以将Animation Clip拖进来。 添加完动画，整个混合的样子： 最上面的图显示了参数对每个动画的影响。每个动画显示为一个蓝色的三角形。如果点击这个三角形，会在下面的动画列表中高亮一下。每个三角形的顶角位置定义了参数在该位置时，会完全使用这个动画，这个值也叫做该动画的阈值（Threshold）。比如上图中的run动画，阈值是0.5，在混合图的中心位置。 图中的红线代表了参数的数值，主要是用来预览调试。可以拖动红线，在下面预览窗口观察动画是如何混合的。 注意点播放按钮，可以预览动画播放的状态 ** 参数范围 ** 上图中，左右两个数字代表了参数的范围。点击数字可以变成输入框修改，也可以在数字上拖拽调节。修改时会影响到第一个动画和最后一个动画的阈值。 ** Threshold 阈值 ** 修改动画对应的阈值可以直接拖拽对应的蓝色三角形。如果没有勾选Automate Threshold（自动计算阈值），也可以在阈值编辑框中直接输入数值。选中Automate Threshold（自动计算阈值）时，阈值会自动在最小值和最大值之间自动平均分布。 下面有一个Compute Thresholds下拉框，使用这个下拉框，可以根据动画中的数据，自动计算阈值。数据包括：speed（速度），velocity x、y、z（xyz三个轴分别的速度），angular speed（转动速度，单位是角度或弧度）。这些数据如何知道呢？ 比如：走路动画的速度是1.5m/s，跑的速度是4m/s，如果选择Compute Thresholds中的Speed，walk动画的阈值会被设置为1.5，run动画的阈值会被设置为4。 ** Time Scale ** 通过动画速度这一列（图标是一个表）可以调节动画的播放速度，比如你想让跑步的动画播放速度变为原来的2倍，可以设置为2。 **Adjust Time Scale &gt; Homogeneous Speed ** 可以将动画的速度调整对应到参数的最小值和最大值，但是保持动画的初始相对速度。 按钮可以将动画的播放速度调整到动画列表中所有动画速度的平均值。 ** Mirroring 镜像 ** 上面复选框可以左右镜像一个humanoid类型的动画Clip。这个功能可以使用同一个动画创建出来两个方向的动画，可以节省一倍的存储空间和内存。 比如一个向左走的动画，通过镜像可以创建出一个向右走的动画。 难点解析“第一个问题：自动计算Threshold的时候，那些动画的速度啊，旋转速度怎么知道啊？”“选中一个Animation Clip，你可以看到这些数据，比如这个：” “第一行是这个动画在xyz轴上的速度，第二行是旋转速度。” “第二个问题：**Adjust Time Scale &gt; Homogeneous Speed **这个到底是干嘛的？”“先将所有动画的平均速度算出来，然后通过调节动画的speed让所有动画的速度都一致。” 总结混合树可以根据参数，混合多个动画，每个动画有不同的权重，这样就有了很多中间状态。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Animator中的Transition]]></title>
    <url>%2F2019%2F05%2F25%2FAnimator%E4%B8%AD%E7%9A%84Transition%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题: Has Exit Time是单位化时间是什么意思？ 导入Standard Assets中的Character包，看看里面的Transition是如何设置的。 TransitionTransition代表状态之间的切换条件，一般会有一个或多个条件，用于从一个状态切换到另一个状态。 添加Transition在一个State上右键，在弹出菜单中选择Make Transition，可以创建一个到其他State的Transition。 增加Transition 点击代表Transition的箭头，可以在Inspector上看到这条Transition的具体情况。选中Transition的源State（从哪个State出发），也可以在State的Inspector中看到这条Transition的具体信息。 Transitions 显示当前选中的Transition。后面有两个复选框包括Solo和Mute。 Solo 如果两个State之间有多条Transition，勾选这个选项后，只有选中Solo的Transition生效。其他Transition会被禁用。 比如Transition1设置为Solo，则从源State到目的State的3个Transition中只有1会生效 Mute 勾选这个选项后，该条Transition会被禁用。如果同时选中了Solo和Mute，Mute会优先生效。 Name Field 名称框。如上图所示，可以给Transition命名，用于区分两个State之间的多个Transition时非常有用。 Has Exit Time 是否有退出时间条件。退出时间是一种特殊的transition条件，它没有依赖参数（下面会讲），而是根据设置的退出时间点作为条件进行状态转换。 Settings transition的一些参数设置。 Exit Time 如果勾选了Has Exit Time，该参数是可以设置的，设置动画退出的单位化时间。例如设置为0.75，代表动画播放到75%时为true，如果没有其他条件，会直接切换到下一个State。 对于循环的动画，如果exit time小于1，那么每次循环到对应位置的时候，该条件都会为true。比如第一次播放到75%，第二次播放到75%……时退出条件都会为true。 如果exit time大于1，该条件只会检测一次。比如exit time为3.5，state的动画会在循环3次后，在播放到第4次的50%时为true。 Fixed Duration 勾选时，下方Transition Duration参数的单位是秒，不勾选时，参数会作为一个百分比。 Transition Duration transition的过渡时间。两个状态在转换时，一般不会瞬间从一个状态转换到另一个状态，而是会经过平滑混合，这个属性就是设置了平滑混合的时间。可以从下图的两个蓝色箭头看出转换的时间。 Transition Offset 目标状态开始播放的时间偏移。比如设置为0.5，则转换到下一个State时，会从50%的位置开始播放。 如图设置为0.5时，下一个State会从50%开始转换 Interruption Source和Ordered Interruption 这两个参数可以用来控制transition的打断。下面会进行详解。 Transition图上面的参数不仅可以手动修改数值，也可以通过Transition图预览、修改。 Conditions 条件一个Transition可以有一个条件，也可以有多个条件，甚至没有条件。 如果Conditions中没有条件，但是勾选了Has exit time，那么exit time会被作为state退出的条件，到达exit time时，会切换到下一个state。 如果有一个或多个条件，需要同时满足这些条件才能切换下一个state。 一个条件可以是： 相等/不相等判断，一个参数等于/不等于一个常量时为true（int，float，bool类型参数） 比较判断，一个参数与一个常量的比较结果（int，float类型参数） 触发器，触发器激活时为true 如果Has Exit Time勾选了，并且transition还有一个或多个条件，那么transition需要同时满足到达exit time同时条件全为true，才会切换到下一个state。 一个transition至少要有一个条件（Has Exit Time可以作为一个条件），否则transition会被忽略。 【选读】Transition Interruption之前我们提到了Interruption Source和Ordered Interruption 这两个参数可以用来控制transition的打断。那么究竟什么是transition打断呢？ 一般情况下，动画系统的transition是不能打断的：一旦transition开始从一个state切换到另一个state，没有打断的方法。就像乘坐跨大西洋航班的乘客一样，你舒适地坐在座位上，直到到达目的地，无法改变主意。对于大多数用户来说，这很好。 但是如果你需要对transition进行更多控制，可以通过多种方式配置动画系统来满足需求。如果你对目前的目的地不满意，你可以跳进飞行员的座位，在飞行途中改变计划。这意味着更具响应性的动画，但也有很有可能迷失在复杂的打断中。 我们通过几个例子来解决这个问题。我们从一个相当简单的状态机开始，这个状态机具有四个状态，标记为A到D，并且使用trigger作为每个transition的条件。 默认情况下，当A到B的切换触发后，状态机开始切换到B，在切换到B之前无法被改变。但是，如果将A-&gt;B的transition的interruption source属性从None切换到Current State，A到B的切换就可以被A上的一些触发器中断。 为什么只有一些呢？因为Ordered Interruption属性默认也会被勾选。这意味着只有优先级大于当前的transition才能打断。选中State A，在Inspector中查看，我们看到A -&gt; C的优先级高于 A -&gt; B，那也意味着只有A -&gt; C能打断A -&gt; B的转换。 如果我们激活AtoB的trigger，然后立马激活AtoD的trigger，A到B的transition不会被打断。但是，如果我们激活AtoB的trigger，然后立马激活AtoC的trigger，A到B的transition会被打断，转而切换到C。 在动画系统内部，会记录下被打断时的动画的状态，然后从打断的状态混合到新的目标动画。 如果不勾选Ordered Interruption属性，会发生什么情况呢？A-&gt;C 和 A-&gt;D 都能打断 A -&gt; B 的transition了。但是，如果在同一帧激活了AtoC和AtoD的trigger，A-&gt;C仍然会优先激活因为A-&gt;C的优先级更高。 如果将A -&gt; B的interruption source属性改为Next State，A-&gt;C 和 A-&gt;D就不能打断A -&gt; B了。如果我们激活AtoB的trigger，然后立马激活BtoD的trigger，A到B的transition会被打断，转而切换到D。 B上的Transition的顺序也有影响。但是这时候Ordered Interruption属性就无法勾选了（因为A -&gt; B是在State A上不在State B上，不参与B的排序）。B上transition的顺序会决定同时触发时，会使用哪一个transition。例如下图的排序，如果B-&gt;D 和B-&gt;C在同一帧被触发，B-&gt;D的transition会被执行。 如果想完整控制，我们可以设置interruption source属性为Current State Then Next State或Next State Then Current State。设置为这两个值时，State A和State B上的transition都会被考虑在内。例如设置如下，选中了Current State Then Next State： 如果A到B切换时，同时激活的A-&gt;C, A-&gt;D, B-&gt;C和B-&gt;D，会发生什么情况？ 如果选中了Ordered Interruption，那么首先可以忽略A-&gt;D（因为比A-&gt;B）的优先级低。然后先考虑Current State A，那么A-&gt;C会胜出，甚至不用考虑Next State B了。 如果同样的配置，只激活了B-&gt;C 和 B-&gt;D，那么B-&gt;D会胜出，因为B-&gt;D的优先级比B-&gt;C更高。 小结 上面我们只使用了A-&gt;B一种情况作为例子进行了讲解，其他的中断都是类似的，只需要根据他们自身的规则即可。 有一点很重要需要记住的是：不管打断发生了几次，只要transition没有完成，source state会一直不会变。比如A-&gt;B被B-&gt;C打断，又被C-&gt;D打断，transition未完成前source state会一直是A。Animator.GetCurrentAnimatorStateInfo()也会返回State A。 简而言之，transition中断功能很强大，并提供了很大的灵活性，但会变得非常混乱。因此，合理地使用transition中断，如有不确定，一定要在编辑器中进行测试。 总结 Transition代表状态之间的切换条件，一般会有一个或多个条件，用于从一个状态切换到另一个状态。 一个transition至少要有一个条件（Has Exit Time可以作为一个条件），否则transition会被忽略。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Animator]]></title>
    <url>%2F2019%2F05%2F25%2FAnimator%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 导入Standard Assets中的Character包，看看里面的Animator Controller是如何设置的。 Animation Clip，是整个动画系统的基本元素。 如果把Animation Clip比作是一段视频的话，那么Animator就是一个视频播放器，用来控制多段视频的播放、切换等等。 Animator组件 在一个物体上播放动画，需要添加Animator组件到这个物体上。 Animator中有一个很重要的属性是Controller，这个属性引用了一种叫Animator Controller的资源，这种资源以文件的形式存储在工程中，文件内存储了动画的各种状态以及状态之间的切换规则。下面会细讲。 Avatar 用于人形动画，设置使用的骨骼节点映射。 Apply Root Motion 应用根节点运动。如果不启用，动画播放时会保持在原地，需要通过脚本控制物体的移动。如果启用，如果动画中有位移，那么Animator组件所在的物体也会移动。 Update Mode 设置Animator更新的时机以及timescale的设置。 Normal Animator按正常的方式更新（随着Update调用更新，timescale减小时，动画播放也会减慢，timescale的具体含义和用法后续会详解） Animate Physics Animator会按照物理系统的频率更新（根据FixedUpdate调用更新，后续会详解），适用于物理交互，例如角色加上了物理属性可以推动周围的其他物体。 Unscaled Time 根据Update调用更新，无视timescale。一般用于UI界面，当你使用timescale暂停游戏时，界面保持正常动画。后面会详解。 Culling Mode 裁剪模式 Always Animate 动画一直运行，即使物体在屏幕外被裁剪掉并没有渲染 Cull Update Transforms 当物体不可见时，禁用Retarget、IK、Transforms的更新（后续动画进阶模块会细讲） Cull Completely 当物体不可见时，完全禁用动画 Animator ControllerAnimator Controller是Animator组件必须的资源，这种资源以文件的形式存储在工程中，文件内存储了动画的各种状态以及状态之间的切换规则。 图中有两个Animator Controller文件 通常一个物体上有不止一段动画，使用Animator Controller可以很容易地管理各段动画以及动画之间的切换。比如角色身上有走、跑、跳、蹲的动画，使用Animator Controller可以很容易管理它们。不过，即使只有一段动画，仍然需要给动画物体添加Animator组件才能播放动画。 Animator Controller中使用了一种叫State Machine（状态机）的技术来管理状态以及状态之间的切换。 StateMachine 状态机状态机由State（状态）和Transition（转换）组成。State代表一个状态，在Animator Controller中一个State可以包含一段动画、一个子状态机或一个混合树（后面会细讲）。Transition用来设置状态之间的切换条件，一般会有一个或多个条件，用于从一个状态切换到另一个状态。 在Animator窗口中，可以可视化看到State以及Transition。 创建Animator Controller创建Animator Controller资源有如下几种方式： 在Unity中创建Animation Clip时，如果选中的GameObject上没有Animator组件，会自动添加Animator组件并在工程中创建一个Animator Controller文件（和Animation Clip文件同目录）。 将任意Animation Clip拖到一个物体上时，如果拖到的物体上没有Animator组件，会自动添加Animator组件并在工程中创建一个Animator Controller文件（和Animation Clip文件同目录）。 可以在Project窗口中手动创建Animator Controller文件，如下图所示： 创建Animator Controller文件 编辑Animator Controller双击Animator Controller文件，可以打开Animator窗口，编辑该文件。 今天我们先简单学习一下如何将导入的动画播放出来，后续的动画进阶模块会更详细讲解Animator Controller中的高级功能。 在Project窗口中直接创建Animator Controller时，其中是不包含任何动画的。如下图所示： 图中包含三个节点： Entry 入口。动画状态机会从这个节点开始，根据Transition进入一个默认State。 Any State 任意状态。用于从任意状态转换到特定状态。比如射击类游戏中，如果被子弹打中后，不管当前处于什么状态，都会倒地死亡。 Exit 退出状态机。一般用于嵌套的状态机的退出。 添加状态可以在空白处右键添加Empty State，也可以将Animation Clip文件拖到Animator窗口中添加一个State。 如果当前在Project窗口选中了一个Animation Clip，也可以通过上图的From Selected Clip创建一个State，不过还是直接将Clip拖到Animator中创建State更简单。 第一个创建的State默认是橘黄色的，代表是默认状态。有一条黄色的箭头从Entry指向橘黄色的State。Animator组件会在一开始播放New State，如果New State中有动画，也会播放对应的动画。 这时候如果你Play这个场景的话，设个物体就会播放默认State的动画。 State设置每个State可以包含一段Animation Clip，处于该State时Animator组件所在的物体会播放该动画。选中一个State时，在Inspector中可以看到如下内容： Motion 可以设置一个Animation Clip，如果是从Animation Clip创建的动画，这里应该已经有动画了，你也可以从工程中选择动画。 Speed 动画的播放速度 Multiplier 乘数，可以使用一个参数来控制动画的播放速度，动画最终的播放速度会是Speed * Multiplier。后面会讲解Animator的参数以及如何在代码中控制参数。 Normalized Time 单位化时间，范围是0-1，需要使用参数控制。 Mirror 镜像动画。也可以使用一个参数控制。 Cycle Offset 循环偏移量。可以用来同步循环的动画。偏移量使用的是单位化时间，范围是0-1。也可以使用参数来控制。 Foot IK 只用于人形动画。角色的脚是否使用反向动力学。 Write Defaults 是否初始化该State没有用到的参数为默认值。 Transitions 该状态参与的状态转换。下面会细讲。 Parameters 参数上面我们提到了参数的概念，那么参数是什么呢？ Animator Controller中的参数可以作为控制transition切换的条件，也可以控制上面可以参数化的属性比如State中的几个属性。 State中可以用参数做属性值的来源 Animator Controller的参数可以通过代码进行控制，进而控制整个Animator状态机的运转。 参数共有4种类型： Int 整数类型 Float 浮点数（小数）类型 Bool true或false（真或者假，用于逻辑判断），界面上显示为复选框 Trigger 触发器，与Bool有点类似，但是transition在使用这个参数后会被自动设置为false状态。界面上显示为一个圆形按钮。 总结 如果把Animation Clip比作是一段视频的话，那么Animator就是一个视频播放器，用来控制多段视频的播放、切换等等。 Animator Controller就是一个剧本，用来指导视频播放器如何播放多段视频。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导入动画]]></title>
    <url>%2F2019%2F05%2F25%2F%E5%AF%BC%E5%85%A5%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 导入Standard Assets中的Character包，看看里面的动画是如何设置的。 点击下载资源 之前学习了如何在Unity中制作动画，但是在Unity中制作动画的功能有限。比如角色的骨骼动画，就无法通过Unity的动画系统直接制作。很多时候动画还是需要美术同学在建模软件中制作并导入Unity中使用。 现在来学习一下如何从模型文件导入动画。 导入模型导入动画和导入3D模型的流程一样，动画会包含在3D模型中。 大多数情况下，含动画的模型导出的fbx文件会同时包含网格信息和动画信息，但是也有一些情况fbx文件只需要导出动画信息。例如同一个模型有很多动画，网格信息只需要一个就够了，其他动画信息可以通过单独的模型文件（不包含网格信息）导出，可以减小Unity工程的体积。 动画信息在单独的模型文件里面 有些情况下，动画是基于特定模型制作的，不能在其他模型上重用。例如，游戏中的终极Boss巨型章鱼会有独特的骨骼，以及自己的动画。 在其他情况下，美术同学在制作动画时应该考虑动画的重用，用于场景中同类的模型。例如，不同的人形角色可能都使用相同的走动和跑步动画。只要保持骨骼结构一致，动画就可以重用。 动画导入设置首先将fbx文件导入Unity中，选中模型。在Inspector面板中会显示模型的导入设置，之前我们已经学习了Model和Materials页签，今天我们看下动画导入的设置。 和动画有关的设置包含Rig和Animation两个页签。 Rig在Rig页签中可以设置动画的类型。 Animation Type 选项有4个： None 不导入动画 Generic 通用动画：适用于所有的动画类型，特别适用于非人形的动画。 Humanoid 人形动画 Legacy 旧版本动画（为了兼容Unity3.x旧版本，不建议使用） Avatar Definition 如果动画是骨骼动画，可以使用这个选项定义骨骼的来源。 Create from this model 基于当前模型 Copy from other Avatar 指向另一个模型的Avatar Root node （选择Generic才有）可以用来设置动画的根节点。一般保持默认即可。 Configure… 选中Humanoid时显示。用来配置骨骼。 Optimize Game Object 选中时，导入的角色模型的层次结构将被删除，存储在Avatar和Animator组件中。角色的SkinnedMeshRenderers将直接使用动画系统内置骨架。该选项可提高动画的性能。在最终发布时你应该选中此选项。在此模式下，蒙皮网格的提取也是多线程的。 Animation这个页签中会显示动画导入的设置。如果Rig页签中的Animation Type选择了None，则无法设置Animation相关的属性。 Import Constraints 是否导入Constraints(约束)。美术同学可能知道在3D建模软件中有Constraints设置，用来添加一些约束。Unity支持5种约束的导入。目前用到的较少。 Import Animation 是否导入动画，如果不勾选代表不导入动画，下面的选项也会隐藏。 Bake Animations 该选项只对Maya、3dsMax 、Cinema4D文件可用，对fbx文件不可用。选中时，Unity在导入模型时会将IK或模拟动画转为正向动力学动画。 Resample Curves 重新采样曲线。如果原来模型的动画曲线插值有问题，可以选中此选项，但是动画可能会有轻微的变化。 Anim.Compression 动画压缩 Off 禁用压缩。Unity不会减少关键帧，这个选项能提高动画的精度，但是会降低运行时性能，存储空间和运行时内存占用都会变大。一般不建议使用此选项，如果你需要非常精准的动画可以减小压缩的误差值。 Keyframe Reduction 根据设置的误差值移除关键帧。 Optimal Unity 自动决定如何压缩。根据设置的误差值移除关键帧并且压缩关键帧。这只会减小动画存储空间占用，运行时内存占用和 Keyframe * Reduction 相同。 Anim.Compression 不选择Off时，会显示下面三个选项： Rotation Error 旋转变化小于这个误差的关键帧会被删除。值越小动画越精确。 Position Error 位置变化小于这个误差的关键帧会被删除。值越小动画越精确。 Scale Error 缩放变化小于这个误差的关键帧会被删除。值越小动画越精确。 Animated Custom Properties 是否导入自定义属性。在3D建模软件中可以设置一些自定义属性，这个选项可以将这些自定义属性导入进来。 Clips 动画片段，Start和End分别代表了该段动画在整段动画中的起始帧和结束帧。下面详细学习。 分割动画 导入的一个角色资源，可能只有一个角色模型资源，也可能包含动画资源。动画资源也分两种情况：1.各个动画部分都是独立的2.所有的动画集成在一个动画片段中。 注：第2种情况，需要在导入资源之后手动分解成不同功能的动画片段。 从3D建模软件导入到Unity中的动画，有时是很多段动画在一起的一段很长的动画，可能包括走路、跑步、站立、跳跃等动画。但是在Unity中使用时，我们需要将长动画拆分为一段段短动画。 创建一段新的Clip 如上图，点击加号可以创建一段新的动画，可以在下方设置该段动画在完整动画中的起始帧和结束帧。设置时，可以下下方预览窗口查看当前移动位置的动画状态。 设置动画Clip的起始结束位置 在拖动起始、结束箭头时，能看到下方会显示4条曲线，右方有4个灯，会显示绿色、黄色或红色。这是做什么用的呢？ 其实这些是为了方便你在剪辑动画时，能更好地剪出循环的动画。比如一个跑步的循环动画，起始帧人物各个骨骼的位置应该和结束帧人物各个骨骼的位置一致，动画循环时才不会出现跳动的现象。绿灯代表开始帧和结束帧符合，黄灯代表有些不符合，红灯代表一点都不符合。但是也不能追求4个全绿灯，因为4个灯代表了4个不同的位置类型，有些情况下是不同的。后续动画进阶模块会详细学习。 Loop Time 如果动画需要循环播放时，勾选此选项。 点击Apply保存对模型的修改 最后，别忘了点击最下方的Apply保存对模型动画的修改。 总结今天讲了如何将外部模型动画导入到Unity中，希望你能记住一下几点：1、Animation Type 选项有4个： None 不导入动画 Generic 通用动画：适用于所有的动画类型，特别适用于非人形的动画。 Humanoid 人形动画 Legacy 旧版本动画（为了兼容Unity3.x旧版本，不建议使用） 2、在Unity中可以分割动画成为一个个片段。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画系统-1]]></title>
    <url>%2F2019%2F05%2F25%2F%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.动画来源有哪两种？2.如何在Unity中制作动画？3.如何控制动画的播放和状态切换？4.动手创建一个简单的动画试一试吧！5.Animation Clip和Animator分别是什么？6.DopeSheet和Curves有什么区别？7.什么是Ripple Edit 波纹编辑？ Unity中内置了强大的动画系统，可以支持在Unity内制作动画（自带的Primitive物体），也支持从外部导入动画。 动画系统基于一种名为Animation Clip（动画剪辑）的资源，这些资源以文件的形式存在工程中。这些文件内的数据记录了物体如何随着时间移动、旋转、缩放，物体上的属性如何随着时间变化等。每一个Clip文件是一段动画。 这些动画可以在Unity中直接制作，也可以由美术同学在3D建模软件中制作并导入到Unity中。 在Unity中制作动画在Unity中制作动画需要用到Animation窗口，可以通过菜单栏Window &gt; Animation打开Animation窗口。 通过这个窗口可以创建、编辑动画，也可以查看导入的动画。Animation窗口同一时间只能查看、编辑同一段Clip中的动画。Animation适合单个物体的动画编辑。后面会讲到Timeline，适合同时对场景中多个物体制作复杂动画，还能包含音频，自定义的动画内容。 在Unity中制作动画一般分为以下几个步骤：1、打开Animation窗口2、选中要制作动画的物体3、创建新的动画Clip4、编辑、预览、修改动画 创建新的Animation Clip选中要制作动画的物体，这时候Animation窗口会有以下两种状态：（1）该物体上没有动画，可以点击Animation窗口中间的Create按钮创建动画Clip。 物体上没有动画的情况 （2）该物体上已经有动画，会在窗口中显示一段动画的关键帧。可以通过左上角的菜单切换预览动画、创建新动画。可以点击Create New Clip…来创建新的动画Clip，如下图所示。 物体上有动画的情况 点击完创建新的动画Clip后，会弹出一个文件对话框，可以设置保存动画Clip的位置。（为了保持工程文件目录的整洁，不要保存在工程根目录，建议保存在Animations文件夹中） 保存完毕后，原先没有动画的物体上会自动附加一个Animator组件，这个组件是做什么的呢？ Animator组件 Animation Clip只是一段动画数据，你可以把它类比成视频文件，而Animator组件是一个播放器，用来控制动画的播放、多个动画片段之间的切换等。 Animator窗口 Animator组件的第一个属性是Controller，对应到工程目录中的文件是一个Animator Controller类型的文件，可以在这个文件中定义动画Clip之间如何进行切换。双击这个文件会打开Unity的Animator窗口，显示该文件中的内容。 制作动画创建了动画Clip后，就可以开始制作动画了。 Animation窗口有两种模式：录制模式和预览模式。 点击图中红色按钮进入录制模式，时间轴会显示为红色 点击图中Preview按钮进入预览模式，时间轴会显示为浅蓝色。在时间轴上点击也会自动进入预览模式 在录制模式下，当你对物体进行改动时（例如移动、旋转、缩放、修改属性等），Unity会自动在当前时间位置生成关键帧，记录修改的属性。 在预览模式下，修改物体不会自动创建/修改关键帧，如果需要创建/修改关键帧，你需要手动点击添加关键帧按钮。 录制关键帧点击录制按钮后，就进入了录制状态。 可以通过在时间轴上拖动修改当前所在的时间位置。 在时间轴上拖动修改当前时间 也可以通过修改当前帧数输入框中的数字，修改时间轴的位置。默认情况下，动画的帧速率是60，即每秒播放60帧。如果设置当前帧数为30，就是0.5秒的位置。 在录制模式下，不管是在场景中移动、旋转、缩放物体，还是在Inspector面板中修改物体组件的属性（Unity动画支持的属性），Unity都会自动在动画Clip的当前时间上添加关键帧保存。 当前被记录的属性，在Inspector上会以红色背景显示 编辑动画 编辑完动画后，可以再次点击录制按钮退出录制模式，避免后续对物体的操作被记录到动画中。 现在你会看到在Animation窗口中，左侧多处很多个属性，这些属性就是所有被记录的属性列表。你也可以通过点击下方的Add Property按钮手动添加需要被动画记录的属性。 手动创建关键帧如果没有在录制模式下，对物体的修改不会自动记录到动画Clip中。如果需要记录，需要手动添加关键帧进行记录。 如果在Inspector中修改了物体的属性，物体的属性会从浅蓝色背景变为浅红色，代表该属性已经被修改。这时候你可以右键点击对应的属性，在弹出菜单中点击Add Key即可添加关键帧，将该属性的数据保存到动画Clip中。如果你在当前帧修改了多个属性，可以点击菜单中的Key All Modified（将所有修改的属性记录关键帧）或Key All Animated（记录属性列表中所有属性的数值，即使与上一帧相同数值的属性也会被记录）来一次性将所有修改的属性保存。 属性上的右键菜单 也可以点击Animation窗口左侧的Add Keyframe按钮来记录当前属性列表中选中属性的关键帧，如果当前没有选中任何属性，则会记录所有属性。如下图所示。 ** 小技巧 **添加关键帧也有快捷键哦，记住快捷键能大幅提高制作动画的效率。 K Key All Animated，将记录当前属性列表中选中属性的关键帧，如果当前没有选中任何属性，则会记录所有属性。 Shift + K Key All Modified，将动画属性列表中所有已修改的属性的数值记录为关键帧。 使用曲线编辑动画 默认情况下，Animation窗口是DopeSheet模式，显示的是关键帧的点。可以通过点击下方的Curves切换为曲线模式，进一步调节关键帧之间的数值是如何过渡的。 可以在左侧属性列表选中一条或多条曲线进行编辑。 ** 小技巧 **别忘了F的妙用，F键可以让曲线充满整个窗口，这在不同属性的曲线之间切换时非常有用。 编辑关键帧编辑关键帧时，可以多选（在Curve编辑中同理）： 按住Shift或Ctrl，再点击关键帧可以选中多个关键帧 通过框选多选关键帧 按住Shift或Ctrl的同时框选，可以添加或移除框选住的关键帧 框选关键帧 批量移动关键帧 批量缩放关键帧 ** Ripple Edit 波纹编辑 ** 你会发现直接拖拽多个关键帧时，后方的关键帧并不会跟随这些关键帧移动。如果你想让后方的关键帧也跟着移动，可以按住R键，同时拖拽这些关键帧。这种编辑方式叫做Ripple Edit（在音视频编辑软件中很常见）。缩放同理。 Ripple Edit 预览动画效果 点击Animation窗口中的播放按钮，就可以在Scane中预览动画。 总结Animation Clip是Unity中保存动画的资源文件，保存在工程中。Animator是Animation Clip的播放器。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL乐观锁与悲观锁]]></title>
    <url>%2F2019%2F05%2F23%2FMySQL%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.什么是悲观锁？乐观锁？2.如何选择？ 来源：漫话：如何给女朋友解释什么是乐观锁与悲观锁 为什么加购物车的时候还有，但是付款的时候提示没有了呢？是因为下单减库存是用了乐观锁，属于并发控制的一种方式。 并发控制当程序中可能出现并发的情况时，我们就需要通过一定的手段来保证在并发情况下数据的准确性，通过这种手段保证了当用户和其他用户一起操作时，所得到的结果和他单独操作时得到的结果是一样的。 这种手段就叫做并发控制。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。 没有做好并发控制，就可能导致脏读、幻读和不可重复读等问题。 我们常说的并发控制，一般都和数据库管理系统（DBMS）有关，在DBMS中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 实现并发控制的主要手段大致可以分为乐观并发控制和悲观并发控制两种。 在开始介绍之前要明确一下：无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。所以，不应该拿乐观锁、悲观锁和其他的数据库锁等进行对比。 悲观锁当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。 这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。 之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。 但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。 乐观锁乐观锁（ Optimistic Locking ） 是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。 悲观锁实现方式悲观锁的实现，往往依靠数据库提供的锁机制。在数据库中，悲观锁的流程如下： 在对记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。 我们拿比较常用的MySql Innodb引擎举例，来说明一下在SQL中如何使用悲观锁。 要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0; 我们举一个简单的例子，如淘宝下单过程中扣减库存的需求说明一下如何使用悲观锁： 12345678//0.开始事务begin; //1.查询出商品库存信息select quantity from items where id=1 for update;//2.修改商品库存为2update items set quantity=2 where id = 1;//3.提交事务commit; 以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。 如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。 上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。 乐观锁实现方式使用乐观锁就不需要借助数据库的锁机制了。 乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。 CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 比如前面的扣减库存问题，通过乐观锁可以实现如下： 1234//查询出商品库存信息，quantity = 3select quantity from items where id=1//修改商品库存为2update items set quantity=2 where id=1 and quantity = 3; 以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。 以上更新语句存在一个比较重要的问题，即传说中的ABA问题。 比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。 有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。改为以下方式即可： 1234//查询出商品信息，version = 1select version from items where id=1//修改商品库存为2update items set quantity=2,version = 3 where id=1 and version = 2; 乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。 除了version以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。 以上SQL其实还是有一定的问题的，就是一旦发上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。 对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。 有一条比较好的建议，可以减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！如下： 1234//修改商品库存update item set quantity=quantity - 1 where id = 1 and quantity - 1 &gt; 0 以上SQL语句中，如果用户下单数为1，则通过quantity - 1 &gt; 0的方式进行乐观锁控制。 以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。 高并发环境下锁粒度把控是一门重要的学问，选择一个好的锁，在保证数据安全的情况下，可以大大提升吞吐率，进而提升性能。 如何选择在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。 1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。 2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。 随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL脏读、不可重复读和幻读]]></title>
    <url>%2F2019%2F05%2F23%2FMySQL%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[什么是脏读？不可重复读和幻读？ “读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。了解它们有助于理解各隔离级别的含义。其中包括脏读、不可重复读和幻读。 事务隔离级别我们知道，在数据库中，事务是要满足ACID的，即满足原子性、一致性、持久性以及隔离性。 在数据库事务的ACID四个属性中，隔离性是一个最常放松的一个。可以在数据操作过程中利用数据库的锁机制或者多版本并发控制机制获取更高的隔离等级。 但是，随着数据库隔离级别的提高，数据的并发能力也会有所下降。所以，如何在并发性和隔离性之间做一个很好的权衡就成了一个至关重要的问题。 奥。你说的这个我明白，但是具体的隔离级别和读现象有什么关系呢？ 不同的隔离级别会导致和解决不同的读现象，我先给你介绍下都有哪些读现象吧。 脏读第一种读现象叫做脏读，顾名思义，就是读到了脏数据，即无效数据。 脏读。是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交(commit)到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。 打个比方，什么情况下会出现脏读呢，就是我在我的本地修改了AbstractPayExecutor这个类的代码，我还没提交。 为了更快的知道这个类被我改成了什么样，你跑到我的电脑前面阅读了我修改后的代码。这就是脏读了。因为我没有提交代码，说明我随时可能撤销刚刚的修改，这时你之前读取到的数据就是脏数据了。 这种情况下，多个开发者之间的并发性很高，几乎没有任何阻塞。师妹想知道代码最新的是什么样，她就读到了最新代码。但是，这个代码我还没有提交，这就是个脏数据。我们之间的隔离性很差。 这显然不是我们想要看到的现象啊。 是的。我们不希望代码在未提交的状态下被别人读到。 嗯，那脏读这种情况实在是太不应该了。 是的，接着我们看下提高一点隔离性。 不可重复读为了解决脏读问题，我们决定提高一点隔离性，我在修改代码的时候，不允许她跑到我的电脑前面读代码。她只能读取到我提交后的代码。 当我需要修改AbstractPayExecutor这个类的时候，我需要告诉师妹让她等一下，等我提交完代码她再读。这就有效的解决了脏读，因为师妹读到的代码全部都是我已经提交的代码。 但是，提高了我们之间的隔离性，并发性就降低了一些。因为她要等我提交代码后才能阅读。 嗯，这样是好了一些，我不会出现脏读了。 嗯，脏读没有了，但是还会存在不可重复读问题。 不可重复读，就是开始我说的那种AbstractPayExecutor种常量被删除的现象吗。 差不多吧。 我们已经提高了一点隔离级别，使得脏读现象没有了。但是并没有办法避免以下现象： 师妹在阅读AbstractPayExecutor的代码，代码中定义了一个LOGGER常量。然后我修改了代码，把这个常量删除了，并提交。师妹更新了代码继续阅读，但是她却发现LOGGER这个常量没有了。 两次读取，得到的文件内容不一样。严重了影响了她的学习进度。这就是不可重复读现象。 不可重复读。是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。 师兄，有没有可能我再读某个类的代码的时候，你先不要修改这个类呢？ 可以呀。这就是进一步提升了隔离性了。 幻读为了让师妹可以更好的学习代码。我们约定好，当她阅读某个类的代码的时候，她通知我以下，然后我就不修改这个类的代码。避免出现不可重复读的情况。 这样，我们之间的并发性就又降低了一些。不仅仅她阅读哪个类有了一些限制，我修改哪个类也有了要求了。 就这样相安无事了一段时间，师妹又来找我了。 师兄呀，你又新增了几个类了么，刚刚我看的时候只有20几个类呀。 嗯嗯，是的呀，我又增加了2个枚举类和1个Java类。 好吧，那我只能继续阅读这几个新增的类了。 在提升了隔离性之后，虽然我不会修改师妹正在阅读的类，师妹也不会阅读我正在修改的类。但是我可能会增加或者删除几个类。这时候和师妹之前读取到的类的总个数就有了变化。也就是说，她之前读到的数据就不准确了。这就是幻读。 幻读。指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。比如同一个事务A内第一次查询时候有n条记录，但是第二次同等条件下查询却又n+1条记录，这就好像产生了幻觉。 幻读是不可重复读的一种特殊场景。 哦，我明白了。原来这就是幻读。 是的，幻读的情况其实也是可以解决的。 我知道如何解决，就是我读代码的时候你不要做任何修改。 如果想要解决幻读问题，那么就只能在师妹阅读代码的时候，我什么也不做了。这样我们之间的隔离性最高，但是并发性就最低了。 要想解决脏读、不可重复读、幻读等读现象，那么就需要提高事务的隔离级别。但与此同时，事务的隔离级别越高，并发能力也就越低。所以，还需要读者根据业务需要进行权衡。 总结事务的隔离性上，从低到高可能产生的读现象分别是：脏读、不可重复读、幻读。 脏读指读到了未提交的数据。 不可重复读指一次事务内的多次相同查询，读取到了不同的结果。 幻读师不可重复读的特殊场景。一次事务内的多次范围查询得到了不同的结果。 通过在写的时候加锁，可以解决脏读。 通过在读的时候加锁，可以解决不可重复读。 通过串行化，可以解决幻读。 以上这几种解决方案其实是数据库的几种隔离级别。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Force Index]]></title>
    <url>%2F2019%2F05%2F23%2FMySQL-Force-Index%2F</url>
    <content type="text"><![CDATA[以下的文章主要介绍的是MySQL Force Index强制索引,以及其他的强制操作，其优先操作的具体操作步骤如下：我们以MySQL中常用的hint来进行详细的解析。 强制索引MySQL FORCE INDEX SELECT * FROM TABLE1 FORCE INDEX (FIELD1) …以上的SQL语句只使用建立在FIELD1上的索引，而不使用其它字段上的索引。 忽略索引 IGNORE INDEX SELECT * FROM TABLE1 IGNORE INDEX (FIELD1, FIELD2) …在上面的SQL语句中，TABLE1表中FIELD1和FIELD2上的索引不被使用。 关闭查询缓冲 SQL_NO_CACHE SELECT SQL_NO_CACHE field1, field2 FROM TABLE1;有一些SQL语句需要实时地查询数据，或者并不经常使用（可能一天就执行一两次）,这样就需要把缓冲关了,不管这条SQL语句是否被执行过，服务器都不会在缓冲区中查找，每次都会执行它。 MySQL force Index 强制索引：强制查询缓冲 SQL_CACHE SELECT SQL_CALHE * FROM TABLE1;如果在my.ini中的query_cache_type设成2，这样只有在使用了SQL_CACHE后，才使用查询缓冲。 优先操作 HIGH_PRIORITY HIGH_PRIORITY可以使用在select和insert操作中，让MySQL知道，这个操作优先进行。 SELECT HIGH_PRIORITY * FROM TABLE1;滞后操作 LOW_PRIORITY LOW_PRIORITY可以使用在insert和update操作中，让MySQL知道，这个操作滞后。 update LOW_PRIORITY table1 set field1= where field1= …延时插入 INSERT DELAYED INSERT DELAYED INTO table1 set field1= …INSERT DELAYED INTO，是客户端提交数据给MySQL，MySQL返回OK状态给客户端。而这是并不是已经将数据插入表，而是存储在内存里面等待排队。当MySQL有空余时，再插入。另一个重要的好处是，来自许多客户端的插入被集中在一起，并被编写入一个块。这比执行许多独立的插入要快很多。坏处是，不能返回自动递增的ID，以及系统崩溃时，MySQL还没有来得及插入数据的话，这些数据将会丢失。 强制连接顺序 STRAIGHT_JOIN SELECT TABLE1.FIELD1, TABLE2.FIELD2 FROM TABLE1 STRAIGHT_JOIN TABLE2 WHERE …由上面的SQL语句可知，通过STRAIGHT_JOIN强迫MySQL按TABLE1、TABLE2的顺序连接表。如果你认为按自己的顺序比MySQL推荐的顺序进行连接的效率高的话，就可以通过STRAIGHT_JOIN来确定连接顺序。 MySQL force Index 强制索引:强制使用临时表 SQL_BUFFER_RESULT SELECT SQL_BUFFER_RESULT * FROM TABLE1 WHERE …当我们查询的结果集中的数据比较多时，可以通过SQL_BUFFER_RESULT.选项强制将结果集放到临时表中，这样就可以很快地释放MySQL的表锁（这样其它的SQL语句就可以对这些记录进行查询了），并且可以长时间地为客户端提供大记录集。 分组使用临时表 SQL_BIG_RESULT和SQL_SMALL_RESULT SELECT SQL_BUFFER_RESULT FIELD1, COUNT(*) FROM TABLE1 GROUP BY FIELD1;一般用于分组或DISTINCT关键字，这个选项通知MySQL，如果有必要，就将查询结果放到临时表中，甚至在临时表中进行排序。SQL_SMALL_RESULT比起SQL_BIG_RESULT差不多，很少使用。 创建索引索引的创建可以在CREATE TABLE语句中进行，也可以单独用CREATE INDEX或ALTER TABLE来给表增加索引。以下命令语句分别展示了如何创建主键索引（PRIMARY KEY），唯一索引（UNIQUE）和普通索引（INDEX）的方法。 12345678910111213mysql&gt;ALTER TABLE `表名` ADD INDEX `索引名` (column list); mysql&gt;ALTER TABLE `表名` ADD UNIQUE `索引名` (column list); mysql&gt;ALTER TABLE `表名` ADD PRIMARY KEY `索引名` (column list); mysql&gt;CREATE INDEX `索引名` ON `表名` (column_list); mysql&gt;CREATE UNIQUE INDEX `索引名` ON `索引名` (column_list); mysql&gt;ALTER TABLE `表名` ADD INDEX (`id`,`order_id`);给article表增加id索引，order_id索引 mysql&gt;ALTER TABLE `表名` ADD INDEX `id`;//给article表增加id索引 2、重建索引 重建索引在常规的数据库维护操作中经常使用。在数据库运行了较长时间后，索引都有损坏的可能，这时就需要重建。对数据重建索引可以起到提高检索效率。 Sql代码 收藏代码mysql&gt; REPAIR TABLE table_name QUICK; 3、查询数据表索引 mysql&gt; SHOW INDEX FROM table_name; 4、删除索引 删除索引可以使用ALTER TABLE或DROP INDEX语句来实现。DROP INDEX可以在ALTER TABLE内部作为一条语句处理，其格式如下： Sql代码 收藏代码mysql&gt;DROP index index_name ON table_name (column list); mysql&gt;ALTER TABLE table_name DROP INDEX index_name (column list); mysql&gt;ALTER TABLE table_name DROP UNIQUE index_name (column list); mysql&gt;ALTER TABLE table_name DROP PRIMARY KEY index_name (column list); 在前面的三条语句中，都删除了table_name中的索引index_name。而在最后一条语句中，只在删除PRIMARY KEY索引中使用，因为一个表只可能有一个PRIMARY KEY索引，因此也可不指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。如果从表中删除某列，则索引会受影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。 5、强制使用索引 Sql代码 收藏代码mysql&gt;SELECT * FROM TABLE1 FORCE INDEX (索引名或PRIMARY) ; 6、联合索引 Sql代码 收藏代码mysql&gt;alter table test add key id_a_b(a,b) ; 对于联合索引当条件为 a=1 and b=1 则使用索引 ，当a=1 时也使用索引 当单独使用b=1时则不使用索引。]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL Explain]]></title>
    <url>%2F2019%2F05%2F23%2FMySQL-Explain%2F</url>
    <content type="text"><![CDATA[MySQL永流传]]></content>
  </entry>
  <entry>
    <title><![CDATA[图片导入]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%9B%BE%E7%89%87%E5%AF%BC%E5%85%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题: 导入的图片为什么不建议psd格式？最好用什么格式？ 图片的尺寸有什么要求？必须是正方形吗？ 图片加载不出来，会是什么原因？ 动手尝试一下Wrap Mode参数的区别，加深理解。 Mip Maps是什么？ 如何预览mipmaps贴图？mip级别越小越模糊吗？ 图片导入设置 游戏开发中许多地方都会用到图片（又叫贴图、纹理）资源，比如模型的贴图、UI界面图片、粒子特效的图片等等。今天我们来学习一下图片导入的设置。 对于大部分图片来说，导入设置只需要保持默认值即可。但是你需要了解各个参数，在遇到问题的时候有线索去解决。 图片要求格式Unity几乎支持所有的图片格式，包括：BMP、EXR、GIF、HDR、IFF、JPG、PICT、PNG、PSD、TGA、TIFF ** 最佳实践 **虽然Unity支持PSD文件，但是尽量不要直接将PSD文件放在工程中使用。因为PSD文件一般都很大，会大幅增加工程文件大小，不利于工程管理和版本控制。一般建议使用png格式。 尺寸大小理想情况下，贴图的宽高应该是2的n次幂（如2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048等），可以加快纹理取样的速度，减少内存占用，提高性能。在可能的情况下，尽可能使用2的n次幂大小的贴图。 不一定需要是正方形的，例如可以是64*128的分辨率。 不同的硬件平台支持的贴图最大分辨率也不同。常见平台支持的最大尺寸如下： 如果上图的表格看不太明白，不用太在意。只需要记住如果贴图出现加载不出来的情况，看一下是否贴图尺寸过大。 ** 但是需要注意 ** 目前Unity的设置中，最大贴图尺寸只能选到8192。 Mali-Txxx GPU和OpenGL ES 3.1最多支持4096px的cubemap贴图。 导入设置如果你的工程设置的是3D，那么图片导入后的默认设置如下： 3D模式图片导入的默认设置 如果你的工程设置的是2D，那么图片导入后的默认设置如下： 2D模式图片导入的默认设置 ** 复习一下 **工程的3D或2D可以在创建工程时设置，也可以在菜单栏Edit &gt; Project Settings &gt; Editor中的 Default Behavior Mode 中修改 ** 注意 **此处的设置并不会改变图片源文件，只是Unity引擎在使用这个图片时，会使用设置后的图片数据。 Texture Type贴图有多种用途，在导入的时候也需要进行不同的设置。Texture Type属性的可选项有： Default：最常用的设置，可以设置贴图导入的大部分属性 Normal Map：用于法线贴图（法线贴图是模型常用的一种贴图类型） Editor GUI and Legacy：用于编辑器GUI或者旧的OnGUI Sprite (2D and UI)：用于2D游戏和UI Cursor：用于自定义光标 Cookie：用于灯光的Cookie属性的贴图 Lightmap：用于光照贴图（在max或maya中烘焙过的模型的光照贴图导入后使用此选项） Single Channel：用于只需要一个通道的情况 Texture Shape 2D：默认，大部分的图片都会使用2D设置，例如模型贴图、UI等 Cube：贴图会被设置为cubemap，一般用于天空盒、反射等情况。这种帖图需要按照特定的格式制作，在Unity中会被展开为立方体或球体。 sRGB(Color Texture)默认选中。选中此选项可以让贴图的颜色存储在伽马空间中。非HDR颜色的纹理应该选中此属性（如反射和高光贴图）。如果贴图存储了特定含义的信息，并且在shader中需要使用对应值（例如平滑度或金属度）则不要选中此属性。 如果现在不理解，保持默认值即可。通过后续的课程会了解这个属性的用途。 Alpha Source设置alpha通道的生成方式，默认是 Input Texture Alpha。 None：不管图片本身是否有alpha通道，该贴图将没有alpha通道。 Input Texture Alpha：如果图片有alpha通道，使用这个alpha通道；如果没有，则该贴图也没有alpha通道。 From Gray Scale：从图片的RGB值的平均值生成alpha通道。 Alpha is Transparency默认选中。是否将alpha通道作为图片的透明度，一般情况都会选中；某些情况下可能仅在代码中使用alpha通道中的数据，但是图片本身是非透明的，则不选中。 Advanced（高级设置）Non Power of 2（非2的N次幂）上文中介绍了贴图尺寸是2的n次幂会对提高性能，在可能的情况下应该尽可能使用2的n次幂大小。但是有些情况可能需要用到非2的n次幂的情况，就需要设置这个属性。这个属性的默认值是To nearest。 ** 选项 ** ** 功能 ** None 保持贴图原始的尺寸 To nearest 贴图会缩放到最接近的2的n次幂的尺寸。如 257x511 px 贴图会缩放到 256x512 px。注意，PVRTC格式要求贴图是正方形的，如果使用此格式贴图会放大到 512x512 px。 To larger 贴图会缩放到更大尺寸的2的n次幂的尺寸。如 257x511 px 贴图会缩放到 512x512 px。 To smaller 贴图会缩放到更小尺寸的2的n次幂的尺寸。如 257x511 px 贴图会缩放到 256x256 px。 Read/Write Enabled默认禁用。有时候需要在代码中获取贴图中的数据（如Texture2D.SetPixels，Texture2D.GetPixels和其他Texture2D函数），需要启用此功能才能操作。 ** 注意 **启用此选项后，会创建该Texture的副本，该贴图占用的内存会加倍。如果不是一定需要读写贴图数据，不要选中此选项。该选项仅适用于未压缩和DXT压缩类型的贴图纹理，其他压缩类型的贴图无法使用。 Generate Mip MapsMipmap是一组逐渐缩小的图片，用于提高3D实时渲染的性能。远离相机的物体会使用更小尺寸的贴图。使用Mipmap会提高33%的内存占用，但是不用mipmap会导致更大的性能损失。对于游戏内的贴图，基本上都应该使用mipmap，例外的情况有：UI图片、天空盒、光标、Cookie贴图。Mipmap也可以避免很多种贴图失真和闪烁的情况。 ** 选项 ** ** 作用 ** Generate Mip Maps 选中此选项来启用生成mipmap Border Mip Maps 默认不选中。选中此选项来避免不同级别的mipmap的边界的颜色发生混合。用于灯光的cookie贴图。 Mip Map Filtering 有两个mipmap滤波（不需要深入了解，想了解的话可以搜索“图像滤波”）的选项，用于优化图像的质量。默认选项是Box。 Box 这是最简单的生成mipmap的方式。 随着尺寸的减小，MIP级别变得更加平滑。 Kaiser mipmap的尺寸在下降时会运行锐化算法。如果贴图在远处太模糊，可以试试这个选项。 Fadeout Mip Maps 启用此功能可使MIP图层随着MIP级别的增加而渐变为灰色。这用于细节度较高的贴图。最左边的滚动条是第一个开始淡出的MIP级别。最右侧的滚动条定义了贴图完全变灰的MIP级别。 ** mipmap预览 **贴图的preview窗口中，可以通过右上角的滚动条查看mipmap不同级别的情况。 mipmap预览 Wrap Mode默认值是Clamp。这个属性设置贴图在平铺时的不同形式。 Wrap Mode需要同时设置材质球中的Tiling属性，才能看出效果。 Repeat平铺时自身重复。 贴图设置为Repeat模式 Clamp贴图的边缘会被拉伸。 贴图设置为Clamp模式 Mirror贴图在重复时会呈现镜像的效果。 贴图设置为Mirror模式 Mirror Once只镜像一次，然后边缘拉伸。 贴图设置为Mirror Once模式 Per-axis每个轴上可以单独设置平铺的模式。 Per-axis模式 贴图设置为Per Axis，U轴是Repeat，V轴是Mirror Filter Mode默认是bilinear。选择纹理在被3D变换拉伸时如何被过滤。 ** 模式 ** ** 功能 ** Point (no filter) 被拉伸时会以放大或缩小像素点 Bilinear 被拉伸时会用双线性计算过渡 Trilinear 和Bilinear一样，但是不同级别的mipmap之间也会模糊。 这三个选项效果差别不是太大，一般保持默认即可。 Aniso Level以陡峭的角度查看纹理时提高纹理质量。对于地板和地面纹理来说，使用这个参数很有用，但是相应的也会占用显卡的资源。 压缩设置压缩设置中，可以设置一个整体的参数，也可以对不同平台进行单独设置。 压缩设置部分 Max Size设置贴图的最大尺寸 Resize Algorithm缩放算法 Mitchell 默认的高质量缩放算法 Bilinear 对于噪波贴图，这个算法可能有更锐利的细节 Compression压缩的质量设置。压缩质量越高，图片的保真度越高，导入Unity编辑器时所花的时间越多。 Format在Default中，Unity会根据你选择的压缩质量，自动选择Format。也可以对不同的平台单独设置。 Use Crunch Compress这是一种有损的压缩格式。这种算法能最大程度降低贴图占用的空间。Crunch Textures可能需要很长时间才能进行压缩，但运行时的解压缩速度非常快。 Label设置还记得Project中可以通过label搜索资源吗？资源的label就是在这里设置的。一个资源可以设置多个label。 label设置 总结图片导入的参数较多，一般除了设置图片类型和大小，其他使用默认的参数即可。所以参数不需要全部记住，只需要有个大概的印象即可。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[预计算实时GI的优化]]></title>
    <url>%2F2019%2F05%2F22%2F%E9%A2%84%E8%AE%A1%E7%AE%97%E5%AE%9E%E6%97%B6GI%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 昨天我们学习了烘焙GI的优化，今天我们来学习一下预计算实时GI的优化。 相比烘焙GI的优化，预计算实时GI优化的空间非常大。一个预计算需要数小时的场景，通过优化可以缩短到几分钟。 全局参数优化我们在学习预计算GI时，对于全局的参数，只设置了一个Indirect Resolution。 Indirect Resolution越大，光影细节程度越高，但是相应的预计算时间越长。 复习一下Indirect Resolution的参考值： 场景 实时GI合适的分辨率室内 每单位2 - 3个像素户外 每单位0.5-1个像素地形 每单位0.1 - 0.5像素建议场景中1个单位=1米为了更好地理解这里面的原因，更好的学习下面的优化参数，在这我们先解释一下Chart。 【选读】理解Chart这部分内容可以帮助你更好的理解一些设置及后续优化的方法。但是略过此部分也不会影响Unity实时GI的优化设置。 在预计算实时GI中，Chart是光照贴图的一个区域，用来映射到对应的物体的Lightmap UV上。Chart是一张大的光照贴图中的一小块，包含了对应物体的光照信息。一个Chart由两个部分组成：光照信息和主要光的方向。 如图所示，左下角的6个小方块就是Cube对应的6个Chart 预计算实时GI在运行时，会计算所有Chart中的所有像素的光照。场景中过多的Chart是影响预计算时间的重要原因之一，所以理解Chart工作的原理以及如何管理它们对于优化预计算时间非常重要。 Lightmap的UV边缘会留出半个像素来避免和其他区域的渗透（bleed）现象 默认情况下，不管一个物体在场景中的尺寸或UV的大小，一个Chart最小是44像素，也就是16像素。例如，如果物体是11米，物体有一个Chart，indirect resolution设置的是1，那么这个物体就需要16个像素。Chart的4*4最小尺寸（单个边至少4个像素）保证Unity可以将Chart的边缘缝，保证物体边缘光照的连续性。 如图中边长1厘米的cube，依然需要6个Chart，每个Char是4*4像素 如果一个物体是1*1厘米，但是拥有50个UV Chart，尽管这个物体很小，但Unity需要为这个物体创建800像素。一个物体拥有大量的chart可以大幅提高所需像素的数量。更多的像素意味着更多的照明预计算和更多的运行时计算、压缩、存储。在复杂的场景中，可能导致非常长时间的预计算和运行时的性能下降。 不合适的Chart是照明预计算无法完成或花费太长时间的罪魁祸首。基于这一点，很多减少预计算时间的策略是减少场景中的图表数量。 一个物体的Chart数量主要是由Lightmap UV（2通道UV）决定的，但是也可以在外部的3D建模软件（合并UV shell）或者Unity中进行优化。 使用Probe Lighting对于小尺寸的物体可能会大幅增加Chart数量和所需计算的像素的数量。所以对于这些对间接光贡献不大（由于尺寸小，间接光的贡献有限）的小物体来说，不参与实时GI的预计算是更好的选择。 这些小物体，只需要通过Light Probe接收光照信息就可以实现非常好的光照效果，没有他们反射的间接光不会对场景光影造成影响。 所以在这一步：将场景中尺寸较小的物体整理到一起，取消他们的Lightmap Static。同时在场景中加入Light Probe给这些物体提供间接光。 物体MeshRenderer设置 UV Charting Control在上面Chart小节，我们知道了Chart会对预计算的时长、运行时的效率影响很大，除了通过外部3D建模软件来优化Lightmap UV以外（较少采用此方法），在Unity中也可以进行优化（常用方法）。 Optimize Realtime UVs如果美术同学已经手动优化了Lightmap UV，那么不要勾选此选项，可以跳过这一部分。如果没有，请勾选并接着看。 Max DistanceUnity自动优化合并UV时，只考虑小于Max Distance的两个UV块。在保证视觉效果的基础上，这个值越大，Chart相对会越少，效率会越高。 Max Angle如果两个UV块的夹角小于Max Angle，Unity会将两个UV块缝合，共享同一条边，相当于减少了Chart。 Ignore Normals有些时候，Unity会将一个Mesh拆分（比如顶点数过多），但是同时也会将Chart拆分开。这可能会增加Chart数量并且增加预计算时间，光影效果也可能不正常。勾选这个选项可以解决这个的问题。 最佳实践优化UV时，目的是减少Chart的数量，同时减少光影的失真。 调整单个物体的参数时，建议将物体放到一个单独的场景进行调整，这样预计算很快，更容易直观看到调整参数后的结果。然后将参数通过复制或制作成Prefab（后面会详细讲解）的形式，将参数保存下来。 参数进行调整后，对比上一张图，小的Chart就少了很多 Cluster（簇）之前我们讲了簇的概念：实时GI并没有用真正的网格来计算光影，而是生成了简化的模型，然后用简化后的模型来计算光照。 这个简化的模型是如何生成的？简化后的复杂度如何？这里面还有很大的优化空间。 可以通过Scene看到当前的Clusters 簇的大小和什么有关呢？ Indirect Resolution Lightmap Paramter中的Resolution和Cluster Resolution 边长1米的立方体和边长5米的地面，实时GI默认值下Cluster的边长也是1米 Cluster的边长变成了1/4 **Cluster的边长 = Cluster Resolution/(Indirect Resolution* Resolution) ** 显然对于场景中的复杂物体，Cluster可以相对多一些，但是对于场景中的大地形来说，Cluster就不需要那么多，可以将这些远处的大地形、大物体的Resolution设置到0.01-0.05，如果效果达不到预期，再增加这个值。 Lightmap Parameters中的其他参数Irradiance BudgetIrradiance Budget决定了光照贴图中每个像素在Cluster之间取样时可以使用的内存，决定了光照的精准度。越低的值光影会更模糊，越高的值光影会越清晰，但是也增加了运行时的内存和CPU占用。 如果使用实时GI后，在运行时帧率比较低，可以尝试降低这个值。优先降低光影细节比较少的物体，比如远处的、模糊的物体。 Irradiance QualityIrradiance Quality决定了光照贴图的一个像素在进行周围Cluster的可见性检测时所使用的射线的数量。 更高的值可以有更好、更精准的光影结果，但同时会增加预计算的时间。不过这个值不会影响运行时的性能。 Lightmap Parameters最佳实践由于Lightmap Parameters是存在于工程中的资源文件，所以建议针对不同类型、不同用途的物体创建对应的Lightmap Parameters。方便对场景中的物体进行设置以及添加新物体时的光照参数设置。 总结今天学习了使用Unity中的光照系统中的实时GI的优化，可以将本篇当作一个优化手册（检查清单），在需要优化时对照逐项检查。 今日思考题拿出你的场景，记录下优化前预计算的时长，试试这些参数调整后，预计算节省了多长时间。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[烘焙GI的优化]]></title>
    <url>%2F2019%2F05%2F22%2F%E7%83%98%E7%84%99GI%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 现在我们已经学会了如何使用烘焙GI作为一个场景的照明系统。但是实际操作时，你可能会遇到各种问题： 烘焙出来效果不好，这种情况主要是需要调参数和灯光（找美术同学帮忙吧） 烘焙时间过长，有些甚至渲染几天都没有渲染完成 今天我们就来学习一下烘焙GI的优化方法，如何在尽可能保证效果的情况下，提高烘焙的速度，提高工作的迭代效率，减少光照贴图的存储空间占用。 烘焙GI的优化主要包括两个方面： 全局参数的优化：如果你的场景是一个室外的场景，但是用了适合室内场景的很高的分辨率，那么烘焙时间一定会很长。 单个物体的优化：场景中物体的大小、重要程度都不相同，如果只使用了统一的全局参数，那这里面就有优化空间。 全局参数的优化全局参数是烘焙效果和速度的基础，尽量设置符合场景大多数物体的参数。全局参数在Lighting面板上，下面我们来看一下各个参数对效果和烘焙速度的影响。 由于烘焙GI有两种：Progressive Lightmapper和Enlighten，建议使用默认的Progressive Lightmapper。下面我们分开讲解。 Progressive Lightmapper参数优化如果Lightmapper是Progressive，那么跟我一起按照下面的顺序检查Lighting面板中的参数。参数的含义我们之前已经详细介绍过了，在这就不再重复。 使用默认参数，烘焙这个简单场景所需的时间是2分6秒 使用默认参数，烘焙这个简单场景所需的时间是2分6秒 Direct Samples和Indirect SamplersDirect Samples默认值是32，Indirect Samples默认值是500。如果场景网格比较简单，比如平面较多，可以大幅减少这两个值。如果场景中物体比较复杂，不规则的面较多，从小到大逐渐增加这个值。 建议在能达到目标效果的基础上，该值尽量低，如果你的场景够简单，可以尝试用1。 小技巧如果你的场景里建筑风格都类似，可以用一个建筑放到一个单独的场景里来进行参数的配置测试，寻找最佳的参数配置。可以大幅提高效率。就像我使用的这个只有一个房子的场景。 使用8，32的值，时间缩短到了16秒 仔细对比这张图和最开始默认值的那张图，你会发现效果是有区别的，但是如果效果能接受，不是节省了很多时间么？场景编辑、迭代效率也会提高很多。 Bounce间接光反射的次数，默认是2。设置为0就会没有间接光的效果，所以建议设置为1，如果效果不能达到要求，再增加。 烘焙时间减少了21秒 Lightmap Resolution一个单位使用光照贴图的像素的个数，默认值是40，也就是1米会使用40个像素来记录光照信息。 这个值不仅会影响烘焙的时间，更会影响光照贴图所占的存储空间，影响打包的体积。但是这个值非常影响光影的效果，所以对待这个值一定要慎重。最好的办法就是对待不同类型的物体单独设置，比如细节很多的物体设置的高一些，大的平面设置的低一些。 使用20的值，烘焙时间缩短了75%，但是能直接看到光阴质量的降低 Ambient OcclusionAO影响的是环境光，对于有方向的光源不受其影响。如果你的场景里类似孔洞、墙壁拐角的地方很少，那么可以不启用AO。启用AO会增加一定的烘焙时间，烘焙时间会随着场景的复杂程度非线性增加。 如图开启了AO以后，烘焙时间增加了6秒 Direction Mode是否存储方向信息用于法线贴图。如果你的场景中没用到法线贴图，那么可以选择Non-directional来节省一半的存储空间。（该参数对于烘焙时间没有优化） 贴图总大小是2.7M，相对默认参数的5.3M减少了一半，但是由于房子用到了法线贴图，所以视觉效果会受影响 Lightmap Parameter本节我们只学习Baked GI相关的参数。 Anti-aliasing Samples抗锯齿采样数。采样数越低，锯齿越明显，烘焙时间越快。采样数越高，锯齿越不明显，烘焙时间越长。默认是8。 降低到1，烘焙时间缩短了14秒 Baked AOBaked AO中的两个值，提高以后可以增强AO的效果，但是会增加烘焙的时间。 Enlighten参数优化如果你是从旧的工程升级过来Lightmapper可能会是Enlighten或者你手动选择了Enlighten，参数有一些不同，下面我们学习一下和Progressive Lightmapper不同的参数。 由于Enlighten也是预计算实时GI的后端，所以此处参数的优化方案对实时GI也有借鉴意义。明天我们会进行详细解释。 由于使用Enlighten时Unity不统计烘焙时长，这里用秒表计时56秒 你发现使用Enlighten烘焙时间少很多，但是最终效果只能等烘焙完后才能看到，不像Progressive在烘焙过程中，可以在场景中看到每一块烘焙的实时进展。 但是如果你仔细看场景，你会发现场景中的光照其实是不正确的，房子有几块光照很黑。（其实如果你仔细看上面Progressive中的光照，场景中也有几个地方的光照是不正确的） 通过Scene窗口的Baked GI中的Albedo模式，可以看到下图中，有很大一块都是黑色的。 这是为什么呢？ 解决UV问题烘焙GI的光照贴图使用了模型的第二套UV（UV2），一般模型在制作时为了节省时间并没有UV2或者UV2可能存在问题。那么如何解决这个问题呢？ Unity中有一个快速解决的办法就是自动生成光照贴图UV。具体怎么做呢？选中Project中对应的模型文件。 在模型导入选项中勾选Generate Lightmap UVs，这样Unity会自动生成UV2，供烘焙光照贴图使用。勾选后别忘了点击Apply。 这时候我们再次烘焙看一下效果： 现在光照贴图正常了 Enlighten有一个优势就是有GI缓存（菜单栏Edit &gt; Perferences打开），第一次烘焙完成后，后续进行烘焙时，Unity会在缓存中获取可用的数据加快烘焙的过程。 Enlighten中与Progressive中同名的参数作用是一样的，在这就不重复讲解了。 Indirect Resolution间接光的分辨率。提高这个值可以增强间接光的效果，但是烘焙时间会加长。 Final Gather能让场景更真实，但是选中会增加额外烘焙时间。 Lightmap Parameter对于Enlighten后端，Lightmap Parameter中Precomputed Realtime GI部分的参数虽然标记为实时GI的参数，但是对于烘焙GI也会有影响（对于Progressive模式没有影响）。 Resolution和Cluster Resolution虽然不会影响光照贴图中的分辨率，但这个参数会影响间接光的Cluster的生成。会在下一节实时GI优化中讲解。 这两个值越大，间接光的效果越好，但是Clustering阶段的时间会越长，造成总体烘焙时间越长。 Direct Light Quality更高的值会让软阴影更准确，但是会增加烘焙时间。 单个物体的优化Scale In Lightmap 可以单独设置单个物体在光照贴图中的分辨率，如果全局分辨率是40，单独设置Scale In Lightmap为0.1，那么该物体的1米所占的像素为40x0.1=4个。 对于场景内的大型物体如地面、墙壁等可以用小一点的值。对于场景内非常精细的物体，可以用大一点的值。 调试技巧可以通过Lighting面板的Object maps查看选中的物体所在的光照贴图的详细情况。 如果没有显示对应的光照贴图，请检查：1、已经选中一个Static的物体 2、场景已经烘焙完成 3、烘焙过后没有修改过场景 Lightmap Parameter单个物体也可以单独设置Lightmap Parameter。根据物体的用途和在场景中的重要程度，参考上面讲到的Lightmap Parameter进行设置优化。 一般仅在发现这类物体对烘焙时间、光照效果影响较大时才进行调整，否则保持默认值即可。 总结今天学习了使用Unity中的光照系统中的烘焙GI的优化，可以将本篇当作一个优化手册（检查清单），在需要优化时对照逐项检查。 今日思考题构建一个简单场景，调整本文中提到的参数，看看对烘焙时长、光照贴图大小和最终效果有什么影响~]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[烘焙GI]]></title>
    <url>%2F2019%2F05%2F22%2F%E7%83%98%E7%84%99GI%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 采用Progressive Lightmapper烘焙中的场景 除了预计算实时GI这种照明技术外，我们还知道有一种照明方案叫Baked lightmaps（烘焙光照贴图） 什么是烘焙光照贴图？烘焙光照贴图是将场景的光影信息提前计算，将计算的结果写入光照贴图中。这个计算是在游戏发布前进行的，在游戏运行时的光影信息通过一张或多张光照贴图直接读取，除了贴图占用的内存外，几乎不产生其他的计算资源消耗。 这是一种用空间换时间的技术，在保证场景图形效果的基础上，还能有非常高的运行效率，非常适合计算能力较低的平台，比如移动平台。 优点通过光照贴图可以生成非常高质量的静态物体的阴影，并且运行时性能好，除了贴图占用的内存外没有额外开销 支持间接光照（从其他物体表面反射的光） 缺点没有实时光照，这意味着无法在运行时修改光源的属性（颜色、强度、位置、旋转等） 从静态物体到动态物体的阴影只能使用Light Probe技术得到，而且分辨率很低 会增加打包体积大小和运行时的内存。相对于实时GI，光照贴图会包含更多的光照细节信息，会占用更多的空间。 烘焙光照贴图的流程烘焙的整个流程大致如下：1、场景环境设置2、对场景打光3、设置静态物体的Lightmap Static标签和Renderer参数4、设置烘焙的参数5、烘焙，根据烘焙结果调整灯光、烘焙的参数重新烘焙直到达到满意的效果 其中前三步已经在上周的27、28课学习，本节课我们从第4步开始学习。 4 烘焙参数设置要想启用烘焙GI，首先需要在Lighting面板勾选Baked Global Illumination。 Lighting Mode 光照模式，该参数决定了Mixed模式的灯光对物体阴影的使用的模式。默认值是Shadowmask，在下方会详细解释。特别注意，如果修改了这个值，场景全部的光照贴图需要重新烘焙，如果Auto Generate勾选，重新烘焙会自动开始。 Lighting Mode该选项只对Light组件的Mode设置为Mixed时生效。 ShadowmaskLighting Mode的默认值。选中Shadowmask时，可以从菜单栏Edit &gt; Project Settings &gt; Quality 中选择Shadowmask的模式。 Distance Shadowmask 在Shadow Distance距离内使用实时渲染的阴影，超过距离的地方使用烘焙阴影（动态物体无法被投射阴影，可用Light Probe解决，后续会讲到）。这样在Shadow Distance内静态物体可以对动态物体产生实时阴影。适用情景举例：开放的大场景，阴影几乎都是投射到地面上，阴影也可以投射到移动的角色身上 Shadowmask 动态物体可以投射实时阴影到静态物体上，但是静态物体无法投射阴影到动态物体上（可用Light Probe解决，后续会讲到）。静态物体之间的阴影通过烘焙贴图渲染。适用情景举例：几乎全静态物体的场景 Shadow Distance渲染阴影是非常消耗性能的一件事。Shadow Distance表示距离摄像机在这个距离范围内的物体才会产生实时阴影，以优化实时运行的效率。 Baked Indirect这种模式下，Unity只烘焙间接光到光照贴图，不烘焙阴影。阴影在Shadow Distance内会采用实时渲染的方式，超出Shadow Distance的阴影不渲染。 适用情景举例场景是房间内的室内射击或冒险游戏，玩家观看距离有限，所有可见的内容通常在阴影距离内；此模式对于有雾的室外场景也很有用，可以使用雾来隐藏距离外缺失的阴影。 Subtractive此模式下，直接光会被烘焙到光照贴图中，因此在运行时不会进行任何直接光照运算。静态的物体因此没有高光、反射效果。 Realtime Shadow Color 该属性只在Subtractive模式下显示。可以用来设置实时阴影的颜色。 适用情景举例块状渲染的场景如卡通渲染风格的场景，并且几乎没有动态物体。 Lightmapping SettingsLightmapper的两个选择 Unity的烘焙GI由子系统提供支持，有两个选择，默认是Progressive，需要配置的参数略微不同。 两种系统没有明显的优劣，但是Progressive Lightmapper是较新的系统，据非官方比较结果，效果比Enlighten好。一般建议使用Progressive Lightmapper。 Progressive Lightmapper（渐进式光照贴图器）这个子系统仅用于烘焙GI。顾名思义，这个系统以渐进的方式烘焙光照贴图，在烘焙过程中可以看到过程中的变化，右下角也会显示预估的时间。 Progressive的默认值 使用Progressive Lightmapper时，主要配置的参数是： Lightmap Resolution 光照贴图分辨率，决定了光影的精细程度。越大的值精细度越高，相应烘焙时间越长，生成的光照贴图也越多。 Direct Samples 直接光采样的数量。提高该值可以提高光照贴图的质量，但是会增加烘焙时间。 Indirect Samples 间接光采样的数量。对于室外场景，一般100就足够了。对于室内复杂场景，可以增加这个值直到达到你预期的效果。提高该值可以提高光照贴图的质量，但是会增加烘焙时间。 Bounces 间接光反弹的次数。对于大多数场景，默认值2次就足够了。但是对于复杂室内场景，可能需要更多的次数。 其他参数可以在下方查看详细解释。 EnlightenEnlighten可以用于烘焙GI，也是实时GI所使用的子系统(实时GI只能用这个子系统)。 Enlighten的默认值 使用Enlighten时，主要配置的参数是： Lightmap Resolution 光照贴图分辨率，决定了光影的精细程度。越大的值精细度越高，相应烘焙时间越长，生成的光照贴图也越多。 Indirect Resolution 间接光计算中，每个单位使用几个像素表示。增加该值可以提高间接光的视觉质量，但也会增加烘焙时间。默认值是2。 其他参数可以在下方查看详细解释。 【选读】Progressive Lightmapper参数详解Prioritize View 优先计算Scene窗口中可见物体的光照，再计算窗口外不可见物体 Direct Samples 直接光采样的数量。提高该值可以提高光照贴图的质量，但是会增加烘焙时间。 Indirect Samples 间接光采样的数量。对于室外场景，一般100就足够了。对于室内复杂场景，可以增加这个值直到达到你预期的效果。提高该值可以提高光照贴图的质量，但是会增加烘焙时间。 Bounces 间接光反弹的次数。对于大多数场景，默认值2次就足够了。但是对于复杂室内场景，可能需要更多的次数。 Filtering 在烘焙完成后，控制间接光噪点的设置。可以设置None，Auto或Advanced。一般保持默认值Auto即可。如果以后你需要详细调节，可以阅读官方文档中该部分的内容。 Advanced中的选项： Gaussian 阴影更平滑 A-Trous 阴影边缘更锐利 Lightmap Resolution 设置世界中每单位对应光照贴图中多少个像素。提高该值可以提高光照贴图的质量，但也会增加烘焙时间。需要注意的是，提高该值，使用的总像素数量会呈2次方增加。比如原来是30，则1平单位使用3030=900个像素；提高到40后，则1平方单位使用4040=1600个像素。 Lightmap Padding 不同物体的光照贴图块在光照贴图中的间隙（避免块之间发生像素交叉的现象），默认值是2。 Lightmap Size 设置单张光照贴图的最大尺寸。默认值是1024。 Compress Lightmaps 是否压缩光照贴图。默认选中。选中时可以压缩贴图，减少存储空间占用，但是可能造成光照贴图出现不正常。 Ambient Occlusion 是否开启AO，默认开启。只影响间接光。 Max Distance 物体之间会产生AO的最大距离。物体之间的距离超出最大距离则不会产生AO。0代表不限制最大距离。 Indirect Contribution 间接光贡献度。提高该值可以增加参与AO的间接光的亮度，减少该值可以降低简介光的亮度。 Direct Contribution 直接光贡献度。提高该值可以增加参与AO的直接光的亮度，减少该值可以降低简介光的亮度。 前面我们提高过AO（Ambient Occlision，环境光遮蔽）。AO模拟环境光（不是来自特定方向的照明）能够照亮物体的程度。它会使弯折的物体、小孔、距离很近的表面变暗。因为这些区域遮挡了环境光线，因此它们看起来较暗。 以下4个选项同时适用于预计算实时GI和烘焙GI Directional Mode 设置光照贴图存储入射光的哪些信息。 Directional 此模式下，Unity会生成次光照贴图来存储主要入射光的方向，用于材质的法线贴图。比如需要10张主光照贴图，使用此模式时，会相应生成10张次光照贴图。相对于Non-directional模式，此模式会占用2倍的存储空间。 Non-directional 此模式只会生成主光照贴图。 Indirect Intensity 控制实时或烘焙光照贴图中间接光的亮度。大于1的值可以提高亮度，小于1的值可以降低亮度。范围是0-5，默认值是1。 Albedo Boost 控制物体表面反射的光线的数量，范围是1-10。增加这个值可以让间接光更亮。默认值是1，模拟了真实世界中光照。 Lightmap Parameters 设置光照贴图的参数，我们已经在28课的选读部分进行了讲解，现在你也可以回去重新学习一遍。 【选读】Enlighten参数详解Indirect Resolution 间接光计算中，每个单位使用几个像素表示。增加该值可以提高间接光的视觉质量，但也会增加烘焙时间。默认值是2。 Final Gather 如果你想要GI计算时最终的光线反弹和烘焙贴图有相同的分辨率，选中这个选项。这可以增加视觉效果，但是会增加额外的烘焙时间。 Ray Count 每个Final Gather（最终聚集）点发射的射线数量。默认是256。 Denoising 是否开启反噪点。默认开启。 以下参数和Progressive Lightmapper中的作用相同，请在上面查阅。Lightmap ResolutionLightmap PaddingLightmap SizeCompress LightmapsAmbient OcclusionDirectional ModeIndirect IntensityAlbedo BoostLightmap Parameters 5 开始烘焙即使不修改第4步周的任何参数，所有参数保持默认值，也可以开始烘焙。你可以先烘焙一次看看效果，再去修改参数进行尝试。 使用Progressive Lightmapper烘焙时，右下角会显示预计剩余时间。 烘焙的时间视场景大小、参数设置的不同时间可能从几分钟到几十小时不等。通常一个正常的场景烘焙几个小时是正常的，会比预计算实时GI的时间长很多。后面我们会有专门的一课讲解场景及参数的优化。 烘焙完成后，你就能看到最终场景的效果。 总结今天学习了使用Unity中的光照系统中的烘焙GI，希望你能记住使用的流程：1、场景环境设置2、对场景打光3、设置静态物体的Lightmap Static标签和Renderer参数4、设置烘焙的参数5、烘焙，根据烘焙结果调整灯光、烘焙的参数重新烘焙直到达到满意的效果 今日思考题构建一个简单场景，试试使用烘焙GI和预计算实时GI的区别~]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[预计算实时GI]]></title>
    <url>%2F2019%2F05%2F22%2F%E9%A2%84%E8%AE%A1%E7%AE%97%E5%AE%9E%E6%97%B6GI%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题:1 前两天我们学习了场景准备的相关工作，今天我们学习Unity光照系统中的预计算实时GI的使用流程。 使用预计算实时GI时，预计算是计算Unity场景中静态物体周围光线的反射并存储此数据以供运行时使用的过程。该过程减少了运行时执行的照明计算次数，允许实时反射光照，同时保持合适的帧率。 如果场景没有经过处理和优化，这些计算所需的时间可能会很长。我们也会学习如何针对Enlighten（Unity的预计算实时GI的后端）优化场景，让照明预计算时长从数小时降低到几分钟。 预计算实时GI的流程一般如下： 场景环境设置 打光 场景中物体的处理 调节预计算实时GI的参数 进行预计算 根据结果调整优化参数，再次进行预计算 前三步我们已经在前两天的课程中详细学习了，今天我们来看一下后面的步骤。 调节预计算实时GI的参数启用预计算实时GI默认情况下，在Unity的Lighting窗口（菜单栏 Window &gt; Lighting &gt; Settings）的Scene页签中同时启用了预计算实时GI和烘焙GI。 默认情况下Lighting的设置默认情况下Lighting的设置 要想使用Realtime GI，我们只选中Realtime Global Illumination。 Indirect Resolution（间接光分辨率）使用实时GI时，第一个需要考虑的就是Indirect Resolution参数。Indirect Resolution设置了一个世界单位使用的实时光照贴图像素的数量。 Indirect Resolution可以在Lighting窗口中查看设置，如下所示： 打开Lighting窗口（Window &gt; Lighting &gt; Settings），然后选择 Scene 选项卡。 选中Realtime Lighting下的Realtime Global Illumination。（一定要选中，否则Indirect Resolution不可修改） 查看Lightmapping Settings中的Indirect Resolution属性。 你可能发现有一些参数是灰色的，无法调整，那是因为那些参数是Baked GI相关的参数，暂时可以忽略。 选择合适的Indirect Resolution在设置场景时，确定项目的单位比例非常重要。可能是在你的项目中，一个单位是米，一英尺或一厘米。Unity中的1个单位（Unity中的Cube创建出来棱长就是1个单位）并没有确定的物理尺寸，但是通常我们将1个单位理解成1米。 在大多数项目中，建议一个单位=1米，这样与现实世界物理系统的单位相同。例如，在Unity中，重力的默认单位是单位/秒。1个单位=1米是真实世界游戏场景的最佳实践。 通常场景的Indirect分辨率可以根据游戏世界的规模来确定。例如，你的场景是一个小而密的室内环境，在间接照明较为复杂的情况下，更高的Indirect分辨率（例如每个unit 2-3个像素）可以有更多的细节。 也许你的场景是一个大型户外环境，世界规模非常大，可能一个表面就成百上千平方米，而且表面颜色几乎一样（反射光的颜色也不会大幅变化）。这种情况下，适用室内场景复杂情况的的分辨率在这种大型户外环境中是非常浪费的。分辨率过大会浪费宝贵的CPU时间和内存，因为需要保存和更新对场景整体外观没有多大贡献的光照贴图。更重要的是，这会大幅增加预计算时间。 对于室外环境和场景内的大型物体，合适的Indirect分辨率可能介于每单位0.5-1个像素之间；对于大地形为0.1至0.5个像素。 预计算实时GI分辨率 vs 烘焙光照贴图分辨率Unity中实时GI所需的Indirect分辨率值比传统光照贴图像素密度低几个数量级。因为我们只在这些光照贴图中保存间接照明，通常是非常柔和、“低频”的。使用实时GI时，通常会使用实时阴影而不是高分辨率光照贴图提供清晰阴影。 使用传统光照贴图技术中看似合适的值 - 例如每个单位30个像素 - 可能会导致预计算失败或计算时间过长。对于室内场景，合适的值为每单位2-3个像素，室外环境为0.5-1（这是基于单位尺寸为1单位= 1米的场景。如果场景单位尺寸比例不同，这些值就需要相应调整）。 场景 实时GI合适的分辨率室内 每单位2 - 3个像素户外 每单位0.5-1个像素地形 每单位0.1 - 0.5像素建议场景中1个单位=1米场景的Indirect分辨率也是场景中所有静态对象的默认分辨率。标记为Lightmap Static的MeshRenderer将默认使用此值，除非单独设置MeshRenderer中的Lightmap Parameters（28课最后的选读内容）中的Resolution。 除了为整个场景选择Indirect分辨率之外，还可以通过MeshRenderer中的Lightmap Parameters中的Resolution为每个物体修改光照分辨率。如果需要更高分辨率提供额外保真度，可以增加此值。通常将适合场景大部分物体的分辨率设置为场景默认值，然后手动调高需要更多照明细节的物体的分辨率。 启动预计算要启动预计算的过程，场景中至少要由一个物体被标记为Lightmap Static。 Lightmap Static标记上节课学习时，我们提到了GameObject的Lightmap Static标记。 Static菜单Static菜单 开始计算过程场景中的静态物体设置为Lightmap Static以后，就可以开始预计算的过程了。 打开Lighting窗口，切换到Scene选项卡。 如果Auto Generate（自动生成）复选框是选中的，那么你应该可以在Unity编辑器的右下角看到已经开始计算过程了。 如果Auto Generate复选框没有选中，你可以选中来让编辑器自动生成（场景发生改变时，会自动启动计算）。如果你不想自动生成，可以点击右侧的Generate Lighting按钮来手动生成。 Unity编辑器的右下角会显示进度Unity编辑器的右下角会显示进度 计算的时间可能根据场景的大小以及你的设置的不同从几分钟到几小时不等。等待计算完成后，你就能看到场景发生的变化。 左图中仅用了实时光照，右图加入了预计算实时GI，可以看到间接光让场景看起来更自然了左图中仅用了实时光照，右图加入了预计算实时GI，可以看到间接光让场景看起来更自然了 如果你的场景比较复杂，可能会需要几小时的时间来进行预计算。后面会有针对预计算时间的优化的专门的课程。 总结今天学习了使用Unity中的光照系统中的预计算实时GI，希望你能记住使用的流程： 场景环境设置 打光 场景中物体的处理 调节预计算实时GI的参数 进行预计算 根据结果调整优化参数，再次进行预计算 今日思考题构建一个简单场景，试试使用预计算实时GI和仅使用实时灯光的区别~]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光照系统：场景准备（2）]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%85%89%E7%85%A7%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%9C%BA%E6%99%AF%E5%87%86%E5%A4%87%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.在Unity中试试今天学习的Renderer中的属性。 昨天我们学习了场景准备的前两步：环境光设置和打光流程。今天我们来学习场景中物体的设置。 3.物体设置如果你选择的是实时光照（注意不是预计算实时GI）方案，不需对物体进行特殊的设置，现在你应该已经达到你的目的了！如果你要用预计算实时GI或烘焙GI，除了全局的环境设置外，参与全局光照的物体也需要进行一些设置。 Static设置一个物体想要参与到实时GI或烘焙GI的计算中，首先要将物体设置为Lightmap Static。在游戏运行时该物体不能移动。 最佳实践 通常我们在Hierarchy中将不同类型的游戏对象进行分组，这样在进行一些操作时可以很容易对这一组物体进行批量操作。 如上图所示，我们将场景中的静态环境都放到Environment这个空物体下，这个空物体在这的作用类似于一个文件夹。 通过分组物体一键设置Static 如上图所示，通过设置父物体为Lightmap Static，并且在弹出框中选择Yes, change children，就可以改变该物体及所有子物体的Static标记。 物体Renderer设置一般情况下，物体Renderer中的属性保持默认值即可，大多数情况都不需要修改。但是有少数情况需要修改一些属性来达到更好的效果。 Light Probes 将会在后续Light Probe模块进行讲解。Reflection Probes 将会在后续Reflection Probe模块进行讲解。Anchor Override 将会在后续Light Probe模块进行讲解。 Cast Shadows 该物体是否投射阴影 On 投射，默认值。当有阴影的灯光照射到该物体时，会投射阴影。 Off 不投射 Two Sided 物体的正反两个面都会投射阴影（只能用于实时渲染的阴影，不能用于GI烘焙的阴影） Shadows Only 该物体只投射阴影，本身不可见 Receive Shadows 别的物体投射的阴影是否会投射到该物体上Motion Vectors 用于一些特效的处理，以后会进行讲解Lightmap Static 与右上角的Static标签中的Lightmap Static功能相同。选中时，物体会参与到GI系统的计算中，但是物体不能移动。如果没选中，也可以使用Light Probe来点亮（后面会详细讲解）。 Lightmap Static选中时，会显示下方的一些配置属性： UV Charting Control这部分理解难度比较高，你可以先大致浏览一下，后续随着学习的深入再回来看会理解的更透彻。 如果使用Unity内置的几种基础模型（如Cube，Sphere等），不会显示这个设置。 Optimize Realtime Uvs 是否为实时GI优化模型的UV。选中时，该模型的UV会被合并、缩放、打包。未选中时，UV只会被缩放和打包，不会被合并。需要注意的是有时可能会错误优化非连续的UV，比如原来是一个锐利的边缘被优化成一个圆滑的面。 Max Distance UV图之间最大的世界空间距离。如果UV图的距离小于这个值，就会被简化。 Max Angle 两个面共享一条边时两个面的最大角度。如果角度小于这个值，UV图会被简化。 Ignore normal 选中这个复选框，避免UV图在预计算的过程中被拆分。Min chart size 指定实时GI中一个UV图的最少像素。如果缝合UV就需要4个像素，那么最小UV图会是4*4像素。如果不需要缝合UV，那么可以用2个像素来减少预计算的时间，提高运行时的性能。关于Charts在后面会详细进行详细介绍，帮助你更好的理解。 Lightmap settingsScale in Lightmap 指定光照贴图中的UV尺寸相对于物体原始UV尺寸的倍数。如果设置为0，该物体的光照信息不会被记录到光照贴图中，但仍会影响场景中的其他物体。大于1的值会使用更多的像素（更精确），小于1的值会使用更少的像素来记录光照信息。可以用这个值来单独优化场景中物体的光照信息，重要复杂的物体可以适当提高这个值，简单不重要的物体可以适当减少这个值。例如：一个场景中独立的简单建筑可以用小于1的值，一个复杂的彩色摩托车可以用大一点的值。 Prioritize illumination 选中此选项，让Unity知道该物体需要参与到光源的计算中。用于强烈自发光的物体并且会点亮周围的物体。 Lightmap Parameters 可以设置Lightmap的参数，一般保持默认值即可。下面会进行详细讲解。 Baked Lightmap 显示该Mesh对应的烘焙光照贴图的信息。其中Lightmap Index如果是65535，则说明该Mesh没有对应的烘焙光照贴图。 Realtime Lightmap 显示该Mesh对应的实时光照贴图的信息。 【选读】Lightmap Parameters（光照贴图参数） 此部分内容你可以暂时略过，在后面进行优化时可以回来看看每个参数的作用，针对你的场景进行细调 Lightmap Parameters是工程中的一种资源，用来存储和Unity全局光照系统相关的配置。你可以配置多个光照贴图参数用于不同的情况，比如不同类型的物体、室内或室外场景。 在Lighting窗口中可以设置全局Lightmap Parameters 每个Mesh也可以单独设置Lightmap Parameters，默认使用场景全局设置 ** 创建Lightmap Parameters ** 有两种方式创建Lightmap Parameters资源文件： 在Project窗口中通过Create菜单创建 在Lightmap Parameters设置的地方，创建一个新的Lightmap Parameters。 ** 参数设置 ** 在Project中选中Lightmap Parameter资源或者在Lightmap Parameter属性栏的右侧点击Edit，Inspector窗口中会显示对应的参数，此时可以编辑资源中的参数。 新创建的Lightmap Parameter资源中的默认值 Precomputed Realtime GI此部分的参数用于预计算实时GI。 Resolution 这个参数是Lighting窗口中的Indirect Resolution的缩放系数。比如Indirect Resolution设置为2，Resolution设置为0.5，那么GI系统最终使用的Indirect Resolution就是1。 Indirect Resolution参数 Cluster Resolution Cluster（簇）分辨率的缩放系数。 Irradiance Budget 这个值决定了光照贴图中入射光数据的精度。低值会更模糊；高值会更清晰，但是会增加运行时的内存占用，也可能增加CPU占用。 Irradiance Quality 这个滑条决定了在计算哪些Cluster会对目标光照贴图的像素有影响时使用的射线数量。更高的值会有更好的视觉效果，但是也会增加在Unity编辑器中预计算的时间。这个值不会影响运行时的性能。 Modelling Tolerance 光线能通过的最小缝隙的尺寸。确保这个值小于场景中的最小缝隙的尺寸。 Edge Stitching 选中时，表示光照贴图中的UV图应该无缝连接，避免一些错误的视觉效果。 Is Transparent 选中时，全局光照计算时会将物体当作透明的，光线会穿过物体表面。一般仅用于透明的自发光表面。 System Tag lightmap被合并到同一张lightmap atlas（图集）的物体被称为一个“system”。这个值为-1时，Unity编辑器会自动检测已有的lightmap图集是否有空余的位置，如果没有才会创建新的lightmap图集。但是有些时候手动设置将一些物体规定到同一个lightmap图集中很有用（比如同一个房间中的物体）。该属性值的大小和顺序对功能没有影响。 ** Baked GI ** 目前Unity中的Baked GI可以从2种系统中选择一种使用：Enlighten或Progressive Lightmapper。Baked GI中的参数在不同系统下的作用不太相同。 属性 Enlighten中的功能 Progressive Lightmapper中的功能Blur Radius 纹理像素进行后期处理时直接照明的模糊滤镜的半径。半径基本上是相邻纹理的平均距离。更大的半径会产生更加模糊的效果，可以减少视觉伪影，但也会柔化阴影的边缘。 不可用Anti-aliasing Samples 应用的抗锯齿程度（减少“块状”伪影）。更高的值会提高质量和烘焙时间。 超级采样纹理以减少锯齿。1-3禁用超采样，4-8使用2倍超采样，9- 256使用4倍超采样。这主要影响用于位置和法线缓冲区的内存量（2x使用4倍的内存量，4x使用16倍的内存量）。Direct Light Quality 用于计算直射照明的光线数量。更多的光线会产生更准确的软阴影，但会增加烘焙时间。 不可用 Baked Tag 与上面Realtime GI中的系统标签属性类似，此编号可让你将特定的对象组合在单独的烘焙光照贴图中。与系统标签一样，数值的大小并不重要。具有不同烘焙标签值的对象不会放在同一个图集中; 然而，不能保证具有相同标签的对象最终一定会出现在同一个图集中，因为一张图集可能无法包含这些对象（参见下面的图A中的示例）。 同左侧Pushoff 开始跟踪光线之前离开模型表面的距离。它适用于所有烘焙的光照贴图，因此会影响直射光，间接光和AO。Pushoff对于移除不需要的AO或阴影很有用。使用此设置可解决物体表面本身产生阴影从而导致斑点阴影图案出现在表面上，但没有明显的来源的问题。还可以使用此设置移除大型模型上由于浮点数精度引起的不该出现的阴影。 同左侧 Baked Tag 上面的图像显示了同一场景的两种情况： 左图：因为所有的GameObjects都有相同的Baked Tag，所以都在一个图集。 右：一个GameObject被分配了一个不同的烘焙标签，并被强制转换到第二个光照贴图。 ** Baked AO ** 仅在Enlighten下可用，在使用Progressive Lightmapper不可用。 环境遮挡（AO）模拟环境照明（不是来自特定方向的照明）能够照亮表面的程度。它会使弯折的物体、孔、距离很近的表面变暗。这些区域遮挡（阻挡）环境光线，因此它们看起来较暗。 Quality 计算AO时使用的射线的数量。更高的值可以增加AO的质量但是会增加烘焙的时间。 Anti-aliasing Samples 计算AO抗锯齿时的采样数量。更高的值可以增加AO的质量但是会增加烘焙的时间。 ** General GI ** Backface Tolerance 网格的结构有时会导致一些光照纹理包含物体背面。来自背面的入射光在任何场景中都毫无意义。此属性允许你选择必须来自网格正面的光线的百分比，大于此阈值被视为有效。无效的纹理的光照近似于其邻居的值。降低此值可以解决由背面入射光引起的照明问题。 总结学习了使用Unity中场景准备的第二部分：单个物体的Static标记和Renderer设置。希望你能记住以下几点： 参与实时GI或烘焙GI的物体必须标记为Lightmap Static 物体Renderer设置一般保持默认值即可，常用的参数是“Cast Shadows”和“Receive Shadows”]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光照系统：场景准备（1）]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%85%89%E7%85%A7%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%9C%BA%E6%99%AF%E5%87%86%E5%A4%87%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.试试不同的环境光对场景的影响 在使用任何一种光照技术（实时光照，预计算实时GI，烘焙GI）之前，都需要对场景进行相应的准备和设置。一般需要准备的内容如下： 针对整个场景的总体环境设置 光源的设置（俗称打光的过程） 物体的Static和Renderer设置 下面我们一起来看一下场景准备的具体内容。 1.场景环境设置在进行每个光源设置之前，需要对场景的总体环境光进行设置。环境光的设置会影响整个场景的基础照明。如果打光之后再设置，可能已经打好的光都需要调节，修改的工作量会非常大。 在Unity的Lighting窗口（菜单栏 Window &gt; Lighting &gt; Settings）的Scene页签中，找到Environment区域。 Skybox Material 天空材质。Unity中的天空是一个渲染在所有物体后面的材质，可以模拟天空或者远处的背景。默认值是Unity内置材质Default-Skybox，也就是我们新建场景看到的那个蓝色天空。Asset Store中也有很多天空资源可供选择。 不同天空材质的效果，来自Asset Store的Skybox Series Free 此外，还可以通过程序化的方式生成天空盒新建一个材质，Shader选择Skybox/Procedural，可以配置下方的几个参数来自定义天空： Sun 是否显示太阳以及显示的质量 Sun Size 太阳显示的尺寸 Sun Size Convergence 太阳尺寸的收敛程度 Atmosphere Thickness 大气层的厚度 Sky Tint 天空的颜色 Ground 地面的颜色 Exposure 天空和地面交界处曝光程度 自定义程序化天空盒 Sun Source 如果Skybox Material设置了一个程序化的天空盒，可以用这个属性设置一个场景中的灯光作为“太阳”。如果设置为None（默认值），场景中Intensity最高的Directional Light会被自动作为Sun Source。你可以在天空上看到这个太阳，这个Light在发生旋转时，在天空中太阳的位置也会发生变化。 天空中太阳变化 ** Environment Lighting（环境光） ** 环境光即整个场景都会受影响的光。与Directional Light的区别是：环境光是没有方向的，相当于是从四面八方都有光照射。这个环境光是整个场景重要的光源之一。 Source 环境光的来源 Skybox（天空盒） 选择此项时，会显示Intensity Multiplier（强度系数），可以用来设置环境光的强度；此外还有一个参数Ambient Mode，用来设置环境光的模式，可以选Realtime（实时，仅在Realtime GI勾选时可选）或Baked（烘焙，仅在Baked GI勾选时可选） Gradient（渐变） 选择此项时，可以设置三个颜色，分别是Sky Color（天空颜色）、Equator Color（地面天空交界处颜色）、Ground Color（地面颜色） Color（颜色） 选择此项时，可以设置一个Ambient颜色来代表环境光颜色和强度 Environment Reflections环境反射的相关设置，将会在后续讲解反射时进行讲解。 2.打光一个场景想要有非常好的效果，打光是非常重要的过程。一般来说，打光的工作都是由艺术细胞很高的美术同学完成的。 打光的流程一般如下：1、确定需要光源的类型、位置、旋转、强度2、设置阴影类型3、设置光源的Mode及参数 Indirect Multiplier（间接光系数）用这个值来改变间接光的强度。间接光就是从一个物体反射到另外一个物体的光。 除了直射到物体上的光之外，还会发生反射到其他物体上 这个间接光系数可以改变反射光的亮度。这个值的默认值是1。如果设置为小于1的值，反射光每次反弹都会变暗；如果设置大于1的值，反射光每次反弹都会变亮。例如，当阴影中的深色表面（例如洞穴内部）需要更亮才能使细节可见时，就需要将这个值设置的大一些。 如果你使用了全局光照（预计算实时GI或烘焙GI），想要一盏灯只有直接光而没有间接光，可以将这个系数设为0。 ** 注意 **仅在使用预计算实时GI或烘焙GI时才有间接光，如果只使用实时光是没有间接光的。 Shadow TypeShadow Type有3个选项： No Shadows 无阴影，该光源照射的物体不会产生阴影 Hard Shadows 硬阴影，使用该选项产生的阴影边缘会比较锐利 Soft Shadows 软阴影，使用该选项产生的阴影边缘比较圆滑，也能减少边缘的锯齿，但是计算量相对硬阴影更高 选中Hard Shadows或Soft Shadows时，下面会有几个选项： Light的Mode为Mixed或Baked时会有下面两个选项： Baked Shadow Angle：仅在Light的Mode为Mixed或Baked，并且Light的Type为Directional时出现，并且Shadow Type为Soft Shadows时可编辑。作用是：增加一些阴影边缘的圆滑处理，让阴影更自然。 Baked Shadow Radius 仅在Light的Mode为Mixed或Baked，并且Light的Type为Spot或Point时出现，并且Shadow Type为Soft Shadows时可编辑。作用是：增加一些阴影边缘的圆滑处理，让阴影更自然。 Light的Mode为Realtime时会有下面几个选项： Strength 阴影的强度（取值范围0-1）。值越大阴影越黑，值越小阴影越淡。默认值是1。 Resolution 阴影的质量。设置质量越高阴影的效果越好，但相应的GPU和内存占用越多。Low/Medium/Hight/Very High分别代表了阴影质量的低、中、高、非常高四个选项。此外默认值是Use Quality Settings，即使用工程的全局Quality Settings（可以从菜单栏Edit &gt; Project Settings &gt; Quality打开设置） Bias 用于修正阴影的位置，一般保持默认值即可。如果阴影出现了下面的情况，可以尝试调节这个值。 左侧是正常的场景，右侧地面阴影划线现象，通过调节Bias可以修正这个现象 但是也不要调的太高，调的太高会出现阴影和物体分离的现象。 太高的Bias出现了物体和阴影分离现象 Normal Bias 用来修正阴影沿物体表面的法线方向产生的收缩的程度。主要也是用来解决阴影划线的现象。一般保持默认值即可。 Near Plane 距离光源超过这个值的物体产生阴影。一般保持默认值即可，如果发现距离光源过近的物体没有阴影，可以尝试缩小这个值。这个值的最小值是0.1或Range的1%中较大的值，最大值是10。 Mode的区别Mode参数在使用不同的光照技术下会产生不同的结果： 1、场景不使用预计算实时GI，也不使用烘焙GI时：只能使用Realtime的灯，Mixed和Baked会自动当作Realtime的灯（Mode参数不会变，但是实际上是以Realtime的灯运行）。Realtime的灯，光照使用实时渲染，无间接光；阴影使用实时渲染。 2、场景使用预计算实时GI，不使用烘焙GI时：只能使用Realtime的灯，Mixed和Baked会被自动当作Realtime的灯（Mode参数不会变，但是实际上是以Realtime的灯运行）。Realtime的灯，光照使用实时渲染，有间接光；阴影使用实时渲染。 3、场景使用烘焙GI，不使用预计算实时GI时： ** Mode ** ** 光照 ** ** 阴影 ** Realtime 实时渲染，无间接光 实时渲染 Mixed 直接光实时渲染，间接光通过烘焙光照贴图渲染 实时渲染 Baked 直接光和间接光都烘焙到光照贴图 烘焙到光照贴图 4、场景使用烘焙GI，也使用预计算实时GI时： ** Mode ** ** 光照 ** ** 阴影 ** Realtime 实时渲染，有间接光（由预计算实时GI提供） 实时渲染 Mixed 直接光实时渲染，间接光通过烘焙光照贴图和与计算实时GI提供，会造成场景更亮 实时渲染 Baked 直接光和间接光都烘焙到光照贴图 烘焙到光照贴图 注意1虽然Mixed类型的灯光能在运行时进行修改（颜色、强度、位置、旋转等），但是由于间接光是烘焙到光照贴图中的，无法在运行时变化，所以会造成不一致的现象。所以尽量不要在运行时修改Mixed模式的灯光，如果确实要修改，尽量减小变化的范围。 左侧烘焙时灯光为黄色，右侧将灯光颜色实时改为了红色，但是间接光部分仍然呈现黄色 注意2预计算实时GI不需要先是设置好光源（光源不参与预计算实时GI的与计算过程），所以可以在预计算过后再打光也可以。 总结学习了使用Unity中的光照系统时，场景需要做的一些准备： 场景总体环境光的设置 场景内灯光的设置 单个物体的设置]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光照方案的选择]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%85%89%E7%85%A7%E6%96%B9%E6%A1%88%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.什么是间接光照？2.不同的光照方案是什么？如何选择？3.实时GI的两个缺点是什么？4.光照贴图包含了哪两种光照？5.想一想你玩过的游戏，里面用到的可能是哪种照明方案？ 为了计算3D物体的光影，Unity需要知道照射在它上面的光的强度，方向和颜色。 场景中的光来自于Light组件、自发光物体和环境光。不同光源的颜色、方向以及强度可能都不同。自发光材质的物体也是光源。 Unity中有多种不同的方式计算复杂的照明效果，每种方法适合不同的情况（目标平台、目标平台的性能等）。 选择光照方案一般来说，Unity中的光照可以分为“realtime（实时）”和“precomputed（预计算）”两种，并且这两种技术可以结合使用来创建逼真的场景光影。 实时光照即游戏运行中实时计算的光照技术，但是由于是实时计算，对硬件的性能要求就会比较高。 预计算即将一些计算过程从实时转移到了游戏发布之前，将预计算的结果存储成文件，在游戏运行时就能快速读取这些预先计算好的数据，大幅提升游戏的运行效率。但是相应的，计算结果存储的文件会占用存储空间和运行时内存。 Realtime Lighting（实时光照）Unity中创建出来的默认灯光（平行光、聚光灯、点光源）是实时光，会在程序运行时实时计算光影效果。光源或物体移动时，可以在Scene和Game窗口实时看到光影的变化。 只使用实时光的效果。注意：阴影完全是黑色的，因为光没有发生反射，并且只有聚光灯锥体内的表面受到了光照影响 实时照明是场景照明的最基本方式，对于照亮人物或其他可移动的物体非常有用。同时不需要进行额外的设置（放一个光源，然后什么都不干，这就是实时光），就能看到运行的效果，非常简单。但是实时照明的光影会在游戏运行的过程中每帧计算、更新，对硬件要求相对较高。 实时照明还有一个很致命的劣势就是Unity中实时灯的光线照射到物体表面不会反弹（不会产生间接光）。现实世界中，灯光照到一个物体表面都会反射一定量的光，然后照亮其他周围的物体。比如在夜晚，月亮受到太阳照射，然后又微弱的照亮地球。 如上图中的场景，立方体背面有一堵墙。现实世界中，墙面会反射光线到立方体的背面，会点亮立方体的背面，我们先来看一看没有间接光的情况下，立方体的背面是什么样的。 仅有实时灯光的情况 可以看到立方体背面是全黑的，这种情况其实不符合现实世界中的光照。我们再来看一下加入了预计算的照明后，场景会变成什么样子。 如上图，立方体在受到地面、墙面反射的间接光后，显得真实了很多。 如果想要场景中的光影更逼真，我们需要使用Unity中的预计算照明方案。 Baked lightmaps（烘焙光照贴图）Unity可以计算复杂的静态（光源及物体都不会移动）光照效果，使用全局照明（GI）的技术，并将计算结果存储在名为“光照贴图”的贴图中。这个计算过程被称为烘焙。 烘焙光照贴图时，Unity计算了光源对场景中静态物体的光照效果。 左边是烘焙过的场景，右边是对应的光照贴图 这些光照贴图既可以包含直接照射到物体表面的光，也可以包含场景内其他物体表面反射的间接光。游戏运行时，这些光照贴图可以叠加在模型原本的贴图上来创建照明效果。光照贴图可以与物体表面其他贴图叠加一起使用，例如Albedo（反照贴图）和Normal（法线贴图）等。 光照贴图在游戏过程中不能改变，因此被称为“静态”照明。但是实时灯可以在光照贴图上叠加使用，但运行时不能也没有改变光照贴图本身。 通过这种方法，我们可以在游戏中用空间换时间的方式来提高性能，适合移动平台等性能较弱的硬件。 Precomputed realtime global illumination（预计算实时全局照明）由于静态烘焙贴图无法在运行时变化，无法用于光源移动、参数变化的情况。预计算实时全局照明技术提供了一种交互式更新复杂场景照明的技术。 通过这种方法，可以创建丰富的全局照明环境，并带有间接光，实时响应光照的变化。一个很好的例子就是一天的昼夜交替：光源的位置和颜色随着时间变化。用传统的烘焙照明，这是不可能实现的。 使用预计算实时GI的简单示例 为了实现这些效果的同时还能保证游戏以可接受的帧率运行，我们需要将一些复杂的计算从运行时转移到预计算的过程中。预计算将一些复杂的计算负担从运行时转移到了开发过程中，这个过程称为“offline（离线）”过程。 这个离线过程具体是什么呢？ 大多数情况下，在光照贴图中存储间接光就可以减少很多运算的过程，这些间接光很大程度决定了场景光照的真实感。间接光比较柔和，几乎没有刺眼或“高频”的颜色变化。Unity的预计算实时GI利用了这些间接光的“漫反射”特性。 一些更精细的照明细节，如清晰的阴影，通常实时灯可以渲染的更好，所以不用将它们烘焙成光照贴图。如果不需要捕捉这些复杂的照明细节，我们可以大大降低预计算实时GI解决方案的计算量和数据量。 通过预计算，可以有效减少我们在玩游戏期间更新GI照明所需的计算，也能很好地支持需要改变灯的属性（例如颜色，旋转或强度）这些需求。 为了进一步加快预计算的过程，Unity并没有直接使用原始的模型网格，而是在场景中创建一个低精度的静态近似几何图形，称为“Cluster（簇）”。 左：将场景视图设置为“Albedo”，可以清楚地看到Unity预先计算好的实时GI生成的贴图。默认情况下，该视图中的贴图大致是簇的大小。 右：光照计算完成后将结果转换为光照贴图并应用到游戏的场景 通常情况，游戏运行时计算全局照明时会用到“光线追踪”来计算光线的反射，这需要非常复杂的处理，实时更新对性能影响很大，但是Unity会在预计算阶段预先用光线追踪来计算表面簇之间的关系。通过将场景简化，移除了复杂网格上对游戏性能影响非常大的光线追踪过程。 Unity高效地为场景创建了一个简化的数学模型，可以在游戏运行时接收不同的输入。这允许我们在游戏运行时对场景中的灯光或模型颜色、贴图进行修改，而且可以实时看到GI在场景灯光更新后效果。然后，GI的输出可以转化为光照贴图，用于在GPU上渲染，与其他照明和表面贴图混合，处理效果并最终输出到屏幕。 收益和成本虽然可以同时使用烘焙GI照明和预计算实时GI，但要小心同时使用两个系统的性能成本恰好是它们的总和。我们不仅需要将两组光照贴图存储在显存中，还要在运行时进行解码处理。 选择一种照明方案而不是另一种取决于项目的性质以及预期硬件的性能。例如，在处理能力有限的移动设备上，烘焙GI照明方法可能更合适。在有独立显卡的PC或最新游戏主机上，可以使用预计算实时GI，甚至可以同时使用这两种系统。 必须根据你的项目的性质和目标平台来评估采取哪种方案。当针对一系列不同的硬件时，通常选择性能最差的平台作为目标平台，然后决定采用哪种照明方案。 总结Unity中的光照有三种方案可供选择： 实时照明：平台性能要求高，没有间接光 烘焙GI：平台性能要求低，有间接光，但是光源无法运行时变化 预计算实时GI：平台性能要求高，有间接光，光源运行时可以变化]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Standard Shader的参数设置（2）]]></title>
    <url>%2F2019%2F05%2F22%2FStandard-Shader%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.动手调节一下参数的值，尝试给每个属性一个贴图试试看。也可以下载Asset Store中的Adam Character资源包，看看Unity官方制作的角色是如何使用这些参数的。 Heightmap（高度映射）高度映射（也称为视差映射）与法线映射类似，但是这种技术更复杂 - 因此性能相对较差。高度贴图通常与法线贴图一起使用，通常用于渲染物体表面较大的凹凸。 法线贴图修改了材质表面上的光照，高度贴图更进一步，实际移动了物体表面的贴图，实现了表面遮挡效果。这意味着凹凸在近侧（面向相机）被放大，在远侧（远离相机）将减小并且看起来被遮挡。 这种技术可以产生非常真实的效果，但仍然局限于物体网格的表面。虽然表面凹凸会突出并相互遮挡，但模型的“轮廓”并没有被修改，因为该效果最终会被绘制到模型的表面上，而不会修改实际的网格。 高度图应该是灰度图像，白色区域代表纹理的高区域，黑色代表低区域。如下图是一个匹配的Albedo贴图和高度图。 Albedo贴图和与其匹配的高度图 在上图中从左到右：1、指定了岩石墙的Albedo贴图，但没有法线贴图或高度图。2、添加了法线贴图，光照在表面发生了变化，但岩石不会相互遮挡。3、添加了normalmap和heightmap的最终效果。岩石看起来凸了出来，并且挡住了后面的石头。 通常（但不总是）用于高度图的灰度图像也适用于遮挡贴图。 Occlusion Map（遮挡贴图） 遮挡贴图用于提供模型的哪些区域应该接收高或低间接光照的信息。间接照明来自环境照明和反射，因此模型的陡峭凹陷部分（如裂缝或折叠）实际上不会接收到太多间接光照。 通常使用建模软件或第三方软件基于3D模型计算遮挡贴图。 遮挡贴图是灰度图像，其中白色表示应该接收全部间接照明的区域，而黑色表示没有间接照明。有时候，对于简单的曲面（比如上面的heightmap示例中显示的可凸起的岩石贴图），遮挡贴图与灰度高度图几乎一样。 在其他时候，生成正确的遮挡贴图稍微复杂一些。例如，场景中的角色戴着头巾，头巾的内侧边缘应该设置为非常低的间接照明，或者根本没有。在这些情况下，遮挡贴图通常会由美术同学通过3D软件生成。 这张遮挡贴图用于下面的模型 使用遮挡贴图的前后：注意脖子周围的颜色变化 Emission（自发光） 该属性用来控制材质表面发光的颜色和亮度。在场景中使用自发光材质时，它会是场景中的光源。 自发光材质通常用于从内部照亮外部的物体，例如显示器的屏幕，汽车急刹车时被烧红的刹车盘，仪器控制面板上的发光按钮或黑暗中怪物的眼睛。 可以使用单一的HDR颜色或自发光贴图来设置自发光颜色。 HDR颜色相对于普通颜色，多了一个Intensity的属性，可以用来定义发光的强度。 HDR(High Dynamic Range)这是通常指超出正常颜色范围（0-1）以外的颜色。例如，太阳通常比蓝天亮十倍。 使用HDR的场景：车窗中反射的阳光比场景中的其他物体亮得多，因为已经使用HDR进行处理 使用自发光材质的物体，即使在黑暗环境中，由于他们自身的发光，仍可以看见它们。 除了使用一个简单的HDR颜色来控制材质的自发光，你也可以使用自发光贴图。和其他的贴图类似，通过自发光贴图，你可以控制哪个区域发光，哪个区域不发光。 图中的贴图有发光区域和不发光区域 在场景里的表现 除了基本的颜色和贴图设置，Emission参数还有一个Global Illumination（全局光照，后续光影的课程会讲到）设置，用来设置这个自发光的物体发出的光照会如何影响周围的物体。有两个选项： Realtime 实时。这个自发光光源会添加到全局光照的计算中，这个光源附近的物体，包括移动的物体会受到这个光源的影响。 Baked 烘焙。这个自发光光源的会被烘焙到静态的灯光贴图（后续光影的课程会讲到）中，周围的静态物体会被点亮，但是动态物体不会受影响。 自发光的物体烘焙后对场景的影响 Tiling/Offset Tiling表示UV坐标的缩放倍数，Offset表示UV坐标的起始位置。贴图的左下角为UV坐标系的(0,0)，右上角为(1,1)。 这么说有点晦涩，我们来举个例子： 左侧为Tiling为(1,1)，中间Tiling为(2,2)，右侧Tiling为(0.5, 1) 左侧为Offset为(0,0)，中间Offset为(0.3,0.3)，右侧Offset为(0.5, 0.5) Secondary Maps（次要贴图） 次要贴图（又叫辅助贴图、细节贴图），可以在主贴图的基础上覆盖第二层贴图。次要贴图可以包含Albedo贴图和法线贴图。 通常使用次要贴图的情况是：需要在物体表面重复一些很小（相对于主贴图）的纹理。比如：皮肤的细节（毛孔和毛发），砖墙上细小的裂缝或青苔，大型金属容器上的小划痕和磨损。 次要贴图能让材质从近处看时非常精细，而从远处看时是有正常的细节，避免了使用单张精度极高的贴图，可以提高性能。 比如下图是一个没有次要贴图的皮肤： 未添加次要贴图 添加了次要贴图 添加了次要贴图后，能清楚看到皮肤上的毛孔 ** 注意 **如果只有一张法线贴图，一定要放在Main Maps的Normal Map中。Secondary Maps中的法线贴图虽然和Main Maps的作用相同，但是比在Main Maps中会耗费更多渲染资源。 Detail Mask（细节贴图遮罩） 细节遮罩贴图只在使用了Secondary Map时生效，用来遮挡Secondary Map的某些区域。可以用来控制只在某些区域显示细节纹理，在其他区域隐藏细节纹理。在上面的脸部例子中，你可能需要考虑创建一个遮罩，在嘴唇或眉毛上不显示毛孔。 Advanced Options（高级选项） Enable GPU Instancing（开启GPU实例化）使用GPU Instancing可以将绘制多个同样的Mesh合并成一次渲染。对于场景中大量重复的的建筑、植被等物体的渲染非常有用。 GPU Instancing可以减少调用底层图形接口的次数，可以大幅改善了项目的渲染性能。 Double Sided Global Illumination（双面全局光照）启用后，在计算全局照明时，会计算网格的正反两面。背面不会渲染，也不会添加到光照贴图，但会遮挡其他物体。 使用Progressive Lightmapper时，反面反射的光使用与正面相同的albedo和emission（目前此设置仅在使用Progressive Lightmapper进行烘焙时可用。） 总结今天学习了Standard Shader的几个属性： Heightmap 高度映射 Occlusion Map 遮挡贴图 Emission 自发光 Tiling/Offset Secondary Maps 次要贴图 Detail Mask 次要贴图遮罩]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Standard Shader的参数设置（1）]]></title>
    <url>%2F2019%2F05%2F22%2FStandard-Shader%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：动手调节一下参数的值，尝试给每个属性一个贴图试试看。 对于大部分的材质需求，使用Unity内置的Standard着色器就够用了。下面详细讲解一下Standard着色器具体参数的设置 Rendering Mode（渲染模式）Standard Shader中的第一个材质参数是渲染模式。使用这个参数设置材质是否透明以及使用哪种类型的透明模式。 Opaque （不透明）- 默认，适用于不需要透明的物体。 Opaque模式 Cutout（裁剪） - 适用于不透明区域和透明区域之间具有明显边缘的透明效果。在这种模式下，没有半透明区域，要么完全不透明，要么完全透明不可见。当需要使用透明通道来决定物体的形状（例如树叶、带孔的布块）时，此功能非常有用。贴图中Alpha值小于Alpha Cutoff属性的区域会被裁剪掉。（所以图片都有Alpha值） 贴图中alpha小于0.16的部分都会完全不显示，大于0.16的部分会完全显示（无透明度） Transparent（透明） - 适用于渲染逼真的透明材质，如透明塑料或玻璃。在这种模式下，材质会使用透明度值（基于贴图的alpha通道和颜色的alpha），但反射和高光还保持可见，就像真正的透明材质一样，所以即使alpha为0，物体看起来并不是完全透明的。 物体有半透明的状态，但是由于有反射和高光，所以看起来并不是全透明 Fade（淡出） - 透明度可以让物体完全透明，包括任何高光或可能的反射。如果模型需要淡入或淡出，则此模式非常有用。它不适合渲染真实的透明材料，如透明塑料或玻璃，因为反射和高光也会消失。 全透明 Albedo（反照率） Albedo属性 Albedo参数用来控制物体表面的基本颜色。 有时仅为Albedo参数指定一个颜色就够了，但为Albedo参数指定一张贴图更为常见。这张贴图应该表示模型表面的颜色。需要注意的是，Albedo贴图非常重要的一点是贴图内不应包含任何灯光阴影信息，这样才能基于场景环境渲染出正确的光影效果。 透明度Albedo颜色的Alpha值控制材质的透明程度。仅在渲染模式设置为非Opaque时有用。上文渲染模式中提到了选择正确的透明度模式非常重要，因为它决定了是否能够看到合适的反射和高光效果，以及能否完全透明。 Transparent模式下不同alpha值的效果 当使用贴图作为Albedo参数的值时，可以通过贴图的Alpha通道来控制材质的透明度。Alpha通道的值对应透明程度，白色完全不透明，黑色完全透明。通过这种方式可以让材质的不同区域有不同的透明度。 带有RGB通道和Alpha通道的贴图，可以点击RGB / A按钮来切换预览的图像通道 最终的结果，一个建筑物的破碎的窗户。玻璃中的缝隙完全透明，而玻璃碎片部分透明，窗框完全不透明 Metallic（金属） Metallic属性 Metallic属性不仅适用于真实的金属的材料。这个属性被称为金属，是因为可以控制一个物体的表面的金属程度或非金属程度。 Metallic参数决定了物体表面的像金属的程度。金属度高时，物体表面会更多地反映环境并且其Albedo颜色变得更不明显。在全金属表面上，表面颜色完全由环境反射决定。金属度较低时，Albedo颜色更清晰，并且表面上也可以看到反射。 Metallic参数从0到1的不同情况（smoothness保持0.8） 默认情况下，如果没有指定贴图，Metallic和Smoothness参数都由滑块控制。这对一些材质已经足够了。但是，如果模型的表面混合了不同的部分，比如一部分是布料，但是一部分是金属纽扣，就可以使用贴图来控制材质表面上的金属度和平滑度。贴图中越亮的部分表示金属感越强，越暗的部分表示金属感越弱。 Metallic参数使用贴图时，Metallic和Smoothness的滑块会自动隐藏。材质的金属度由贴图的R(红色)通道中的值控制，材质的Smoothness属性由贴图的Alpha通道控制（贴图的绿色和蓝色通道会被忽略）。这意味着你可以用单个贴图定义粗糙或光滑的区域和金属或非金属的区域，这对于复杂的模型表面非常有用。例如一张贴图通常包含多个区域，比如皮料、布料、手和脸的皮肤、金属扣等。 没有Metallic贴图时的皮箱 上图中，皮箱的材质不包含Metallic贴图，整个箱子共用一个metallic值和一个smoothness值，这样效果就不好。理想情况是，箱子的金属扣应该金属感更强。 使用了Metallic贴图的皮箱 上图中，材质被赋予了一张Metallic贴图。现在金属扣的金属感很强并且光照也有相应的变化。皮革提手比皮箱的皮革表面更光滑，但是它们的“金属感”较低，所以它看起来是有光泽的非金属表面。最右边的贴图可以看出：金属感强的区域是贴图中颜色较浅的区域，而金属感低的区域是贴图中灰黑色区域。 Smoothness（平滑度）默认情况下，没有使用Metallic贴图时，Smoothness是由一个滑条控制物体表面有更多的“微观表面细节”还是更光滑。 smoothness的值从0-1的不同情况 上面提到的“微观表面细节”不是直接能看到的细节，而是在计算光照时参与计算的一个概念。微观表面细节越多，则受到光照时，发生的散射越强。表面越光滑，所有光线都倾向于以可预测和一致的角度反射。极端情况下，非常光滑的表面反射光的方式和镜子一样。较光滑的表面在较宽的角度范围内反射光线（因为光线照到微观表面的凸起），因此反射具有较少的细节，并以更加分散的方式散布在表面上。 平滑度的低，中和高值（从左到右），作为材质的理论微观表面细节图。黄线代表照射到表面的光线并在不同平滑度下的反射角度。 光滑的表面具有非常低的微观表面细节，或者根本没有，因此光线以均匀的方式反射，产生清晰的反射。粗糙表面在其微观表面细节处凹凸不平，因此光线会以广泛的角度反射出来，这些反射的光线平均后就是漫反射颜色，而且没有明显的反射。 平滑度的低，中，高值（从上到下） 使用Smoothness贴图与许多其他参数类似，可以指定贴图而不是使用单个滑块值。这样可以更好地控制物体表面不同区域的光滑度。 Source 选择光滑度的来源 Metallic Alpha：从Metallic贴图的Alpha通道中获取。贴图中alpha的0-1对应Smoothness的0-1。 Albedo Alpha：从Albedo贴图的Alpha通道中获取。贴图中alpha的0-1对应Smoothness的0-1。 Forward Rendering Options在材质的最下方，有两个特殊的选项，主要是针对Metallic和Smoothness属性。 Specular Highlights：是否显示高光效果 Reflections：是否显示反射效果 Normal map（法线贴图/凹凸贴图） 法线贴图是凹凸贴图的一种。它是一种特殊的贴图，可以将表面的细节（如凹凸、凹槽、划痕）添加到受光照影响的模型中，就好像它们是由真实网格渲染的一样。 例如，你可能想飞机外壳上有沟槽、螺钉、铆钉。一种方法是将这些细节建模为几何图形，如下所示。 通过建模实现的飞机外壳上的细节 将这种微小的细节建模成“真实”的网格通常不是一个好主意。在上图右侧，你可以看到制作单个螺母需要很多个面。在有许多表面细节的大型模型上，这会需要非常多的面。为了避免这种情况，我们应该使用法线贴图来增加复杂表面的细节，并使用较低分辨率的多边形表面来模拟较大的形状。 如果用凹凸映射来实现这些细节，那么表面网格可以变得更简单，并且仅用一张贴图就可以表现出这些细节，现今的图形硬件不用耗费太多资源就可以渲染出来。添加法线贴图后，飞机外壳可以是一个低面模型，但是螺丝、铆钉、凹槽、划痕部分受光照影响后会显得有深度，就像网格实现的一样。 法线贴图中绘制了螺丝、凹槽、划痕，它会影响光线如何从这个表面反射，给人以3D细节的视觉效果。除铆钉和螺钉外，贴图还能包含更多细节，如细微的凹凸和划痕 在现代游戏开发美术工作流中，美术使用他们的3D建模程序基于高模（高精度、高面数的模型）生成法线贴图，然后将法线贴图映射到对应的低模（低精度，低面数的模型）。低模使用法线贴图可以渲染出高模细节，能大幅提高运行时的性能。 总结今天学习了Standard Shader的几个属性： Rendering Mode 渲染模式 Albedo 反照率 Metallic 金属度 Smoothness 平滑度 Normal Map 法线映射]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚本]]></title>
    <url>%2F2019%2F05%2F21%2F%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.bit和Byte有什么区别？有什么关系？2.有几种浮点类型？为什么float = 0.1f要加f？3.C#中一个变量的作用范围是怎么判定的？4.char类型和string类型赋值方式有什么不同？5.前加加和后加加有什么区别？6.为什么有时候不能进行隐式转换？7.显式转换的语法是什么？8.成员变量和局部变量的区别 Unity脚本（继承MonoBehaviour类）的脚本必须拖到GameObject上才能生效。如果没继承MonoBehaviour，就无需拖到游戏对象上 每次将脚本附加到GameObject上时，会使用这个脚本模具创建一个实例。 整数类型整数又分为有符号整数和无符号整数，有符号整数会使用1位(bit)表示正负的符号，无符号整数会用所有的位数来表示数值，所以相同位数的数值，有符号和无符号能表示的数值范围有差别。举例如下： sbyte 8位有符号整数，范围是[-128, 127] byte 8位无符号整数，范围是[0, 255] int 32位有符号整数，范围是-2,147,483,648到 2,147,483,647 1个bit（比特）代表计算机内的一个0或11个Byte（字节）= 8bit 一个sbyte的数值有8位，在计算机内部表示可能是01110111，一共有8位0/1的值。 一般在缩写时，小写字母b代表bit，大写字母B代表Byte，比如1KB=8Kb。 浮点类型浮点类型可以认为是小数类型，有三种类型的浮点数类型，分别是：float、double和decimal。 这三种类型所占用的空间分别是32位，64位和128位，精度依次升高。不过在Unity中最常用的还是float，如果float精度不够时，可以尝试使用后两个类型。 浮点数在赋值时需要注意的是：默认C#中浮点数常量是double类型，比如3.14默认是double类型，当你将3.14赋值给float类型变量时会报错。 1float pi = 3.14; 报错的内容是：error CS0664: Literal（字面量） of type double cannot be implicitly（隐式） converted to type ‘float’. Add suffix ‘f’ to create a literal of this type。 123int a; //变量const int b = 10; //b为常量，10为字面量string str = "hello world！"; // str 为变量，hello world！为字面量 含义是：无法将double类型转换为float类型，需要将double类型手动转换为float类型。 这时候需要在3.14后面加上f，将3.14强制转换为float类型的数值。后面会讲解显示转换和隐式转换。 1float pi = 3.14f; 字符类型字符类型包括单个字符char和一串字符的字符串类型string。 12char firstLetter; // 第一个字母string playerName; // 玩家名字 字符和字符串的赋值方法如下，char类型需要使用单引号，string类型需要使用双引号。 12char question = '?';string stem = "编程使我快乐"; 变量的作用范围C#代码中变量的声明是有作用范围的，在特定的范围内才能获取、操作这个盒子。C#中变量按作用范围可以划分为成员变量和局部变量。 确定一个变量的作用范围很好记，一个变量的作用范围就是变量当前所处的大括号范围内。如下面代码中score的作用范围就是最外层的大括号，而hp的作用范围仅限于Start方法的大括号。 12345678910111213141516171819202122using System.Collections;using System.Collections.Generic;using UnityEngine;public class MyClass : MonoBehaviour&#123; int score = 100;// 成员变量 // Use this for initialization void Start () &#123; int hp = 100; // 局部变量 score = 50; &#125; // Update is called once per frame void Update () &#123; score = score + 1; // 这行代码正常 hp = hp + 1; // 这行代码会报错 &#125;&#125; 上面这段代码中，Update方法中的第二行代码会报错，因为hp的作用范围仅限于Start方法中，无法在Update中获取。 运算符+(一元)运算符可能看起来有些奇怪，因为它不会改变运算的结果，不过把值变为正的，而是仍旧保持原始值。例如var2是-1，则+var2的结果还是-1。这个运算符只在运算符重载时有用，后面会讲到。 特别注意除法操作，在大多数编程语言中，如果两个int类型的数相除，结果还是int类型，会丢失小数部分。如果想要保留小数部分，需要手动将int类型转为float或double类型以保留小数。 12Debug.Log(10/3); // 3Debug.Log(10/3f); // 3.333... 只有加号能用于字符串的连接，其他运算符不能用于处理字符串。 前加加与后加加的区别可以记为：前加加是先加后赋值，后加加是先赋值后加。 1234float var1 = -2, var2 = 7.21f; // 可以在同一行进行声明和初始化Debug.Log(var1++); // 先返回var1的值，再+1，成为-1Debug.Log(++var1); // 先+1成为0，再返回var1的值 类型转换无论是什么类型，在计算机内部，所有的数据都是由0和1构成的。一个变量具体代表的内容是由解释这些数据的方式来确定的。比如char类型和ushort类型，这两种类型存储方式完全相同，都存储0-65535之间的数字，但是一个代表的是字符，另外一个是数字。 有时候需要对数据的类型进行转换，有以下两种形式： 隐式转换 从类型A到类型B的转换不需要额外的代码，可以自动执行转换。 显示转换 只能在某些情况下转换，需要额外写代码。 ** 隐式转换 ** 12int a = 10;float b = a; 如上面两行代码，a是int类型的变量，b是float类型的变量，但是可以直接将a赋值给b。 无法隐式转换时，编译器会报错。 比如下方的代码： 12float a = 10;int b = a; float类型只能隐式转换为double类型，如果转为int类型，就会报如下错误： error CS0266: Cannot implicitly convert type `float’ to `int’. An explicit conversion exists (are you missing a cast?) 那么能不能把float转成int呢？答案是可以的，但是必须显式转换。 ** 显式转换 ** 显式转换就是通过明确的代码，将一种数据类型转换为另一种数据类型。 如上面的代码，可以通过显式转换的方式转换数据类型： 12float a = 10.1f;int b = (int)a; 显式转换的语法是： 1(&lt;数据类型&gt;)&lt;变量名&gt; 需要显式转换的情况一般都是：转换时会发生数据或数据精度丢失。比如double类型的数据精度比float类型精度高，从double转为float类型时，需要显式转换。 上面的代码转换时，由于b是整数类型，变量a值为10.1的小数部分会丢失，b的值是10。 10.1f中的f也是一种显示转换，这种显示转换只能用于字面值（即字面就代表了数值的常量）。一般只在对float类型的变量赋值时使用。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Standard Shader的用法]]></title>
    <url>%2F2019%2F05%2F20%2FStandard-Shader%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考题:1.动手创建3个材质，分别使用Standard Shader的三种，看看有什么异同。2.PBS是什么？如何发挥作用？ 对于大部分的材质需求，使用Unity内置的Standard着色器就够用了。 Standard ShaderUnity内置的Standard Shader包含了非常全面的功能。可以用来渲染真实世界中的物体，比如石头、木头、玻璃、塑料、金属等。Standard Shader在一个Shader中支持了多种Shader类型以及它们之间的组合，仅仅通过设置或不设置材质中的某些属性即可。 Standard Shader还包含一种名为Physically Based Shading（PBS，基于物理的着色）的高级照明模型。PBS模拟了现实世界中材质和光照之间的相互作用。从Unity5开始支持在实时渲染中使用PBS。PBS在灯光和材质一起作用下才能发挥最佳效果。 PBS可以让我们的模型在不同的灯光下看起来表现一致。它的算法模拟光在现实中的特性，遵循物理原理，包括能量守恒（物体不会反射比它们接收的光更多的光），菲涅耳（Fresnel）反射（所有表面在掠射角度下反射会更加强烈），以及表面互相遮挡等等。 Standard Shader是基于硬表面（也称为“建筑材料”）设计的，可以支持大多数真实世界的材质，如石头、玻璃、陶瓷、黄铜、银器、橡胶等。不过它也可以用于不是硬表面的材料如皮肤，头发、布料等，也有一个不错的效果。 Standard Shader将多个类型的shader（例如漫反射，高光，法线高光，折射）合并到单个着色器中。好处是可以在场景的所有区域使用相同的照明计算方式，从而为使用Standard Shader的所有模型提供逼真、一致的光照和阴影。 三种Standard Shader的区别如果你尝试切换Shader，你会发现有三种Standard Shader： 三种Standard Shader 这三种Shader能达到的效果是相同的，只是在属性参数设置上稍微有些不同。 StandardShader的参数中有一个“metallic”属性，用来设置材质的金属度。 金属度最低时，材质会有与入射光相同颜色的高光，并且模型表面时几乎不会反射。金属度最高时，Albedo颜色会控制高光的颜色，并且大部分光线将反射为高光。 metallic参数从0-1的变化 Standard(Specular高光 setup)这个Shader适合很多传统的美术工作流程。高光颜色用于控制材质中镜面反射的颜色和强度。这样就能设置与漫反射不同颜色的镜面反射颜色。 只修改灰度，和metallic属性的效果类似 但是还可以给个颜色 如上图所示，Specular的颜色的灰度值可以对应到Standard中的Metallic的0-1，此外Specular还可以设置颜色，这个颜色会影响高光。 Standard(Roughness setup)Roughness与上面两个Shader不同的是，Roughness Shader中没有Smoothness（光滑度）这个属性，取而代之的是Roughness（粗糙度）这个属性。顾名思义，光滑度就是设置材质的光滑程度，取值范围是从0到1，0代表光滑度很低（很粗糙），1代表非常光滑（类似镜面）；粗糙度就是设置材质的粗糙程度，取值范围是从0到1，0代表粗糙度很低（很光滑），1代表粗糙度很高（很不光滑）。 所以Standard（Roughness setup）与Standard的区别是：一个取值相反参数。如果在Standard中Smoothness设置为0.8，那么在Standard(Roughness setup)中Roughtness值设置为0.2就能取得相同的效果。 一般情况下，上面三个Shader选择使用任何一种都可以很好地表现大多数常见材质。因此大多数情况下，选择一种或另一种是个人喜好的问题，只要适合你的项目的美术工作流程即可。例如，以下是三种不同Shader创建的橡胶塑料材质的示例： 第一个代表metallic工作流程，材质的Metallic设置为零（非金属）。第二个设置几乎完全相同，但高光设置为几乎黑色（所以我们不会看到镜面反射）。第三个将Roughness设置为0.4，即1-Smoothness。 有人可能会问，这些值从何而来，什么是“近乎黑色”，究竟是什么让草与铝不同？在基于物理着色的世界中，我们可以使用来自已知真实世界材质作为参考。Unity官方已经将这些参考文献中的一部分编译成了一组可用于创建材料的便利图表。 Standard参考图表 Standard(Specular setup)参考图表 Standard与Standard(Roughness setup)的设置几乎一样，只是Smoothness = 1 - Roughness，所以Standard(Roughness setup)可以参考Standard图表。 总结Standard有三个Shader，选择使用任何一种都可以很好地表现大多数常见材质。因此大多数情况下，选择一种或另一种是个人喜好的问题，只要适合你的项目的美术工作流程即可。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[材质]]></title>
    <url>%2F2019%2F05%2F20%2F%E6%9D%90%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[思考题：1.动手创建一个材质，尝试修改其中的各个参数，看看有什么效果。2.一个模型可以有几个材质？怎么设置？3.Unity除了内置的Standard着色器外，还内置了哪些着色器？4.什么是Texture Atlas？为什么使用？5.什么是UV映射？6.如何预览贴图？ 材质是连接贴图、着色器和模型的重要资源。 创建材质在Project窗口任一文件夹或空白处右键，Create &gt; Material可以创建一个新的材质。 新创建的材质默认会被设置为Standard着色器，所有贴图属性为空，如下图所示： 材质创建后，可以在Project窗口中选中，在Inspector中修改其所有属性。 将材质拖拽到场景或Hierarchy中的任一物体即可将材质赋予对应的物体。 ** 注意 ** 如果一个模型有多个材质，不要使用拖拽的方式赋予材质，否则会将多个材质全部替换为拖拽的材质。正确的做法是：将材质拖拽到模型Mesh Renderer的Materials列表的对应位置。 编辑材质编辑材质的第一步是确定要使用的着色器，可以点击材质的Shader下拉菜单选择着色器。 选中的着色器决定了材质包含的可配置的属性。 属性的类型包括颜色、滑条、贴图、数字、向量。如果将材质赋予了场景中的模型，修改属性会实时反馈到场景的模型上。 其中修改贴图属性有两种办法： 将贴图从Project窗口中拖到材质的贴图属性的小方框中（最常用） 点击材质属性的小圆点，可以从列表中选择贴图 ** 小技巧 ** Ctrl+点击贴图的小图标，可以预览贴图。 Ctrl+点击红框位置可以预览贴图 内置着色器Unity除了内置的Standard着色器外，还内置了一些其他类型的着色器： ** 着色器 ** ** 用途 ** FX 照明和玻璃效果。 GUI和UI 用于用户界面图形。 Mobile 经过简化的适用于移动设备的高性能着色器。 Nature 适用于树木和地形。 Particles 用于粒子系统特效 Skybox 在场景中所有的模型背后渲染的背景环境 Sprites 用于2D精灵系统 Toon 卡通风格的渲染。 Unlit 用于不需要光照和阴影的渲染 Legacy 旧的Unity版本中的着色器，已经被Standard着色器取代 当你需要使用对应的效果时，可以先去里面看看有没有合适的Shader。 Shader技术细节我们都知道在Unity里写代码需要用C#语言，不过Shader是一种比较特殊的代码，用来处理图形的显示。 Shader代码里包含了一系列数学计算和算法，用于将模型的顶点位置和表面颜色计算出来。比如Unity内置的Standard着色器内处理了复杂的真实光照计算。 Shader代码中定义的属性，可以通过Material的界面进行赋值。材质会被游戏物体上的Renderer组件引用，来渲染游戏物体的每一个网格。 不同的材质可以引用同一张贴图，这些材质可以是相同或不同的着色器。 如下图所示，一共有三个材质，使用了2个Shader和一张贴图。 上图中有一辆红色汽车和一辆蓝色汽车。两款车型分别使用单独的车身材质，分别为“Red car material”和“Blue car material”。 这两种车身材质都使用相同的自定义着色器“Carbody Shader”。使用自定义着色器的原因是汽车的渲染需要额外的功能，例如金属闪烁效果、自定义的损坏遮罩贴图功能（可以在车身的某一块增加划痕、擦碰等效果）。 每个车身材质都有一个对“Car Texture”贴图的引用，这是一个包含车身所有细节的贴图，但是没有特定的颜色。 Carbody着色器还可以接受设置自定义颜色，红色和蓝色汽车使用同一张贴图，只需要设置不同的颜色，就能为每辆汽车提供不同的外观。 车轮模型使用了单独的材质，但是这两辆车的车轮共用了同一个材质，因为两辆车上的车轮没什么差别。轮子材质使用标准着色器，并再次使用了Car Texture贴图。 注意这里仅使用了一张汽车贴图就包含车身和车轮的细节，这种做法叫做Texture Atlas（纹理图集），贴图的不同部分映射到了模型的不同部分。使用Texture Atlas可以提高游戏的性能。 你可能注意到，车身材质使用贴图中也包含了车轮图像，但车轮并未出现在车身上，这是因为该部分纹理未映射到车身上。 同样，轮子材质使用相同的贴图，贴图中有车身细节。但车身细节未出现在车轮上，这是因为只有显示车轮细节的贴图部分映射到车轮上。 该映射是由美术同学在外部3D建模程序中完成的，叫做“UV映射”。 总结Shader定义了： 渲染物体的方法。包括代码和数学计算，可能包括光源角度，视角和任何其他相关计算。着色器也可以根据最终用户的图形硬件来选择。 可以在材质Inspector中自定义的参数，例如贴图，颜色和数值。 材质定义了： 使用哪种着色器渲染此材质。 着色器参数的具体值 - 例如使用哪些纹理贴图，颜色和数值。 自定义着色器由开发同学编写，使用ShaderLab语言创建，复杂的会涉及到Cg/HLSL语言。不过，让着色器在各种显卡上运行良好是一项有难度的工作，需要对显卡的工作原理有相当全面的了解。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渲染和贴图]]></title>
    <url>%2F2019%2F05%2F20%2F%E6%B8%B2%E6%9F%93%E5%92%8C%E8%B4%B4%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Unity中图形模块的两个重要模块是哪两个？ 决定物体外观的因素有什么？这些因素之间有什么关系？ 材质的可配置参数取决于什么？ 着色器是什么？根据哪两种信息来渲染什么？ 贴图是什么？有哪些用途？2D图形和UGUI对图形有什么要求？粒子系统需要使用贴图吗？ Albedo是什么意思？还有什么其他类型的贴图？ 一定要动手查看一下贴图、材质和着色器在Unity中的关联。 本章涵盖： 3D模型的贴图 GUI 粒子 渲染和光照是Unity中图形模块的两个重要模块。 在Unity中渲染一个物体，最重要的三个概念是材质（Material），贴图（Texture），着色器（Shader）。 材质通过使用贴图，Tiling参数，颜色参数等来定义物体表面应该如何呈现。材质的可配置参数取决于材质使用的着色器。 着色器是一段代码，基于场景的光照信息和材质的配置，计算物体最终渲染的顶点位置和颜色。着色器决定了材质上面的可配置参数。 贴图是位图图像。材质可以对贴图进行引用，然后着色器在计算GameObject的表面颜色时可以使用贴图中的信息。除了GameObject表面的基本颜色（Albedo）外，贴图还可以丰富材质表面的许多其他方面，例如自发光、表面凹凸等。 这三者之间的关系是： 一个材质只能使用一种着色器，一种着色器可以被多个材质使用。 一个材质可能需要多张不同的贴图（基本的漫反射贴图、法线贴图、高光贴图等），一张贴图可以被多个不同的材质复用。 材质可以和网格Mesh关联起来，网格的表面最终会显示成对应材质的样子。 对于大多数的写实渲染需求（角色、场景、环境等），使用内置的Standard着色器通常是最好的选择。 对于特殊的渲染需求，Unity也内置了多种不同风格渲染的Shader。 如果这些都不能满足你的需要，当然还可以自己制作ShaderGraph或者写Shader代码来实现。 之前我们已经学习了图片（贴图）导入图片导入的设置，今天我们来学习一下贴图在Unity中的作用都有什么。 Texture（贴图）通常情况下，物体的Mesh网格只给出了物体的大概形状，大部分细节都由贴图提供。贴图是绘制在物体网格表面的图像。你可以把贴图想象成有弹性的壁纸，这个壁纸可以通过拉伸、压缩贴到网格的表面。通常贴图的定位（UV信息）是通过3D建模软件完成的。 一个圆柱体，贴上树皮的贴图，看起来就像是一段树干 3D模型的贴图一张贴图要想贴到模型上，必须先将贴图赋予一个材质，然后将材质与模型关联。 贴图有不同类型和用途，例如： Albedo（反照率）贴图：一个材质最基础的贴图，能表示材质表面反射的颜色及比率。 这里用到了光学中的概念，人眼能看到一个物体是黄色，是因为黄色的光反射到了人的眼睛里。反照率贴图就是一张这样的贴图，可以理解为是物体原本自身的颜色贴图。 一般的漫反射贴图都是实际颜色 法线贴图：一种特殊的贴图，通过贴图的方式来实现模型表面的凸凹，增加模型的细节 一般的法线贴图大概都是这个样子的 一个材质可以使用多张贴图，比如同时使用漫反射贴图和法线贴图，就能让模型有基本颜色的基础上，细节更加丰富。 贴图的尺寸应该尽可能使用2的n次幂的大小，比如256x256，512x1024等尺寸。 2D图形2D游戏中，贴图需要设置为Sprite。在场景中绘制时类似一个纸片的形式，没有厚度。 在3D视角下查看2D的Sprite 一般情况2D游戏的角色需要一系列的图片来实现角色的不同状态或者动画。 GUI使用Unity内置的GUI系统时，用到的图片需要设置为Sprite。 游戏的图形用户界面（GUI）可以让玩家查看信息、进行交互。例如，显示游戏当前得分、游戏菜单是游戏中常见的GUI。虽然界面的图片与模型表面的贴图有很大不同，但是都是使用的图片资源。 粒子网格非常适合表示实体物体，但对于魔法遗留的火焰，烟雾和火花等效果并不适合。粒子系统可以更好地处理这种特效。粒子一般用来表示很小的东西，比如液体或气体。当大量粒子一起运动时，可以产生非常逼真的效果。例如，可以将火焰贴图的粒子从中心点以极快的速度发射出去来模拟爆炸；可以用大量高速向下运动的水珠来模拟瀑布。 总结本文讲解了渲染的三大核心概念：材质，贴图和着色器。 材质是贴图和着色器的载体。 着色器决定了如何使用材质的参数来计算最终的显示结果。 贴图是一个材质的灵魂，贴图的质量很大程度决定了场景、角色的效果。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏开发中的美术工作流程（1）]]></title>
    <url>%2F2019%2F05%2F19%2F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%BE%8E%E6%9C%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.渲染路径有哪两种设置方式？2.渲染路径主要影响什么？3.Deferred shading和Forward rendering的区别 大部分用户对游戏产生兴趣可能都是从游戏画面开始的。 视图操作捕捉Unity的快捷键如下所示： 按住鼠标中建平移视图。 按住鼠标右键+Alt键旋转视图。 滑动鼠标滑轮推拉视图。 按F键可以快速锁定选中的目标。 在场景中选中一个物体后，按W键可移动物体，按E键可旋转物体，按R键可缩放物体。在操作的同时按住Ctrl键可以启用单位捕捉功能，使用单位捕捉能精确摆放位置或旋转物体的角度，默认的捕捉精度是1个单位（相当于3D动画软件中的1m），在菜单栏中选择Edit-&gt;Snap Setting，可以对捕捉精度进行设置，如下图所示。Unity资源商店中的插件ProGrids，提供了更多捕捉设置，使用起来更加便捷。 光照和渲染系统光源类型Unity提供了4种光源，主要区别在于照明的范围。Area Light是矩形的区域灯光，它通过一个矩形范围向一个方向发射光线，注意，它只能被用来烘焙Lightmap（光照贴图）。 渲染管道在开始一个Unity项目的美术工作之前，我们应该清楚Unity支持多种渲染管道，选择不同的渲染方式将可能会影响到光照和其他很多设置，因此，确定渲染方式，并根据其特点制作美术资源也是非常重要的。 Unity目前主要支持三种渲染方式，它们分别是Deferred Lighting、Forward和Vertex Lit（已经不推荐）。 Deferred Lighting有最真实的光效，可以不受数量限制地使用灯光和实时阴影，当需要使用大量的实时光且光照的范围较小时会取得很好的性能，所有的灯光都支持per-pixel（像素光照）用于计算法线贴图。该模式当前不支持抗锯齿和半透明显示，需要显卡支持Shader Model 3.0或更高，目前不支持手机平台。 Forward是默认的渲染模式，与Deferred的主要区别是Forward渲染模式下的光源并不总是按照像素光照方式计算。如下图所示，左图没有使用像素光照，照明效果受模型顶点数量的影响且不能正确渲染法线贴图，也没有阴影。右图使用了像素光照，渲染出高光和法线贴图的凹凸效果，可以正确显示阴影。 在Forward模式下，光源的表现与各种设置有关。默认所有的光源都被设置为Auto（自动）模式，如下图所示，Unity会根据光源强度来决定哪个光源采用像素光照。如果将光源的Render Mode设为Important，该光源将总是采用像素光照；如果设为Not Important，该光源将总是采用订点或SH模式（更不精确的一种模式）。注意，场景中最亮的方向光将总是像素光照。 设置光源的渲染模式和像素光的数量 Vertex Lit是光照效果最简单的渲染模式，不支持实时阴影和法线贴图，目前官方已经不推荐使用。 在菜单栏中选择Edit-&gt;Project Settings-&gt;Graphics，打开图形设置窗口，在这里可以设置渲染模式，默认是Forward。选择场景中的摄像机，也可以单独为其设置渲染模式，如下图所示。 为摄像机设置渲染模式 质量设置 设置渲染质量 实时阴影所有的实时光源，都能够提供实时阴影（在模型的Mesh Renderer中可以设置是否投影和接收阴影，模型所使用的Shader也会影响到阴影投射），在光源设置的Shadow Type中可以选择使用Hard Shadows（硬边阴影）或Soft Shadows（软边阴影），如下图所示。设置Resolution可以影响阴影的质量，默认是采用质量设置中的设置。 设置阴影 注意，Bias这个值是阴影的偏移量，默认不是0。如下图所示，左图Bias的值为默认的0.05，脸上的阴影几乎看不到，中间图的Bias设为0，可以看到脸上细节的阴影。设置阴影偏移主要是为了防止向自身投影可能会产生的锯齿，右图是Bias为0时自投影出现了锯齿。 在质量设置的Shadows选项组中，提供了对阴影的设置，如下图所示，这会对所有场景中的实时阴影造成影响。 Shadow Distance决定了阴影能显示的最大范围，因为实时阴影对性能是有较大影响的，对于比较远的地方，可以忽略阴影的效果。另外，范围越大，局部的阴影质量会越低。 Shadow Projection主要对方向光产生影响，选择Close Fit会得到更高的阴影精度，但当摄像机移动时阴影投射位置可能会不准确，Stable Fit可以得到正确的阴影投射位置，但阴影精度略低。 Shadow Cascades（阴影区域划分）可以设为0或更高，它的作用是将阴影投射分为几个区域。 设置Shadow Cascades 如果将Shadow Cascades设为0，整个场景将使用一张阴影贴图，其结果可能是近处的阴影精度不够，远处精度过高。提高Shadow Cascades的数量会对性能有一定影响，但比将场景的总体阴影质量全部设得比较高，效率要高一些。 Unity允许实时预览Shadow Cascades的区域范围，每块区域所使用的阴影贴图大小是一样的，因此阴影所影响的区域越小，投影质量越高。因为摄像机透视的关系，远处的可视区域会更大，所以实际的投影精度会更低。 环境光Unity场景默认会提供一个方向光作为默认光源，如果删除这个唯一的光源会怎么样呢？如下图所示，场景中没有任何光源，但并没有一片漆黑，仍有均匀的光线。 场景中的均匀光线是环境光提供的。环境光是Unity提供的一种特殊光源，它没有范围和方向，会整体改变场景亮度。环境光在场景中是一直存在的，在菜单栏中选择Window-&gt;Lighting-&gt;Settings，打开Lighting窗口，如下图所示，在这里可以设置环境光和Lightmap等。 环境光设置 在Skybox Material中，Unity提供了一个默认的Skybox材质。 默认Environment Light（环境光）和Environment Reflection（环境反射）的Source（来源）都是Skybox，光源会受到天空盒的影响。如下图所示，场景中的光源完全一样，但使用了不同的天空盒，其光照强度和反射效果看起来都不同。 环境光和环境反射都有一个Intensity Multiplier（强度）选项，该值是环境光和环境反射的强度。如果将这两个值都设为0，然后删除场景内所有的光源，场景中将不会存在任何亮度。环境光可以设置为Realtime或Baked。 默认Auto Generate复选框是选中状态的，Unity会自动创建环境光，环境反射和Lightmap；如果取消选中该复选框，需要手动选择Generate Lighting生成光效，然后才能看到正确的环境光和环境反射效果。针对环境反射效果，Unity实际是根据天空盒材质生成了一张环境反射贴图，如下图所示。 注意，环境反射效果和模型使用的Shader功能有很大关系，Unity提供的默认材质Standard材质（基于物理的材质）可以很好地反映出环境反射效果，但其他材质，如Unlit（无光），环境反射对这类材质毫无影响。 Fog（雾）直接照明和间接照明Unity的光源提供了两种照明方式，一种称为直接照明，如下图所示，场景中只有一个方向光，为了更好地说明问题，本示例的环境光、环境反射和间接照明强度都已经设为0，光源只能到达直接照射的表面，无法到达的位置没有任何亮度，这就是直接照明。增加 Intensity的值可以增加直接照明的光照强度。 Unity提供的另一种照明方式称为间接照明，如下图所示，场景中同样只有一个方向光，环境光、环境反射都已经设为0，但Indirect Multiplier（间接照明强度）的值设为2，光源不但能到达直接照射的表面，还能照明没有到达的位置，这就是间接照明，也称作全局光（Global Illumination）。注意，接收间接照明的模型一定要被设为Lightmap Static。 Unity的光源提供了三种Mode：Realtime、Mixed和Baked。默认的光源是Realtime模式，光源的光照和阴影都是实时计算的，如果想取得实时的全局光效果，需要在Lighting窗口中选中Realtime Global Illumination复选框，如下图所示。 实时的全局光可以动态地改变全局光源的强度和方向，但在低端硬件上对性能会造成很大影响。如果将光源设为Baked模式，光源的直接照明、间接照明和阴影效果都将被烘焙到Lightmap上。 将光源模式设为Mixed，即混合模式，光源的直接照明和阴影将采用实时模式，间接照明效果会被烘焙到Lightmap上。启用该功能必须保证Lighting窗口中的Mixed Lighting-Baked Global Illumination复选框为选中状态。 除了使用光源照亮场景，Unity提供的标准Shader包括一个Emission（发光）选项，如果启用该功能，就可以将Shader中的Global Illumination设置为实时或烘焙的全局光，其作用于普通光源的间接照明类似。如下图所示，场景中没有任何光源，仅使用一个普通模型照亮场景，这个模型必须被设为Lightmap Static，否则可能看不到效果。 最后需要注意的是，无论采用哪种间接照明方法，当Lighting窗口中的Auto Generate 复选框没有被选中时，都需要选择Generate Lighting才能生成间接照明效果。如下图所示，生成的数据将保存在LightingData.asset文件中，选择Clear Baked Data可以清除所有烘焙信息。 Lightmapping（光照贴图）Lightmap的作用是将场景中的光效烘焙到贴图上，然后叠加到模型的材质上，这样就不用担心光源数量和实时阴影对性能带来的开销，可以获得高质量的光影效果。缺点是光照不能动态变化，同时生成过多的Lightmap也会增加游戏的体积。 下面通过一个示例来说明创建Lightmap的技术。 1、准备好场景，将场景中所有需要烘焙Lightmap的模型设为Lightmap Static，如下图所示。设为Static的模型在游戏运行时不能改变位置、旋转角度或缩放。 使用Lightmap的模型必须有第二套UV，这套UV不能有UV重叠的地方。 如果参与Lightmap计算的模型没有第二套UV，选中Generate Lightmap UVs复选框后，Unity会为其自动生成一套Lightmap UV，如下图所示。 2、为了使Lightmap的效果更明显，这里将环境光和环境反射都设为0，仅创建了一个点光源，将Indirect Multiplier设为2，如下图所示。注意，要单击场景窗口的“太阳”图标，才能在场景中预览实际的光效。 3、在Lighting窗口中选择Generate Lighting生成光照，因为默认的光源是Realtime类型，光照将由实时的直接照明和实时的间接照明构成，效果如下图所示。 4、将光源设为Baked模式，再次生成光照，这一次将生成光照贴图并保存到工程中，如下图所示。 我们生成的Lightmap使用的是默认设置，Lightmap窗口中提供了很多选项可以对Lightmap进行设置，如下图所示。 Lightmapper（渲染器）：Unity提供了多种Lightmap解决方案，默认的方案名称为Enlighten。 Indirect Resolution（间接照明计算精度）：间接照明的精度越高，计算越慢，保存有光照烘焙数据的文件也会变得越大。如果这个值过低，间接照明的效果就几乎看不到了。 Lightmap Resolution（光照计算精度）：Lightmap精度越高，计算时间越长，生成的Lightmap数量也越多，在场景窗中选择Baked Lightmap，可以在场景中实时预览Lightmap精度，如下图所示。 Lightmap Padding（贴图间距）：场景中通常有多个烘焙对象，Unity将自动排列组合这些烘焙对象的UV到光照贴图上，Lightmap Padding值即是不同烘焙对象UV在Lightmap上的间距。 Lightmap Size（贴图尺寸）：当这个尺寸不能满足当前Lightmap的精度，就会生成多张Lightmap。 Compress Lightmaps（压缩贴图）：默认Lightmap都会采用压缩格式保存，这样会减小贴图容量，但Lightmap可能会出现接缝或锯齿。 Ambient Occlusion（环境阴影）：使模型的相交截面之间产生自然过渡的阴影，如下图所示。这个功能会增加一定的计算时间，但对最后Lightmap的精度没有影响。 Final Gather（最终聚集渲染）：使用最终聚集渲染技术改善Lightmap渲染质量，但会明显增加计算时间。 Directional Mode（方向模式）：选择Directional（直接），该模式可以在烘焙Lightmap时生成额外一张贴图保存有光源方向信息，能够表现出法线贴图效果，但会花费额外的存储和内存空间，如下图所示。根据项目的实际需要，要选择正确的Directional Mode，如果在项目中的静态模型根本没有使用到法线贴图，使用Directional模式就比较浪费了。 Indirect Intensity（间接照明强度）：这个值会整体改变间接照明的亮度，0表示没有间接照明，1表示正常。 在场景中选中参与光照计算的模型后，在Object maps中可以通过预览Baked Intensity查看该模型在Lightmap中UV分布所占的比例，如下图所示。 很多时候，我们需要调整场景中物件在Lightmap中所占的比例，比如远处的空地，可能只需要很小的精度，近处的物件虽然体积较小，但因为距离镜头较近，我们希望增加它在Lightmap空间中所占的比例。如下图所示，在模型的Mesh Renderer中将Scale In Lightmap的值加大，重新生成Lightmap后，发现当前模型在Lightmap中所占的比例提高了。 色彩空间在菜单栏中选择Edit-&gt;Project Settings-&gt;Player，在Rendering（渲染）选项组可以设置Color Space（色彩空间），默认为Gamma（传统的模式），另一个是Linear（线性），如下图所示。简单概况地说，颜色由深变亮是一个线性的过渡，但显示器信号按线性过渡传递到眼睛看到的却是错误的，通常亮度计算使用Linear方式，而最后会通过Gamma算法修正使肉眼看上去是正确的。因此，Unity中很多关于亮度的计算都是通过Linear方式，比如Lightmap计算。无论Color Space如何设置，计算过程都采用的Linear方式，但最后的Lightmap结果却是基于Gamma的。 设置Color Space 选择Gamma或Linear，会对光照的亮度效果产生很大影响，因此在项目初期应当确定使用哪种模式，针对不同的模式制作美术资源。注意，Linear方式在很多低端硬件是不支持的。下面是一组基于Gamma和Linear的光照对比图。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity 3D/2D手机游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Light Probe]]></title>
    <url>%2F2019%2F05%2F16%2FLight-Probe%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.如何创建一个空表？ Unity的预计算实时GI或者烘焙照明只对静态的物体起作用，对于可移动的物体，需要用一种新的技术来解决光照问题。 为了让动态物体（如交互式场景元素或角色）能够获得静态物体反弹的光线，需要将这些光照信息记录下来，并且在运行时能快速读取和使用。 通过在场景中放置采样点捕捉各个方向的光线来实现动态物体接收间接光的功能。这些采样点记录的光照信息被编码成可以在游戏过程中快速计算值。在Unity中，我们将这些采样点称为“光照探头”。 Light Probe（光照探头）这个技术是让动态物体从场景接收间接光的有效方法。尽管使用该技术的动态物体不会产生反射光，但通常这没有什么明显的影响。因为探测照明的物体往往是较小的物体，能反射的光很少，对周围环境的影响很有限。 什么是Probe Lighting(探测照明)？探测照明是一种用于实时渲染的高级照明技术，常用于场景中的角色或非静态(Static)物体的照明。探测照明运行时效率非常高并且预计算也很快。 探测照明通过3D空间中的探头对入射光进行采样并将这些信息通过球谐函数编码处理后保存成文件。这些信息占用的存储空间很少并且在运行时解码非常快。场景中的Shader可以使用这些信息来模拟物体表面的光照。 当然了，有优势也会有相应的劣势。在一定的计算量下，探测照明很难表现变化复杂的照明效果。但是如果增加模拟精度，计算代价也会随之增高。基于性能的考虑，Unity限制了计算的精度。另外一个，由于一个3D位置只用了一个球来进行模拟，在大模型以及较平的模型表面上的光照效果可能会不太好。 除去这些限制，探测照明在小的、凸状的物体上有很好的效果，同时性能很好。 放置Light Probe非静态物体根据距离最近的探头来接收光照。光照探头会将整个空间划分成一个个四面体，一个物体最终从哪个探头读取光照数据这个物体最终落在哪一个四面体中确定的。为了能够形成这些四面体，探头在摆放时必须形成三维的立体形状或者笼子的形状（不能只在一个平面上摆放）。 光照探针在编辑器中显示为球体 探测照明在运行时耗费的资源很少并且预计算也很快。但是，为了尽可能优化性能，在摆放光照探头时也有一些注意事项。 以整齐的密集网格排列会减少摆放时的工作量，但是这样会造成很多探头的浪费，因为很多探头在相近的位置接收到的光照都类似，在相似的光照位置，只需要一个或几个探头就足够了。 为了提高探头的效率，应该在光照变化比较大的地方多放置探头，在光照变化不大的地方少放探头。比如应该在从明亮到阴影的过渡位置多放探头，在反射光较强烈的表面多放置探头，在大的平面上少放探头。 设置Light Probe的步骤如下： 首先从GameObject菜单（GameObject &gt; Light &gt; Light Probe Group）创建一个Light Probe Group。 现在我们将开始放置探头。在Hierarchy中选择新创建的Light Probe Group。 在Inspector中，在Light Probe Group组件中选择“Edit Light Probes ”。 默认创建出来Light Probe Group有8个探头组成了一个立方体，你可以选中一个小黄球，移动重新摆放这些探头，也可以删除所有的探头重新创建。 选中一个探头，按Ctrl + D（Mac上的Cmd + D）可以复制一个出来，然后使用Move Tool（W）移动探头。 一般来说，放置探头在Y轴至少要放置两层（上文提到了探头需要组成三维立体或笼子形状），接近地面的区域可以多放置一些，空中可以少放置一些 这样的垂直布置光照探头的原因是为了能够从角色的头部高度或更高的空中接收从地面反射的间接光。当我们在场景复制这些光照探头来组成四面体时，确保任何物体都能落入四面体内。探头之间绘制的洋红线可以可视化这些四面体。 图中显示了光照探头的位置和它们位置之间构成的四面体。 可以通过Ctrl+点击多选或框选，选择多个探头进行复制并布置。将复制出来的探头移动到场景中光照“敏感”的区域。 ** 光照“敏感”的区域有哪些呢？ ** 寻找光影变化的区域，或者材质颜色变化较大的区域。记住，我们的目标是在整个场景中采样。为了保证添加的光照探头是合理的，我们需要确保它正在采样的地方照明有明显的变化。如果使用光照探头来采样没有特点或其他探头已采样过的区域，那么当动态物体通过这些探头获取光照信息时，不会看到太多变化，所以这些探头也没什么必要。基于游戏优化方面的考虑，我们应该尽可能让放进去场景的东西发挥一定的作用。 重复复制探头并将它们放置在合适的位置，直到所有探头形成的稀疏笼式布局，覆盖玩家可到达的区域。 在放置探头时，记住检查最底端的探头是否高于地面（在地面以下可能会造成地面上的物体光照信息错误）。 一个场景中可以创建多个Light Probe Group，比如一个光影复杂的城市中使用一个较密集的Light Probe Group，城市周边使用一个较稀疏的Light Probe Group。场景中有多个Light Probe Group时，Unity在运行时会将这些Group自动合并，并且会移除位置重复的Probe。 如图中有两个Light Probe Group，一个探头稠密用于较复杂的区域，一个探头稀疏用于简单的周边环境 预计算完成后，我们才能看见光照探头对场景中物体的作用。如果Lighting窗口中的Auto Generate复选框是选中的，预计算会自动开始；如果没有选中，可以点击右侧的Generate Lighting来启动预计算。 计算完成后，你就能看到场景中的非静态物体上的灯光和整个场景更契合了。 在GI烘焙中，大量的小物体会增加非常多的计算量，但是这些小物体反射的光基本上对场景没有影响。所以如果能将这些小物体排除在外，只接收间接光，不反射光，可以将预计算的时间减少很多。这也是光照探头针对GI的一个优化点。 物体Renderer上的Light ProbeLight Probe与计算完毕后，选中一个非Static的物体，你可以在场景中看到： 图中显示了包围物体的4个Probe 如果没有显示成上图那样，Lighting面板的Debug Settings按下图所示设置。 还记得MeshRenderer中关于Light Probe的设置么？（通常保持默认值即可） Off 不使用Light Probe，即不会从Probe中获取光照信息 Blend Probes 默认值。使用混合后的Probe。 Use Proxy Volume 用到的较少。当大的物体使用Blend Probes光照效果不好时，可以尝试使用。具体用法可以参考官方文档 Custom Provided 用于在Shader中自定义Probe，后面Shader模块会讲到。 总结Light Probe能给动态物体提供高质量光照放置Light Probe时尽量放到光影变化多的地方]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Unity编辑器]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%88%9D%E8%AF%86Unity%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 如果Unity崩溃未保存场景，如何恢复？ 空游戏对象有哪些使用场景？ Preset是干嘛用的？ unitypackage是什么？优点是什么？ Unity项目下哪几个文件夹需要加入版本控制？ 鼓励自己种一棵树最好的时间是十年前，其次是现在。只要你进入的这个行业可以不断成长，那就值得投入。其实早晚都是相对的，只要Unity这个引擎还在发展，只要游戏行业还在发展，只要虚拟现实、增强现实产业还在发展，现在就是学Unity的最好时间。 虚拟现实和增强现实是增长非常快的产业。 人们总是对未知的事物有莫名的恐惧。克服恐惧的过程就是你成长的过程。 就拿Unity来说，英文、编程、每隔几个月的新版本新功能的变化都可能让你恐惧和焦虑。 书读百遍，其义自见。剩下1%看不懂的内容，你见的多了，自然就懂了。 知识就像是1+1=2，你知道了就可以去做计算。但是技能就像弹吉他，纵然你看了很多书，看了很多教学视频，但是不开始练习，你拿到一把吉他还是不会弹奏。 安装UnityStandard Assets 内置标准资源：安装此组件后，可以使用Unity官方自带的资源如地形资源，角色控制器等。如果没安装，可以在Asset Store中找到。 后续需要新增加组件，可以重新打开此程序，选择增加的组件进行下载安装。比如一开始没有安装Documentation，后续想安装的时候可以重新打开UnityDownloadAssistant.exe，只选中Documentation，再下一步中选中相同的安装目录即可。 Visual StudioTemplate 模板 ** 模板 ** ** 描述 ** 2D 使用Unity内置渲染管道的2D项目。默认使用2D的项目设置，包括图像导入参数，Sprite打包器，场景视图，照明和正交相机。 3D 使用Unity内置渲染管道的3D项目。默认使用3D的项目设置，包括2018的新功能线性颜色空间和渐进式光照贴图。 3D with Extras 与3D模板类似，但包含了后处理，预设和示例内容。 High-Definition RP(Preview) 适用于支持Shader Model 5.0（DX11及以上版本）的平台上的高端图形。该模板使用HD RP，一种现代渲染流水线，其中包括高级材质类型和可配置的混合Tile/Cluster延迟/前向照明架构。 Lightweight RP 关注主要使用烘焙照明解决方案的项目。该模板使用LW RP，这是一个单pass前向渲染器，每个对象都有光照剔除。使用LW RP将减少项目的绘图调用次数，使其成为低端硬件的理想解决方案。所有灯都以单通道着色，而不是每个像素灯一个pass。 Lightweight VR RP(Preview) 开发主要使用烘焙照明解决方案的VR项目，重点关注性能。该模板使用LW RP并需要VR设备来运行。 如果选错了，可以后续在菜单栏Edit-&gt;Project Settings-&gt;Editor中的Default Behavior Mode中修改。 查看工程目录结构打开刚才创建工程的磁盘目录，你会看到Unity根据你的工程名称自动创建了一个文件夹，对于我来说就是MyFirstUnityProject，文件夹里面有以下内容： 目录结构 ** 文件夹 ** ** 内容 ** Assets 工程中所有资源的存放目录 Library Unity自动生成的中间文件目录 Packages Unity的包管理器相关文件存放目录 ProjectSettings 工程的相关设置 Temp 只有Unity打开这个工程的时候，Temp目录才会出现存放一些临时文件，关闭Unity会该目录会自动消失 sln文件和csproj文件 Unity自动生成的Visual Studio工程文件，用于代码编写和调试 ** 小技巧 ** 这些文件中，Assets、Packages、ProjectSettings三个文件夹是必须的，也不能删除，其他文件都可以由Unity自动生成。在存档、拷贝工程源文件时，可以只压缩Assets、Packages、ProjectSettings这三个文件夹，可以减小压缩包的体积。 资源文件的位置如果你需要直接访问下载下来的资源文件，你可以在下方路径找到： Windows: C:\Users\‹accountName›\AppData\Roaming\Unity\Asset Store 下载下来的资源会以发布者的名称作为文件夹，你可以在对应的发布者名称的文件夹下找到对应的资源。 其他TextMesh Pro（用于渲染字体）、ProBuilder（可以在Unity编辑三维模型）、Cinemachine（强大的相机插件）]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>大话Unity2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Rewrite with Htaccess理解与技巧]]></title>
    <url>%2F2019%2F05%2F15%2FApache-Rewrite-with-Htaccess-%E7%90%86%E8%A7%A3%E4%B8%8E%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[台湾人写的繁体字，我给改成了简体字方便阅读。 来源：Apache Rewrite with Htaccess理解与技巧 在搜寻Apache针对网址改写、避免访问敏感档案时，都会看到RewriteRule、RewriteCond等的Directive，但因为有时候不理解其中特性或Rule跟Cond的差异等，加上若不熟悉正则表达式，完全只想逃避这些Rule，因此本文将介绍： 一、开启Rewrite功能二、RewriteRule三、RewriteCond四、如何排错五、一些小特性六、使用Htaccess的缺点 一、开启Rewrite功能进行以下操作开启Rewrite模块（CentOS7编译安装） 找到apache的配置文件httpd.conf并寻找下面这行： 1LoadModule rewrite_module modules/mod_rewrite.so 将前面“#”去掉，如果不存在则添加此句。 确认是否已经开启模块了 123$ cd /usr/local/apache/bin$ sudo apachectl -M | grep rewriterewrite_module (shared) 接着就可以开始在Site Config里面撰写所需的RewriteRule了。 在理解Rewrite的过程中，常常会出现与之搭配的.htaccess文件。.htaccess称作「Hypertext Access」，以一个文件夹为单位改变Apache设定的配置（Override Config），简单来说就是可以根据每个文件夹Override原本Site Config，可以针对一个文件夹改写网址，所以RewriteRule并非就只能写在.htaccess当中哦！ 但本篇文章还是会以使用.htaccess作为范例，若要打开Override的功能，只要修改Site Config，加入AllowOverride All就可以了（例如/usr/local/apache/conf/vhost/example.conf） 123&lt;Directory "/var/www/html"&gt; AllowOverride All&lt;/Directory&gt; All、FlieInfo都可以让.htaccess使用Rewrite功能，详情可以参考官方设定值的意义。 二、Rewrite Rule** 基本用法 ** 就是改写网址条件的规则，它的写法结构如下： 1RewriteRule [match_uri] [rewrite_uri] [flags] match_uri：符合Pattern的URIrewrite_uri：将被改写的URI这两个也都可以使用正则表达式撰写，一个Rule范例长这样： 1Rewrite ^match\.html$ rewrite.html [NC,L] 意义等同于以下Pseudo Code： 123456假设输入网址：http://domain.com/a/b/c.htmluri = a/b/c.htmlif (uri.match("match.html") &#123; url = "rewrite.html"&#125; ** RewriteRule的Flag ** 最后面的flags代表设定Rule的行为，可用逗号代表多个Flag，中间不能有空格，介绍以下常用的： 12345678[L]：Last，代表成功执行这个Rule后就会停止，不继续往下执行。[NC]：Non Case-sensitive，代表match_uri不比对大小写差异。[QSA]：Query String Append，代表保留网址尾端带的GET参数，没使用flag的默认是会把参数去掉的。[QSD]：Query String Discard（丢弃），与QSA相反的作用，apache v2.4才有。[R]: Redirect，代表用转址的方式转到新的网址，默认是302 Status Code，如：[R=301]，也可以回传400、200、404等的Status Code，通常会跟[L]一起代表结束，也是排错常用的Flag[DPI]: 不要再接续的Rule中结尾中加上 PathInfo，会在「五、一些小特性」的段落说明。[F]: Forbidden 就是不给看啦！※ more flags: http://httpd.apache.org/docs/2.4/rewrite/flags.html ** 范例 ** 接着来举例多个Rules加上Flag的功用，假设网站文件夹结构如下： 123456root/ ├ match.html ├ rewrite.html ├ .htaccess └ secret/ └ database_password.json 而范例的.htaccess的內容为： 123456789101112131415161718# 前面有井字号是注释### 开启RewriteRewriteEngine On### 设定Rewrite前面会加上的path，默认会是DocumentRoot(如：/var/www/html）RewriteBase /# Rules 将会由上往下依序执行# 直到最后一行或遇到有符合且有 L flag 的 Rule 就会停止### Rule 1. 输入 domain.com/match.html 将会显示 rewrite.html 的內容RewriteRule ^match\.html$ rewrite.html [NC,L]### Rule 2. 输入 domain.com/redirect.html 将会被导至 domain.com/rewrite.htmlRewriteRule ^redirect\.html$ rewrite.html [NC,R=302,L]### Rule 3. 如果输入 domain.com/secret/… 这样格式的网址，则去掉 secret/ 后，转回 root 并加上 .html### $1 是正则表达式的 group capture，就是 $1=(.*) 取得括号內的值RewriteRule ^secret/(.*)$ $1.html [NC,L] 在浏览器上输入 match.html或 redirect.html均会显示 rewrite.html的內容，明显是 Rule 2 将网址改变了，而 Rule 1 没有，因为就是 302 Status Code 的关系。 在此建议可以使用 POSTMAN或是 cURL命令列或 Request 擷取等工具观察整个 Response的差異，将会非常容易除错，详细原因将在「四、如何除错」段落中解释，以下使用 cURL示范： 1.Request：http://localhost/match.html 12$ curl &apos;http://localhost/match.html&apos;I’m rewrite.html 2.Request： http://localhost/redirect.html 1234567891011$ curl 'http://localhost/redirect.html'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Found&lt;/h1&gt;&lt;p&gt;The document has moved &lt;a href="http://localhost/rewrite.html"&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7 Server at localhost Port 80&lt;/address&gt;&lt;/body&gt;&lt;/html&gt; 与浏览器不同的是，这里的Response会指出网址被转移至另外一个新网址http://localhost/rewrite.html，浏览器自动帮忙处理转址的工作，根据上面回传的网址，再发出另一个Request取得网页內容，让使用者仅感觉到网址与页面改变而已。 这时候读者可试着把RewriteBase这行注解，将会发现回传结果出错了，Rewrite结果与Domain之间被加上DocumentRoot预设的路径。 1234567891011$ curl 'http://localhost/redirect.html'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Found&lt;/h1&gt;&lt;p&gt;The document has moved &lt;a href="http://localhost/var/www/html/rewrite.html"&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7 Server at localhost Port 80&lt;/address&gt;&lt;/body&gt;&lt;/html&gt; 前面两个Rule仅是一个基本的示范，平常应用当然会难上许多，来继续看第三个Rule吧 1234### Rule 3. 如果输入domain.com/secret/…这样格式的网址，则去掉 secret/后，转回root并加上.html### $1是正则表达式的group capture，就是取得那个满足括号内的值RewriteRule ^secret/(.*)$ $1.html [NC,L] 第三个Rule是禁止使用者访问敏感的secret文件夹，来试着访问database_password.json看能不能得到结果： 123456789$ curl 'http://localhost/secret/database_password.json'HTTP/1.1 404 Not FoundDate: Sun, 07 Oct 2018 13:39:11 GMTServer: Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7Vary: accept-language,accept-charsetAccept-Ranges: bytesContent-Type: text/html; charset=utf-8Content-Language: en 不管网址改成任何http://localhost/secret/...，都会回传404找不到页面，是理想中的状况，非常棒！但是访问 http://localhost/secret/反而变成403禁止访问了耶，咦？ 123456789$ curl 'http://localhost/secret/'HTTP/1.1 403 ForbiddenDate: Sun, 07 Oct 2018 13:43:08 GMTServer: Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7Vary: accept-language,accept-charsetAccept-Ranges: bytesContent-Type: text/html; charset=utf-8Content-Language: en 这时候不知出了什么错的话，可以将 Rule 的 Flag 加上 R=302，检查最后改写的结果出了什么状况： 1234567891011$ curl 'http://localhost/secret/'&lt;!DOCTYPE HTML PUBLIC “-//IETF//DTD HTML 2.0//EN”&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Found&lt;/h1&gt;&lt;p&gt;The document has moved &lt;a href=”http://localhost/.html"&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7 Server at localhost Port 80&lt;/address&gt;&lt;/body&gt;&lt;/html&gt; 发现 $1没有抓到任何字串，所以没有任何檔名加上 .html，就变成 403 的结果，所以只要在 Rule 3 之前加上以下新的 Rule 就可以！ 1RewriteRule ^secret/$ / [R=302,NC,L] 以上就是RewriteRule与简单的Debug方法，只要再加上看得懂正则表达式就能懂一般常见的Rules！继续看更难一点的RewriteCond吧～ 三、RewriteCondRewriteRule仅仅只能判断Request URI是否匹配而改写URI，但有很多需求是希望根据一些Request Header（Host、User-agent）与Apache的环境变量做改写，先满足某些条件后，再次Rewrite URI，因此有了RewriteCond的出现，它的写法结构如下： 12RewriteCond [test_string] [match_string] [flags]RewriteRule … test_string：要比对的条件match_string：符合的条件 以上这两个都可以使用正则表达式撰写，而且RewriteCond结束一定会接着一个RewriteRule，真正的范例会长这样： 12RewriteCond %&#123;HTTP_USER_AGENT&#125; (facebookexternalhit)RewriteRule ^blog/(.*)$ fb-bot.html?path=$1&amp;type=%1 [L] 以上意义等同于以下Pseudo Code： 1234567if ($HTTP_USER_AGENT == &apos;facebookexternalhit&apos;) &#123; if (url.match(&apos;^blog/(.*)$&apos;)) &#123; url = &apos;fb-bot.html?path=$1&amp;type=facebookexternalhit&apos;; &#125;&#125; ※ 前面说到$1是Group Capture的用法，而RewriteCond则是用%1表示 ** RewriteCond可使用的变量 ** ${HTTP_USER_AGENT}是RewriteCond可使用的变量，有以下常见的变量： 1234567891011%&#123;REQUEST_URI&#125;：Domain后面完整的URI Path，Rule其实会拿到不完整的URI，详情可以参考「五、一些小特性」段落%&#123;QUERY_STRING&#125;：后面GET带的参数%&#123;HTTP_HOST&#125;：Domain 例：163.com%&#123;HTTP_COOKIE&#125;：Cookie%&#123;HTTPS&#125;：判断是否用https或http，如果是https就等于「on」，否则为“off”%&#123;HTTP_USER_AGENT&#125;：User Agent%&#123;REQUEST_FILENAME&#125;：访问的文件名称※ more variables：https://httpd.apache.org/docs/current/mod/mod_rewrite.html#rewritecond※ 其实变量也可以放在RewriteRule的rewrite url当中 以及判断文件时，很常见搭配这两个match用法： 12-d：directory. 代表如果有这个文件夹-f：regular file. 代表如果有这个文件 搭配起来写法就像以下范例，代表着如果没有这个文件就转到首页： 12RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteRule ^(.*)$ index.html 其实还有不同的match写法，可以参考Apache官网的 RewriteCond 。 ** RewriteCond 的 Flag 用法 ** 12NC：Non case-sensitiveOR：就是OR条件，下面会说明 RewriteCond也有OR跟AND的条件，先前提到RewriteCond后面一定会接一个RewriteRule，有个特性是它只吃接续的第一个rule ，来看下面的范例： 123456789101112131415161718192021222324252627282930### 范例 ARewriteCond 1RewriteRule 1RewriteRule 2// 等同于if (Cond1) &#123; Rule1&#125;Rule 2### 范例 BRewriteCond 1RewriteCond 2RewriteRule 1// 等同于if (Cond1 &amp;&amp; Cond2) &#123; Rule1&#125;### 范例 CRewriteCond 1 [OR]RewriteCond 2RewriteRule 1// 等同于if (Cond1 || Cond2) &#123; Rule1&#125; 了解RewriteCond跟RewriteRule的用法与每一行执行下来的逻辑，就可以更轻易的改写网络上別人写好的规则。 四、如何排错先前在RewriteRule的段落有稍微简单展示Debug的流程，这里仅使用文字讲解一些小秘诀。 ** 1.该使用什么Debug工具 ** 使用POSTMAN、cURL等的工具，浏览器除了有Cache外，也会帮忙转址，此时就没办法观察第一次转址的网址內容，譬如：最常见就是浏览器直接显示转址太多次的错误，但使用工具的话，就可以看到Response回传的转址结果。 ** 2.如何知道撰写的Regular Expression是否正确？ ** 把RewriteRule的Flag加上[R=302]，302 Status Code代表Moved Temporarily，浏览器并不会Cache302的转址结果，但301会，可以确定Rule无误后再拿掉或改为原本301就好，像这样观察转址的结果： 1RewriteRule ^(.*)$ =$1 [L,R=302] ** 3.非得要修改正在运行中的网站怎么办？ ** 可以用一些识別的Header，加上RewriteCond来测试撰写的RewriteRule，譬如自定义一个User-agent，每次Reuqest都用这个User-agent即可。 ** 4.浏览器有Cache ** 前面提到浏览器cache的问题，若认为写的没问题，但访问网站仍是旧有结果的话，就开启私密浏览访问看看，最后仍没办法只好重开Apache看看。 五、关于一些小特性1.RewriteRule在嵌套.htaccess当中不会取得完整URI Path 直接看范例，假设文件夹结構如下： root/ ├ a/ ├ b.html └ .htaccess ├ c.html └ .htaccess 12### 两个.htaccess都只有这一行內容RewriteRule ^(.*)$ $1 [L] 1.Request：c.html 使用 root/.htaccessRule 结果：c.html 2.Request： a/b.html 使用root/a/.htaccessRule结果： b.html没错，发生了不会拿到 a/ 的路径的情况。※ Apache 会自动选择最接近的 .htaccess 文件（详情会在下一段落说明） 3.如果拿掉 root/a/.htaccess文件，重新 Request： a/b.html 使用 root/.htaccessRule 结果：a/b.html这样的结果又正常了，如果真的想确保拿到完整的 URI Path，可以使用 %{REQUEST_URL}变量来取得 URI ！ 12RewriteCond %&#123;REQUEST_URI&#125; ^(.*)$RewriteRule ^ %1 [L] 2.RewriteRule自动附加在结尾的 PATH_INFO有时候会希望遇到 Rule1 改写之后，再传递至下一个 Rule2 判断与改写，可是会遇到后面莫名多了先前的 URI，来看一个简单的示范例子： 123RewriteRule ^(.*)$ web/$1 [NC]RewriteRule ^(.*)$ sec======$1====== [NC,R=301]Request： a/b/c.html 经过第一个Rule变成：web/a/b/c.html最后到第二个Rule变成：sec======web/a/b/c.html/b/c.html======发现它在Rule1的结果末端多了一个不需要的/b/c.html ，这是因为PATH_INFO的缘故，若不需要后面Path 的话，可以在Rule 1加上DPI Flag移除它，由于一些php的CMS或是Framework会使用到PATH_INFO的功能，所以是否关掉PATH_INFO的作用还是要注意一下！ 3.重新寻找.htaccess文件有时候要的Rule很纯，就只是将所有Request都转到web/文件夹下： 12RewriteBase /RewriteRule ^(.*)$ web/$1 [QSA,L] 但在Apache 2.4后就会遇到出现Redirect Loop的错误，原因是第一次Request URI被改写后成web/xxxx，它会根据新URI找对应最近的.htaccess并再重跑一次RewriteRule 此时有两种解法，第一种是在 web/ 文件夹下放一个空的 .htaccess ，第二种是可以参考下一点停止 Redirect Loop 的写法，放在 RewriteRule 前面。 4.停止 Redirect Loop 的情况 有时候会遇到无穷Loop 的问题： Request exceeded the limit of 10 internal redirects due to probable configuration error. Use ‘LimitInternalRecursion’ to increase the limit if necessary. Use ‘LogLevel debug’ to get a backtrace.可以在所有 RewriteRule 之前加上判断，若 Redirect Status 是 200 的话，就停止 Loop： RewriteCond %{ENV:REDIRECT_STATUS} 200RewriteRule ^ - [L]不过建议还是检查 RewriteRule 哪边有写错的，毕竟这解不太算是萬靈藥。 Ref：https://stackoverflow.com/a/20930010 六、使用Htaccess的缺点使用Override很方便，只要将.htaccess放到文件夹下面就有效果，但官方其实不推荐开启Override的功能，它会降低效能，主要是有以下缺点： 1.每次Request的嵌套搜寻每一次Request都会使得Apache透过嵌套递归的方式搜寻.htaccess文件，导致Apache缓慢，譬如送出这个 Request： Request： /example/sub/index.html Apache 则会根据路径寻找以下 .htaccess文件 /var/www/.htaccess/var/www/example/.htaccess/var/www/example/sub/.htaccess 最后 Apache 选择离文件最近的 /var/www/example/sub/.htaccess 2.重复Compile RewirteRule 由于每次 Request 都会嵌套搜寻 .htaccess，所以再遇到 RewriteRule 都会重新 Compile 一次，不像 Site Config 只会 Compile 一次后做 cache，所以 RewriteRule 非常多的话，也会导致 apache 缓慢。 笔者使用Apache Benchmark做了一个小型的压力测试，连续访问10000次，同时 1000个连线，取其三次执行ab指令的平均值，分别比较是否有打开Override功能，和Rewrite数量多寡是否有影响，Rewrite的状况都是以跑到倒数第三行结束为主，且每行RewriteRule跟RewriteCond不重复。 图1. 针对 orverride 功能开关和 Rule 数量的压力测试比较图 如图上的Total平均值，有开启Override功能还是比没开启花的时间多了一些，而行数的多寡也会影响到花費的时间，但筆者还是有点疑惑，差0.1秒好像也没什么关系吶。 官方认为.htaccess主要还是给无法编辑Site Config的情况下使用，像是一台主机上有多站共用，但真的想用.htaccess效果又不想开启Override的话怎么办呢？也是有一个取得中间值的做法。 在Site Config中预先指定.htaccess文件路径，把Override功能关掉，并使用Include指定引入的.htaccess，如下写法： 123456DocumentRoot /var/www/&lt;Directory /var/www/&gt; AllowOverride None Include /var/www/.htaccess …&lt;/Directory&gt; 但这方法也是有个小缺点：每次更新.htaccess都必须重新启动Apache重新读取设定。 如果主机流量不大的话，效能问题并没这么严重，最后还是得依据主机上的网站与情况，衡量哪种做法比较好哦！ Reference Apache.org When (not) to use .htaccess files]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F05%2F15%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是单例模式？ 为什么要用单例？ 怎么设计单例？ 单例如何具体实现？ 其实Unity中也有单例，单例作为一种设计模式是全语言通用的，最主要的目的还是为了优化CPU和内存的使用，提高加载速度。虽然硬件上去了，但单例这种简单快捷有效的代码内存优化永远不会消失。 还有一种和单例很相似的是静态类。主要是用在工具类的使用，没有必要在使用工具类，比如Math类的时候new一次，直接使用静态方法快捷又方便。 下面用PHP重温一下单例。 来源：理解php单例模式 一、什么是单例wiki百科：单例模式，也叫单子模式，是一种常用的软件设计模式。 在应用这个模式时，单例对象的类必须保证只有一个实例存在。 许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。 通俗的说，也就是对于某一个功能只能实例化一个对象。 二、为什么用单例实际项目中像数据库查询，日志输出，全局回调，统一校验等模块。这些模块功能单一，但需要多次访问，如果能够全局唯一，多次复用会大大提升性能。这也就是单例存在的必要性。 单例模式的好处： 1：减少频繁创建，节省了cpu。 2：静态对象公用，节省了内存。 3：功能解耦，代码已维护。 三、如何设计单例通过上面的描述，单例的核心是，实例一次生成，全局唯一，多次调用。因此在单例模式必须包含三要素： 1：私有化构造函数，私有化clone。也就是不能new，不能clone。【唯一】 2：拥有一个静态变量，用于保存当前的类。【唯一如何保存】 3：提供一个公共的访问入口。【可以访问】 当然，单例不止一个写法。但只要包含以上的三要素，都可以是单例模式。 四、php实现php实现的单例模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpclass XiaozhuaiSingleton&#123; // 私有化构造方法 private function __construct() &#123; &#125; // 私有化clone方法 private function __clone() &#123; &#125; // 保存实例的静态对象 public static $singleInstance; /** * 声明静态调用方法 * 目的：保证该方法的调用全局唯一 * * @return XiaozhuaiSingleton */ public static function getInstance() &#123; if (!self::$singleInstance) &#123; self::$singleInstance = new self(); &#125; return self::$singleInstance; &#125; // 调用单例的方法 public function singletonFunc() &#123; echo "call single ton method"; &#125;&#125;$singleInstance = XiaozhuaiSingleton::getInstance();$singleInstance-&gt;singletonFunc();$singleInstance2 = XiaozhuaiSingleton::getInstance();$singleInstance2-&gt;singletonFunc();// 校验是否是一个实例var_dump($singleInstance === $singleInstance2); // true ，一个对象]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GI cache]]></title>
    <url>%2F2019%2F05%2F15%2FGI-cache%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.GI cache是干嘛用的？怎么设置？ The GI cache is used by the Global Illumination (GI) system to store intermediate files when precomputing real-time GI, and when baking Static Lightmaps, Light Probes and Reflection Probes. The cache is shared between all Unity projects on the computer, so projects with the same content and same version of the lighting system (Enlighten) can share the files and speed up subsequent builds. You can manage the size, location, and compression of the cache using the GI Cache preferences. For more information, see the Preferences documentation. ** GI cache and lighting ** To ensure that the the lighting data loads from the GI cache in a very short amount of time when you reload your Scene, open the Lighting window (menu: Window &gt; Lighting) and enable the Auto option next to the build button. This makes lightmap baking automatic, meaning that the lightmap data is stored in the GI cache. In the Lighting window, you can clear the baked data in a Scene (disable the Auto option and choose Clear Baked Data from the Build button drop-down menu). This does not clear the GI Cache, because this would increase bake time afterwards. You can share the GiCache folder among different machines. This can make your lighting build faster, because the files are downloaded from the GiCache folder instead of computed locally. Note that the build process isn’t optimized for slow network-attached storage (NAS), so test if your bake times are severely affected before moving the cache to NAS.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Light Probes（4）]]></title>
    <url>%2F2019%2F05%2F15%2FLight-Probes%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题:1. Light Probes and the Mesh RendererTo use Light Probes on your moving GameObjects, the Mesh Renderer component on the moving GameObject must set correctly. The Mesh Renderer component has a Light Probes setting which is set to Blend Probes by default. This means that by default, all GameObjects will use light probes and will blend between the nearest probes as it changes position in your scene. The Light Probes setting on the Mesh Renderer component. You can change this setting to either “off” or “use proxy volume”. Switching the light probes setting to off will disable the light probe’s effect on this GameObject. Light Probe Proxy Volumes are a special setting which you can use for situations where a large moving object might be too big to be sensibly lit by the results of a single tetrahedron from the light probe group, and instead needs to be lit by multiple groups of light probes across the length of the model. See Light Probe Proxy Volumes for more information. The other setting in the Mesh Renderer inspector which relates to light probes is the Anchor Override setting. As described previously, when a GameObject moves through your scene, Unity calculates which tetrahedron the GameObject falls within from the volume defined by the light probe groups. By default this is calculated from the centre point of the Mesh’s bounding box, however you can override the point that is used by assigning a different GameObject to the Anchor Override field. The Anchor Override setting in the Mesh Renderer component. If you assign a different GameObject to this field, it is up to you to move that GameObject in a way that suits the lighting you want on your mesh. The anchor override may be useful when a GameObject contains two separate adjoining meshes; if both meshes are lit individually according to their bounding box positions then the lighting will be discontinuous at the place where they join. This can be prevented by using the same Transform (for example the parent or a child object) as the interpolation point for both Mesh Renderers or by using a Light Probe Proxy Volume.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Light Probes（3）]]></title>
    <url>%2F2019%2F05%2F13%2FLight-Probes%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题:1.光照探针要附加到什么游戏对象上？如何操作？ To place Light Probes in your Scene, you must use a GameObject with a Light Probe Group component attached. You can add a Light Probe Group component from the menu: Component &gt; Rendering &gt; Light Probe Group.其实GameObject-&gt;LightProbeGroup创建一个对象是创建一个名为LightProbeGroup的空对象自带了Light Probe Group组件，和给对象添加组件是一回事。 You can add the Light Probe Group component to any GameObject in the Scene. However, it’s good practice to create a new empty GameObject (menu: GameObject &gt; Create Empty) and add it to that, to decrease the possibility of accidentally removing it from the Project. The Light Probe Group component Property Function Edit Light Probes To make changes to a Light Probe Group, click the Edit Light Probes button to enable editing. This changes Unity so that you can only move and edit Light Probes, so you must remember to disable it when you are finished. You cannot move or edit GameObjects or other element in Unity while Edit Light Probes is enabled. Show Wireframe When this property is enabled, Unity displays the wireframe of the Light Probe Group in the Scene view. When it is disabled, Unity only displays the Light Probe points, and not the wireframe connecting them. Remove Ringing When this property is enabled, Unity automatically removes Light Probe ringing from the Scene. For more information, see Ringing, later in this section. Selected Probe Position This gives the x, y and z coordinates of the selected Light Probes in the Scene. This property is read-only. Add Probe Click this to add a Light Probe to the Light Probe Group. Select All Click this to select all Light Probes in the Light Probe Group. Delete Selected Click this to delete the selected Light Probes from the Light Probe Group. Duplicate Selected Click this to duplicate the selected Light Probes. ** Ringing ** Under certain circumstances, Light Probes exhibit an unwanted behaviour called “ringing”. This often happens when there are significant differences in the light surrounding a Light Probe. For example, if you have bright light on one side of a Light Probe, and no light on the other side, the light intensity can “overshoot” on the back side. This overshoot causes a light spot on the back side. Example of Light Probe ringing There are several ways to deal with this: In the Light Probe Group component, enable Remove Ringing. Unity automatically removes the unintended light spots. However, this generally makes the Light Probes less accurate, and reduces light contrast, so you must check the visual results. Place in-game obstacles in such a way that players can’t get to a position where they can see the light spot. Avoid baking direct light into Light Probes. Direct light tends to have sharp discontinuities (such as shadow edges), which makes it unsuitable for Light Probes. To only bake indirect light, use Mixed lighting. Use Realtime GI instead of Light Probes to light dynamic GameObjects. ** Placing Light Probes ** When editing a Light Probe Group, you can manipulate individual Light Probes in a similar way to GameObjects. However, Light Probes are not GameObjects; they are a set of points in the Light Probe Group component. When you begin editing a new Light Probe Group, you start with a default formation of eight probes arranged in a cube, as shown below: The default arrangement of Light Probes. You can now use the controls in the Light Probe Group inspector to add new probe positions to the group. The probes appear in the Scene as yellow spheres which you can position in the same way as GameObjects. You can also select and duplicate individual probes or in groups, by using the usual “duplicate” keyboard shortcut (ctrl+d/cmd+d). Remember to disable the Light Probe Group edit mode when you’ve finished editing the Light Probes, so that you can continue to edit and move GameObjects in your Scene as normal. ** Choosing Light Probe positions ** Unlike lightmaps, which usually have a continuous resolution across the surface of an object, the resolution of the Light Probe information depends on how closely packed you choose to position the Light Probes. To optimise the amount of data that Light Probes store, and the amount of computation done while the game is playing, you should generally attempt to place as few Light Probes as possible. However, you should also place enough Light Probes so that changes in light from one space to another are recorded at a level that is acceptable to you. This means you might place Light Probes in a more condensed pattern around areas that have complex or highly contrasting light, and you might place them in a much more spread out pattern over areas where the light does not significantly change. Light Probes placed with varying density around a simple Scene In the example above, the Light Probes are placed more densely near and between the buildings where there is more contrast and color variation, and less densely along the road, where the lighting does not significantly change. The simplest approach to positioning Light Probes is to arrange them in a regular 3D grid pattern. While this setup is simple and effective, it is likely to consume more memory than necessary, and you may have lots of redundant Light Probes. For example, in the Scene above, if there were lots of Light Probes placed along the road it would be a waste of resources. The light does not change much along the length of the road, so many Light Probes would be storing almost identical lighting data to their neighbouring Light Probes. In situations like this, it is much more efficient to interpolate this lighting data between fewer, more spread-out, Light Probes. Light Probes individually do not store a large amount of information. From a technical perspective, each probe is a spherical, panoramic HDR image of the view from the sample point, encoded using Spherical Harmonics L2 which is stored as 27 floating point values. However, in large Scenes with hundreds of Light Probes they can add up, and having unnecessarily densely packed Light Probes can result in large amounts of wasted memory in your game. ** Creating a volume ** Even if your gameplay takes place on a 2D plane (for example, cars driving around on a road surface), your Light Probes must form a 3D volume. This means you should have at least two vertical “layers” of points in your group of Light Probes. In the example below, you can see on the left the Light Probes are arranged only across the surface of the ground. This does not result in good lighting because the Light Probe system cannot calculate sensible tetrahedral volumes from the Light Probes. On the right, the Light Probes are arranged in two layers, some low to the ground and others higher up, so that together they form a 3D volume made up of lots of individual tetrahedra. This is a good layout. The left image shows a bad choice of Light Probe positions, because there is no height to the volume defined by the Light Probes. The right image shows a good choice of Light Probe positions. ** Light Probe placement for dynamic GI ** Unity’s real-time GI allows moving lights to cast dynamic bounced light against your static scenery. However, you can also receive dynamic bounced light from moving lights on moving GameObjects when you are using Light Probes. Light Probes therefore perform two very similar but distinct functions - they store static baked light, and at run time they represent sampling points for dynamic real-time global illumination (GI, or bounced light) to affect the lighting on moving objects. Therefore, if you are using dynamic moving lights, and want real-time bounced light on your moving GameObjects, this may have implications on your choice of where you place your Light Probes, and how densely you group them. The main point to consider in this situation is that in large areas of relatively unchanging static light you might have placed only a few Light Probes - because the light does not change across a wide area. However, if you plan to have moving lights within this area, and you want moving objects to receive bounced light from them, you need a more dense network of Light Probes within the area so that there is a high enough level of accuracy to match your light’s range and style. How densely placed your Light Probes need to be varies depending on the size and range of your lights, how fast they move, and how large the moving objects are that you want to receive bounced light. ** Troubleshooting Light Probe placement ** Your choice of Light Probe positions must take into account that the lighting is interpolated between sets of Light Probes. Problems can arise if your Light Probes don’t adequately cover the changes in lighting across your Scene. The example below shows a night-time Scene with two bright street lamps on either side, and a dark area in the middle. If Light Probes are only placed near the street lamps, and none in the dark area, the lighting from the lamps “bleeds” across the dark gap, on moving objects. This is because the lighting is being interpolated from one bright point to another, with no information about the dark area in-between. This image shows poor Light Probe placement. There are no Light Probes in the dark area between the two lamps, so the dark area is not included in the interpolation at all. If you are using Realtime or Mixed lights, this problem may be less noticeable, because only the indirect light bleeds across the gap. The problem is more noticable if you are using fully baked lights, because in this situation the direct light on moving objects is also interpolated from the Light Probes. In this example Scene, the two lamps are baked, so moving objects get their direct light from Light Probes. Here you can see the result - a moving object (the ambulance) remains brightly lit while passing through the dark area, which is not the desired effect. The yellow wireframe tetrahedron shows that the interpolation is occurring between one brightly lit end of the street to the other. This is an undesired effect - the ambulance remains brightly lit while passing through a dark area, because no Light Probes were placed in the dark area. To solve this, you should place more Light Probes in the dark area, as shown below: Now the Scene has Light Probes in the dark area too. As a result, the moving ambulance takes on the darker lighting as it travels from one side of the Scene to the other. The ambulance now takes on the darker lighting in the centre of the Scene, as desired.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Light Probes（2）]]></title>
    <url>%2F2019%2F05%2F11%2FLight-Probes%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.光照探针是干嘛用的？不使用会怎么样？2.整个场景都需要加光照探针吗？ Lightmapping adds greatly to the realism（真实感） of a scene by capturing realistic（逼真的） bounced light as textures which are “baked” onto the surface of static objects. However, due to the nature（性质） of lightmapping, it can only be applied to non-moving objects marked as Lightmap Static.lightmapping不是烘焙模式才用， 实时也可以用，因为没必要计算阴影，反正都是静态的，不计算可以加快游戏速度，所以lightmapping不是偶尔使用，是必须使用，不管光照模式是什么。静态物体的直接光照和间接光照信息都储存在了lightmapping中。 While realtime and mixed mode lights can cast direct light on moving objects, moving objects do not receive bounced light from your static environment unless you use light probes.（尽管实时和混合模式的灯光可以投射光线给移动物体，但移动物体不会从静态物体那接收间接光照，除非使用光照探针） Light probes store information about how light is bouncing around in your scene.Therefore as objects move through the spaces in your game environment, they can use the information stored in your light probes to show an approximation（近似） of the bounced light at their current position.实时和混合模式下，移动物体可以接受直射光，但接收不了间接光。烘焙模式下移动物体什么光都接收不了。所以光照探针也是必须的。静态物体在三种光照模式下都使用lightmapping，光模式对他们没影响。 A simple scene showing bounced light from static scenery. In the above scene, as the directional light hits the red and green buildings, which are static scenery, bounced light is cast into the scene. The bounced light is visible（可见） as a red and green tint on the ground directly in front of each building. Because all these models are static, all this lighting is stored in lightmaps. When you introduce（引入） moving objects into your scene, they do not automatically receive bounced light. In the below image, you can see the ambulance (a dynamic moving object) is not affected by the bounced red light coming off（从…反射出来） the building. Instead, its side is a flat grey color. This is because the ambulance is a dynamic object which can move around in the game, and therefore cannot use lightmaps, because they are static by nature. The scene needs Light Probes so that the moving ambulance can receive bounced light. The side of the ambulance is a flat grey color, even though it should be receiving some bounced red light from the front of the building. To use the light probe feature to cast bounced light onto dynamic moving objects, you must position light probes throughout（到处，各处） your scene, so that they cover the areas of space that moving objects in your game might pass through. The probes you place in your scene define a 3D volume. The lighting at any position within this volume is then approximated on moving objects by interpolating between the information baked into the nearest probes.然后，通过在烘焙到最近探针的信息之间进行插值，在该体积内的任何位置处的移动物体上的照明近似于实际的光照信息。 Light probes placed around（周围） the static scenery in a simple scene. The light probes are shown as yellow dots. They are shown connected by magenta（品红色） lines, to visualise the volume that they define. Once you have added probes, and baked the light in your scene, your dynamic moving objects will receive bounced light based on the nearest probes in the scene. Using the same example as above, the dynamic object (the ambulance) now receives bounced light from the static scenery, giving the side of the vehicle a red tint, because it is in front of the red building which is casting bounced light. The side of the ambulance now has a red tint because it is receiving bounced red light from the front of the building, via the light probes in the scene. When a dynamic object is selected, the Scene view will draw a visualisation of which light probes are being used for the interpolated bounced light. The nearest probes to the dynamic object are used to form a tetrahedral（四面体）volume, and the dynamic object’s light is interpolated from the four points of this tetrahedron. The light probes that are being used to light a dynamic object are revealed in the scene view when the object is selected, connected by yellow lines to show the tetrahedral volume. As an object passes through the scene, it moves from one tetrahedral volume to another, and the lighting is calculated based on its position within the current tetrahedron. A dynamic object moving through a scene with light probes, showing how it passes from one tetrahedral light probe volume to another.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Light Probes（1）]]></title>
    <url>%2F2019%2F05%2F11%2FLight-Probes%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.光照探针和光照贴图有什么异同点？2.光照探针两个主要的用途是什么？ Light Probes provide a way to capture and use information about light that is passing through the empty space in your scene. Similar to lightmaps, light probes store “baked” information about lighting in your scene. The difference is that while lightmaps store lighting information about light hitting the surfaces in your scene, light probes store information about light passing through empty space in your scene. An extremely simple scene showing light probes placed around two cubes Light Probes have two main uses: The primary use of light probes is to provide high quality lighting (including indirect bounced light) on moving objects in your scene. The secondary use of light probes is to provide the lighting information for static scenery when that scenery is using Unity’s LOD system. When using light probes for either of these two distinct（不同的，独特的） purposes, many of the techniques you need to use are the same. It’s important to understand how light probes work so that you can choose where to place your probes in the scene.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflection Probe（3）]]></title>
    <url>%2F2019%2F05%2F11%2FReflection-Probe%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1. CG films and animations commonly feature highly realistic reflections（通常具有高度逼真的反射）, which are important for giving a sense of “connectedness” among the objects in the scene. However, the accuracy（准确性） of these reflections comes with a high cost in processor time and while this is not a problem for films, it severely limits the use of reflective objects in realtime games. 只使用一张反射贴图的缺点。Traditionally, games have used a technique called reflection mapping to simulate reflections from objects while keeping the processing overhead（开销） to an acceptable level. This technique assumes that all reflective（反光） objects in the scene can “see” (and therefore reflect) the exact same surroundings. This works quite well for the game’s main character (a shiny car, say) if it is in open space but is unconvincing（不能令人信服的） when the character passes into different surroundings; it looks strange if a car drives into a tunnel but the sky is still visibly（明显的） reflected in its windows. Unity improves on basic reflection mapping through the use of Reflection Probes, which allow the visual environment to be sampled（采样） at strategic points（关键点） in the scene. You should generally place them at every point where the appearance of a reflective object would change noticeably（明显地） (eg, tunnels, areas near buildings and places where the ground colour changes). When a reflective object passes near to a probe, the reflection sampled by the probe can be used for the object’s reflection map. Furthermore, when several probes are nearby, Unity can interpolate between them to allow for gradual（逐渐的） changes in reflections. Thus, the use of reflection probes can create quite convincing reflections with an acceptable processing overhead. ** How Reflection Probes Work ** The visual（视觉） environment for a point in the scene can be represented by a cubemap. This is conceptually（概念） like a box with flat images of the view from six directions (up, down, left, right, forward and backward) painted on its interior（内部） surfaces. Inside surfaces of a skybox cubemap (front face removed) For an object to show the reflections, its shader must have access to the images representing the cubemap. Each point of the object’s surface can “see” a small area of cubemap in the direction the surface faces (ie, the direction of the surface normal vector). The shader uses the colour of the cubemap at this point in calculating what colour the object’s surface should be; a mirror material might reflect the colour exactly while a shiny car might fade and tint it somewhat.对于显示反射的对象，其着色器必须能够访问表示立方体贴图的图像。物体表面的每个点都可以在表面朝向的方向（即表面法线向量的方向）上“看到”立方体图的一小块区域。着色器在此时使用立方体贴图的颜色来计算对象表面应该是什么颜色；镜面材料可能会完全反映颜色，而闪亮的汽车可能会褪色并略微着色 As mentioned above, traditional reflection mapping makes use of only a single cubemap to represent the surroundings for the whole scene. The cubemap can be painted by an artist or it can be obtained by taking six “snapshots” from a point in the scene, with one shot for each cube face. Reflection probes improve on this by allowing you to set up many predefined points in the scene where cubemap snapshots can be taken. You can therefore record the surrounding view at any point in the scene where the reflections differ noticeably. In addition to its view point, a probe also has a zone of effect defined by an invisible box shape in the scene. A reflective object that passes within a probe’s zone has its reflection cubemap supplied temporarily by that probe. As the object moves from one zone to another, the cubemap changes accordingly.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflection Probe（2）]]></title>
    <url>%2F2019%2F05%2F11%2FReflection-Probe%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.如何使用Reflection Probe？ You can add the Reflection Probe component to any object in a Scene but it’s standard to add each probe to a separate empty GameObject. The usual workflow is: Create a new empty GameObject (menu: GameObject &gt; Create Empty) and then add the Reflection Probe component to it (menu: Component &gt; Rendering &gt; Reflection Probe). Alternatively, if you already have a probe in the scene you will probably find it easier to duplicate that instead (menu: Edit &gt; Duplicate). Place the new probe in the desired location and set its Offset point and the size of its zone of effect. Optionally set other properties on the probe to customise its behaviour. Continue adding probes until all required locations have been assigned. To see the reflections, you will also need at least one reflective object in the scene. A simple test object can be created as follows: Add a primitive object such as a Sphere to the scene (menu: GameObject &gt; 3D Object &gt; Sphere).Create a new material (menu: Assets &gt; Create &gt; Material) and leave the default Standard shader in place. Make the material reflective by setting both the Metallic and Smoothness properties to 1.0.Drag the newly-created material onto the sphere object to assign it. The sphere can now show the reflections obtained from the probes. A simple arrangement with a single probe is enough to see the basic effect of the reflections. Finally, the probes must be baked before the reflections become visible. If you have the Auto Generate option enabled in the Lighting window (this is the default setting) then the reflections will update as you position or change objects in the scene, although the response is not instantaneous（瞬间）. If you disable auto baking then you must click the Bake button in the Reflection Probe inspector to update the probes. The main reason for disabling auto baking is that the baking process can take quite some time for a complicated scene with many probes. ** Positioning probes ** The position of a probe is primarily（主要） determined by the position of its GameObject and so you can simply drag the object to the desired location. Having done this, you should set the probe’s zone of effect; this is an axis-aligned（对齐） box shape whose dimensions（尺寸） are set by the Box Size property. You can set the size values directly or enable the size editing mode in the inspector and drag the sides of the box in the Scene view(see the Reflection Probe component page for details). The zones of the full set of probes should collectively（共同地） cover all areas of the scene where a reflective object might pass. You should place probes close to any large objects in the scene that would be reflected noticeably（明显地）. Areas around the centres and corners of walls are good candidate locations for probes. Smaller objects might require probes close by if they have a strong visual effect. For example, you would probably want the flames（火焰） of a campfire to be reflected even if the object itself is small and otherwise insignificant（微不足道）. When you have probes in all the appropriate places, you then need to define the zone of effect for each probe, which you can do using the Box Size property as mentioned above. A wall might need just a single probe zone along most of its length (at least if it has a fairly（相当） uniform（统一） appearance) but the zone might be relatively narrow（狭窄） in the direction perpendicular（垂直） to the wall; this would imply that the wall is only reflected by objects that are fairly（比较） close to it. An open space whose appearance varies little from place to place can often be covered by a single probe. Note that a probe’s zone is aligned to the main world axes (X, Y and Z) and can’t be rotated. This means that sometimes a group of probes might be needed along a uniform wall if it is not axis-aligned. By default, a probe’s zone of effect is centred on its view point but this may not be the ideal position for capturing the reflection cubemap. For example, the probe zone for a very high wall might extend some distance from the wall but you might want the reflection to be captured from a point close to it rather than the zone’s centre. You can optionally add an offset to view point using the Box Offset property (ie, the offset is the position in the GameObject’s local space that the probe’s cubemap view is generated from). Using this, you can easily place the view point anywhere within the zone of effect or indeed outside the zone altogether. ** Overlapping probe zones ** It would be very difficult to position the zones of neighbouring reflection probes without them overlapping and fortunately, it is not necessary to do so. However, this leaves the issue of choosing which probe to use in the overlap areas. By default, Unity calculates the intersection between the reflective object’s bounding box and each of the overlapping probe zones; the zone which has the largest volume of intersection with the bounding box is the one that will be selected. Probe A is selected since its intersection（相交） with the object is larger You can modify the calculation using the probes’ Importance properties. Probes with a higher importance value have priority over those of lower importance within overlap zones. This is useful, say, if you have a small probe zone that is contained completely inside a larger zone (ie, the intersection of the character’s bounding box with the enclosing（封闭） zone might always be larger and so the small zone would never be used). ** Blending ** To enable Reflection Probe blending, navigate to Graphic Settings &gt; Tier（一级） settings. With blending enabled, Unity will gradually fade out one probe’s cubemap while fading in（渐渐消失） the other’s as the reflective object passes from one zone to the other. This gradual transition avoids the situation where a distinctive object suddenly “pops” into the reflection as an object crosses the zone boundary（边界）. Blending is controlled using the Reflection Probes property of the Mesh Renderer component. Four blending options are available: Off - Reflection probe blending is disabled. Only the skybox will be used for reflection Blend Probes - Blends only adjacent（邻近的） probes and ignores the skybox. You should use this for objects that are “indoors” or in covered parts of the scene (eg, caves and tunnels) since the sky is not visible from these place and so should never appear in the reflections. Blend Probes and Skybox - Works like Blend Probes but also allows the skybox to be used in the blending. You should use this option for objects in the open air, where the sky would always be visible. Simple - Disables blending between probes when there are two overlapping reflection probe volumes.When probes have equal Importance values, the blending weight for a given probe zone is calculated by dividing its intersection (volume) with the object’s bounding box by the sum of all probes’ intersections with the box. For example, if the box intersects probe A’s zone by 1.0 cubic units and intersects probe B’s zone by 2.0 cubic units then the blending values will be: Probe A: 1.0 / (1.0 + 2.0) = 0.33 Probe B: 2.0 / (1.0 + 2.0) = 0.67 In other words, the blend will incorporate（包括） 33% of probe A’s reflection and 67% of probe B’s reflection. The calculation must be handled slightly（稍微） differently in the case where one probe is entirely contained within the other, since the inner zone overlaps entirely with the outer. If the object’s bounding（边界） box is entirely within the inner zone then that zone’s blending weight is 1.0 (ie, the outer zone is not used at all). When the object is partially outside the inner zone, the intersection volume of its bounding box with the inner zone is divided by the total volume of the box. For example, if the intersection volume is 1.0 cubic units and the bounding box’s volume is 4.0 cubic units, then the blending weight of the inner probe will be 1.0 / 4.0 = 0.25. This value is then subtracted from 1.0 to get the weight for the outer probe which in this case will be 0.75. When one probe involved in the blend has a higher Importance value than another, the more important probe overrides the other in the usual way.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflection Probe（1）]]></title>
    <url>%2F2019%2F05%2F11%2FReflection-Probe%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.反射探针是干嘛用的？不使用可以吗？ A Reflection Probe is rather like a camera that captures a spherical（球形） view of its surroundings in all directions. The captured image is then stored as a Cubemap that can be used by objects with reflective（反射） materials. Several reflection probes can be used in a given scene and objects can be set to use the cubemap produced by the nearest probe（可以在给定场景中使用多个反射探针，并且可以设置对象使用由最近探针生成的立方体贴图 ）. The result is that the reflections on the object can change convincingly according to its environment（结果是对象的反射可以根据其环境令人信服地改变）. A Reflection Probe showing reflections from a nearby object ** Properties ** Property Function Type Choose whether the probe is for a Baked, Custom or Realtime setup? Dynamic Objects (Custom type only) Forces objects not marked as Static to be baked in to the reflection.强制将未标记为静态的对象烘焙到反射中。 Cubemap (Custom type only) Sets a custom cubemap for the probe. Refresh Mode (Realtime type only) Selects if and how the probe will refresh at runtime. The On Awake option renders the probe only once when it first becomes active. Every Frame renders the probe every frame update, optionally using Time Slicing (see below). The Via（通过） Scripting option refreshes the probe from a user script command rather than an automatic update. Time Slicing (Realtime type only) How should the probe distribute（分配） its updates over time? The options are All Faces At Once (spreads update over nine frames), Individual Faces (updates over fourteen frames) and No Time Slicing (the update happens entirely within one frame). See below for further details. Runtime settings Importance The degree（程度） of “importance” of this probe compared to its neighbours. Higher values indicate（表明） greater importance; more important probes will have priority over less important one in cases where an object is within range of two or more probes. This setting also affects the Blending, explained here. Intensity The intensity modifier（修改） that is applied to the texture of this probe in its shader. Box Projection（投影） Check this box to enable projection for reflection UV mappings. Box Size The size of the box in which the reflection will be applied to the GameObject. The value is not affected by the Transform of the GameObject. Also used by Box Projection. Box Offset The center of the box in which the reflections will be applied to the GameObject. The value is relative to the position of the GameObject. Also used by Box Projection. Cubemap capture settings Resolution The resolution of the captured reflection image. HDR Should High Dynamic Range rendering be enabled for the cubemap? This also determines whether probe data is saved in OpenEXR or PNG format. Shadow Distance Distance at which shadows are drawn when rendering the probe. Clear Flags Option to specify how empty background areas of the cubemap will be filled（填满）. The options are Skybox and Solid Color. Background Background colour to which the reflection cubemap is cleared before rendering. Culling Mask Allows objects on specified（指定的） layers to be included or excluded（排除） in the reflection. See the section about the Camera’s culling mask on the Layers page. Use Occlusion Culling Should occlusion culling be used when baking the probe? Clipping Planes Near and far clipping planes of the probe’s “camera”. ** Details ** There are two buttons at the top of the Reflection Probe Inspector window that are used for editing the Size and Probe Origin properties directly within the Scene. With the leftmost（最左侧） button (Size) selected, the probe’s zone of effect is shown in the scene as a yellow box shape with handles to adjust the box’s size. The other button (Origin) allows you to drag the probe’s origin relative to the box. Note that the origin handle resembles（酷似） the Transform position handle but the two positions are not the same. Also, the rotation and scale operations are not available for the probe box. The probe’s Type property determines how the reflection data is created and updated: Baked probes store a static reflection cubemap generated by baking in the editor. Custom probes store a static cubemap which can either be generated by baking or set manually by the user. Realtime probes update the cubemap at runtime and can therefore react to（对…做出反应） dynamic objects in the scene. To make use of the reflection cubemap, an object must have the Reflection Probes option enabled on its Mesh Renderer and also be using a shader that supports reflection probes. When the object passes within the volume set by the probe’s Size and Probe Origin properties, the probe’s cubemap will be applied to the object. You can also manually set which reflection probe to use for a particular（特定的） object using the settings on the object’s Mesh Renderer. To do this, select one of the options for the MeshRenderer’s Reflection Probes property (Simple, Blend Probes or Blend Probes and Skybox) and drag the chosen probe onto its Anchor Override property. See the Reflection Probes section in the manual for further details about principles and usage.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS]]></title>
    <url>%2F2019%2F05%2F09%2FHTTPS%2F</url>
    <content type="text"><![CDATA[HTTPS的相关知识 首先需要知道SSL证书的种类有哪些？分别适合什么类型的域名 SSl证书的类型区分 1.单域名SSL证书 单域名证书只能绑定一个域名http://bitcert.com和http://www.bitctrt.com算一个域名，在证书绑定域名时，输入其中一个即可 2.多域名SSL证书 多域名证书可以绑定多个域名 支持任何域名,例如您有多个顶级域名完全不同的域名需要使用SSL证书（如：http://bitcert.com、http://ABC.com、http://123.com）即可选择多域名证书，注意的是在多域名ssl证书里，www与@算两个域名 一般产品都是默认有3-5个域名，每增加一个再另外收费，最多可以增加到250个域名 3.通配符SSL证书 通配型证书只支持*.http://domain.com通配符子域名。例如您有多个顶级域名相同的子域名需要使用SSL证书，（如：http://A.domain.com、http://B.domain.com、http://C.domain.com等通配符域名）就选择通配符证书 可以免费绑定无限个二级子域名。那有人问，如果有主域名下的3级域名和4级域名怎么办？正常通配符证书只能支持2级域名。 4.多域名通配符证书 多域名通配符是结合多域名SSL+通配符SSL两种组合的特征,例如您有多个域名以及无限子域名，那多域名通配符是你绝佳的选择,（如:*.http://feizhu.com、*.http://alibaba.com、*.http://m.chiniao.com，*.http://china.taobao.com）类似于阿里巴巴这种大企业,名下域名繁多的情况下，选择多域名通配符证书，不仅多域名和子域名方便管理，还可以节省时间与金钱 Ssl证书的区分种类就只有这几个,企业申请ssl证书的时候务必需要了解自身拥有什么样的域名，再根据域名去选购证书，就很简单了、为了避免打不开或提升不安全的情况下,还是很有必要为网站所有的域名申请ssl证书，为网站实现全站的https加密认证。]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#与闭包]]></title>
    <url>%2F2019%2F05%2F06%2FC-%E4%B8%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/syaguang2006/article/details/22787111 https://www.cnblogs.com/jackFloyd/p/4844073.html https://www.cnblogs.com/jujusharp/archive/2011/08/04/C-Sharp-And-Closure.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Namespaces]]></title>
    <url>%2F2019%2F05%2F05%2FNamespaces%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：命名空间是什么？怎么用？ As projects become larger and the number of scripts increases, the likelihood（可能性） of having clashes between script class names grows ever greater. This is especially true when several programmers are working on different aspects of the game separately and will eventually combine their efforts in one project. For example, one programmer may be writing the code to control the main player character while another writes the equivalent（相等） code for the enemy. Both programmers may choose to call their main script class Controller, but this will cause a clash when their projects are combined. To some extent（在某种程度上）, this problem can be avoided by adopting（采用） a naming convention or by renaming classes whenever a clash is discovered (eg, the classes above could be given names like PlayerController and EnemyController). However, this is troublesome when there are several classes with clashing names or when variables are declared using those names - each mention of the old class name must be replaced（替换） for the code to compile. The C# language offers a feature called namespaces that solves this problem in a robust（强大的） way. A namespace is simply a collection of classes that are referred to using a chosen prefix on the class name. In the example below, the classes Controller1 and Controller2 are members of a namespace called Enemy: 12345678910namespace Enemy &#123; public class Controller1 : MonoBehaviour &#123; ... &#125; public class Controller2 : MonoBehaviour &#123; ... &#125;&#125; In code, these classes are referred to as Enemy.Controller1 and Enemy.Controller2, respectively（分别地）. This is better than renaming the classes insofar as（只要） the namespace declaration can be bracketed（括号） around existing class declarations (ie, it is not necessary to change the names of all the classes individually). Furthermore, you can use multiple bracketed namespace sections around classes wherever they occur, even if those classes are in different source files. You can avoid having to type the namespace prefix repeatedly by adding a using directive at the top of the file. 1using Enemy; This line indicates that where the class names Controller1 and Controller2 are found, they should be taken to mean Enemy.Controller1 and Enemy.Controller2, respectively. If the script also needs to refer to classes with the same name from a different namespace (one called Player, say), then the prefix can still be used. If two namespaces that contain clashing class names are imported with using directives at the same time, the compiler will report an error.]]></content>
  </entry>
  <entry>
    <title><![CDATA[着色器--Shader]]></title>
    <url>%2F2019%2F05%2F04%2F%E7%9D%80%E8%89%B2%E5%99%A8-Shader%2F</url>
    <content type="text"><![CDATA[本章将介绍Unity中的着色器和着色语言--ShaderLab。通过本章的学习，读者将会对Unity中的着色器及其开发产生一定的了解。接下来，将先对Unity中的着色器进行简要概述，帮助读者初步认识着色器。 初识着色器实际游戏开发中的许多特效，如镜面反射和折射、动物毛发、卡通效果等，都是使用着色器来实现的。这些效果如果直接通过编程实现会比较困难，即使实现了，在程序运行的时候其计算量会比用着色器实现同样效果的计算量大很多，因而会影响游戏的整体运行。 着色器概述着色器--Shader是一款运行在图形处理单元（Graphie Processor Unit，GPU）上的程序，其可以让开发人员对图形硬件的渲染功能进行设置。Unity中大多数的渲染都是通过着色器来完成的。Unity中有大量内置着色器程序，开发人员可以直接使用，也可以根据需求开发自己的着色器程序。 目前这种面向GPU的编程有以下3种高级图像语言可供选择。 1.HLSL语言 Microsoft公司提供的HLSL（High Level Shading Language）语言，是通过Direct3D图形软件库来编写着色器程序，只能供Microsoft的Direct3D和XNA使用（Direct3D是Microsoft公司的Directx Graphics的三维部件）。 2.Cg语言 NVIDIA公司和微软公司合作提供了Cg（C for Graphics）语言，Cg与C语言相似，不过有了自己的一套关键词和函数库。Cg是独立于三维编程接口的，完全和Direct3D或者OpenGL结合在一起，一个正确的Cg程序可以编写一次，之后工作在Direct3D或者OpenGL上，这种灵活性意味着Cg提供了一种方法用来编写能够同时工作在主要的三维程序接口和任何操作系统上的程序。Cg的这种多厂商、跨API和多平台的特征使它成为可编程图形处理器编写程序的最好选择。 3.GLSL语言OpenGL委员会提供了GLSL（OpenGL Shading Language）语言，它是用来在OpenGL中进行着色编程的语言，即开发人员写的短小的自定义程序。它们是在图形卡的GPU上执行的，代替了固定的渲染管线的一部分，使渲染管线中不同层次具有可编程型。 Unity引擎对着色语言的支持非常全面，但为了实现对跨平台性的支持，Unity对着色语言的重点支持为Cg语言。作为一款跨平台性最好的游戏开发引擎，对于要适应不同GPU的着色器来说，Unity使用自定义ShaderLab来组织着色器程序的内容，并将对不同的平台进行编译。 ShaderLab语法基础Unity中的着色器程序使用的是ShaderLab着色语言，该语言具备了显示材质所需的一切信息，同时还支持使用Cg，HLSL或GLSL语言编写的着色器程序。ShaderLab着色语言类似于微软公司的FX文件或NVIDIA的CgFX，顶点和片段程序是用Cg或HLSL语言编写。下面将介绍ShaderLab的基本语法结构。 1.Shader Shader是一个着色器程序的根命令，每个着色器程序都必须定义唯一一个Shader，其中定义了材质如何使用这个着色器渲染对象。Shader命令的语法如下。 12345Shader "name" &#123; [Properties] Subshaders |...| [Fallback]&#125; 口上面的语句定义了一个名为”name”的Shader.这些内容在材质属性查看器上列于”name”下。着色器程序通过”Properties”来可选地定义一个显示在材质设定界面的属性列表。后面紧跟”SubShaders”的列表,并可额外添加一个代码块用于应对”Fallback”的情况。 口着色器程序拥有一个”Properties”的列表,任何定义在着色器程序中的属性都会显示在属性查看器中。典型的属性有颜色、纹理或是任何被着色器所使用的数值数据。 口着色器程序还包含一个子着色器的列表,其中至少有一个子着色器,当加载一个着色器程序时, Unity将遍历这个列表,获取第一个能被用户机器支持的子着色器,如果没有子着色器被支持, Unity将尝试使用降级着色器,即Fallback操作. Subshader和Fallbak,在后面的内容中会进行详细讲解。 Properties 着色器可以在属性块中定义一些属性参数,这些参数可以由开发人员在Unity的”Inspector”面板中编辑和调整,而不需要单独的编辑器,着色器程序中的Properties块就是用来定义这些参数的地方. Proprties 的基本语法如下.Rroperties (属性块) 它定义了属性块,其中可包含多个属性。其定义如表7-1所示。表7-1 Properties类型]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity游戏开发技术详解与典型案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rendering Paths]]></title>
    <url>%2F2019%2F05%2F04%2FRendering-Paths%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.渲染路径是干嘛用的？2.有哪些渲染路径？3.区别是什么？ Unity supports different Rendering Paths. You should choose which one you use depending on your game content and target platform / hardware.Different rendering paths have different performance（性能） characteristics（特点） that mostly affect Lights and Shadows. See render pipeline for technical details. The rendering path used by your project is chosen on the Graphics window. Additionally, you can override it for each Camera. If the graphics card can’t handle a selected rendering path, Unity automatically uses a lower fidelity（保真度） one. For example, on a GPU that can’t handle Deferred Shading, Forward Rendering will be used. ** Deferred Shading ** Deferred Shading is the rendering path with the most lighting and shadow fidelity, and is best suited if you have many realtime lights. It requires a certain level of hardware support. ** Forward Rendering ** Forward is the traditional rendering path. It supports all the typical Unity graphics features (normal maps, per-pixel lights, shadows etc.).However under default settings, only a small number of the brightest lights are rendered in per-pixel lighting mode. The rest of the lights are calculated at object vertices or per-object. ** Legacy Deferred ** Legacy Deferred (light prepass) is similar to Deferred Shading, just using a different technique with different trade-offs. It does not support the Unity 5 physically based standard shader. ** Legacy Vertex Lit ** Legacy Vertex Lit is the rendering path with the lowest lighting fidelity and no support for realtime shadows. It is a subset of Forward rendering path. NOTE: Deferred rendering is not supported when using Orthographic projection. If the camera’s projection mode is set to Orthographic, these values are overridden, and the camera will always use Forward rendering.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D光照系统中的高级功能]]></title>
    <url>%2F2019%2F05%2F04%2FUnity3D%E5%85%89%E7%85%A7%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Unity光照系统中不仅仅是几个光源投射阴影这么简单，还包括有很多有趣的功能比如镜头光晕、光环、剔除等，这些小功能在某些时候可以极大地美化场景，使场景更加真实。此外，还有Light Probes来优化场景的阴影效果。 渲染路径与颜色空间了解Unity的具体光照功能前，首先需要了解Unity中的光影效果的场景设置即渲染路径和颜色空间。这些功能与光照或阴影的渲染有关，通过对其设置可以配合对应的设备产生更加真实的光影效果和配色方案，下面将对其进行详细的介绍。 ** 1.渲染路径 ** Unity支持许多渲染路径（Rendering Path），而用户在使用的时候需要根据自己场景的实际情况以及目标平台和硬件的支持情况来进行选择。不同的渲染路径有不同的性能和效果，大多数都是影响光照和阴影的，比如需要点光源和区域光源显示阴影时就需要将渲染路径设置为“Legacy Deferred”或“Deferred”。 Unity 5.0中设置渲染路径的步骤为“Edit-&gt;Project Settings-&gt;Player”。在Inspector面板中的Other Settings卷展栏下的Rendering Path选框，如下图所示，主要有4种渲染路径下面将对其进行一一介绍。 Forward 该渲染路径也是Unity的预设渲染路径，在该渲染路径，每个对象的着色是根据影响对象的灯光，通过“Pass”来着色，所以当一个物体同时在多个光源的作用范围内时，该对象会被重复着色多次。这个渲染路径的优点是快速，硬件要求低，可以快速处理透明度。然而其缺点是要为每盏灯付出相应的成本，在有大量光源的复杂场景中效率反而会降低。 Deferred 该路径为延迟渲染路径，延迟了光的遮蔽与混合信息直到第一次接收到表面的位置发现材质数据着色到一个“几何缓冲器（G-buffer）”作为一个屏幕空间的贴图。该方法的优点是照明的着色成本和像素数量成正比，而非灯光数量，所以非常适合在有大量realime模式的光源存在时显示真实的光照和阴影，但是需要较高的硬件水平支持。 Legacy Vertex Lit 顶点照明渲染路径通常在一个pass中渲染物体，所有的光源照明都是在物体的顶点上计算的。该渲染路径是最快速的，并且具有最广泛的硬件支持（不能工作在游戏机上）。由于所有的光照都是在顶点层级上计算的，所以此渲染路径不支持大部分逐像素渲染效果，如阴影、法线贴图、灯光遮罩、高精度的高光等。 Legacy Defferred (Light prepass) 该渲染和Defterred渲染路径非常相似，只是采用了不同的手段去实现，需要注意的是，该渲染路径不支持Unity 5.0中的physically based standard着色器。 ** 2.颜色空间 ** 设置好渲染路径后，选择一个颜色空间(Color Space)也是非常重要的，色彩空间决定采用哪种算法来计算照明或者材质加载时的颜色混合，这会对游戏画面的真实感有非常大的影响。一般情况下，超过色彩空间设定可能会被目标平台强制限制。 颜色空间的设定步骤为”di-ProjeetStings-Player”, Inspector面板中的Other Settings卷展栏下的Rendering Path选框，如图9-56所示，通常推荐的比较接近真实的是Linear颜色空间。其优点是场景内提供给着色器的颜色会因为光强增加边亮，,如果换成Gamma色彩空间，亮度马上会转为以白色作为参考，可能会导致照明在有些部位太亮。如下图所示。 Linear颜色空间的另一个好处是着色器能在没有Gamma补偿的情况下对贴图进行采样，这有助于确保颜色质量在经过着色通道后还能保持一致性，能提高颜色和计算的精度，最后屏幕的输出会更加真实，但是目前有些手机平台不支持Linear，在这种情况下就需要使用Gamma替代了.. …… 切换颜色空间后场景中已经烘焙好的Lightmap需要重新烘焙(在默认的情况说明:下这是Unity引掌自动完成的)。 Cookies灯光中的Cookies是一个很有趣的功能。在很早的电影或戏曲中灯光特效就被用来产生一个没有真实存在的物体的印模或轮廓，比如丛林中产生的假象的树冠阴影、监狱中栏杆的阴影等，这些效果可以极大地提升场景的真实感，Unity也支持这种效果，就是灯光中的Cookies参数，如下图所示。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity游戏开发技术详解与典型案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[资源加载与优化（2）]]></title>
    <url>%2F2019%2F05%2F03%2F%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本章涵盖： 游戏对象 优化工具 资源管理实例 游戏对象游戏对象就是个空壳子，它关联着所有资源以及组件的引用。游戏对象也有一套自己的管理方式，Unity也提供了丰富的接口来操作它，比如创建、删除、修改和查询等。 创建游戏对象创建游戏对象的方式有两种。第一种是从资源中创建对象，Resources读取一个Prefab，接着通过GameObject.Instantiate()实例化创建。另一种就是通过代码创建，即使用new GameObject()，接着在后面挂脚本或者设置参数等。如下代码所示，我们可以在运行时创建一个空的游戏对象，并将其绑定在一个摄像机脚本中。 1234567891011using System.Collections;using UnityEngine;public class Script : MonoBehaviour&#123; void Start() &#123; Camera camera = new GameObject("MyCamera").AddComponent&lt;Camera&gt;(); camera.transform.position = Vector3.one * 10f; &#125;&#125; Transform设置排序]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Global Illumination]]></title>
    <url>%2F2019%2F05%2F01%2FGlobal-Illumination%2F</url>
    <content type="text"><![CDATA[Global Illumination (GI) is a system that models how light is bounced off of surfaces onto other surfaces (indirect light) rather than being limited to just the light that hits a surface directly from a light source (direct light)全局照明是一种系统，可以模拟光线如何从表面反射到其他表面（间接光），而不仅仅局限于直接从光源照射到表面的光线（直接光）. Modelling indirect lighting allows for effects that make the virtual world seem more realistic and connected, since objects affect each other’s appearance塑造间接照明允许使虚拟世界看起来有更逼真和连接的效果，因为物体会影响彼此的外观. One classic example is ‘color bleeding’where, for example, sunlight hitting a red sofa will cause red light to be bounced onto the wall behind it一个典型的例子是’颜色溢出’，例如，阳光照射到红色沙发上会导致红光反射到它后面的墙上. Another is when sunlight hits the floor at the opening of a cave and bounces around inside so the inner parts of the cave are illuminated too另一种情况是当阳光照射到洞穴开口处的地板上并在内部反弹时，洞穴的内部也会被照亮。. ** GI concepts ** Traditionally, video games and other realtime graphics applications have been limited to direct lighting, while the calculations required for indirect lighting were too slow so they could only be used in non-realtime situations such as CG animated films传统上，视频游戏和其他实时图形应用仅限于直接照明，而间接照明所需的计算速度太慢，因此它们只能用于非实时情况，如CG动画电影. A way for games to work around this limitation is to calculate indirect light only for objects and surfaces that are known ahead of time to not move around (that are static)游戏解决此限制的一种方法是仅为提前知道的不移动的物体和表面计算间接光（静态）. That way the slow computation can be done ahead of time, but since the objects don’t move, the indirect light that is pre-calculated this way will still be correct at runtime这样，慢速计算可以提前完成，但由于对象不移动，以这种方式预先计算的间接光在运行时仍然是正确的. Unity supports this technique, called Baked GI (also known as Baked Lightmaps), which is named after “the bake” - the process in which the indirect light is precalculated and stored (baked)Unity支持这种技术，称为Baked GI（也称为Baked Lightmaps），以“the bake”命名 - 间接光被预先计算并存储（烘焙）的过程. In addition to indirect light, Baked GI also takes advantage of the greater computation time available to generate more realistic soft shadows from area lights and indirect light than what can normally be achieved with realtime techniques除了间接光之外，Baked GI还利用了更多的计算时间，可以从区域光源和间接光源生成更逼真的软阴影，而不是通常通过实时技术实现. Additionally, Unity 5.0 adds support for a new technique called Precomputed Realtime GI此外，Unity 5.0还增加了对称为预计算实时GI的新技术的支持. It still requires a precomputation phase similar to the bake mentioned above, and it is still limited to static objects它仍然需要类似于上面提到的烘焙的预计算阶段，并且它仍然限于静态对象. However it doesn’t just precompute how light bounces in the scene at the time it is built, but rather it precomputes all possible light bounces and encodes this information for use at runtime然而，它不仅预先计算场景中光线反射的方式，而是预先计算所有可能的光线反射并对此信息进行编码以便在运行时使用. So essentially for all static objects it answers the question “if any light hits this surface, where does it bounce to?” Unity then saves this information about which paths light can propagate by for later use. The final lighting is done at runtime by feeding the actual lights present into these previously computed light propagation paths因此，它主要针对所有静态对象回答了这个问题：“如果有任何光线照射到这个表面，它会在哪里反弹？”Unity然后保存这些信息，关于光可以传播哪些路径供以后使用. This means that the number and type of lights, their position, direction and other properties can all be changed and the indirect lighting will update accordingly这意味着灯的数量和类型，它们的位置，方向和其他属性都可以更改，间接照明也会相应更新. Similarly it’s also possible to change material properties of objects, such as their color, how much light they absorb or how much light they emit themselves同样地，也可以改变物体的材料属性，例如它们的颜色，它们吸收的光量或它们发出的光量。. While Precomputed Realtime GI also results in soft shadows, they will typically have to be more coarse-grained than what can be achieved with Baked GI unless the scene is very small虽然预先计算的实时GI也会产生柔和的阴影，但它们通常必须比使用Baked GI可以实现的更粗糙，除非场景非常小. Also note that while Precomputed Realtime GI does the final lighting at runtime, it does so iteratively over several frames, so if a big a change is done in the lighting, it will take more frames for it to fully take effect另请注意，虽然预计算实时GI在运行时进行最终照明，但它会在几个帧上迭代执行，因此如果在照明中进行了大量更改，则需要更多帧才能完全生效. And while this is fast enough for realtime applications, if the target platform has very constrained resources it may be better to to use Baked GI for better runtime performance虽然这对于实时应用来说足够快，但目标平台的资源非常有限，使用Baked GI以获得更好的运行时性能可能更好. ** Limitations of GIGI的局限性 ** Both Baked GI and Precomputed Realtime GI have the limitation that only static objects can be included in the bake/precomputation - so moving objects cannot bounce light onto other objects and vice versaBaked GI和Precomputed Realtime GI都有限制，只有静态对象可以包含在烘焙/预计算中 - 因此移动对象不能将光反射到其他对象上，反之亦然. However they can still pick up bounce light from static objects using Light Probes然而，他们仍然可以使用Light Probes从静态物体中拾取反射光. Light Probes are positions in the scene where the light is measured (probed) during the bake/precomputation, and then at runtime the indirect light that hits non-static objects is approximated using the values from the probes that the object is closest to at any given moment光探测器是在烘焙/预计算期间测量（探测）光的场景中的位置，然后在运行时使用来自对象最接近的探测器的值来近似击中非静态对象的间接光。 给定的时刻。. So for example a red ball that rolls up next to a white wall would not bleed its color onto the wall, but a white ball next to a red wall could pick up a red color bleed from the wall via the light probes 因此，例如，在白墙旁边卷起的红色球不会将其颜色吹到墙上，但是红色墙旁边的白色球可以通过光探测器从墙壁上吸出红色的颜色。. ** Examples of GI effects ** Changing the direction and color of a directional light to simulate the effect of the sun moving across the sky改变定向光的方向和颜色，以模拟太阳在天空中移动的效果. By modifying the skybox along with the directional light it is possible to create a realistic time-of-day effect that is updated at runtime. (In fact the new built-in procedural skybox makes it easy to do this)通过修改天空盒以及定向光，可以创建在运行时更新的实际时间效果。 （事实上，新的内置程序天空盒可以很容易地做到这一点）. As the day progresses the sunlight streaming in through a window moves across the floor, and this light is realistically bounced around the room and onto the ceiling随着时间的推移，通过窗户流入的阳光穿过地板，这种光在房间周围和天花板上实际反弹. When the sunlight reaches a red sofa, the red light is bounced onto the wall behind it. Changing the color of the sofa from red to green will result in the color bleed on the wall behind it turning from red to green too当阳光到达红色沙发时，红灯会反射到它后面的墙上。 将沙发的颜色从红色变为绿色将导致其后面的墙壁上的颜色从红色变为绿色. Animating the emissiveness of a neon sign’s material so it starts glowing onto its surroundings when it is turned on激活霓虹灯标志材料的发射率，使其在打开时开始发光.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Level of Detail(LOD)]]></title>
    <url>%2F2019%2F04%2F30%2FLevel-of-Detail-LOD%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.LOD是什么？2.如何使用？3.命名约定是怎样的？ When a GameObject in the Scene is far away from the Camera, you can’t see very much detail, compared to when the GameObject is close to the Camera. And even though you can’t see the detail on a distant GameObject, Unity uses the same number of triangles to render it at both distances. To optimize rendering, you can use the Level Of Detail (LOD) technique. It allows you to reduce the number of triangles rendered for a GameObject as its distance from the Camera increases. You use several Meshes and optionally a Billboard Asset, which all（它们都） represent the same GameObject with decreasing detail in the geometry（您可以使用多个网格和可选的Billboard Asset，它们都代表相同的GameObject，并且几何体中的细节不断减少）. Each of the Meshes contains a Mesh Renderer component and represents a ‘MeshLOD level’, while the Billboard Asset has a Billboard Renderer component and represents a ‘Billboard LOD level’. As long as your GameObjects aren’t all close to the Camera at the same time, LOD reduces the load on the hardware and improves the rendering performance. ** Working with LOD levels ** In Unity, you use the LOD Group component to set up LOD rendering for a GameObject. The images below demonstrate（演示） how the LOD levels change according to distance from the Camera. Image 1: Camera at LOD 0 shows a large number of small triangles in the Mesh Image 1 shows the first level, LOD 0. This level is the closest to the Camera, and therefore the most detailed LOD level. For example, many first-level LODs are active when the GameObject’s height fills(填满) 50% or more of the screen’s height. Image 2: Camera at LOD 1 shows the Mesh with far fewer triangles and they are much larger in size Image 2 shows the next level, LOD 1. This level is farther away from the Camera, and therefore is a lower LOD level. For example, many LOD Groups use three levels, where LOD 1 is active when the GameObject fills between 25% and 49% of the screen height, and LOD 2 is active when the GameObject fills less than 25% of the screen height. Because the arrangement of LOD levels depends on the target platform and available rendering performance, you can set maximum LOD levels and a Lod Bias Quality setting in Unity. The Lod Bias determines whether to favor higher or lower LOD levels at threshold distances（由于LOD级别的排列取决于目标平台和可用的渲染性能，因此您可以在Unity中设置最大LOD级别和Lod偏差质量设置。Lod Bias确定是否在阈值距离处支持更高或更低的LOD水平。）. ** Naming convention（命名约定） for importing Meshes ** When you import a set of LOD Meshes, Unity automatically creates an LOD group for the GameObject with appropriate settings if you follow this naming convention（导入一组LOD网格时，如果遵循以下命名约定，Unity会自动为GameObject创建一个具有适当设置的LOD组）: Your set of Meshes have file names ending in _LOD and a number ranging from 0 to the total number of LOD levels minus one. For example, if the base name for your Mesh is Player, name your files Player_LOD0, Player_LOD1 and Player_LOD2 to generate a Player GameObject with three LOD levels. Name the most detailed Mesh file _LOD0. Make sure the rest of the Mesh file names increment corresponding to decreasing（减少） detail. Set Billboard LOD levels to have the highest numerical prefix (because they always have the least detailed level). You can use as many LOD levels as you need.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookies]]></title>
    <url>%2F2019%2F04%2F30%2FCookies%2F</url>
    <content type="text"><![CDATA[回答并思考以下问题：1.Cookies是什么？2.如何创建？ In theatre and film, lighting effects（效果） have long been used to create an impression（印象） of objects that don’t really exist in the set. Jungle（丛林） explorers may appear to be covered in shadows from an imaginary（假想的） tree canopy（树冠）. A prison scene often shows the light coming through the barred window, even though the window and indeed the wall are not really part of the set（直接用灯光在地上打一个中间有栏杆的窗户的形状）. Though very atmospheric（虽然非常有气氛）, the shadows are created very simply by placing a shaped mask in between the light source and the action. The mask is known as a cucoloris or cookie for short. Unity lights allow you to add cookies in the form of textures（以纹理的形式添加cookie）; these provide an efficient way to add atmosphere to a scene. A directional light cookie simulating（模拟） light from a window ** Creating a Cookie ** A cookie is just an ordinary texture but only the alpha/transparency channel is relevant. When you import a cookie, Unity gives you the option to convert the brightness of the image to alpha so it is often easier to design your cookie as a grayscale texture（灰度纹理）. You can use any available image editor to create a cookie and save it to your project’s Assets folder. A simple cookie for a window light When the cookie is imported into Unity, select it from the Project view and set the Texture Type to Cookie in the inspector. You should also enable Alpha From Grayscale（灰阶） unless you have already designed the image’s alpha channel yourself. The Light Type affects the way the cookie is projected（投射） by the light. Since a point light projects in all directions, the cookie texture must be in the form of a Cubemap. A spot light should use a cookie with the type set to Spotlight but a directional light can actually use either the Spotlight or Directional options. A directional light with a directional cookie will repeat the cookie in a tiled pattern all over the scene. When a spotlight cookie is used, the cookie will appear just once in the direct path of the “beam（光束）” of the light; this is the only case where the position of a directional light is important. The window cookie “tiled” in directional mode ** Applying a Cookie to a Light ** When the texture is imported, drag it to the Light’s Cookie property in the inspector to apply it. The spot light and point light simply scale the cookie according to the size of the cone（锥体） or sphere. The directional light has an additional option Cookie Size that lets you scale the cookie yourself; the scaling works with both Spotlight and Directional cookie types. ** Uses of Cookies ** Cookies are often used to change the shape of a light so it matches a detail “painted” in the scene. For example, a dark tunnel may have striplights（长条灯） along the ceiling（天花板）. If you use standard spot lights for illumination then the beams will have an unexpected round shape but you could use cookies to restrict the lights to a thin rectangle. A monitor screen may cast a green glow（辉光） onto the face of the character using it but the glow should be restricted to a small box shape. Note that a cookie need not be completely black and white but can also incorporate（包括） any grayscale level. This can be useful for simulating dust or dirt in the path of the light. For example, if a game scene takes place in a long abandoned house, you could add atmosphere by using “dirty” cookies with noise on the windows and other light sources. Similarly, car headlight glass usually contains ridges that create “caustic” patterns of slightly lighter and darker areas in the beam; another good use for a cookie.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glossary]]></title>
    <url>%2F2019%2F04%2F30%2FGlossary%2F</url>
    <content type="text"><![CDATA[词汇 英文 含义 Culling Mask Allows you to includes or omit（忽略） objects to be rendered by a Camera, by Layer. Cubemap A collection of six square（正方形）textures that can represent the reflections in an environment or the skybox drawn behind your geometry. The six squares form the faces of an imaginary cube that surrounds an object; each face represents the view along the directions of the world axes (up, down, left, right, forward and back). GI Cache The cached intermediate（中间） files used when Unity precomputes real-time GI, and when baking Static Lightmaps, Light Probes and Reflection Probes.Unity keeps this cache to speed up computation. Light Probe Light probes store information about how light passes through space in your scene. A collection of light probes arranged within a given space can improve lighting on moving objects and static LOD scenery within that space布置在给定空间内的light probes的集合可以改善移动物体上的照明以及该空间内的静态LOD景物. Mesh The main graphics primitive of Unity. Meshes make up a large part of your 3D worlds. Unity supports triangulated or Quadrangulated polygon meshes. Nurbs, Nurms, Subdiv surfaces must be converted to polygons. Reflection Probe A rendering component that captures a spherical view of its surroundings in all directions, rather like a camera. The captured image is then stored as a Cubemap that can be used by objects with reflective materials一个渲染组件，可以捕捉所有方向的周围环境的球形视图，就像一个摄像头。然后将捕获的图像存储为Cubemap，其可以被具有反射材质的对象使用. Mesh Filter A mesh component that takes a mesh from your assets and passes it to the Mesh Renderer for rendering on the screen. Mesh Rendere A mesh component that takes the geometry from the Mesh Filter and renders it at the position defined by the object’s Transform component. Deferred shading A rendering path that places no limit on the number of lights that can affect a GameObject. All lights are evaluated per-pixel, which means that they all interact correctly with normal maps and so on所有灯都按像素进行评估，这意味着它们都可以与法线贴图正确交互，依此类推. Additionally, all lights can have cookies and shadows. Lightmaps A pre-rendered texture that contains the effects of light sources on static objects in the scene. Lightmaps are overlaid on top of scene geometry to create the effect of lighting Rendering Path The technique Unity uses to render graphics. Choosing a different path affects the performance of your game, and how lighting and shading are calculated. Some paths are more suited to different platforms and hardware than others. Occlusion Culling A Unity feature that disables rendering of objects when they are not currently seen by the camera because they are obscured (occluded) by other objects.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的游戏这么好玩，为什么卖不动？]]></title>
    <url>%2F2019%2F04%2F29%2F%E6%88%91%E7%9A%84%E6%B8%B8%E6%88%8F%E8%BF%99%E4%B9%88%E5%A5%BD%E7%8E%A9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%96%E4%B8%8D%E5%8A%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[来源：我的游戏这么好玩，为什么卖不动？ 关于游戏的销量，自古以来流传着这么几种说法： 1.销量是玄学；2.这届玩家不行；3.发行不给力 or 只擅长做研发、不知道怎么做宣传。 但也许，不止如此。 作为游戏开发者，我们最希望的状态，就是“好玩的游戏能赚钱”。 比如《Celeste》，IGN 10分，销量爆炸，这应该是很多开发者的目标。 但同类型的《The Messenger》，同样好评如潮，并且发行是大名鼎鼎的D社，销量却有明显差距。 并且二者发售时间相差半年以上，并不存在《The Messenger》被《Celeste》冲击的关系。 类似的例子，如果你想找，还会发现很多。 因此，也就有了“销量是玄学”的说法。 个人口味上，更喜欢《The Messenger》，除了战斗、跳跃的流畅感，游戏里还埋了各种有趣的梗 当时发的一条朋友圈 “好玩 = 销量高”。 这是我们最单纯的期望，也是最大的误区。 影响销量，更关键的其实是游戏是否“有趣”。 举个例子，就很容易理解。 《八分音符酱》，一款非常有趣，但不那么好玩的游戏。 这款游戏的玩法是，通过对着麦克风吼，来控制角色跳平台，吼的音量决定跳跃的高度。 可想而知，会有无数主播来播这款游戏，因为实在是太魔性了。 但有人会深入玩这款游戏，研究其中各种关卡设计、吼叫的技巧么？应该没有。 对比一下，我们就更清楚“好玩”和“有趣”的区别了： 好玩，也就是我们常说的“核心玩法有深度”，是要玩了才知道的；有趣，则是听了、看了就可以知道的。 比如，我们尝试向朋友安利一下《Celeste》和《八分音符酱》这两款游戏。 《Celeste》 游戏关卡的解法充满挑战性，通关之后则让人充满成就感。关卡中隐藏着许多秘密和收集品，其中一些物品的获得方式极度考验你的操作水平。游戏通关后的可玩内容非常丰富，足以让你沉迷数十小时——IGN 《八分音符酱》 对着麦克风吼来玩的游戏 哪个更容易吸引到大众的兴趣，显而易见。 我们再来看一些“有趣”的例子。 《没有人知道的大冒险》，画面堪比简笔画，玩法和AVG类似，但在当时也是个小热点。 贴地气的故事+处处埋梗+独特的表现形式，造就了一款独特而有趣的游戏（如果《没有人知道的大冒险》把画面做的非常精美，我觉得反而会失去味道）。 去年的《中国式家长》，更是个典型的例子。 如果只是一款养成类游戏，不管养的是女儿、明星，都不会有这么高的销量。 而让《中国式家长》销量爆炸的原因，恰恰不是它在养成玩法上做了哪些突破，而是借助了题材、包装。 玩法简单，但看着就很有趣 因此，“有趣”的游戏会拥有以下特征： 玩到之前，你就能大致了解游戏的乐趣（正如前文提到，“好玩”要玩了才知道，“有趣”只要听了、看了就知道）；即使没玩过，你也会向别人安利（由第1点导致的）；可能会让你大呼“卧槽，这也可以”（强化了第2点的效果）。 而这三点，最终形成的结果就是——易理解、二次传播、独特性。 这导致的结果，自然就是销量更高。 接下来的问题，自然是“如何才能让游戏更有趣”。 这方面我也只是略知一二，在此抛砖引玉。 很多道理，其实是相通的。 想要了解有趣，不一定要从游戏入手。 我平时经常会逛煎蛋网的无聊图版块，这里面基本都是这种图。 有一天，我忽然无聊到做了这么一件事……将几十页的无聊图进行分门别类，看看oo多的（即“点赞”）都是些什么样的图。 然后，我发现群众喜闻乐见的东西，确实是有套路的。 颠覆→混搭 颠覆，是个最大的套路，下面又分为几类。 比如“混搭”，就是将不同事物进行组合，从而达到颠覆原有概念的效果。 这种手法，在游戏中也经常用到。 题材，就是最好用的“混搭”手法。 比如《文豪野犬》，就是把文豪的作品变成对应的超能力来战斗，用大家最熟悉的鲁迅为例： 呐喊，咆哮击退周围敌人；彷徨，左右横跳躲避敌人攻击；从百草园到三味书屋，制造巨大迷宫困住敌人。 这个例子来自LexBurner的视频《文豪野犬》都是日本作家，没有鲁迅 题材之外，玩法等元素也都可以进行混搭。 比如《八分音符酱》，就是将“吼”与“操作”进行了混搭。类似的，还有将“听”与“解谜”进行了混搭的《疑案追声》。 颠覆→神点评 将两个事物的共同点进行组合联想，从而建立全新的视角，来达到对常规视角的颠覆。 奥利奥 这种手法在游戏中相对少见，可能仅用于一些剧情、道具文本的吐槽中。 由于吐槽早已成为了全世界范围的文化现象，我觉得未来很可能会有游戏将其融入。 日式冷吐槽，火遍网络 颠覆→神转折 对之前的内容进行180°的改变，来达到颠覆的效果。 这种方式，在各种奇葩小游戏中经常用到。 甚至一些3A游戏的结局，也会用到这个手法。 比如《合金装备V》，玩家最后发现自己操作的其实不是Big Boss，而是一个替身。 但这可能不适合作为“有趣”的结合点，因为传播的过程就会破坏了最后反转的乐趣。 颠覆→断章取义、视角转换 断章取义：选取特定片段，故意造成误解。 视角转换：和断章取义类似，但是通过展现“平时未被发现的一面”，来达到颠覆的效果。 这两种方式，我还没想到在游戏中结合的场景。 颠覆→猎奇 展现现实中罕为人知的事情，由于是真实存在的，所以颠覆的效果更加强烈。 华美极乐鸟，这周也算讲过动物了 这种手法，在游戏中使用的非常多。 近几年的各种模拟器游戏，其实都在满足我们猎奇的需求。 steam七大名著之一的《欧洲卡车司机模拟器2》 《外科医生模拟器》 此外，还有以“签证官”为视角的《Papers,Please》，以“监察员”为视角的《Beholder》，都比模拟器更进一步，将“独特的身份”与玩法进行了更深的结合。 《1979 Revolution》，以伊朗伊斯兰革命为背景的游戏，可惜做得一般 某个朋友说，如果做一款《版号送审模拟器》，一定会火。 我深以为然。 除了“颠覆”，还有两种手法非常有效。 一种是卖萌，尤其是猫咪……这个不用我多说了。 《猫咪后院》 另外一种……是2B（我尝试用其他词语表述，但都不如2B直观，虽然有些粗俗但请大家谅解）。 2B→智障 这点无需赘述，C菌的火爆已经说明了一切。 以《QWOP》为首的各种智障游戏，都在满足我们这方面的需求。 甚至看主播玩这些游戏的时候，我们往往会获得比自己玩更强烈的愉悦感…… 2B→自我感觉良好、蛋逼 这两种放在一起。 自我感觉良好，是在做别人认为很2B的事儿，而自己却不自知（至少看起来是）。 蛋逼，是自己也知道这事儿2B，但仍然很认真的在做，极具娱乐精神。 蛋逼在游戏中很常见，比如《超脱力医院》，就是此中翘楚。 自我感觉良好，我觉得也应该有。 不过奇葩游戏我玩得比较少……如果大家想到请在评论中补充。 以上，都是一些我认为可以让游戏变得“有趣”的方法。 也许未必所有的开发者、玩家都喜欢，觉得这会有些低俗，好游戏就是应该关注在最纯粹的乐趣上。 我不否认，马里奥完全不用靠上述的任何技巧，依然世界第一。 但我们不是宫本茂。 为了能继续做游戏，养活自己活下去是必要的。希望上面的内容，可以帮到一些开发者。 也希望未来可以玩到更多又好玩又有趣的国产游戏。 共勉。]]></content>
      <categories>
        <category>游戏设计</category>
      </categories>
      <tags>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息事件封装]]></title>
    <url>%2F2019%2F04%2F27%2F%E6%B6%88%E6%81%AF%E4%BA%8B%E4%BB%B6%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 消息类型定义和封装 Unity游戏中通常使用的消息事件是直接使用委托实现的，这对用户来说使用起来不是很方便，因为游戏开发不是一个人可以完成的，需要一个团队的力量。所以需要封装一个统一的接口供开发者使用，使用事件机制的优点是不需要在UI上直接挂接代码。 本章实现的消息事件封装采用的是监听和分发机制，它主要运用在逻辑判断时。比如数据加载完成后需要触发某个事件，遇到这种情况我们就可以使用监听和分发机制，方便逻辑判断，减少程序之间的耦合度，而且使用起来非常方便。监听服务器消息也可以运用事件监听机制，收到服务器的信息后可以执行某个事件。本章的消息事件封装主要是围绕客户端的事件封装，首先介绍消息类型定义和封装。 消息类型定义和封装消息类型主要是针对不同消息定义的枚举。比如游戏有数据加载、关卡、游戏结束等，完成以上工作后，还可以继续执行其他操作。可以将定义的枚举类型单独放在一个文件中，定义的枚举代码如下所示： 12345678public enum CEventType&#123; GAME_OVER, GAME_WIN, PAUSE, ENERGY_EMEPTY, GAME_DATA,&#125; 消息系统的封装设计采用了模块化设计理念，首先要定义一个消息事件的基类，这个主要是消息底层的实现方式，主要目的是初始化消息，完整代码如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576using UnityEngine;using System.Collections; public class CBaseEvent&#123; protected Hashtable arguments; protected CEventType type; protected Object sender; public CEventType Type &#123; get &#123; return this.type; &#125; set &#123; this.type = value; &#125; &#125; public IDictionary Params &#123; get &#123; return this.arguments; &#125; set &#123; this.arguments = (value as Hashtable); &#125; &#125; public Object Sender &#123; get &#123; return this.sender; &#125; set &#123; this.sender = value; &#125; &#125; public override string ToString() &#123; return this.type + " [ " + ((this.sender == null) ? "null" : this.sender.ToString()) + " ] "; &#125; public CBaseEvent Clone() &#123; return new CBaseEvent(this.type, this.arguments, Sender); &#125; public CBaseEvent(CEventType type, Object sender) &#123; this.Type = type; Sender = sender; if (this.arguments == null) &#123; this.arguments = new Hashtable(); &#125; &#125; public CBaseEvent(CEventType type, Hashtable args, Object sender) &#123; this.Type = type; this.arguments = args; Sender = sender; if (this.arguments == null) &#123; this.arguments = new Hashtable(); &#125; &#125;&#125; 下面开始讲最核心的部分，消息事件的监听和分发。其实，监听和分发就是事先把消息事件注册到已定义好的Dictionary字典中，当需要触发时将其从字典中取出。 消息事件的监听与分发事件的监听和分发接口封装在游戏逻辑中经常被调用，同时也是对外提供的接口。完整代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System.Collections;using System;public delegate void CEventListenerDelegate(CBaseEvent evt); public class CEventDispatcher&#123; static CEventDispatcher instance; public static CEventDispatcher GetInstance() &#123; if (instance == null) &#123; instance = new CEventDispatcher(); &#125; return instance; &#125; private Hashtable listeners = new Hashtable();//增加事件监听 public void AddEventListener(CEventType eventType, CEventListenerDelegate listener) &#123; CEventListenerDelegate ceventListenerDelegate = this.listeners[eventType] as CEventListenerDelegate; ceventListenerDelegate = (CEventListenerDelegate)Delegate.Combine(ceventListenerDelegate, listener); this.listeners[eventType] = ceventListenerDelegate; &#125;//移除事件监听 public void RemoveEventListener(CEventType eventType, CEventListenerDelegate listener) &#123; CEventListenerDelegate ceventListenerDelegate = this.listeners[eventType] as CEventListenerDelegate; if (ceventListenerDelegate != null) &#123; ceventListenerDelegate = (CEventListenerDelegate)Delegate.Remove(ceventListenerDelegate, listener); &#125; this.listeners[eventType] = ceventListenerDelegate; &#125;//分发事件消息 public void DispatchEvent(CBaseEvent evt) &#123; CEventListenerDelegate ceventListenerDelegate = this.listeners[evt.Type] as CEventListenerDelegate; if (ceventListenerDelegate != null) &#123; try &#123; ceventListenerDelegate(evt); &#125; catch (System.Exception e) &#123; throw new System.Exception( string.Concat(new string[] &#123; "Error dispatching event", evt.Type.ToString(), ": ", e.Message, " ", e.StackTrace &#125;),e); &#125; &#125; &#125; public void RemoveAll() &#123; this.listeners.Clear(); &#125;&#125; 下面把代码的核心部分介绍一下，在代码中定义了一个委托函数用于事件消息回调： 1public delegate void CEventListenerDelegate(CBaseEvent evt); 这个委托函数大家应该非常熟悉，下面介绍事件监听的接口函数实现，如下所示。 123456public void AddEventListener(CEventType eventType, CEventListenerDelegate listener)&#123; CEventListenerDelegate ceventListenerDelegate = this.listeners[eventType] as CEventListenerDelegate; ceventListenerDelegate = (CEventListenerDelegate)Delegate.Combine(ceventListenerDelegate, listener); this.listeners[eventType] = ceventListenerDelegate;&#125; 该函数事先将消息放到列表中，便于后面分发时从列表中取出数据。分发函数的封装代码如下所示。 123456789101112131415161718192021222324public void DispatchEvent(CBaseEvent evt)&#123; CEventListenerDelegate ceventListenerDelegate = this.listeners[evt.Type] as CEventListenerDelegate; if (ceventListenerDelegate != null) &#123; try &#123; ceventListenerDelegate(evt); &#125; catch (System.Exception e) &#123; throw new System.Exception( string.Concat(new string[] &#123; "Error dispatching event", evt.Type.ToString(), ": ", e.Message, " ", e.StackTrace &#125;),e); &#125; &#125;&#125; 这两个函数最重要，它们在代码中是成对出现的。下面就说说它们在项目中的应用。 事件的监听与分发在游戏中是如何使用的？下面通过案例给大家介绍一下，首先在代码中加入监听事件，事例代码如下： 123456void Start()&#123; CEventDispatcher.GetInstance().AddEventListener(CEventType.NEXT_BATTALE_START, StartKongxi); CEventDispatcher.GetInstance().AddEventListener(CEventType.GAME_WIN, StopKongxi); CEventDispatcher.GetInstance().AddEventListener(CEventType.GAME_OVER, StopKongxi);&#125; 粗体部分是加入了监听事件，有监听的类型和监听需要触发的函数，如果需要触发该函数，需要去调用事件的分发函数，代码如下： CEventDispatcher.GetInstance().DispatchEvent(newCBaseEvent(CEventType.NEXT_BATTALE_START, this));这样就会触发监听事件的StartKongxi函数。如果需要移除该监听事件，调用函数如下所示。 123456void OnDestroy()&#123; CEventDispatcher.GetInstance().RemoveEventListener(CEventType.NEXT_BATTALE_START, StartKongxi); CEventDispatcher.GetInstance().RemoveEventListener(CEventType.GAME_WIN, StopKongxi); CEventDispatcher.GetInstance().RemoveEventListener(CEventType.GAME_OVER, StopKongxi);&#125; 以上就是事件监听的使用案例。其实设计事件的监听和分发功能主要是为了模块之间解耦合以及逻辑判断使用的。在游戏逻辑开发中还是很方便的，当然实现方式有很多种，只要满足条件的都可以称为事件机制。 小结我以前做事件系统时主要使用的还是委托，扩展起来比较麻烦，每一个回调都要重新封装一个函数。最初的事件机制是应用在服务器上发送消息给客户端，客户端监听服务器发送给客户端的消息，使用起来非常方便，扩展也方便。后期又把它应用到了客户端自己的事件监听上，其实它就是把委托封装了一下，将事件的监听函数存放到了表中。掌握事件监听原理，再将其应用到游戏中，这样你才能真正掌握事件监听机制。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity 3D实战核心技术详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Avatar换装系统]]></title>
    <url>%2F2019%2F04%2F27%2FAvatar%E6%8D%A2%E8%A3%85%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 直接更换Mesh的方法有什么缺点？ 本章涵盖： 换装原理 换装代码实现 小结 换装系统又称纸娃娃系统，是运用在游戏开发上的关键技术。市面上关于换装的游戏非常多，3D MMORPG游戏中也使用了角色换装技术，所以掌握换装技术是非常重要的。换装系统原理也同样适用于换武器、换表情等。本章先讲换装实现原理，再讲换装的编程实现，最后提醒读者在运用该技术解决问题时应注意的事项。 换装原理游戏内的角色，能够像纸娃娃换装那样让玩家为自己的角色改变外观，一直深受广大玩家欢迎。一般而言，建好的3D模型，如果要将其中一个部位换成另外一个形状，最直接的做法是将该物件的模型Mesh替换掉，那么外观就改变了，但这种方法如果运用在需要做动作的模型上，被置换的部位可能就不会正常做动作了，更糟的状况是可能连模型显示的位置及方向都是错误的，所以，直接更换Mesh的方法只适用于静态模型物件。为此，必须找出更深入的方法来实现换装的功能。 首先看看模型的结构。在Hierarchy视窗中将物件展开，我们会发现几个名称相同并使用数字区别的物件，它们分別代表人物各部位的模型。由此可知，整个人物包含多个相同部位的模型，其在Unity中的表现如下图所示。对象FemaleAvatar的子节点Famale_Bip01是整个人物的骨架结构，人物的动作组件则设置在顶层对象（FemaleAvatar）的Animation组件中，这个模型是资源模型，而不是实际上要放在场景中的目标物件。模型的制作是需要美术将其呈现出来的，最后交付给程序使用。在这里给读者介绍模型资源结构的主要目的是希望读者了解模型制作要求。 上图的FemaleAvatar对象中每个部位都有多个模型部件，这些部件就是用来换装的，其在Unity场景中的效果表现如下图所示。 身体的每个部位是由两部分组成的，这也是换装模型的源文件，将模型作为来源模型资源，再依照需求将资源模型各部位重新组合成一个新的目标模型。接下来开始制作源模型Source和目标模型Target。现将人物模型FemaleAvatar放到场景中，同时再复制一个作为目标模型使用，把它们分别命名为Source和Target，在Unity编辑器的操作如下图所示。 其中targetmodel模型是将源FemaleAvatar对象中除了Female_Bip01外其他部分都删除掉，将父节点名字改成targetmodel，这样就完成了targetmodel对象的制作，是不是很简单？然后将它们拖入Resources文件夹中作为实例化模型。接下来需要为其设置一个动作，可以循环播放的动作，设置组件参数如下图所示。 Source物件是作为来源资源使用的，实际在场景中不需要显示。Source中的各部位名称必须要有编号，例如，face-001。为了便于区分换装的各个Mesh部分，如果没有编号，请开发者自行加上编号，这些工作需要程序员和美工事先定义好，完成以上的准备工作，就要开始写程序了。 程序员的主要工作是先将Source中每个物件的SkinnedMeshRenderer取出并储存在data表中，data的内容则是根据部位分类索引。接下来在Target中加入SkinnedMeshRenderer，然后在每个部位取出一个指定的Mesh，利用CombineInstance类及Mesh.CombineMeshes()将各部位模型合并，同时也要重新排列材质，依照取出的SkinnedMeshRenderer的bone的名称，找到与Target的Female_Bip01子物件内名称相对应的物件重建骨架列表。最后将这些重新组合建立的资源赋给Target的各个SkinnedMeshRenderer，如此就可完成换装的工作了。原理搞清楚了，下面开始实现具体代码。 换装代码实现以下是完整的换装源代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162using UnityEngine;using System.Collections.Generic;public class AvatarSys : MonoBehaviour &#123; // 来源模型资源的物件 private Transform source; // 目标物件 private Transform target; // 实例化的源文件和目标文件 private GameObject sourceobj; private GameObject targetobj; // 模型资源 private Dictionary&lt;string, Dictionary&lt;string, Transform&gt;&gt; data = new Dictionary&lt;string, Dictionary&lt;string, Transform&gt;&gt;(); // 播放的动作 private Animation mAnim; // 目标物件的骨架 private Transform[] hips; // 目标物件各部位的 SkinnedMeshRenderer（参照） private Dictionary&lt;string, SkinnedMeshRenderer&gt; targetSmr = new Dictionary&lt;string, SkinnedMeshRenderer&gt;(); public static AvatarSys instance; // 各部分换装的名字 string[,] avatarstr = new string[,] &#123; &#123; "coat", "003" &#125;, &#123; "hair", "003" &#125;, &#123; "pant", "003" &#125;, &#123; "hand", "003" &#125;, &#123; "foot", "003" &#125;, &#123; "head", "003" &#125; &#125;; string[,] avatarstr0 = new string[,] &#123; &#123; "coat", "001" &#125;, &#123; "hair", "001" &#125;, &#123; "pant", "001" &#125;, &#123; "hand", "003" &#125;, &#123; "foot", "003" &#125;, &#123; "head", "003" &#125; &#125;; string[,] avatarstr1 = new string[,] &#123; &#123; "coat", "003" &#125;, &#123; "hair", "001" &#125;, &#123; "pant", "001" &#125;, &#123; "hand", "003" &#125;, &#123; "foot", "001" &#125;, &#123; "head", "001" &#125; &#125;; private float pos; // 用于初始化 void Start () &#123; instance = this; AvatarManager(0.0f); AvatarManager0(1.0f); //AvatarManager1(2.0f); &#125; // 创建多个换装模型 void AvatarManager(float pos) &#123; InstantiateAvatar(); InstantiateSkeleton(pos); LoadAvatarData(source); hips = target.GetComponentsInChildren&lt;Transform&gt;(); Inivatar(); &#125; void AvatarManager0(float pos) &#123; InstantiateAvatar(); InstantiateSkeleton(pos); LoadAvatarData(source); hips = target.GetComponentsInChildren&lt;Transform&gt;(); Inivatar0(); &#125; void AvatarManager1(float pos) &#123; InstantiateAvatar(); InstantiateSkeleton(pos); LoadAvatarData(source); hips = target.GetComponentsInChildren&lt;Transform&gt;(); Inivatar1(); &#125; // 实例化Avatar模型 void InstantiateAvatar() &#123; sourceobj = Instantiate(Resources.Load("FemaleAvatar")) as GameObject; source = sourceobj.transform; sourceobj.SetActive(false); &#125; // 实例化骨骼动画 void InstantiateSkeleton(float pos) &#123; targetobj = Instantiate(Resources.Load("targetmodel")) as GameObject; target = targetobj.transform; target.transform.position = new Vector3(pos, 0.0f, 0.0f); &#125; // 加载Avatar数据 void LoadAvatarData(Transform source) &#123; data.Clear(); targetSmr.Clear(); if (source == null) return; SkinnedMeshRenderer[] parts = source.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;(true); foreach (SkinnedMeshRenderer part in parts) &#123; string[] partName = part.name.Split('-'); if(!data.ContainsKey(partName[0])) &#123; data.Add(partName[0], new Dictionary&lt;string, Transform&gt;()); GameObject partobj = new GameObject(); partobj.name = partName[0]; partobj.transform.parent = target; targetSmr.Add(partName[0], partobj.AddComponent&lt;SkinnedMeshRenderer&gt;()); &#125; data[partName[0]].Add(partName[1], part.transform); &#125; &#125; // 改变Avatar模型 public void ChangeMesh(string part, string item) &#123; SkinnedMeshRenderer smr = data[part][item].GetComponent&lt;SkinnedMeshRenderer&gt;(); List&lt;Transform&gt; bones = new List&lt;Transform&gt;(); foreach (Transform bone in smr.bones) &#123; foreach (Transform hip in hips) &#123; if (hip.name != bone.name) &#123; continue; &#125; bones.Add(hip); break; &#125; &#125; targetSmr[part].sharedMesh = smr.sharedMesh; targetSmr[part].bones = bones.ToArray(); targetSmr[part].materials = smr.materials; &#125; void Inivatar() &#123; int nLength = avatarstr.GetLength(0); for (int i = 0; i &lt; nLength; i++ ) &#123; ChangeMesh(avatarstr[i, 0], avatarstr[i, 1]); &#125; &#125; void Inivatar0() &#123; int nLength = avatarstr0.GetLength(0); for (int i = 0; i &lt; nLength; i++) &#123; ChangeMesh(avatarstr0[i, 0], avatarstr0[i, 1]); &#125; &#125; void Inivatar1() &#123; int nLength = avatarstr1.GetLength(0); for (int i = 0; i &lt; nLength; i++) &#123; ChangeMesh(avatarstr1[i, 0], avatarstr1[i, 1]); &#125; &#125;&#125; 程序将模型资源的存储放到了一个Dictionary字典列表里面，代码如下所示。 12// 模型资源private Dictionary&lt;string, Dictionary&lt;string, Transform&gt;&gt; data = new Dictionary&lt;string, Dictionary&lt;string, Transform&gt;&gt;(); 模型Mesh的挂接部位SkinnedMeshRenderer放在如下的列表里面，代码如下所示。 12// 目标物件各部位的 SkinnedMeshRenderer （参照）private Dictionary&lt;string, SkinnedMeshRenderer&gt; targetSmr = new Dictionary&lt;string, SkinnedMeshRenderer&gt;(); 下面开始介绍代码的编写思路。我们可以创建多个Avatar模型，创建Avatar模型的函数如下所示。 12345678910// 创建多个换装模型void AvatarManager(float pos)&#123; InstantiateAvatar(); InstantiateSkeleton(pos); LoadAvatarData(source); hips = target.GetComponentsInChildren&lt;Transform&gt;(); Inivatar();&#125; 该函数调用了多个接口函数，第一个函数InstantiateAvatar()用于创建资源实例，其实就是加载要更换的模型资源，加载完成后将其设置成不可见，代码如下所示。 1234567// 实例化Avatar模型void InstantiateAvatar()&#123; sourceobj = Instantiate(Resources.Load("FemaleAvatar")) as GameObject; source = sourceobj.transform; sourceobj.SetActive(false);&#125; 更换的资源实例化后，需要将它们挂接到骨骼动画上，所以接下来需要实例化出Target目标模型——骨骼动画，也就是函数InstantiateSkeleton(float pos)要做的事情，代码如下所示。 1234567// 实例化骨骼动画void InstantiateSkeleton(float pos)&#123; targetobj = Instantiate(Resources.Load("targetmodel")) as GameObject; target = targetobj.transform; target.transform.position = new Vector3(pos, 0.0f, 0.0f);&#125; 资源和骨骼动画实例化后就要考虑更换Mesh，也就是换装的操作。函数InstantiateAvatar()只是把资源实例化出来，还没有把各个Mesh取到，这样还不能进行换装，在换装之前还要做的一项工作就是拿到各个部分的Mesh。函数LoadAvatarData(Transform source)就是做这个工作的，代码如下所示。 123456789101112131415161718192021222324// 加载Avatar数据void LoadAvatarData(Transform source)&#123; data.Clear(); targetSmr.Clear(); if (source == null) return; SkinnedMeshRenderer[] parts = source.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;(true); foreach (SkinnedMeshRenderer part in parts) &#123; string[] partName = part.name.Split('-'); if(!data.ContainsKey(partName[0])) &#123; data.Add(partName[0], new Dictionary&lt;string, Transform&gt;()); GameObject partobj = new GameObject(); partobj.name = partName[0]; partobj.transform.parent = target; targetSmr.Add(partName[0], partobj.AddComponent&lt;SkinnedMeshRenderer&gt;()); &#125; data[partName[0]].Add(partName[1], part.transform); &#125;&#125; 执行该函数后，就拿到了运用于换装的各个Mesh，下面开始换装了，换装的函数是public void ChangeMesh(string part，string item)，其参数分别表示换装的名字和换装项的名字，类似这个“coat”“03”，函数代码如下所示。 1234567891011121314151617181920212223// 改变Avatar模型public void ChangeMesh(string part, string item)&#123; SkinnedMeshRenderer smr = data[part][item].GetComponent&lt;SkinnedMeshRenderer&gt;(); List&lt;Transform&gt; bones = new List&lt;Transform&gt;(); foreach (Transform bone in smr.bones) &#123; foreach (Transform hip in hips) &#123; if (hip.name != bone.name) &#123; continue; &#125; bones.Add(hip); break; &#125; &#125; targetSmr[part].sharedMesh = smr.sharedMesh; targetSmr[part].bones = bones.ToArray(); targetSmr[part].materials = smr.materials;&#125; 这样整个换装代码的流程就写完了，该脚本可以直接挂接到场景中的某个对象上，该程序是挂接到Camera上面的，如下图所示。 挂接好脚本后，需要把要实例化的资源模型FemaleAvatar和targetmodel放到Resources资源文件夹下面，主要是便于实例化加载，如下图所示。 接下来为了便于换装操作，需要做几个UI按钮，搭建一个舞台场景，如下图所示。 最后需要编写一个脚本用于UI的操作，完整的代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687using UnityEngine;using System.Collections; public class Avatar_Btn : MonoBehaviour &#123; int count = 0; public void OnClick() &#123; string name = this.gameObject.name; switch (name) &#123; case "coat": if (count == 0) &#123; AvatarSys.instance.ChangeMesh("coat", "001"); count = 1; &#125; else &#123; AvatarSys.instance.ChangeMesh("coat", "003"); count = 0; &#125; break; case "hair": if (count == 0) &#123; AvatarSys.instance.ChangeMesh("hair", "001"); count = 1; &#125; else &#123; AvatarSys.instance.ChangeMesh("hair", "003"); count = 0; &#125; break; case "hand": if (count == 0) &#123; AvatarSys.instance.ChangeMesh("hand", "001"); count = 1; &#125; else &#123; AvatarSys.instance.ChangeMesh("hand", "003"); count = 0; &#125; break; case "head": if (count == 0) &#123; AvatarSys.instance.ChangeMesh("head", "001"); count = 1; &#125; else &#123; AvatarSys.instance.ChangeMesh("head", "003"); count = 1; &#125; break; case "pant": if (count == 0) &#123; AvatarSys.instance.ChangeMesh("pant", "001"); count = 1; &#125; else &#123; AvatarSys.instance.ChangeMesh("pant", "003"); count = 0; &#125; break; case "foot": if (count == 0) &#123; AvatarSys.instance.ChangeMesh("foot", "001"); count = 1; &#125; else &#123; AvatarSys.instance.ChangeMesh("foot", "003"); count = 0; &#125; break; &#125; &#125;&#125; 该类实现了接口publicvoid OnClick()。调用AvatarSys脚本中的ChangeMesh完成换装，将该脚本挂接到UI的每个Button上面，如下图所示。 完成以上操作后就可以运行游戏了，效果如下图所示。 角色在运动，单击头发按钮，角色的头发已经被更换过了。再单击裤子，裤子已经被更换过了。再看看换装后运行的资源效果，如下图所示。 换装后的材质发生了改变，通过上图可以看出，有不同部位的裤子材质。 以上介绍主要是为了帮助读者了解换装所需要做的工作，实际项目开发时，不太可能把游戏中的角色全身各部位的模型资料全部都载入作为来源资料。例如游戏中的武器有100种，角色背包中有3种武器，但为了换装却把100种武器都载入到游戏中，而实际上此角色最多也只能变换背包中的3种武器而已，这样无疑是浪费了97种武器所占用的资源。所以在了解如何换装后，实际操作时应该尽量把来源资源包装起来，只取出需要的资源来进行换装。 小结本章的Avatar换装技术，是针对3D游戏设计的，2D游戏只需要换材质就可以了，比较简单，这里就不介绍了。3D的Avatar换装技术是作为游戏开发者和VR/AR开发者必须要掌握的技能之一。要想掌握Avatar技术主要从两方面入手：一是技术实现，Mesh是绑定到骨骼上的；二是3D MAX建模的要求，或者说是规范，要告诉美工如何建模。希望通过本章的学习，读者可以举一反三做一套更换面部表情的换装系统。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity 3D实战核心技术详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让角色活灵活现：Unity中的动画系统]]></title>
    <url>%2F2019%2F04%2F26%2F%E8%AE%A9%E8%A7%92%E8%89%B2%E6%B4%BB%E7%81%B5%E6%B4%BB%E7%8E%B0%EF%BC%9AUnity%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity AR/VR开发--从新手到专家</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 主从配置（Windows版）]]></title>
    <url>%2F2019%2F04%2F25%2FRedis-%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE%EF%BC%88Windows%E7%89%88%EF%BC%89%2F</url>
    <content type="text"></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity脚本程序开发（2）]]></title>
    <url>%2F2019%2F04%2F22%2FUnity%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本章涵盖： 预制体（prefab）资源的应用 常用输入对象 与销毁相关的方法 思考并回答以下问题：1.鼠标有几个输入来源？如何得到？2.键盘这么多的按键怎么得到？3.如何得到不同的操作状态，比如按下，按住，抬起？ 预制体（prefab）资源的应用在一个项目的开发过程中经常会应用到预制件（prefab）资源。在场景的开发中会同时创建多个完全相同的游戏对象，如果一一创建会耗费大量的时间，并且也会耗费游戏资源，在管理上也会有一定的难度。这时就需要实例化预制件（prefab）来实现。 预制件（prefab）资源的创建在Assets菜单Create命令的选项中选择创建perfab，就会在资源项目列表中创建一个预制件（perfab）资源。此时的预制件（perfab）只是一个空壳，还需添加一些具体的游戏对象，具体操作步骤如下。 (1)通过菜单创建一个prefab。执行“Assets-&gt;Create-&gt;Prefab”命令，即可在项目资源列表中创建一个prefab，然后将其名字改为“BallPrefab”。 (2)在场景中创建一个球体并改名为“Ball”。 (3)向项目中导入一个球面纹理图片资源。执行“Assets-&gt;Import New Asset…”命令，会立刻弹出一个Import New Assets对话框，在对话框中选中需要的球面纹理图片，单击“Import”按钮完成导入。 (4)为创建的Ball添加刚体属性和球体碰撞者属性，即先选中Ball，再执行“Component-&gt;Physics-&gt;Rigidbody”命令，即可为Ball添加刚体属性，再执行“Component-&gt;Physics-&gt;Sphere Collider”命令，即可为Ball添加球体碰撞属性。 (5)将导入的球面纹理图片资源添加到创建的Ball上面。选中纹理图片然后将其拖动到创建的Ball上面即可，添加的各个属性都将在属性查看器中显示出来。 (6)为刚创建的BallPrefab添加真实的游戏对象。这个操作跟5中一样，只要选中刚刚创建的Ball对象，然后将其拖到Assets面板中已经创建好的BallPrefab上即可，此时这个空的BallPrefab就具有了与Ball对象完全相同的属性。 通过prefab资源进而实例化对象在实际的开发过程中，若要创建大量的重复化的资源，就需要使用到prefab资源。通过脚本编写程序实例化这些游戏对象，这样可以省去创建过程的时间，以及为各个游戏对象添加相同属性的烦琐操作，并且还会节省大量的游戏资源，提高项目的运行效率。 下面将通过一个实例化篮球的小案例来讲解prefab实例化的具体操作过程。 1.以上面的BallPrefab为例，在此有关prefab的具体创建过程就不再进行讲解。 2.编写脚本，实例化篮球。在项目中创建一个“BallPrefabScript”脚本。 12345678910111213141516171819202122232425262728293031using UnityEngine;using System.Collections;public class BallPrefabScript : MonoBehaviour &#123; public int i = 5; // 声明整型变量i public int j = 0; // 声明整型变量j public Rigidbody BallPrefab; // 声明刚体BallPrefab public float x = 0.0f; // 初始化x,y,z的坐标 public float y = 4.0f; public float z = 0.0f; public float k = 2.0f; public int n = 4; // 声明实例化球的行数 int count = 0; // 声明一个计数器 public Rigidbody[] BP; // 声明刚体数组 void Start() &#123; Bp = new Rigidbody[10]; // 初始化刚体数组 count = 0; // 计数器置0 for (i = 0; i &lt;= n; i++) // 对变量i进行循环 &#123; for (j = 0; j &lt; i; j++) // 对变量j进行循环 &#123; // 在自定义坐标位置实例化10球 BP[count++] = (Rigidbody)Instantiate(BallPrefab, new Vector3 (x-2.0f*k*i + 4.0f*j*k, 2.0f, z-2.0f*1.75f*k*i), BallPrefab.rotation); &#125; &#125; &#125; &#125; 首先声明变量，主要声明了整型变量i、j，刚体BallPrefab, x、y、z的坐标，刚体的行数及计数器，并且对相关的参数进行了赋值。在开发环境下的属性查看器中可以为各个参数指定资源或者取值。 对Start方法进行了重写，初始化了刚体数组，然后先对i进行循环，再在i的循环中将j进行循环，最后在自定义坐标位置通过实例化刚体数组创建了10个球体，并且对10个球的位置按照一定的规律进行了排列。 3.将编写完的脚本挂载到摄像机上，然后对摄像机脚本属性中的各个变量参数进行设置。设置完毕后运行，在游戏场景中会显示出实例化的效果。本案例中创建了10个BallPefab。 常用的输入对象在游戏的开发过程中，时常需要获取用户的输入情况，类似于手机或平板中的触控行为，计算机端的键盘鼠标操作行为等，在其他的开发平台中，要获取这些操控参数往往需要通过开发人员编写不少代码来实现，而Unity 3D引擎在设计时就封装好了这些常用的方法与参数。 针对用户的输入，引擎专门为开发人员提供了两个输入对象--Touch与Input。开发人员通过Touch与Input输入对象中的方法以及参数可以非常方便地获取用户输入的各种参数，包括触控的位置、相位、手指按下位移，以及用户鼠标键盘的输入等。 Touch输入对象Touch输入对象中提供了非常详细的参数以及方法，通过使用该对象可以获取如Android、IOS等移动平台中的详细的触摸操控信息，读者可以将分析Touch的代码写在对应的脚本中，然后挂载到对应的游戏对象上，就可以轻松地获取到Touch的信息了。Touch事件变量如下表所示。 变量名 含义 fingerID 手指的索引 position 手指的位置 deltaPosition 距离上次改变的距离增量 deltaTime 自上次改变的时间增量 tapCount 点击次数 phase 触摸相位 Touch触摸输入对象的各个参数在开发的过程中一般都是相互配合使用的，只有这样才能符合开发的需要。 1.首先新建一个场景并将其命名为“TouchTest”，创建一个小球并赋予其纹理图。调整小球的大小与位置以及摄像机的位置，如下图所示。 2.新建一个名为“TouchTest.cs”的C#脚本，将其挂载到主摄像机MainCamera上。脚本代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using UnityEngine;using System.Collections;public class TouchTest : MonoBehaviour &#123; public GameObject ball; // Sphere游戏对象的引用 private float lastDis = 0; // 上一次两个手指的距离 private float cameraDis = -20; // 摄像机距离球的距离 public float ScaleDump = 0.1f; // 缩放阻尼 void Update() &#123; if (Input.touchCount == 1) // 触控 &#123; Touch t = Input.GetTouch(0); // 获取触控 if (t.phase == TouchPhase.Moved) // 手指移动中 &#123; ball.transform.Rotate(Vector3.right, Input.GetAxis("Mouse Y"), Space.World); // 竖直旋转 ball.transform.Rotate(Vector3.up, -1 * Input.GetAxis("Mouse X"), Space.World);// 水平旋转 &#125; &#125; else if (Input.touchCount &gt; 1) &#123; Touch t1 = Input.GetTouch(0); // 获取触控 Touch t2 = Input.GetTouch(1); // 获取触控 if (t2.phase == TouchPhase.Began) // 开始触摸 &#123; lastDis = Vector2.Distance(t1.position, t2.position); // 初始化lastDis &#125; elseif (t1.phase == TouchPhase.Moved &amp;&amp; t2.phase == TouchPhase.Moved) // 两个手指都在移动 &#123; float dis = Vector2.Distance(t1.position, t2.position); // 计算手指位置 if (Mathf.Abs(dis -lastDis) &gt; 1) &#123; // 若是手指距离&gt;1 cameraDis += (dis - lastDis) * ScaleDump; // 设置摄像机到物体的距离 cameraDis = Mathf.Clamp(cameraDis, -40, -5); // 限制摄像机到物体的距离 lastDis = dis; // 备份本次触摸结果 &#125; &#125; &#125; &#125; void LateUpdate() &#123; this.transform.position = new Vector3(0, 0, cameraDis); // 调整摄像机的位置 &#125; void OnGUI() &#123; // 打印信息与退出按钮 string s = string.Format("Input.touchCount=&#123;0&#125;\ncameraDIS=\n&#123;1&#125;",Input.touchCount, cameraDis); // 打印字符 GUI.TextArea(new Rect (0, 0, Screen.width / 10, Screen.height), s); // 用Text控件显示字符串 if (GUI.Button(new Rect (Screen.width *9/10, 0, Screen.width / 10, Screen.height / 10), "quit")) // 退出按钮 &#123; Debug.Log("quit"); // 打印点击信息 Application.Quit(); // 退出程序 &#125; &#125; &#125; 首先引用命名空间以及声明变量。在声明变量的部分中声明了场景中的Sphere游戏对象的引用Ball，方便下面对其进行旋转等变换；同时还声明了一些数据全局变量。 在Update方法中对单指操控行为进行解析。当发生触控并且用户的手指在移动状态，就可以通过Input.GetAxis(“Mouse X/Y”)获取用户的手指位移，然后将其转换为旋转角对ball进行旋转。运行时就可以看到，当用户滑动手指时，场景中的小球根据滑动方向进行旋转。 接着解析用户多点操控的行为，当手指数目大于1时，计算两个手指间的距离，并与上一次计算出的距离进行比较，若是距离变大就将摄像机向近推产生放大的效果，反之摄像机向后推就可以得到缩小的效果。这里还对摄像机的位置进行了限制，使其不能无限放大或者缩小。最后备份下这一帧中手指间的距离用于下一帧中和新的距离进行比较。 对LateUpdate方法进行重写，这个方法在Update方法回调完后进行回调。在这部分中根据上一步算出来的cameraDis对摄像机进行前推或者后拉，产生放大或者缩小的效果。 OnGUI函数与触控的检测没有什么关系，主要是使用Text控件对触控的信息进行打印，使其在真机上也可以看到，方便学习与调试，最后还设置了一个退出按钮，单击该按钮后程序结束运行。 使用了Input.GetAxis(“Mouse X/Y”)来获取用户手指的位移而没有使用Touch.deltaPosition，这是因为手机屏幕的不同Touch.deltaPosition的返回值是不同的，所以使用起来比较不方便；而Input.GetAxis(“Mouse X/Y”)也可以实现相应的效果，并且在iOS平台中也可以使用该方法。具体使用哪个，读者可以根据开发需要自行选择。 (3)将案例导入手机中运行，就可以看到小球根据玩家的手指滑动或两指放大收缩而发生旋转或缩放了。需要注意的是，与Touch有关的项目都需要在真机上进行测试。 Input输入对象如果说Touch输入对象可以用于获取用户的触摸操作信息，那么Input对象就可以获取用户其他所有行为的输入，如鼠标、键盘、加速度、陀螺仪、按钮等，所以掌握Input输入对象就可以在外部输入信息和系统之间架立一座桥梁，因此显得其尤为重要。Input对象的主要变量如下表所示。 Input对象的主要变量 变量名 含义 mousePosition 当前鼠标的像素坐标 anyKeyDown 用户点击任何键或鼠标按钮，第一帧返回true acceleration 加速度传感器的值 anyKey 当前是否有按键按住，若有返回true inputString 返回键盘输入的字符串 touches 返回当前所有触摸（Touch）列表 1.mousePosition变量 变量mousePosition是一个三维的坐标，用于获取当前鼠标的像素坐标。像素坐标是以屏幕左下角为（0,0），屏幕右上角坐标为（Screen.width, Screen.height）计算的。 1234567void Update()&#123; if(Input.GetButtonDown("Fire1")) // 鼠标左键点下 &#123; Debug.Log(Input.mousePosition); // 打印鼠标位置 &#125;&#125; 2.anyKey变量与anyKeyDown变量 变量anyKey用于显示当前是否有任何按键按下，若是有，就始终返回True。将下面的代码添加到脚本中，将脚本挂载到摄像机上，当按下任何按键时就会不停地显示打印信息。 12345678void Update()&#123; if(Input.anyKey) // 有按钮按下 &#123; // 打印信息 Debug.Log("A key or mouse click has been detected"); &#125;&#125; 变量anyKeyDown和变量anyKey有些许差别，前者只有按下按钮后的第一帧返回True。将上面的代码片段稍做修改后运行场景即可发现，只要有按钮按下，就会打印一次信息；若是按钮持续处于按下状态，也仅仅打印第一次。 12345678void Update()&#123; if (Input.anyKeyDown) // 按钮按下 &#123; // 打印信息 Debug.Log("A key or mouse click has been detected"); &#125; &#125; 3.inputString变量 变量inputString返回键盘在这一帧中输入的字符串。注意，在返回的字符串中只包含ASCII码中的字符，若是本次没有输入字符串就会返回一个空串，如下面的代码片段所示。 1234567void Update()&#123; if (Input.inputString != "") // 若当前输入字符串不为空 &#123; Debug.Log(Input.inputString); // 打印输入字符串 &#125;&#125; 4.acceleration变量 变量acceleration可以获取设备在当前三维空间中的线性加速度，常见于3D游戏中的重力感应操控模式。当用户倾斜设备时，若设备上有加速度传感器，就会回传一个代表设备倾斜加速度的三维向量，使用Input.acceleration变量就可以获取该参数。具体实现代码如下。 1234567891011121314151617181920using UnityEngine;using System.Collections;public class example : MonoBehaviour&#123; public float speed = 10.0f; // 移动速度 void Update() &#123; Vector3 dir = Vector3.zero; // 新建一个三维向量 dir.x = -Input.acceleration.y; // 获取重力感应y轴参数 dir.z = Input.acceleration.x; // 获取重力感应x轴参数 if (dir.sgrMagnitude &gt;1) // 若是获取的三维向量不是标准向量 dir.Normalize(); // 规格化向量 dir *= Time.deltaTime; // 将方向向量转换为速度 transform.Translate(dir * speed); // 平移物体 &#125;&#125; 将该脚本挂载在一个游戏对象上，导入支持重力传感器的设备中运行后就可以看到，游戏对象会根据用户倾斜手机的方向进行相应方向的移动。当然，这段代码需要设备支持重力感应，否则就会一直返回Vector3.Zero。 5.touches变量 上一节中介绍过Touch输入对象，与之相对应地，通过Input.touches变量可以获取到当前在屏幕上的所有触控的引用（Touch[]类型），开发人员就可以根据索引轻易地获取各个触控点的信息，所以该变量也会经常被使用到。 1234567891011121314151617void Update()&#123; int fingerCount = 0; // 手指数目计数器 foreach (Touch touch in Input.touches) // 遍历每个触控点 &#123; if (touch.phase != TouchPhase. Ended &amp;&amp; touch.phase != TouchPhase.Canceled) // 当前触控点不是结束状态且当前触控不是取消状态 &#123; fingerCount++; // 触摸计数器自加 &#125; if (fingerCount &gt; 0) // 有触摸 &#123; // 打印信息 print("User has " + fingerCount + "finger(s) touching the screen"); &#125; &#125;&#125; 该代码片段的作用为，每当触控发生时就通过Input.touches获取到每个触控的引用，然后遍历触控列表。若触控的相位不是结束状态或取消状态，就将手指数目计数器fingerCount加1，最后打印出当前在屏幕上的有效触控手指的数目。 Input输入对象中不仅包括了丰富的变量，而且还提供了大量的实用方法。下面将对Input输入对象中封装好的常用方法进行进行详细的介绍。 Input输入对象中的主要方法 方法名 含义 GetAxis 返回被表示的虚拟轴的值 GetButton 若虚拟按钮被按下返同true GetButtonUp 虚拟按钮抬起的一帧返回true GetKeyDown 按下指定按钮的一帧返回true GetMouseButton 指定的鼠标按键按下时返回true GetMouseButtontUp 指定鼠标按键抬起的一帧返回true GetAxisRaw 返回没有经过平滑处理的虚拟轴的值 GetButtonDown 虚拟按钮被按下的一帧返回true GetKey 按下指定按钮时返回true GetKeyUp 抬起指定按钮的一帧返回true GetMouseButtonDown 指定的鼠标按键按下的一帧返回true GetTouch 根据索引返回当前触控（Touch类型） 6.GetAxis方法和GetAxisRaw方法 GetAxis方法和GetAxisRaw方法都是获取虚拟轴的值的方法。在游戏的开发过程中，经常会在屏幕中添加一些2D的虚拟轴，可以通过触控或者鼠标事件改变虚拟轴的值来控制场景中的游戏对象。具体使用方法如下面的代码片段所示。 1234567891011121314using UnityEngine;using System.Collections;public class InputTest : MonoBehaviour &#123; private float speed = 0.1f; // 移动速度 void Update() &#123; float moveX = Input.GetAxis("Horizontal"); // 获取水平轴的值 float moveY = Input.GetAxis("Vertical"); // 获取垂直轴的值 this.transform.Translate(new Vector3(moveX, moveY, 0) *speed); //移动物体 &#125;&#125; 将上面的脚本挂载到场景中的游戏对象上，使用键盘的方向键就可以控制游戏对象的移动了。这时若是把moveX的值打印出来就会发现，当按下方向键时，其值是从-1~ 1之间平滑过渡的。接下来运行下面的代码片段。 12345void Update()&#123; float moveX = Input.GetAxisRaw("Horizontal"); // 获取水平轴的值 Debug.Log(moveX);&#125; 这段代码使用了GetAxisRaw方法，运行后按下方向键就会观察到moveX的值只会有-1、0、1三种变化，没有中间的过渡值。这是因为GetAxisRaw方法没有使用平滑滤波器。在需要自定义差值的情况下可以使用GetAxisRaw方法。 7.GetButton方法、GetButtonDown方法与GetButtonUp方法 这3种方法用于监听虚拟按钮的按下状态，包括按钮按下时、按钮按下中、按钮抬起时3个状态。开发人员需要在Update方法中回调这些方法来判断按钮的状态。其中的区别可以参看下面的功能代码片段。 1234567891011121314151617181920212223using UnityEngine;using System.Collections;public class InputTest : MonoBehaviour&#123; void Update() &#123; if (Input.GetButton("Fire1")) // 使用GetButton监听“Fire1”按键 &#123; Debug.Log("Fire GetButton"); &#125; if(Input.GetButtonDown("Fire1")) // 使用GetButtonDown监听“Fire1”按键 &#123; Debug.Log("Fire GetButtonDown"); &#125; if (Input.GetButtonUp("Fire1")) // 使用GetButtonUp监听“Fire1”按键 &#123; Debug.Log("Fire GetButtonUp"); &#125; &#125;&#125; 将上述脚本挂载到主摄像机上，按住鼠标左键不放，就会发现第6行的打印始终在被回调，而第8行的打印代码仅在按下时回调了两次。当松开鼠标左键时，才会发现第12行代码被回调。通过这个简单的脚本，读者应该已经可以区分这3种方法的区别了。 8.GetKey方法、GetKeyDown方法与GetKeyUp方法 这3种方法用于监听键盘上的按键的状态，开发人员需要在Update方法中调用这些方法，并传入想要监听的键名或键码。每个按钮的状态也分为按下、抬起、按住3种，使用者可以根据需要进行选用，使用方法如下面的代码片段所示。 1234567891011121314151617181920212223using UnityEngine;using System.Collections;public class InputTest : MonoBehaviour&#123; void Update() &#123; if (Input.Getkey("up")) // 使用GetKey监听“↑”按键 &#123; Debug.Log("up arrow Getkey"); &#125; if (Input.GetKeyDown(KeyCode.UpArrow)) // 使用GetKeyDown监听“↑”按键 &#123; Debug.Log("up arrow GetKeyDown"); &#125; if (Input.GetKeyUp(KeyCode.UpArrow)) // 使用GetKeyUp监听“↑”按键 &#123; Debug.Log("up arrow GetKeyUp"); &#125; &#125; &#125; 第5行和第8行分别使用了键名和键码两种方式来监听方向上键，其效果是相同的。将上面的脚本挂载到摄像机上运行场景，点击“方向上键”就会看到相应的打印信息，可见GetKey是按住时始终回调的，GetKeyDown和GetKeyUp分别只有按下和抬起时的一帧调用。 9.GetMouseButton方法、GetMouseButtonDown方法和GetMouseButtonUp方法 当开发计算机端的游戏时，肯定需要监听鼠标的操控。Input输入对象中包含了GeMouseButton、GetMouseButtonbDown和GetMouseButtonUp三种方法，用它们来监听鼠标按键。在使用时只要在Update方法中传入鼠标按键的索引，就可以对鼠标进行监听了。与前面介绍的方法类似，这3种方法也分别监听了鼠标按键的3个状态。使用方法见如下代码。 1234567891011121314151617void Update()&#123; if (Input.GetMouseButton(0)) // GetMouseButton监听鼠标左键 &#123; Debug.Log("left mouseButton GetMouseButton"); // 打印信息 &#125; if (Input.GetMouseButtonDown(0)) // GetMouseButtonDown监听鼠标左键 &#123; Debug.Log("left mouseButton GetMouseButtonDown"); // 打印信息 &#125; if (Input.GetMouseButtonUp(0)) // GetMouseButtonUp监听鼠标左键 &#123; Debug.Log("left mouseButton GetMouseButtonUp"); // 打印信息 &#125;&#125; 这三种方法的参数是一个int类型的索引。常用的鼠标按键索引为0，1，2，分别监听了鼠标的左键、右键、中键。需要使用的时候传入相应的索引就可以监听对应的按键了。 10.GetTouch方法 前面已经介绍过了Touch输入对象，使用其参数时需要获取一个Touch类型的变量。Input.GetTouch方法就是用于获取Touch输入对象的引用，在使用时应传入一个索引值代表要获取的触控索引，使用方式见如下代码片段。 1234567void Update()&#123; if (Input.touchCount != 0) // 当前发生触控 &#123; Vector3 touchPOS = Input.GetTouch(0).position; // 记录下触控点的位置 &#125;&#125; 上面的代码片段获取了发生触控时的首个触控点，并将其位置记录了下来。注意这个方法只有在支持触摸的移动设备上运行才会生效。 与销毁相关的方法在游戏的开发过程中，经常会遇到对象、组件、资源等在使用完毕后就失去了作用的情况，放任其不管的话轻则影响项目运行效率，重则可能影响到项目的正常运行。所以必须有一类方法来管理（删除）这些没有用的资源。在本节中将要介绍Unity中的各类删除方法。 Unity中有很多Destroy方法，不同功能的Destroy方法用于销毁不同类型的资源，下面将主要讲解常用的各个类型的Destroy方法的区别以及使用，不同功能的Destroy方法如下表所示。 函数 功能 Object.Destroy 删除游戏对象、组件或资源 NetWork.Destroy 销毁网络对象 MonoBehavior.OnDestroy 脚本被销毁时间 Object.Destroy方法Object.Destroy方法可以将对象立即销毁，也可以设置时间后销毁。如果删除的对象是一个组件，则该组件会被移除。下面将通过一个具体的代码片段来说明Object.Destroy的使用方式。 12345void Start()&#123; Destroy(ball.GetComponent&lt;Rigidbody&gt;()); Destroy(ball, 5);&#125; 在这个代码片段中，ball是场景中的一个挂有Rigidbody组件的游戏对象。在Start方法中，首先删除掉ball上挂载的刚体组件，然后在5s后删除ball游戏对象。 NetWork.Destroy方法NetWork.Destroy方法可以销毁网络对象，该方法包含了如下两种重载方式。 12static function Destroy(viewID : NetworkViewID) : voidstatic function Destroy(gameObject : GameObject) : void 当使用第一种方法重载方式时，需要给出网络对象的viewID，然后系统会删除所有和该viewID相关的物体。需要注意的是，本地的和远端的物体都会被销毁。使用方法见如下代码片段。 1234567891011121314151617181920212223using UnityEngine;using System.Collections;public class example : MonoBehaviour&#123; //通过网络销毁拥有该脚本的物体，必须具备Networkview离性 public float timer= 0; void Awake () &#123; timer = Time.time; &#125; // 计时器 // 记录下开始时间 void Update() &#123; if (Time.time-timer&gt;2) // 2s后 &#123; Network.Destroy(GetComponent&lt;NetworkView&gt;().viewID) ; // 删除具有NetworkView的物体 &#125; &#125;&#125; NetWork.Destroy方法还可以使用第二种重载方式来销毁网络上的游戏对象，下面将用一段代码片段来说明。 1234567891011121314151617181920using UnityEngine;using System.Collections;public class example : MonoBehaviour&#123; public float timer = 0; // 声明计时器 void Awake() &#123; timer = Time.time; // 记录下开始时间 void Update() &#123; if (Time.time - timer &gt;2) // 2s后 &#123; Network.Destroy(gameObject); // 删除gameObject &#125; &#125; &#125;&#125; 这段代码的主要功能就是自脚本唤醒后2s删除游戏对象“gameObject”，其中Time.time代表游戏开始后的真实时间。 MonoBehaviour.OnDestroy方法MonoBehaviour.OnDestroy方法是MonoBehaviour中的销毁回调方法。类似于脚本中常见的Update()、Start()方法，该方法也由系统自动回调，这个方法的回调条件是当该脚本被移除时系统回调。具体实现方法如下面代码片段所示。 123456789101112131415using UnityEngine;using System.Collections;public class DestroyTest : MonoBehaviour&#123; void Start() &#123; Destroy(this.GetComponent&lt;DestroyTest&gt;(), 5); // 移除该脚本 &#125; void OnDestroy() &#123; Debug.Log("this script has been destroy"); //移除该脚本时回调 &#125;&#125; 将该脚本挂载到摄像机上后运行场景，在这段代码中首先在第5行指定5s后从摄像机上删除这个脚本，所以等到5后删除脚本时就会看到第8行的打印，这是因为OnDestroy()方法在移除该脚本时被自动回调了。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity游戏开发技术详解与典型案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光照与着色器]]></title>
    <url>%2F2019%2F04%2F21%2F%E5%85%89%E7%85%A7%E4%B8%8E%E7%9D%80%E8%89%B2%E5%99%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.材质有哪两部分构成？2.什么是着色器？3.Unity中有几种着色器？各自有什么特点？ 本章将介绍光照与材质，它们是除纹理之外决定游戏外观效果的首要因素。具体来说，我们将深入介绍Standard着色器，它简化了创建美观材质的过程。另外还将介绍如何编写自己的着色器，从而在很大程度上自己控制对象在游戏中的显示效果。最后讨论如何使用全局光照和光照贴图，通过在场景中对光线传播进行真实建模，创建看起来很棒的环境。 材质与着色器在Unity中，对象的外观由其附加的材质所定义。材质由两个元素构成：着色器，以及着色器使用的数据。 着色器是在显卡上运行的一个非常小的程序。你在屏幕上看到的每个东西，都是着色器为每个像素计算出正确的颜色值后的显示结果。 Unity中主要有两种不同类型的着色器，即表面着色器和顶点-片段着色器。 表面着色器负责计算对象表面的颜色。表面的颜色由多个组件定义，包括其反射率、平滑性等。表面着色器的工作是为对象的每个像素计算这些属性的值，然后表面信息被返回到Unity，Unity把表面信息与场景中每个灯光的信息结合起来，决定像素的最终光照颜色。 顶点-片段着色器则简单得多。这种着色器负责计算像素的最终颜色，那么需要你自己计算。顶点-片段着色器提供了低级控制，意味着它们能够实现出色的效果。因为这种着色器一般更加简单，所以相比于表面着色器，速度通常也更快。 实际上，Unity会把表面着色器编译为顶点-片段着色器。它替你完成了困难的工作，实现必要的光照计算来得到真实的光照效果。表面着色器能实现的任何效果，在顶点-片段着色器中也能实现，只不过需要更多的工作。 除非有特殊的用例需要，否则表面着色器一般是最好的选择。 Unity还提供了第三种类型的着色器，称为固定功能着色器。固定功能着色器将预定义操作组合到一起，而不是让你编写自定义着色器。在自定义着色器得到广泛应用之前，固定功能着色器是主要采用的着色器；它们比自定义着色器更加简单，但是效果则不如自定义着色器。 我们首先创建一个自定义表面着色器，它与标准着色器很相似，但是添加了显示边缘高光（即高光显示对象边缘）的能力。下图显示了这种效果的一个例子。 使用自定义着色器的边缘高光 创建该效果需要执行下面的步骤。（1）创建一个新项目。按照自己的想法任意命名此项目，然后选择3D模式。（2）选择Create-&gt;Shader-&gt;Surface Shader，创建一个新着色器。将新着色器命名为SimpleSurfaceShader。（3）双击该着色器。（4）替换为下面的代码： 12]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity移动游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何不痛苦地早起跑步？每天5点多起床的我，有一点小小的经验]]></title>
    <url>%2F2019%2F04%2F18%2F%E5%A6%82%E4%BD%95%E4%B8%8D%E7%97%9B%E8%8B%A6%E5%9C%B0%E6%97%A9%E8%B5%B7%E8%B7%91%E6%AD%A5%EF%BC%9F%E6%AF%8F%E5%A4%A95%E7%82%B9%E5%A4%9A%E8%B5%B7%E5%BA%8A%E7%9A%84%E6%88%91%EF%BC%8C%E6%9C%89%E4%B8%80%E7%82%B9%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[来源：如何不痛苦地早起跑步？每天5点多起床的我，有一点小小的经验-陈章鱼-跑步学院 01 春困秋乏夏打盹，睡不醒的冬仨月。 于是很多人越睡越晚，生生把自己的作息调成了土耳其时间。 你心里又有一个声音告诉自己，这样实在是不对，应该改，应该早睡早起。可是坚持了两天，发现这个事情太难了，干脆放弃。 我从今年下半年开始，训练自己早睡早起的习惯，目前基本上可以固定在晚上十点半睡，早上五点半起，已经成功坚持了四五个月。 我想聊一点自己的经验。关键是，我是一个懒人，是一个非常没有毅力的人，所以我的经验，完全是自己如何「勾引」自己的经验。相信会对你有帮助。 02 早睡早起这件事情，基本上就是生理的调整和心理的调整。 生理的调整，其实相对简单。 早起必然就想早睡，不然就困，早睡多半也会早起，因为我们睡眠的时间基本是固定的。 所以在生理上，早睡早起是可以形成一个正向循环的，关键就在于要打破现在的一个模式。一旦开始，早睡和早起就会相互促进。 怎么打破呢？两种方法，一种就是晚上硬睡，一种就是早上硬起。 这里边比较简单的，是早上硬起。最好的办法，就是一定要选一个非常非常贱的闹钟。目前手机有很多这样的 APP，必须答对数学题才能关闹钟的，必须在指定地点照照片才能关闹钟的，必须扫一个二维码才能关闹钟的。 我现在就是在厨房的冰箱那里贴了一个二维码，每天我要走到那，扫一下，我的闹钟才不会再响。刚开始的几天，肯定会有些痛苦，白天困得不行，只要经过了这段时间，也就不会难受了。 03 心理的调整，会更难一些。上边的方法，其实只能保证早睡早「醒」，还不能保证早睡早起。 晚上拖着不睡，是因为你可以开心愉快地玩耍，早上拖着不起，是因为你会感觉起来就要面对一大堆焦头烂额的事情。 怎么克服这个心结呢？我的经验是，早起千万不要干正经事。 什么是正经事？读书、背单词、跑步…… 因为我们平时就没有读书、背单词、跑步的习惯，所以其实我们在同时培养两个习惯，一个叫早起，一个叫跑步。这就是双倍的痛苦和阻力了。 那么早起了干点啥呢？打游戏、刷美剧、逛淘宝、看综艺、上微博、刷朋友圈。 前一天晚上你拖着不想睡的时候，就问自己，如果我十点不睡，十二点半再睡，那么这两个半小时我要干点啥？多半就是打游戏、刷美剧、逛淘宝、看综艺、上微博、刷朋友圈。把这些活动记下来，挪到早上早起之后这段时间。 这套方法的关键，就是把晚睡对你的诱惑，变成早起对你的诱惑。 04 你可能会问，这样玩物丧志的早起有意义吗？ 有意义。 首先，早起就是意义。无论是对我们的身体，还是对我们的心态，都有很积极的影响。 其次，当你养成早起的习惯后，你就可以培养自己做更有意义的事情。 比如当你真正培养早起的习惯后，你可以早起跑步，早起背单词，早起看书。我想说的是，对于一直晚睡的我们，对于平时可能还没有养成锻炼、背单词习惯的我们，可以分两步走，先培养早起的习惯，再培养其他习惯，没有必要一定要把多个习惯捆绑在一起。 换句话说，如果能一下培养两个习惯，那么你也不会现在关注这个问题了。你就开开心心早起跑步去了。 所以，先培养早起的习惯，当这个习惯固定下来，再考虑慢慢地将早上的时间分配给你觉得更有意义的事情。这样一个软过渡，会更容易接受。 慢一点、分阶段的自律，总比干脆放弃要好得多，不是吗？ 05 最后一点建议，是培养习惯的时候，要给自己留一点弹性空间。 比如，培养习惯要设一个期限，21 天也好，33 天也好，90 天也好，这样，你能看见你的「进度条」，就更容易坚持。 「永远」是个很要命的词，再好的事情，如果前边冠上「永远」二字，人都会有些疙瘩。如果没有期限，那对于你来说，就是要永远早起，这件事就会让人很想放弃。 你可能会问，过了 21 天，我会不会又回到原先的习惯？根本不用这样的担心，因为你完全可以再开 21 天啊。 除此之外，你还可以有更多的方式鼓励自己。比如每天在朋友圈打卡，自己知道自己在坚持是一回事，用另一种方式「看到」自己在坚持，是会给自己更多动力的。 另外，平时逛淘宝，想给自己买的东西，挑一件自己最想要的，作为坚持一个早期周期的礼物。这样也会更有动力。 06 最后说点题外话。 你看这些方法，可能会觉得很多都像是「歪招」，哄着自己、骗着自己、吓着自己、逗着自己，感觉和我们想象中的样子不是很一样。而这，恰恰就是慢慢认识自己的过程。 一件事情「应该」怎么做成，和一件事情「实际」怎么才能做成，这中间常常是有区别的。 形而上地说呢，是要区分这个世界的「应然」和「实然」。 问题的关键，在于到底哪个对你更有意义，是真正养成一个好习惯更有意义？还是保持一种幻想更有意义？ 想清楚这个问题，你才会找到更好的方法。 哪怕是哄着自己、骗着自己、吓着自己、逗着自己。]]></content>
      <categories>
        <category>运动</category>
      </categories>
      <tags>
        <tag>早起</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity脚本语言开发基础（1）]]></title>
    <url>%2F2019%2F04%2F16%2FUnity%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.值类型和引用类型的区别是什么？各自有哪些类型？2.C#变量的赋值方式有两种，分别是什么样子的？3.几种修饰符的作用范围？4.怎么创建数组？给数组赋值？读取数组的值？ C#脚本语法变量C#是一种强类型语言，在使用任意一个对象前，必须声明这个对象的类型，如整数型、浮点型、字符串类型等。 C#的类型分为两大类：值类型和引用类型。两者的主要区别是值在内存中的存储方式不同。值类型的实例通常是在线程的堆栈上分配的，引用类型的对象则是在托管堆上分配的。 值类型包括内置类型（用关键字int、float、bool、string等声明）。 引用类型包括类（用关键字class声明）和委托（用关键字delegate声明）。 在Unity中，定义C#变量的格式如下：数据类型 变量名称例如，下面定义一个整数变量intNum。 1int intNum; 我们可以通过对变量赋值来对其初始化，赋值的方式是使用“=”赋值运算符给变量赋值，赋值的格式有两种，一种为： 12int intNum;intNum = 5; 另一种是以字面形式初始化，形式如下: 1int intNum = 5; 在C#声明变量之前还可以添加访问修饰符：private，（默认修饰符）只能在本类中访问；protected，只能由类或派生类中访问；internal，只能在本项目中访问。 但是如果想让脚本中定义的变量在Unity的Inspector视图中显示，则必须用public修饰。 数组数组是具有相同类型的一组数据，如一个班级、一副麻将、一副扑克牌等都可以看成一个数组。数组就是同一数据类型的组值。在C#中只能使用内建数组，如下所示。 12345678910111213141516using UnityEngine;using System.Collections;public class ArraySample : MonoBehaviour&#123; private int[] array = new int[5]; void Start() &#123; for (int i=0; i&lt;array.Length;i++) &#123; array[i] = i; print_r(i); &#125; &#125;&#125; 把脚本添加到Unity中，得到运行结果，如下图所示。 语句for比while可以更好的控制循环次数。 函数Unity脚本一些常用的内置运行函数。 Awake:在游戏运行时调用,用于初始化;Start:只在游戏开始时执行一次,在Awake0函数后执行:Updates在游戏每一帧都执行一次,在Start函数后执行;LateUpdate:同Update,只是它会在Update()函数执行后再执行:FixedUpdate: 当游戏中引入刚体系统,并使用适配的方式同步物理时钟时,可以让动力学更精确地计算:OnGUI:绘制游戏界面的函数,因为每一帧执行多次,所以一些时间相关的函数要尽量避免直接在其内部使用;OnMouseOver:鼠标光标停留在物体上时执行该函数的内容;DnMouseEnter:鼠标光标进入物体范围时执行该函数的内容.和OnMouseOver不同,该函数只执行一次:OnMouseExit:鼠标光标离开物体范围时执行该函数的内容;nMouseDown:鼠标键按下时执行该函数的内容;OnMouselp:鼠标键释放时执行该函数的内容;OnMouseDrag:按住鼠标键拖动时执行该函数的内容。关函数。OnMouse系列函数是针对指定物体的,如果要使用全局鼠标控制操作,则需要使用射线相 C#脚本在Unity中使用C#脚本时需要注意以下几点。1.所有的行为脚本必须从monobehaviour继承（直接的或间接的）。在Javascript中，这个是自动完成的，但是在C#中，必须显式注明。如果你通过Asset-&gt;Create-&gt;C Sharp Script创建脚本，系统模板已经包含了必要的定义。 123public class newbehaviourscript : monobehaviour &#123;&#125; 2.使用Awake或Start函数初始化. Awake和Start函数的不同之处在于, Awake函数是在加戟场景时运行, Start函数是在第一次调用Update或Fixedupdate函数之前被调用, Awake函数运行在所有的Start函数之前, 3.类名字必须匹配文件名. 4.协同函数(Coroutines)返回类型必须是1Enumerator,并且用yield returm替代yield. 5.不要使用命名空间,目前Unity暂不支持命名空间. 6.只有序列化的成员变量才能显示在检视面板中,私有和保护变量只能在专家模式中显示,属性不被序列化或显示在检视面板中。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X 完全自学手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚本调试优化与内存管理]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%84%9A%E6%9C%AC%E8%B0%83%E8%AF%95%E4%BC%98%E5%8C%96%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X 完全自学手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物理引擎（2）]]></title>
    <url>%2F2019%2F04%2F13%2F%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本章涵盖 布料 力场 拓展训练 布料World Acceleration Scale布样是Unity中的一种特殊组件，它可以随意变化成任意形状，例如桌布、旅帜、窗帘等。布料系统包括交互布料与蒙皮布料两种形式。 Unity中的布料系统为游戏开发者提供了强大的可模拟类似布料行为状态的交互功能。在Unity 5.x中，布料系统为游戏开发者提供了一个更快、多线程、更稳定的角色布料的解决方法。当进行新布料原件的添加时，不再对任何刚体做出反应。 属性力场在Unity中，若需要为刚体快速地添加恒定的作用力，则需要为其添加力场组件。 力场组件属性设置 英文 中文 详解 Force 力 此选项参数用于设置在世界坐标中所使用的力度值 Relative Force 相对力 此选项用于设置在物体自身局部坐标中所使用的力度值 Torque 扭矩 此选项参数用于设置在世界坐标中所使用的扭短力度值 Relative Toroue 相对扭矩 此选项参数用于设置在自身局部坐标中所使用的扭短力度值]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X 完全自学手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[塔防类游戏设计]]></title>
    <url>%2F2019%2F04%2F12%2F%E5%A1%94%E9%98%B2%E7%B1%BB%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.塔防类游戏的三个元素是什么？ 本章涵盖： 塔防类游戏设计说明 游戏环境设定 游戏开始界面UGUI的制作 游戏开始界面脚本设计 游戏场景设计 主角动作脚本设计 子弹脚本设定 NPC怪物诞生脚本设计 NPC怪物动作脚本设计 角色血量脚本设计 角色得分及过关脚本设计 游戏界面制作 游戏结束及暂停界面制作 游戏发布测试 通常意义上讲，塔防类游戏是指一类在地图上建造地台或者类似建筑物来阻止敌人进攻的策略类游戏。从这个概念中，我们可以快速地抽离出三个元素，即地图（场景）、敌人、炮台（防守单位）。当抽离出这三个元素后，塔防类游戏就变成了这样的一种描述，即敌人按照地图中设计的路径进攻，玩家利用防守单位进行防守的一类策略类游戏。 经典的塔防类游戏有哪些呢？比如我们最为熟悉的《植物大战僵尸》、《保卫萝卜》等都是塔防类游戏的经典游戏。下面我们将尝试制作并讲解一个简单的塔防类游戏。 塔防类游戏设计说明1.游戏玩法： 点击屏幕，控制子弹的方向 击倒所有的怪物，取得游戏胜利。 2.游戏架构，如下图所示。 游戏环境设定启动Unity，打开Tower Defens Game工程项目，如下图所示。 游戏开始界面UGUI的制作新建一个游戏场景Menu，将场景存储在Game Scene文件夹内 单击File菜单中的Build Settings选项来设定PC玩家模式，单击Player Setting选项，在Inspector面板设置游戏的分辨率为800*480，如图16-3和图164所示。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X 完全自学手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物理引擎（1）]]></title>
    <url>%2F2019%2F04%2F12%2F%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本章涵盖： 刚体 碰撞体 角色控制器 Unity软件中强大的物理引擎通过为刚性物体赋予真实物理属性的方法来计算刚性物体的运动、旋转、碰撞、跌落等反应。在游戏制作过程中，并不需要为每一个游戏对象都添加物理引擎，例如可以通过脚本编写的方式为游戏对象赋予加速或减速的属性。当然，当在处理较为复杂的游戏对象的物体碰撞、物体滚动以及物体弹跳的时候，不建议通过编程的方式进行实现。 刚体Unity中的Rigidbody刚体组件可为游戏对象赋予物理属性，使游戏对象在物理系统的控制下接受推力与扭力，从而如在现实世界中进行运动。只有为游戏对象添加了刚体组件，其才能受到重力的影响。通过脚本为游戏对象添加作用力以及通过NVIDIA物理引擎与其他的游戏对象发生互动的运算也是较为可行和有效的为游戏对象添加物理属性的方式，但其也需要为游戏对象添加刚体组件。 刚体的基本使用方法Unity中的Rigidbody刚体组件为游戏开发者提供如在现实世界中物体受到力的作用的逼真效果。当一个游戏对象被赋予刚体组件后，游戏引擎会对其进行物理效果模拟。 ** Rigidbody刚体组件使用注意事项 ** (1)Parenting：父子级关系 当为一个游戏对象赋予物理属性，受物理系统控制时，其刚体的运动会随着游戏对象所属的父对象的运动而运动。值得注意的是，虽然游戏对象刚体的运动是跟随父级对象的运动，但其依然会受重力作用的影响而下落。 (2)Animation：动画 当将刚体标记为动力学模式的时候，具有刚体组件的游戏对象就不会受到物理效果的影响，此时便需要对此游戏对象的Transform组件属性进行直接操作。可见，动力学刚体会影响其他的游戏对象，但其自身并不受到物理系统的影响。 (3)Script：脚本 若利用脚本的方式来为游戏对象添加作用力或扭矩力，则需要在游戏对象的刚体上添加AddForce()和AddToraue()函数。 刚体选项设置 刚体组件Inspector属性面板参数与选项设置功能介绍 英文 中文 含义 Mass 质量 设置游戏对象的质量大小 Drag 阻力 设置游戏对象在运动时受到空气阻力的大小。数值0表示无空气阻力，阻力越大游戏对象运动越慢，阻力极大时游戏对象则会停止运动 Angular Drag 角阻力 设置游戏对象受到扭矩力时受到的空气阻力的大小。数值0表示无空气阻力，阻力越大游戏对象运动越慢。阻力极大时游戏对象则会停止运动 Use Giavity 使用重力 此项开启则表示游戏对象会受到重力的影响 Is Kinematic 是否开启动力学 开启动力学后，游戏对象将只能通过Transform属性对其进行控制，且不再受物理系统的影响 Interpolate 插值 此选项用于控制刚体运动的抖动情况，共包括三个子选项：1.None：无差值；2.Interpolate：内插值，表示将基于上一帧的Transform来平滑此次的Transform；3.Extrapolate：外插值，表示将基于下一帧的Transform来平滑此次的Transform； Collision Delection 碰撞检测 用于避免较高运动速度的游戏对象无法与其他游戏对象发生碰撞，共包括三个子选项：1.Discrete：离散碰撞检测。此选项为被选中的游戏对象与场景中其他所有的碰撞体进行碰撞检测；2.Continuous：连续碰撞检测。该选项用于检测被选中游戏对象与动态碰撞体的碰撞，使用连续碰撞检测模式来检测与网络碰撞体的碰撑；3.Continuots Dynamic：连续动态碰撞检测。此选项用于检测连续碰撞模式或是连续动态碰撞模式对象的检测 Constraints 约束 此选项用于约束刚体的运动，共包括两个子选项：1.Freeze Position：冻结位置；2.Freeze Rotation：冻结旋转 碰撞体在游戏制作的过程中，游戏对象要根据游戏的需要进行物理属性的交互。为此，Unity的物理组件为游戏开发者提供了碰撞体组件。碰撞体是物理组件的一类，它与刚体一起，促使碰撞的发生。 使用碰撞体在Unity的物理组件的使用过程中，碰撞体需要与刚体一起添加到游戏对象上才能触发碰撞。因此，在游戏制作的过程中，没有添加刚体组件的碰撞体会相互穿过。 为游戏对象添加碰撞体后，其使用需要注意以下两点: (1)碰撞体与刚体 游戏对象物理效果的产生，是碰撞体与刚体共同作用的结果。值得注意的是，刚体一定要绑定在一个被碰撞到的对象上才能够产生碰撞效果，而碰撞体则不需要一定绑定刚体。（球碰到墙，墙绑定刚体，球不是必须绑定刚体） (2)物理材质 Unity中内置了多种物理材质供游戏开发者进行选择，如下图所示，物理材质的参数设置如下表所示。 碰撞体组件Inspector属性面板参数与选项设置功能介绍 英文 中文 功能详解 Dynamic Friction 动态摩擦力 此数值为游戏对象在处于运动状态时的摩擦力数值 Static Friction 静态摩擦力 此数值为游戏对象被放置于某一表面时的静态摩擦力 Bounciness 反弹 此选项用于设置游戏对象的反弹幅度 Friction Combine 摩擦力组合 此选项用于设置游戏对象的摩擦力组合方式，共包括四个子选项：1.Average：使用摩擦力平均值；2.Min：使用较小摩擦力值；3.Max：使用较大摩擦力值；4.Maliply：使用摩擦力相乘的值 Bounce Combine 反弹组合 此选项用于设置游戏对象反弹组合方式 Friction Direction 2 摩擦力方向 此参数为向异性的摩擦力方向 Dynamic Friction 2 动态摩擦力2 若向异性的摩擦力被激活，则动态摩擦将沿着摩擦力方向而启用 Static Friction 2 静态摩擦力2 若向异性的摩擦力被激活，则静态摩擦将沿着摩擦力方向而启用 碰撞体选项设置Unity为游戏开发者提供了多种类型的碰撞体资源。 (1)Box Collider：盒碰撞体，如下图所示，具体内容的参数设置如下表所示。 角色控制器在Unity中，游戏开发者可以通过角色控制器来控制角色的移动。角色控制器允许游戏开发者在受制于碰撞的情况下能很容易进行运动，而不用处理刚体。角色控制器不会受到力的影响，仅仅当游戏制作者调用Move的函数语言时才会进行运动。在游戏制作的过程中，游戏开发者通常在人物模型上添加这个组件后，就可以进行模型的模拟运动了。 英文 中文 详解 Slope Limit 坡度限制 被控制的角色对象只能爬上小于或等于该参数所设置的值 Step Offset 台阶高度 设置所控制的角色对象可以迈上的最高台阶的高度值 Skin Width 皮肤厚度 决定两个碰撞体碰撞后所相互渗入的程度值，较小的游戏对象将会被卡住。而较大的游戏对象则会产生不同程度的抖动现象 Min Move Distance 最小移动距离 设置角色对象所移动的最小值，若角色对象移动的距离小于此数值，则游戏对象将不会移动 Center 中心 设置胶囊碰撞体在世界坐标中的位置 Radius 半径 设置胶囊碰撞体的长度半径 Height 高度 设置胶囊碰撞体的高度]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X 完全自学手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光照-2]]></title>
    <url>%2F2019%2F04%2F11%2F%E5%85%89%E7%85%A7-2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.光照来源有几种？分别是什么意思？2.预计算阶段是什么意思？3.GI是什么意思？选择Bake后有几种模式？4.Reflection Probe是什么？使用步骤是什么？5.烘焙模式下移动物体没有直射光和间接光，如何处理？ 本章涵盖： GI 反射环境 光照探针 GI(Global Illumination)光照按光的来源可分为两种：直接光照（Direct Lighting）和间接光照（Indirect Lighting）。从光源直接发出的光称为直接光照，物体表面在接受光照后反射出的光称为间接光照。 GI介绍在Unity 5.0以前，Unity的光照系统只能将光照信息（包括间接光照）通过烘焙的方式储存在Lightmap即光照贴图中，而无法实时处理间接光照。而Unity 5.0之后的版本使用了Enlighten光照系统。该系统提供了最先进的动态光照解决方案，能实时计算间接光照。这种能计算间接光照的光照系统，就是GI系统，即全局光照系统。 Unity所使用的Enlighten光照系统是唯一被证明能提供实时GI的光照系统，并且支持移动平台。GI有实时、烘焙以及混合这几种模式，切换也非常简单，直接设置光的Mode属性，在Realtime（实时），Baked（烘焙）和Mixed（混合）3种模式之间切换即可。 Realtime：实时模式。在编译前有一个预计算阶段，主要收集场景几何信息等信息。在实时渲染阶段，会根据预计算阶段收集的信息进行直接光照和间接光照的计算。 Baked：烘焙模式。将静态光照和动态光照等信息烘焙至Lightmap光照贴图中。 Mixed：实时模式与烘焙模式的混合。 GI使用点击导航菜单-&gt;Window-&gt;Lighting，进入光照界面，如图1所示。Environment Light栏是环境光和天空盒的设置。 图1：Lighting设置 Precomputed是预计算阶段的GI设置。一般来说，Realtime Resolution分辨率设置低的值以便快速更新，填1也就是一米一像素够了。 Baked GI是烘焙阶段的GI设置。 GI分为两种模式：迭代式和快照式。 迭代式（Iterative）：当勾选图1中右下角的Continuous Baking时为迭代式， Editor监测任何场景改变并立刻开始更新对应烘焙信息或者动态光照的预计算信息并自动烘焙数据。 快照式（Snapshot）：当不勾选图1中右下角的Continuous Baking时为快照式，当点击Build按钮后进行GI计算，其他时候不进行任何GI计算。每一次点击Build后的光照信息都会作为快照被储存起来。 在Scene窗口的Shaded页签下有多种观察模式，如图2所示，我们可以选择Global Illumination下的各个模式，以可视化的形式观察场景GI的状态。 图2：Shaded模式 反射环境在3D开发中，需要模拟很多现实中的效果。例如一颗钢珠会将四周的画面反射，如图3所示。在Unity中，可以通过设置材质的属性来实现。 图3：反射环境 反射天空盒实现起来非常简单。新建一个场景，然后创建一个Sphere球体，新建材质并赋予球体，画面如图4所示。 接下来只需要设置材质的两个参数即可反射天空盒，将材质的Metallic设置为1，也就是金属属性为最大，将Smoothness设置为1，最平滑，画面如图5所示。 图4：Metallic为0 图5：Metallic为1 反射天空盒及场景但是仅仅反射天空盒是不够的，像赛车游戏中赛车的玻璃和车身，如果能反映周围的环境，就会大大提高游戏的画面表现力。这一切都可以借助Reflection Probe反射探针来实现。 创建一个新场景，加入地形和树木。点击导航菜单栏-&gt;GamgObject-&gt;Light-&gt;Reflection Probe，创建反射探针，如图6所示。 图6：反射探针 探针像摄像机一样拍摄周围的画面，不同的是，探针拍摄的是四周所有角度的画面，然后将画面存在一张Cube Map中，如图7所示。我们可以在场景里创建多个这样的反射探针，当物体需要反映场景时，取最近的数个反射探针，并将它们的Cube Map混合显示。图6所示的立方体线框所示区域，为反射探针的作用区域，超过此区域的物体不能获取此探针。 图7：Cube Map Cube Map 这里我们创建一个胶囊体，新建一个材质并赋予胶囊体，将材质的Metallic设置为1，将Smoothness设置为1，再将胶囊体Mesh Renderer组件的Reflection Probes属性设置为Blend Probes And SkyBox，画面如图8所示。 胶囊体反射天空盒及场景的画面 下面我们再来详细看看Reflection Probe的属性。首先是类型，如表1所示。 表1：Reflection Probe的类型 类型 说明 Baked 根据标记为ReflectionProbeStatic的对象生成静态的CubeMap。烘焙只在Editor中进行，也就是动态物体不会被反射探针探测到 Custom 为各个反射探针手动生成Cube Map。在手动点击Inspector界面下ReflectionProbe的Bake按钮时，指定Cube Map的保存路径并保存，也可以在Cubemap栏指定其他Cubemap Realtime 根据所有区域内静态及动态物体实时生成Cube Map，非常消耗效率 还有一些非常重要的参数，如表2所示。 表2：Reflection Probe的参数 属性 说明 Size 区域内的物体能够接收探针的Cube Map，在Scene窗口中以黄色线框显示 Intensity Cube Map应用于贴图的强度，默认值为1 Resolution 分辨率 HDR 是否开启HDR高动态范围模式 Box Projection 盒子投影，当反映的是近似立方体的环境（例如一个房间）时，开启盒子投影能得到正确的结果，效果如图9及图10所示（Shader model 3.0以上才支持） 图9：未开启Box Projection 图10：开启Box Projection 选中胶囊体，在Inspector界面中的Mesh Renderer栏下的Reflection Probes设置反射探针的混合类型，如表3所示。 表3：Reflection Probes的类型 类型 说明 off 不混合、仅仅反射天空盒 Simple 简单混合天空盒和最近的反射探针 Blend Probes 在附近的反射探针之间取插值。不包括天空盒，适用于室内物体 Blend Probes And Skybox 在附近的反射探针之间取插值并与天空盒混合。适用于室外对象，当位于探针区域内时取探针Cube Map，离开区域后切换到天空盒 光照探针首先介绍一组名词：在Inspector视图的右上角的Static下拉菜单中勾选Lightmap Static的物体，在光照方面我们称之为静态物体，不勾选的我们称之为动态物体。一般来说，对于静止不动的物体（如建筑物等），我们会勾选Lightmap Static，即设置其为静态物体，而将人物等移动的物体设置为动态物体。对于设置为实时的光源，静态物体的直接光照和间接光照以及动态物体的直接光照，光照系统都会处理，而动态物体的间接光照则需要光照探针（ Light Probe ）来辅助计算。对于设置为烘焙的光源，静态物体的直接光照和间接光照光照系统都会处理，而动态物体的直接光照以及间接光照都需要光照探针来辅助计算。 例如在场景1中，有一个聚光灯光源，为烘焙类型。地面为静态物体，中央摆放的立方体为动态物体。在烘焙后，地面作为静态物体参与直接光照和间接光照的计算，因此有光照效果；而立方体作为动态物体，它的直接光照以及间接光照都需要光照探针来辅助计算，而我们还没有设置光照探针，所以没有光照效果，如图11所示。 图11：场景1在烘焙后的效果 而光照探针组（Light Probe Group）可以帮助动态物体计算光照。大致原理是每个探针根据所处位置及周围环境计算该点的直接光照和间接光照并将信息储存起来。位于探针区域内的动态物体根据周围探针的光照信息综合计算得出光照信息并显示。 新建一个场景并命名为2，进行相似的场景布置。然后点击导航菜单栏-&gt;GameObject-&gt;Light-&gt;Light Probe Group，创建一个光照探针组。如图12所示，选中Light Probe Group对象，在Scene界面中显示的黄色圆球为一个个光照探针，可以对其进行拖曳等操作 图12：Scene界面中的光照探针组 在Inspector视图中，光照探针组界面有4个按钮辅助操作，如图13所示，按钮说明如表4所示。 图13：Inspector界面中的光照探针组 表4：光照探针组的按钮 按钮 说明 Add Probe 添加一个探针 Select All 选择所有探针 Delete Selected 删除已选探针 Duplicate Selected 复制已选探针 选取探针也非常简单，在Scene界面中点击黄色球体即可，按住Ctrl或者Shift键点击则是多选。新创建的探针组有默认的8个探针组成一个封闭的空间。通常我们创建均匀分布的探针，使探针组成为一个阵列。 设置好探针组，等烘焙完，中央的立方体就受到光照的影响而改变亮度了，如图14所示。 图14：设置探针组后的效果 小结本章首先介绍了光照的基本类型以及使用方法，接着介绍了阴影和渲染模式，然后介绍了5.0中最新的全域光照GI系统，最后讲解了如何使用反射探针反射环境和使用光照探针计算光照。 习题1.光源有哪几种类型？2.简述反射探针和光照探针各自的作用。3.创建并布置一个场景，加入光源并进行烘焙。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光照-1]]></title>
    <url>%2F2019%2F04%2F11%2F%E5%85%89%E7%85%A7-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.光的3个基本组成部分是哪些？2.光有几种渲染模式？区别在哪？3.提升阴影画面质量和性能有哪两种方法？4.Shadow Cascade是数量越低效果越好吗？在Scene怎么查看？3.Pixel Light Count是干嘛用的？ 本章涵盖： 光照基础 光的使用 阴影 渲染模式 光照基础光有3个基本组成部分：Intensity（强度）、Color（颜色）和Direction（方向）。 新建一个场景，选取Directional Light，属性如图1所示。我们可以直接设置Intensity和Color，而方向是由光照类型Type决定的。 图1：Inspector窗口中的Light Unity中一共有4种光照类型：点光源、聚光源、方向光和区域光。每种光的图标都不一样，如图2所示。 图2：每种光对应不同的图标 点光源点光源（Point Light）基于空间中的一点，均匀地向四面八方发送光。光照强度随着距离衰减，最小强度为0，如图3所示。 点光源经常用于模拟由灯泡发出的光、开枪的瞬间发出的火花，或者爆炸时的强光，效果如图4所示。 点光源 点光源的效果 聚光源聚光源（Spot Light）和点光源一样，也是从某一点发出光。不同的是，它是在一个角度范围内发出光，所以是一个圆锥形，想象一下手电筒的发光就很清楚了。它的方向是Z轴正向，主要用于表现手电筒和车灯等。 方向光方向光（Directional Light）并没有具体的光源位置，所以会对整个场景进行照射。它可以置于任意位置，也没有距离的概念，因为光的强度不会衰减。 方向光主要用来表现非常大的光源从场景模型空间投射过来，例如阳光或者月光。在抽象化的游戏中，也可以用来让物体受到光照，并产生阴影，从而增加画面感。 区域光区域光（Area Light）在空间中以一个矩形展现，如下图所示，光从矩形一侧照向另一侧会衰减。因为区域光非常占用CPU，所以是唯一必须提前烘焙的光源类型。 因为区域光从不同的角度照射物体，所以明暗变化更柔和，可以用来模拟街灯。 光的使用在Unity中，光的创建和使用都非常简单。 例如创建方向光，点击导航菜单栏-&gt;GameObjet-&gt;Light-&gt;Direcitonal Light。在Scene窗口中有一个太阳形状的按钮，默认是按下状态。当按下时，直接在Scene窗口中就能看到光照的效果。 方向光一般用来表现阳光，方向光稍微朝下并和场景模型最好有些角度。例如一个立方体，如果方向光垂直其一面照射，那么立体感不会太明显；如果斜着照射，那么立体感会强很多。 一般把点光源或者是聚光源置入场景时，可能会看不出效果，调整范围和角度以达到更好的效果。 阴影Unity中受到光源照射的物体会投射阴影（Shadow）到物体的其他部位或其他物体。 开启光的阴影选中Light，在Inspector窗口中，可以通过Shadow Type一栏设置阴影，有3个选项：No Shadows（无阴影），Hard Shadows（硬边缘阴影）和Soft Shadows（软边缘阴影）。 No Shadows不造成阴影。Hard Shadows产生边缘硬朗的阴影，甚至是锯齿，没有Soft Shadows效果好，但是运行效率要高，并且效果也是可以接受的。Strength决定了阴影暗的程度，通常光会被空气分散，并反射到其他物体，所以这个值一般不会设为最大值。Resolution分辨率是指Shadow Map的分辨率，如果想要比较清晰的阴影边缘的话，需要设置高分辨率。 每个Mesh Renderer都有两个参数。 Cast Shadows：是否投射阴影。 Receive Shadows：是否接受阴影。 一般这两个参数都是默认开启的，也就是所有创建的物体默认会投射阴影也会接受阴影，我们只要确保光的Shadow Type设置为Hard Shadows或者Soft Shadows，那么阴影功能就是开启的。 阴影技巧关于阴影，还有一些细节需要注意：方向光的阴影、阴影距离、阴影层以及支持阴影的设备。 ** 1.方向光的阴影 ** 方向光通常模拟阳光，一个光就照亮整个场景。它的Shadow Map需要覆盖大部分场景，因此在阴影细节上的分辨率不够，特别是距离摄像机很近的阴影，“被放大了”会出现马赛克的效果。如下图所示，距离摄像机远的球体阴影效果不错，但随着与摄像机距离的拉近，阴影被放大的效果越来越差。 未使用Shadow Cascade的效果 这个问题在使用Soft Shadow并将Shadow Map设置为高分辨率时不明显，但是这么设置的话，会消耗性能导致低帧率。 ** 2.阴影距离 ** 要提升阴影画面质量和性能，还有一个很重要的办法，就是把阴影距离（Shadow Distance）设置得尽量小。该值越小，需要绘制在Shadow Map的物体就越少。特别是在没有阴影级联的移动平台，设置较小的阴影距离是移动平台提高质量最有效的办法。 ** 3.阴影级联 ** 阴影级联（Shadow Cascade）是方向光独有的一个技术，移动平台不支持。在QualitySettings界面中有Shadow Cascade参数设置，有No Cascades（无阴影级联）、Two Cascades（2张阴影级联）、Four Cascades（4张阴影级联）3个选项。数量越高，方向光的阴影效果越好。使用4张Shadow Cascade的效果如下图所示。 点击Scene窗口的“Shaded”按钮，选择Shadow Cascades模式，可以以不同的颜色显示Cascades图，如下图所示。 渲染模式光有以下两种渲染模式。 Vertex Lighting：顶点光照，只计算模型顶点的光照，对于模型表面的其他地方通过插值运算取光照值，效率高，如下图所示。 图：顶点光照 Pixel Light：像素光照，每个像素点都单独计算，支持一些顶点光照不支持的技术如法线贴图、实时阴影等，如下图所示。 图：像素光照 因为像素光非常耗效率，所以Unity会将光源按照光照强度进行排序，只有强度最高的数量少于设定值的光按像素光照处理，剩余的按顶点光照处理。这个值在导航菜单栏-&gt;Edit-&gt;ProjectSettings-&gt;Quality中的Pixel Light Count设定，也可以通过Render Mode的Auto、Important和Not important去升高或降低优先级。 当设置Pixel Light Count为0时，即使是像素光也会被以顶点光照处理。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户界面-2]]></title>
    <url>%2F2019%2F04%2F10%2F%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2-2%2F</url>
    <content type="text"></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户界面-1]]></title>
    <url>%2F2019%2F04%2F10%2F%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2-1%2F</url>
    <content type="text"><![CDATA[本章将首先介绍精灵系统及图片导入，因为图片是UI的基本组成部分。接着将正式介绍UI系统，介绍将从Canvas画布开始，它是所有UI元素的承载体。之后将逐一介绍各个UI元素，如Text文本元素和Image图片元素，以及互动控制元素Button按钮和Slider滑动条等。 Sprite精灵Sprite精灵是UI以及Unity 2D的基本元素。在UI系统中，所有图片的显示都必须通过精灵。如果建立工程时选择的是2D工程，那么导入的所有图片会自动设置为精灵；而如果是3D，那么需要对图片的导入设置进行更改。 图片设置为精灵导入button图片，在Inspector窗口中将其“Texture Type”设置为“Sprite(2D and UI)”，并点击窗口右下角的Apply按钮，之后如下图所示。 精灵导入设置 参数 说明 Sprite Mode 精灵模式，有Single单图，Multiple多图两种模式 Packing Tag 打包标签，相同标签的精灵在打包时会被分为一组 Pixels To Units 像素至单位，多少像素对应一个单位 Pivot 轴心点 Generate Mip Maps 是否生成Mip Map Filter Mode 过滤模式，有Point（点过滤），Bilinear（两倍过滤），Tilinear（三倍过滤）3种 Max Size 最大尺寸，贴图的尺寸上限 Format 格式，有Compressed（压缩）， 16 bits（16位），Turecolor（真彩色）3种 图片切割为多个精灵当Sprite Mode为Single时，表明整张图片将作为一个精灵；当Sprite Mode为Multiple时，表明整张图片包含多个精灵。我们需要图片进行切割。 选中图片“atlas”，并设置为精灵。Sprite Mode设置为Multiple，接着点击下图中的“Sprite Edtior”按钮，打开Sprite Editor精灵编辑器，如下图所示。 接着点击左上角的“Slice”按钮，弹出如下图所示的切割设置窗口。一般来说，保留默认设置即可， Type为Automatic表明为自动切割。点击“Slice”按钮，完成切割。接者点击图片编辑对应的精灵，主要是命名，如下图所示。 完成所有精灵的命名后，点击“Apply”按钮，应用切割。在Inspector窗口中，选择对应的“atlas”图片，并点击图片左侧的三角形按钮展开，下图罗列了该图片切割出的精灵列表。 设置Border边界Border边界在之后如切片类型Image的UI元素中会用到。选中frame设置为单个精灵，点击“Sprite Editor”按钮打开精灵编辑器界面 1图9-4中的Sprite小窗口有Border边界一栏. L代表左边界，R代表右边界，T代表上边界，B代表下边界。我们可以直接在输入栏中填写正整数进行设置，也可以拖曳图片上的绿色小正方形设置对应的边界。这里将矩形框的所有边界设置为30，最后点击”Apply”按钮完成边界设置效果如图9-6所示。设置边界常用于底板、边框的制作。绝大部分底板边框都是矩形。当设置了所有边界后，俗称为九宫格（nine-sliced sprite）。 Pivot锚点Pivot锚点在精灵编辑器界面以蓝色实心圆钮表示，如下图中心的钮，锚点的选项如19-7所示。 Canvas画布Canvas画布是承载所有UI元素的区域。Canvas实际上是一个游戏对象上绑定了Canvas组件，所有UI元素都必须是Canvas的子对象。如果场景里没有画布，那么我们创建任何一个UI元素，都将自动创建画布并将新元素置于其下。 创建画布点击导航菜单栏&gt; “GameObject”&gt;”UI”&gt; “Canvas”导航栏，创建一个画布,如图9-8所示, Scene岗口中的白色矩形表示画布。 画布参数下面介绍一下Canvas画布的参数第一个参数RenderMode的渲染模式有3种：Screen Space-Overlay, Screen Space-Camera以及World Space.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能分析工具-Profiler-2]]></title>
    <url>%2F2019%2F04%2F10%2F%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-Profiler-2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是Drawcall合并？它有哪几种实现方式？ 本章涵盖 渲染优化 内存优化 渲染优化渲染主要和显卡上搭载GPU运算有关。如果在Profiler的CPU栏下显示Gfx.WaitForPresent，那么就表示GPU每帧渲染需要的时间过长，CPU需要等GPU。 渲染参数和渲染有关的最重要的几个参数可以在Game窗口下查看。在Game窗口中点击“Stats”按钮弹出面板，如下图所示。 其中，FPS和毫秒数代表的是在Unity编辑器下运行的效率，所以仅供参考，真正重要的是下列参数。 Tris：Trianglie，三角形的数量，渲染的基础指标。图中为17.1K，也就是当前画面一共渲染了约17100个三角形。 Verts：Vertices，模型顶点的数量，渲染的基础指标。图中为10.7K，也就是当前画面一共渲染了约10700个顶点。 SetPass calls：SetPass的调用次数。 Batches：合并后的Drawcall次数。 Saved by batching：被合并的Drawcall次数。 Shadow casters：阴影投射图的数量。 优化优化主要分为4个方面：模型优化、材质优化、光照优化和Draw Call合并。 1.模型优化 三角形和顶点数代表了基本场景的几何负担。在保证效果的情况下，它们当然是越少越好。主要是在3D建模工具中要将视角并不可见的面裁掉，如果是固定视角的场景则非常简单，将摄像机视角的反面删除即可；如果是自由视角，通常也存在死角，如房屋内部、地底等。 2.材质优化 材质方面首先使用尽量小的可以接受的贴图尺寸。在通过代码操作材质的时候，请尽量使用renderer.sharedMaterial或者renderer.sharedMaterials。而不要使用renderer.materia或者renderer.materials，因为对后两者的每一次改动都会创建一个新的材质。 这里首先介绍一个概念：像素填充率。像素填充率是指图形处理单元在每秒内所渲染的像素数量。当一个像素点渲染的是不透明材质，那么只有一次运算；而如果该像素点是由很多透明的物体像素点叠加显示的话，就是多次运算，会加大GPU的负担。 材质优化也包括Shader渲染器的选择。Shader渲染器本书并不涉及，这里主要说一下原则。 首先尽量少使用Standard Shader，因为它的参数比较多，运算相对也就比较多。 一般可以不接受光照的物体就用不参与光照的Shader。选中一个材质，在Inspector窗口的Shader栏展开下拉菜单，其中Unlit栏里的都是不参与光照的Shader。 对于不涉及颜色变化的物体，请尽量用没有颜色参数的Shader。 3.光照优化 请尽量使用烘焙，预先烘焙好场景的Lightmap。如果是移动平台开发，要控制光的数量以及谨慎使用产生实时阴影的光。 4.Draw Call合并 下面就重点介绍下Draw Call合并。首先，我们介绍下Draw Call的概念。 Unity（或者说基本上所有的图形引擎）生成一帧画面的处理过程大致可以这样简化描述：引肇首先经过简单的可见性测试，确定摄像机可以看到的物体，然后把这些物体的顶点（包括本地位置、法线、 UV等）、索引（顶点如何组成三角形）、变换（就是物体的位置、旋转、缩放以及摄像机位置等），相关光源、纹理、渲染方式（由材质/Shader决定）等数据准备好，然后通知图形API--或者就简单地看作是通知GPU--开始绘制，GPU基于这些数据经过一系列运算在屏幕上画出成千上万的三角形，最终构成一幅图像。 在Uniy中，每次引擎准备数据并通知GPU的过程称为一次Draw Call，这一过程是逐个物体进行的。对于每个物体，不只GPU的渲染，引擎重新设置材质/Shader也是一项非常耗时的操作。因此，每帧的Draw Call次数是一项非常重要的性能指标。Unity内置了Draw Call合并技术，顾名思义，它的主要目标就是在一次Draw Call中批量处理多个物体。只要物体的变换和材质相同，GPU就可以按完全相同的方式进行处理，即可以把它们放在一个Draw Call中。Draw Call Baching（即Draw Call合并技术）的核心就是在可见性测试之后检查所有要绘制物体的材质，把相同材质的分为一组（一个Batch ），然后把它们组合成一个物体（统一变换），这样就可以在一个Draw Call中处理多个物体了（实际上是组合后的一个物体）。 因此，Draw Call优化合并（即Draw Call Batching）通过减少每帧的Draw Call数降低显卡计算从而提高性能。 在Unity中，渲染模型有两种方式：Skinned Mesh Renderer和Mesh Filter加Mesh Renderer。Skinned Mesh Renderer渲染带有骨骼动画的模型，而Mesh Filter加Mesh Renderer渲染没有骨格动画的模型。Draw Call合并只针对Mesh Filter加Mesh Renderer，也就是Skinned Mesh Renderer渲染带有骨骼动画的模型是没有Draw Call合并的。 Draw Call合并分为Dynamic Batching动态合并和Static Batching静态合并两种。 ** 动态合并** 动态合并不需要任何操作。游戏运行时，所有使用相同材质的游戏对象，无论是否使用相同的网格模型都可被合并。被合并的对象依然可以自由移动旋转，但有以下使用要求。 模型文件共计点数不超过900（重复使用同一个Mesh不计）。 单个物体可以不超过300点，Shader可以有法线UV，但如果Shader使用了UV0 UV1两套UV吗，或者使用了Tangent切线的话，单个物体只能不超过180点。 游戏对象使用相同模型和材质时，只有相同缩放（即xyz等比缩放，浮点尾数可以有细微差）的会被合并。比如：(1,1,1)与(1,1,1)、(2,2,2)与(2,2,2)、(0.5,0.5,0.5)与(0.5,0.5,0.5)、(2,2,2)与(2,2,2.0001) 场景烘焙：烘焙后同材质将不会被烘焙。lightmap有隐藏的材质参数：offset/scale，所以使用lightmap的物体不会被合并。 Shader不能使用多Pass：多Pass的Shader会破坏Dynamic Batching。 静态合并 静态合并的原理是在运行游戏后将一组游戏对象的多个网格模型合并为1个网格模型。使用同一材质的游戏对象都在一个DrawCall中完成，这些游戏对象运行后无法移动缩放旋转。但是Drawcall一定是最大化合并的，并且不受动态合并的诸多限制。 注意在游戏运行时，静态合并会动态创建合并后的网格模型，因此过多的静态合并会增加内存占用。例如，场景里的树群就不适合静态合并，而适合动态合并。 静态合并的实现方法有以下两种。 MeshRenderer勾选Batching Static。 代码中使用UnityEngine.StaticBatchingUtility实现（可以在任何平台调用），方法是创建一个空的游戏对象作为根对象，将所有要合并的静态物体（不需勾选Batching Static）置于其下，然后使用StaticBatchingUtility.Combine(root);。 以上两种实现方式的区别是勾选Batching Static属于完全自动合并，在MeshFilter里显示的是Combined Mesh(root:scene)，合并后不能移动；而代码调用StaticBatchingUtility合并到一个游戏对象下，合并后可以移动父节点游戏对象。 内存优化介绍了CPU优化和谊染优化后，接下来我们介绍内存优化。内存优化一般来说主要从以下两方面人手：降低资源大小、及时释放不用资源。 降低资源大小要降低资源大小，首先需要分析哪些资源占用较大的比重。在Build后，打开Console界面点击界面右上角的下拉菜单&gt;Open Editor Log打开Editor日志，其中有在整个包中按大小排序的资源列表，它显示了资源的大小以及在安装包中所占的比例。一般来说，一个3D游戏项目中贴图及UI资源图至少古用50%以上的容量，其次可能就是模型资源、音频资源等。这些资源首先尽量选择合适的压缩格式，并在可接受的范围内适当降低品质，例如一个按钮框素材如果使用1024x 1024的尺寸就明显是浪费了，使用256x256的尺寸是更好的选择。而且，一定要慎用全屏背景图，这类图每张都会占用非常大的空间。在设计UI时，多考虑UI的复用性，多使用九宫格都是很有帮助的。 释放内存中的资源及时释放内存中的资源也是内存优化中非常重要的环节。我们有AssetBundle.Unload、Resource.unload、 GC.Collect等方法可用。 其他优化经验 设置目标帧率。 通过Application.targetFrameRate设定FPS上限，好处是稳定帧率，减少在高帧率和低帧率间切换造成的不流畅感。这也会减少设备发热和耗电。移动设备上推荐设置为30。 音频格式 在游戏中播放时间较长的音乐（如背景音乐）时，建议音频使用OGG或者MP3压缩格式；短促音效（如枪声、按钮点击音效等）建议采用WAV或者AlF未压缩格式 摄像机 摄像机将远平面设置成合适的距离。远平面过大会将一些不必要的物体加入渲染，降低效率。 碰撞 尽量使用立方体或者圆柱体等基本碰撞体。对于复杂的网格模型，请尽量不要使用MeshCollider，而选用基本的立方体或者圆柱体等去拼近似形状。 习题1.简述什么是预定义标签以及它可以用于哪些地方？2.什么是Drawcall合并？它有哪几种实现方式？3.使用Profiler分析Unity示例工程AngryBots运行时的性能。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能分析工具-Profiler-1]]></title>
    <url>%2F2019%2F04%2F10%2F%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-Profiler-1%2F</url>
    <content type="text"><![CDATA[Profiler是Unity中一个辅助优化游戏性能的工具，它在游戏运行时实时详细报告游戏各个部分每帧所耗费的时间。例如，图像渲染部分、动画系统或者脚本各耗费多少时间。 在运行场景或者使用设备运行游戏的时候打开Profiler，它会记录并以时间轴为基础显示数据，让你可以知道哪些帧或者功能部分消耗较多的时间。 Profiler会检测代码，这会对性能造成定影响。一般来说，重点关注时间消耗最多的那些帧里消耗最多的部分。 Profiler界面点击导航菜单栏-&gt;Window-&gt;Profiler打开Profiler界面，再打开并运行场景，Profiler窗口如下图所示。本章将图中黑色部分（即以时间为横轴的性能数据）统称为波形图。 功能被分为如下5个部分检测：中央处理器使用率（CPU Usage）、渲染（Rendering）、内存（Memory ）、音频（Audio）、物理（Physics），具体功能分析如下表所示。 中央处理器使用率部分主要分析游戏运行时每帧游戏各个部分所消耗的CPU时间。波形图分为7个子项并以不同颜色显示。 渲染部分的波形图不再是表示每帧消耗的时间，而是表示渲染的性能指标。波形图分为4个子项并以不同颜色显示。 内存部分主要分析游戏运行时每帧游戏各部分所占用的内存大小。波形图分为7个子项并以不同颜色显示。 音频部分主要分析游戏运行时每帧的音频性能指标。波形图分为4个子项并以不同颜色显示。 物理部分主要分析游戏运行时每帧的物理性能指标。波形图分为两个子项并以不同颜色显示。 所有栏中的波形图都是在最右侧绘制最新的时间占用并向左移动。当前选中的CPU Usage栏，我们可以在这里看到有16ms（60FPS）、10ms（100FPS）、5ms（200FPS）3条横向基准线，它们代表的意思是当波形刚好位于基准线上的数值。5ms代表的是这一帧的CPUi计算占用了5ms的时间，1s等于1000ms，1000除以5等于200，也就是括号内的200FPS即帧的刷新率是200帧/秒。 Overview中显示的是脚本各占用了多少时间。 请将鼠标光标移动到CPU波形图的任意一点并单击鼠标左键，此时出现一条竖线，旁边伴以数据显示该帧的性能情况，参见下图。 连接设备我们已经知道了性能分析的方法，游戏运行的性能分析还是要在具体设备上进行才有实际参考意义。下面就以安卓设备运行游戏并通过Profiler检测为例。 首先打开Build Settings窗口，勾选Development Build，再勾选Autoconnected Profiler，然后点击Build，将打出的apk文件安装至设备，运行设备，并确保设备和电脑处于同一网络环境下（连的是一个Wi-Fi）。 在手机上查看Wi-Fi得到IP地址，然后在Profiler窗口中点击Active Profile按钮，在下拉菜单中点击Enter Player IP按钮，并输入IP地址，点击Connect连接，如下图所示。 连接成功后就正常显示数据了。 CPU优化下面我们就来具体介绍下优化经验，并首先看看CPU优化。CPU优化主要关注那些卡的帧，也就是CPU耗时特别长的帧。原因各种各样，这里主要介绍一下各种情况，以便在开发过程中避免。 控制台日志与预定义标签首先新建一个场景和一个空的游戏对象，然后新建一个脚本，命名为CodeExample.cs，并添加至游戏对象上。 12345678910111213141516using UnityEngine;using System.Collections;using System.Collections.Generic;public class CodeExample : MonoBehaviour&#123; public List&lt;string&gt; playerNames; void Update() &#123; for (int i = 0; i &lt; playerNames.Count; i++) &#123; Debug.Log("player:" + playerNames[i]); &#125; &#125;&#125; 输出控制台日志，这可以很方便地调试。但是实际情况呢？我们在Inspector视图中将PlayerNames的Size设置为100，并填入各种名字，当然留空也可以，如下图所示。接着，打开Profiler视图并运行场景，数据如图所示。 LogStringToConsole就是对应Debug.Log控制台日志的CPU情况。可以看到，该项每帧的CPU占用时间达到了517ms，也就是仅FPS 1.9!正常的游戏起码要达到FPS 20，本例是远远低于该数值的，原因如下。 Unity中控制台日志是非常占用CPU的，无论是Debug.Log()还是print()，而且生成的应用安装包在运行时依然会输出日志。故在正式发布的时候，请一定不能包含控制台日志。 Update()每帧都会运行，能不放在Update()中运行的逻辑尽量不要放在Update()中。 预定义标签预定义标签Script Define Symbols，编译器会在编译的时候根据预定义标签去生成对应的二进制编码。 点击导航菜单栏&gt;Edit&gt;Project Settings&gt;Player，在Inspector窗口中打开的Player Settings界面的Script Define Symbols栏，在其中输入Test并回车，如下图所示。 然后修改代码。 1234567891011121314151617using UnityEngine;using System.Collections;using System.Collections.Generic;public class CodeExample : MonoBehaviour&#123; public List&lt;string&gt; playerNames; #if Test void Update() &#123; for (int i = 0; i &lt; playerNames.Count; i++) &#123; Debug.Log("player:" + playerNames[i]); &#125; &#125; #endif&#125; 其中, #if Test和#endif的意思是，当有预定义标签的时候才会运行标签中的代码，而如果在Player中将这个预定义标签去掉，那么标签中的代码在编辑器里为灰色，也不会被编译执行。我们可以将测试代码用预定义标签包裹，在测试的时候保留Player Settings里的预定义标签，在发包的时候去掉，所以合理的代码如代码清单14-3所示: 以下是一些注意事项。 尽量少用Cameobject.Find()搜索函数，因为这些方法效率比较低。相反，你应直接定义公共变量，如果目标是场景中的非动态创建对象，直接在Inspector视图中指定；如果是动态创建的对象，创建的时候就直接保存。 尽量少用SendMessage()函数，因为这些方法效率比较低。相反，你应直接调用方法，或者使用C#的委托代理delegate或System.Action。 尽最少用粒子系统，或者使粒子系统的粒子数献尽可能少，或者用帧序列动画代替。因为粒子系统中粒子运动的计算对CPU是不小的负担。 尽量将资源读取或者释放放在展示Loading画面的时候去做，或者将大的资源拆成小的模块分批加载，外放CPU对硬盘的读写运算,降低峰值。 尽量降低场景里的模型面数和点数,因为CPU需要对其进行运算再传递给GPU,]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识和编辑器]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本章涵盖 基础知识 编辑器 基础知识跨平台要想真正用好Unity的跨平台功能，有很多东西要处理。比如代码用宏定义标签来区分，不同的游戏平台执行不同的代码逻辑；再如区分好游戏资源，性能好的设备下载优质的资源，性能差的设备下载普通的资源等。 管理好自己的项目是一等一的大事。以移动平台为例，开发之前第一件事就要先和美工确定资源的格式，比如图片大小、模型面数、骨骼数量、粒子发射器、粒子数量、UI图集大小，等等。 工程设置下面进行工程设置，点击导航菜单栏&gt;Edit&gt;Project Settings&gt;Player，在Inpector视图中显示Player设置界面，如下图所示。 基本栏的参数主要是设置公司名称（ Company Name），产品名称（Product Name）和图标 Default ICon） Resolution and Presentation栏的主要作用是设置游戏在屏幕显示的朝向。 Default Orientation为默认朝向，有多种选择：Auto Rotation自动旋转，Portrait!向( Home键位于底部)， Portrait Upside Down竖向倒置(Home键位于顶部)， Landscape Rightt横屏(Home键位于左侧)， Landscape Left （Home键位于右侧），如果Default Orienation设置为Auto Rotation，该参数下方会有额外的参数需要设置。Status Bar Hidden用于设置是否隐藏设备状态栏。 Icon栏可以为当前平台详细设定各个分辨率的图标。 Splash Image是设置应用启动画面，只有专业版可以设置此项。 Other Settings是其他设置，PlayerSetings.bundleidentifier，用程序的Bundle Id。是设备识别应用的Id，一般格式是com.公司名应用名。PlayerSettings.bundleVersion，版本号，例如1.0.1.Minimum API Level.支持的最低安卓系统版本。 操作Find References In Scene:在Scene视图和Hierarchy视图中显示使用了选中资源的游戏对象。在Scene视图(见图2-12)中相关游戏对象正常显示,其余游戏对象显示呈灰色。在Hierarchy视图(见图2-13)中，只显示相关游戏对象 Select Dependencies：这里我们再点击导航菜单栏”GameObiecc” “3D Objec” “Sphere”创建一个球体作为对比。选择该资源所依赖的所有资源,例如之前创建的”CubeMat”材质依赖于”ConiferBark”贴图。所以选中”CubeMat”,点击鼠标右键,再点击”SelectDependencies”项,如图2-14所示,资源本身和所依赖的所有资源会以蓝色高亮显示。 口缩放工具:点击灰色立方体,然后移动鼠标,对游戏对象进行整体缩放 点击Scene规图左上角的”Shaded”按钮,如图2-24所示,进人Scene视图的渲染模式菜单。 下面就其中常用的两种模式进行讲解o :默认的模式,所有游戏对象的贴图都正常显示,如图2-25所示。コ Wireframe:所有游戏对象的贴图都不显示,仅仅将游戏对象的国格模型以线框形式呈现如图2-26所示。 要将游戏对象保存在工程中,在需要的时候创建出来,这就是预制体( prefab ),预制体储存着个游戏对象,包括游戏对象的所有组件以及其下的所有子游戏对象。 2,预制体的实例化将预制体复制一份放到场景里,我们称这个过程为实例化。在Project窗口中选中”MyCube’点击鼠标左键并拖曳到Inspector窗口中,可以直接实例化一个对象,或者点击鼠标左键并拖曳到Scene窗口下直接显示对象,将鼠标移动到合适的位置,松开鼠标左键完成实例化。预制体的实例化不是普通的复制,对场景中的普通对象进行简单的CrltC复制CtritV粘贴后相互之间不再有关系,其中一个对象的改变不会对另一个对象产生影响。但是预制体实例化后产生的新游戏对象依然保持着与预制体的关联( Hirarchy视图中呈现为蓝色),也就是对预制休进行添加组件、修改组件属性等改变。预制体实例化后的游戏对象都会发生相应的改变。 Mobile Input如果激话的话,运行场就时,可以用Unity Remote app远程移动终湖替代鼠标建a进行控制]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态对象-2]]></title>
    <url>%2F2019%2F04%2F09%2F%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1-2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.2.3.4. 本章涵盖 寻路网格 寻路网格寻路就是提供一个目标点，根据障碍物自动计算出一条最优的路径，Unity寻路使用的是A*算法。寻路可分为动态寻路以及静态寻路两种。动态寻路就是障碍物的位置可以动态修改，而静态寻路表示障碍物永远都不会发生改变。由此可见，静态寻路的效率会更高。 设置寻路参与寻路计算的游戏对象需要选中Navigation Static复选框，接着在导航菜单栏中选择Window-&gt;Navigation命令，打开寻路烘焙面板，如下图所示。这里还需要设置控制角色寻路的一些基本信息，其中Agent Radius表示角色胶囊体的半径，Agent Height表示胶囊体的高度，Max Slope表示爬坡的最高坡度，Step Height表示每次爬楼的高度。Generated Off Mesh Links用于设置角色落下或者跳起来没有在连接在一起的两个点的高度和距离，例如角色可以跳过一条水沟。最后，单击Bake按钮即可。 如下图所示，我们来做一个简单的寻路。点击地面，让“方块”越过障碍物自动走过去，点击屏幕时，需要使用射线计算出点在地面的位置，接着就可以控制“方块”寻路过去了。 如下代码所示，控制角色寻路时，需要调用navMeshAgent.SetDestination()来设置它的位移。 123456789101112131415161718192021222324using UnityEngine;using UnityEngine.AI;public class Script_09_06 :MonoBehaviour&#123; public NavMeshAgent navMeshAgent; public void Update() &#123; if(Input.GetMouseButton(0)) &#123; Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);; // 穿透所有Mesh直到找到地面 RaycastHit[] hits = Physics.RaycastAll (ray); foreach (var hit in hits) &#123; string name = hit.collider.gameObject.name; if (name == "Plane") &#123; // 移动方块 navMeshAgent.SetDestination (hit.point); &#125; &#125; &#125; &#125;&#125; 连接两点寻路必须保证两点是能走过去的，但有时候设计上不一定是走过去，例如跳过去、掉下去或空中飞过去等。寻路专门提供了一个OffMesh Link组件来处理两点之间的连接。如下图所示。 获取寻路路径有时候，需要在寻路之前判断一下目标点是否合法，或者寻路的路径是否合法，此时就要提前获取寻路的完整路径了，如下图所示。在代码中，我们可以使用NavMesh.CalculatePath()方法来提前计算出目标点的路径。如下代码所示，调用NavMesh.CalculatePath()方法提前计算寻路路径，接着通过Debug.DrawLine()方法将路径绘制在Scene中查看。 123456789101112131415161718192021222324using UnityEngine;using UnityEngine.AI;public class Script_09_08 :MonoBehaviour&#123; public NavMeshAgent navMeshAgent; public Transform target; private NavMeshPath m_Path = null; void Start() &#123; m_Path = new NavMeshPath (); // 计算路径 NavMesh.CalculatePath(transform.position, target.position, NavMesh.AllAreas, m_Path); &#125; void Update () &#123; // 绘制路径 for (int i = 0; i &lt; m_Path.corners.Length-1; i++) Debug.DrawLine(m_Path.corners[i], m_Path.corners[i+1], Color.red); &#125;&#125; 动态阻挡在Unity的寻路中，很多元素是需要支持动态阻拦的，例如一堵空气墙，玩家在经历某种特殊事件之前是不能走过去的。如下图所示，给需要动态阻挡的游戏对象添加Nav Mesh Obstacle组件。设置游戏对象的隐藏或显示，即可控制是否发生动态阻挡。 这里需要介绍一个Carve属性，一旦选中它，表示这个对象支持动态烘焙。其中Move Threshold表示移动多长的距离后启动动态烘焙，Time To Stationary表示元素停止运动后多久标记为静止状态，Carve Only Stationary表示元素是否需要移动，例如空气墙，只有开启或关闭两个状态。 导出寻路网格信息Unity的寻路是能满足客户端的，但是如果是网络游戏，服务器需要控制怪物寻找主角，此时就需要将寻路的网格信息导出来。如下图所示，可以利用发射线的方式来检测到当前地面是否可以行走，接着导出一个二维数组，其中0表示不可走，1表示可走，也就是图中红色和蓝色的射线区域。 如下图所示，首先需要设置X坐标格子的数量、Y坐标格子的数量以及每个格子的大小，接着利用Gizmos绘制射线来查看效果。 如下代码所示，绑定脚本后，在Scene视图中单击一个该对象，即可渲染射线区域并自动生成网格信息文本。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#if UNITY_EDITORusing UnityEngine;using UnityEngine.AI;using System.IO;using UnityEditor;using System.Text;public class Script_09_09 :MonoBehaviour&#123; // X坐标格子的数量 public int width; // Y坐标格子的数量 public int height; // 每个格子的大小 public int size; void OnDrawGizmosSelected() &#123; // 确保当前场景烘焙过 if (NavMesh.CalculateTriangulation ().indices.Length &gt; 0) &#123; // 获取场景名 string scenePath = UnityEditor.SceneManagement.EditorSceneManager.GetSceneAt(0).path; string sceneName = System.IO.Path.GetFileName(scenePath); string filePath = Path.ChangeExtension(Path.Combine (Application.dataPath, sceneName),"txt"); if (File.Exists (filePath)) &#123; File.Delete (filePath); &#125; // 准备写入数据 StringBuilder sb = new StringBuilder (); sb.AppendFormat ("scene=&#123;0&#125;", sceneName).AppendLine (); sb.AppendFormat ("width=&#123;0&#125;", width).AppendLine (); sb.AppendFormat ("height=&#123;0&#125;", height).AppendLine (); sb.AppendFormat ("size=&#123;0&#125;", size).AppendLine (); sb.Append ("data=&#123;").AppendLine (); Gizmos.color = Color.yellow; Gizmos.DrawSphere (transform.position, 1); float widthHalf = (float)width / 2f; float heightHalf = (float)height / 2f; float sizeHalf = (float)size / 2f; // 从左到右从下到上一次写入每个格子的数据 for (int i = 0; i &lt; height; i++) &#123; sb.Append("\t&#123;"); Vector3 startPos = new Vector3 (-widthHalf + sizeHalf, 0, -heightHalf + (i * size) + sizeHalf); for (int j = 0; j &lt; width; j++) &#123; Vector3 source = startPos + Vector3.right * size * j; NavMeshHit hit; Color color = Color.red; int a = 0; // 检测当前格子是否可以行走 if (NavMesh.SamplePosition (source, out hit, 0.2f, NavMesh.AllAreas)) &#123; color = Color.blue; a = 1; &#125; sb.AppendFormat (j &gt; 0?",&#123;0&#125;":"&#123;0&#125;", a); Debug.DrawRay (source, Vector3.up, color); &#125; sb.Append ("&#125;").AppendLine (); &#125; sb.Append ("&#125;").AppendLine (); // 绘制格子的总区域 Gizmos.DrawLine (new Vector3 (-widthHalf, 0, -heightHalf), new Vector3 (widthHalf, 0, -heightHalf)); Gizmos.DrawLine (new Vector3 (widthHalf, 0, -heightHalf), new Vector3 (widthHalf, 0, heightHalf)); Gizmos.DrawLine (new Vector3 (widthHalf, 0, heightHalf), new Vector3 (-widthHalf, 0, heightHalf)); Gizmos.DrawLine (new Vector3 (-widthHalf, 0, heightHalf), new Vector3 (-widthHalf, 0, -heightHalf)); // 写入文件 File.WriteAllText (filePath, sb.ToString ()); &#125; &#125;&#125;#endif 如图所示，行走区域的二维数组已生成完毕，数据的排序是从左到右、从下到上，服务端拿到这个数据后，即可按照此格式来解析了。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动寻路系统]]></title>
    <url>%2F2019%2F04%2F08%2F%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.如何自定义路线？ Unity 3D提供了一套Navigation自动寻路系统，开发人员可以通过调用该自动寻路系统来快速实现开发所需的寻路需求。自动寻路系统不但支持在不规则地形上的寻路，还能通过自定义路线和设置跳跃参数对寻路地形进行扩展。 基础知识下面介绍Unity 3D中在自动寻路系统可以使用到的几个寻路组件的主要功能。 ** 1.代理器--Nav Mesh Agent ** Nav Mesh Agent组件可实现对指定对象自动寻路的代理，该组件又自带了许多参数，通过修改这些参数实现对代理器大小、速度、加速度等值的控制，其参数如下表所示。系统会使附着该组件的对象以指定的速度向开发人员指定的目标点移动，移动过程中忽略一切碰撞体。 ** 参数 ** ** 含义 ** Agent Type 代理类型 Base offset Radius 代理器半径 Speed 代理器移动速度 Acceleration 代理器加速度 Angular Speed 代理器角速度 Stopping Distance 代理器到达时与目标点的距离 Auto Traverse OffMesh Link 是否自动穿过自定义路线 Auto Braking 是否自动停止无法到达目的地的路线 Auto Repath 原有路线发现变化时是否重新寻路 Height 代理器高度 Base offset 代理器相对导航网格的高度偏移 Obstacle Avoidance Type 代理器回避级别 Avoidance Priority 代理器回避优先级 NavMesh Walkable 代理器可使用的导航网格层 Nav Mesh Agent参数含义 NavMesh Walkable参数可对可使用导航网格层进行设置。Unity 3D使用2^n对导航网格层进行编号，如第0层编号为2^0=1、第1层编号为2^1=2……而NavMesh Walkable值为可使用导航网格层编号之和，如NavMesh Walkable的值为3的代理器可在第0层和第1层上移动，而其他层均无法使用。 ** 2.自定义路线-Off Mesh Link ** Off Mesh Link是为了满足复杂地形对生成导航网格的特殊需求所提供的一个组件，开发人员可自行设计所需路线，该路线将会被并入指定的导航网格层中，与其他路线一并进行寻路计算。该组件提供一系列参数，实现对该路线的自定义，其详细含义如下所示。 ** 参数 ** ** 含义 ** Start 自定义路线起始位置信息 End 自定义路线目标位置信息 Cost Override 自定义路线成本覆盖 Bi Directional 自定义路线是否允许双向穿越 Activated 是否激活该路线 Off Mesh Link参数含义 Off Mesh Link组件挂载在一个对象上，同时需要指定另外两个对象来充当这个路线的起始点和目标点。其产生的自定义路线有一个name参数，该参数指向了被挂载对象的对象名，读者可通过获取这个参数来判断当前正在穿越的路线，以进行相对应的操作。 ** 3.动态障碍物-Nav Mesh Obstacle ** 由于导航代理在移动的过程中会忽略所有的碰撞体，所以在寻路的过程中可能会出现代理器穿过其他对象的现象。为防止这些情况的发生，Unity 3D提供了Nav Mesh Obstacle组件来提供对动态障碍物的支持，通过这个组件可实现英雄横穿人群而不被穿透的效果。 ** 参数 ** ** 含义 ** Radius 动态障碍物的半径大小 Height 动态障碍物的高度 Move Threshold 动态障碍物的移动阈值 Carve 是否允许被代理器穿入 Nav Mesh Obstacle参数含义 一个简单的案例(1)新建一个场景。在菜单栏中选择“Fie“，打开文件操作按钮。选择“NewScene“，创建一个场景，按下快捷键Crits保存该场景，命名为“Pathing“. (2)导入资源。依次单击“Assets-Import Assets“选中所需的模型、贴图和动画，单击“Import“导入。本案例中所有的资源文件都已经整理好了，放在随书光盘第11章/资源包文件夹下。 (3)新建一个地形，调整其形状及大小，并将模型包中的“map.fbx”拖曳进场景，调整其大小，使其位于刚刚创建的地形之上。然后再把模型包中的“hero.fbx“拖曳进场景，使其位于mar对象上，最后将本游戏场景的天空盒设置为Textures文件夹下的“MySkyBox“.游戏场景如图11-32所示。 (4)依次单击“Assets-Import Assets-Projectors”导入阴影资源包，然后把Projectors文件夹下的“Blob Shadow Projector“拖曳给hero对象作为其子对象以产生阴影。 (5)选中map对象和Terrain对象，在Inspector面板中的Static下拉列表中选中“NavigationStatic“，使系统能在该对象的基础上生成导航网格，如图11-33所示。依次单击“Window一Navigation“调出Navigation窗口，单击该窗口下的“Bake“按钮，进行导航网格的烘焙，如图11-34所示。 (6)经过短暂的等待,游戏场景被设置为”Navigation Statio”的对象上面都会出现青色的导航网格层,如图11-35所示。同时, Assets目乘下会出现一个名为”Pathing”的文件夹,生成的导航网格数据会被记录在该文件夹下的NavMesh.asset文件上,如图11-36所示. (7)为人物添加代理器组件。选中hero对象,依次单击”Component-Navigation-Nav MeshAgent”,并设置其各项参数。如图11-37所示。 (8)为梯子添加自定义路线。创建一个空对象,命名为”JumpLink”,并为该空对象创建两个子对象,分别命名为”Start”和”End”,按此步骤再创建一个”ClimLink”.然后分别为这两个对象添加Of Mesh Link组件,分别设置其参数,如图11-38所示。 (9)分别调整JumpLink和ClimLink的子对象的位置,使其两个子对象分别位于两个导航网格上,且Jumplink的Start在上End在下,而ClimlLink刚好相反。此时其两个子对象之间会产生条弧线,如图11-39所示,这条弧线所代表的路线会归并入对应的导航网格中. (10)为hero对象添加Animation组件,并向该组件挂载”run” “jump” “hit “casting”等动画。这些动画将会在接下来的脚本开发中进行调用,使hero在移动的过程中更为自然. (11)下面进行脚本的开发。首先为摄像机添加监听脚本,通过触摸屏幕,可实现摄像机视角的转换、寻路目标点的设置等功能。该脚本的具体内容如下 (12)将上述脚本拖曳到主摄像机对象上,并调整该脚本下的参数,使其与图11-40所示相符合,该脚本可实现动态更改导航目标点,当用户点击场景中的地图时,场景中的人物会自动寻找最佳路线,并缓慢移动到该点。至此,本案例的基本功能已经实现,其效果如图11-41所示。 (13)现在人物的移动还稍显不自然,且还不能爬梯子和下梯子,接下来进行人物动画脚本的开发,来实现这些缺失的功能。创建一个脚本并将其命名为”HeroMovement.cs”,其具体代码内容如下. (14)将上述脚本拖曳到人物对象hero上。该脚本实现了人物对象在自动寻路过程中动画的切换,使其寻路更为自然,而不是简单的平移。 至此,本案例的开发已经全部完成。读者可将本案例导出为APK文件,并在手机上安装运行,查看案例运行效果。通过点击手机屏幕,在指定位置放置一个旗子,人物对象就将走向旗子.如果在人物对象寻路的过程中重新点击屏幕,人物对象将会重新进行寻路,走向新的目标点.如图11-42所示.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity游戏开发技术详解与典型案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity脚本-2]]></title>
    <url>%2F2019%2F04%2F08%2FUnity%E8%84%9A%E6%9C%AC-2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.如何通过脚本移动，旋转和缩放对象？2.四元数是什么？如何使用？3.如何自定义输入？4.如何使用重力感应？ 本章涵盖 移动、旋转和缩放游戏对象 工具类 输入控制 移动、旋转和缩放游戏对象在3D世界中，任何一个游戏对象在创建的时候都会附带Transform组件，并且该组件是无法删除的。 Transform面板中一共包含3个属性：Position（位置），Rotation（旋转）和Scale（缩放）。既可在场景中使用移动工具来拖动和旋转模型，也可以直接在Inspector窗口下的Transform面板中手动填写对象的位置、旋转和缩放的数值。 游戏对象的位置在3D世界中，任何一个模型的三维坐标都保存在Vector3容器中，该容器将记录物体在x轴、y轴和z轴方向的坐标。一旦在程序中修改该游戏对象的坐标，那么Scene视图中游戏对象的位置将发生改变。 移动游戏对象游戏对象在原有位置的基础上继续移动，在代码中可以使用transform.Translate()函数实现，此函数的唯一参数为位移的数值：transform.Translate(Vector3 offset);该函数相当于transform.position = transform.position + offset。 缩放游戏对象在Unity中，可以通过代码动态缩放游戏中的游戏对象。 1transform.localScale = new Vector3(x,y,z); 其中Vector3的x为x轴向的缩放，y为y轴向的缩放，z为z轴向的缩放。也可以通过下面的代码格式快速整体缩放： 1transform.localScale *= 1.2f; // 对象整体放大1.2倍 旋转游戏对象游戏对象的旋转方式分为两种：第一种是自转；第二种是围绕旋转，也就是围绕一个点或者一个游戏对象来旋转。 transform.Rotate()：该函数用于设置游戏对象自转。 transform.RotateAround()：该函数用于设置游戏对象围绕某一个点旋转。 Time.deltatime：上一帧所消耗的时间，这里用作模型旋转的速度系数。 Vector3.right：x轴正方向。 Vector3.up：y轴正方向。 vector3.forward：z轴正方向。 实例在本实例中，我们会通过点击按钮对游戏对象进行对应的移动缩放旋转操作，如代码所示。 12345678910111213141516171819202122232425262728293031323334353637using UnityEngine;using System.Collections;public class testDemo : MonoBehaviour &#123; public GameObject cube; public GameObject cylinder; void OnGUI() &#123; if(GUILayout.Button("向左移动物体")) &#123; cube.transform.Translate(new Vector3(-0.5f, 0f, 0f)); &#125; if(GUILayout.Button("向右移动物体")) &#123; cube.transform.position = cube.transform.position + new Vector3(0.5f, 0f, 0f); &#125; if (GUILayout.Button("放大物体")) &#123; cube.transform.localScale *= 1.2f; &#125; if(GUILayout.Button("缩小物体")) &#123; cube.transform.localScale = 0.8f; &#125; if (GUILayout.Button("旋转物体")) &#123; cube.transform.Rotate(new Vector3(0, 10, 0)); &#125; if(GUILayout.Button("围绕圆柱体旋转物体") &#123; cube.transform.RotateAround(cylinder.transform.position, Vector3.up, 10); &#125; &#125;&#125; 工具类时间类Unity提供了Time类，这个类主要用来得到与时间相关的信息。 12345678910111213141516using UnityEngine;using System.Collections;public class TimeDemo : MonoBehavlour &#123; void OnGUI() &#123; GUILayout.Label("当前游戏时间" + Time.time); GUILayout.Label("游戏时间的缩放" + Time.timeScale); GUILayout.Label("上一帧所消耗的时间" + Time.deltaTime); GUILayout.Label("固定增量时间" + Time.fixedTime); GUILayout.Label("上一帧所消耗的固定时间" + Time.fixedDeltaTime); GUILayout.Label("真实逝去时间" + Time.realtimeSinceStartup); &#125;&#125; Time.time：从游戏开始时计时，截止到目前共运行的游戏时间，受Time.timeScale影响，游戏暂停时该时间不增加。 Time.timeScale：时间流逝的速度。当该值设置为1时表示和现实中的时间流逝一致；当该值设置为0.5时，表示真实时间逝去1秒时，游戏时间仅逝去0.5秒；当设置该值为2表示真实时间逝去1秒时，游戏时间逝去2秒。 Time.deltaTime：上一帧所消耗的时间。 Time.fixedTime：每一次执行FixedUpdate()函数的时间间隔。可通过导航菜单栏Edit-&gt;Project Settings-&gt;Time菜单项设置。 Time.fixedDeltaTime：固定更新上一帧所消耗的时间。 Time.realtimeSinceStartup：从游戏开始时计时，截止到目前共运行的真实时间，不受Time.timeScale影响，游戏暂停时该时间仍然增加。 随机数在开发中，有时需要获取程序中的随机数，这可以使用Random类中的Random.Range()函数实现，其中该函数的第一个参数传入的是随机数的最小值，第二个参数传入的是随机数的最大值。两个参数共同决定了生成随机数的值域。 1234567891011121314151617using UnityEngine;using System.Collections;public class RandomDemo : MonoBehaviour&#123; void OnGUI() &#123; if(GUILayout.Button("生成随机数")) &#123; // 生成随机数 int i = Random.Range(0, 10); Debug.Log("随机生成的一个0~10之间的整数是:" + i); float f = Random.Range(0f, 10f); Debug.Log("随机生成的一个0~10之间的浮点数是:" + f);. &#125; &#125;&#125; 数学类Unity提供了一个数学类Mathf，该类位于UnityEngine命名空间下。以下是Mathf类里常用的函数和属性。 Mathf.Abs(a)：返回a的绝对值，参数为整数或者浮点数。 Mathf.Clamp(a, min, max)：将a限制在min和max之间，参数为整数或者浮点数。 Mathf.Lerp(from, to, a)：插入值，返回值=from+to(1-a)。 Mathf.Min(a, b, c)：返回两个或n个数的最小值，参数为整数或者浮点数。 Mathf.Max(a, b, c)：返回两个或n个数的最大值，参数为整数或者浮点数。 Mathf.Pow(a, b)：a的b次方。 Mathf.Deg2Rad：常量浮点数，0.0174532924f，用于将角度转换成弧度。 Mathf.Rad2Deg：常量浮点数，57.29578f，用于将弧度转换成角度。 Mathf.Pi：常量浮点数，表示圆周率。 Mathf.Sin(a)：返回弧度a的正弦值。 Mathf.Cos(a)：返回弧度a的余弦值。 Mathf.Tan(a)：返回弧度a的正切值。 四元数四元数（Quaternion）是非常重要的工具类之一。在Unity中所有用到模型旋转的，其底层都是由四元数实现的，它可以精确地计算模型旋转的角度。在场景中创建一个立方体，并添加代码脚本。点击运行，立方体会一直旋转。 1234567891011121314using UnityEngine;using System.Collections;public class QuaternionDemo : MonoBehaviour &#123; // 绕y轴自转的速度 float rotateSpeed = 50f; void Update() &#123; // 绕y轴自转 transform.rotation = Quaternion.Euler(0f, rotateSpeed * Time.time, 0); &#125;&#125; 我们使用Quaternion.Euler(Vector3 vec)函数，传入一个Vector3(x,y,z)，分别代表围绕x、y、z轴旋转的角度，返回该角度对应的四元数，将四元数赋值给立方体的rotation旋转变量完成旋转。 输入控制玩家点击鼠标左键开火、按住键盘w键前进等都属于输入控制，如何监测输入是非常重要的内容。 计算机输入计算机设备的输入指的是仅对应键盘和鼠标的输入检测，一般单项检测分为3类：按下、拉住、抬起。 123456789101112131415161718192021222324252627282930313233using UnityEngine;using System.Collections;public class DetectInput : MonoBehaviour&#123; void Update() &#123; // 按下键盘A键 if (Input.GetKeyDown(KeyCode.A))&#123;&#125; // 按住键盘A键 if (Input.GetKey(KeyCode.A))&#123;&#125; // 抬起键盘A键 if (Input.GetKeyUp(KeyCode.A))&#123;&#125; // 按下键盘左Shift键 if (Input.GetKey(KeyCode.LeftShift))&#123;&#125; // 按住键盘左Shift键 if (Input.GetKey(KeyCode.LeftShift))&#123;&#125; // 抬起键盘左Shift键 if (Input.GetKeyUp(KeyCode.LeftShift))&#123;&#125; // 按下鼠标左键 if (Input.GetMouseButtonDown(0))&#123;&#125; // 按住鼠标左键 if (Input.GetMouseButton(0))&#123;&#125; // 抬起鼠标左键 if (Input.GetMouseButtonUp(0))&#123;&#125; // 按下鼠标右键 if (Input.GetMouseButtonDown(1))&#123;&#125; // 按住鼠标右键 if (Input.GetMouseButton(1))&#123;&#125; // 抬起鼠标右键 if (Input.GetMouseButtonUp(1))&#123;&#125; &#125;&#125; 自定义输入但是键盘鼠标输入检测十分局限，一般仅用于计算机等设备，下面就来介绍另一种方法。 自定义输入可以设置输入类型名称、输入设备类型、输入键位等参数，从而方便地解决了计算机与家用机的输入兼容。 点击导航菜单栏-&gt;Edit-&gt;Project Settings-&gt;Input，打开输入设置界面。如下图所示，Unity提供了默认的输入设置，包括了“Horizontal”横向移动、“Vertical”纵向移动、“Fire1”开火按钮等输入。展开“Fire1”输入项，各项参数如图所示，参数说明见下表。 参数 说明 Name 名字 Descriptive Name 控制设置中显示的正值名称 Descriptive Negative Name 控制设置中显示的负值名称 Negative Button 该按钮用于负方向移动轴 Positive Button 该按钮用于正方向移动轴 Alt Negative Button 备选按钮用于负方向移动轴 Alt Positive Button 备选按钮用于正方向移动轴 Gravity 当没有相关按钮按下时,回归0的速度。单位/秒 Dead 模拟的死区大小。设定范围内所有模拟设备的值为0 Sensitivity 灵敏度,单位/秒。仅用于数码设备 Snap 如果启用,当按下相反方向的按钮,该轴值将重设为0 Invert 如果启用,负按钮将提供正值,反之亦然 Type 控制轴的输人设备类型 Axis 连接设备的轴将控制这个轴 Joy Num 连接操纵杆将控制这个轴 可以发现很多键如Horizontal都出现了重复，这是因为所有键位键盘鼠标是单独的一套键而手柄则是另一套。例如“Fire1”开火键1分为键盘鼠标版和手柄版，无论哪种都能触发脚本中对应的逻辑。 ** 1.按钮 ** 这里以开火按钮为例，如图3-16所示我们可以检测开火按钮的按下、按住、抬起3个状态下面就来介绍如何实现按钮输入。 □ 键盘鼠标。键盘鼠标实现按钮非常简单。 第一步：设置类型，首先将Type设置为Key or Mouse Button。第二步：填写名字，这里Name填的是Fire1。第三步：设置键位。因为是单一按钮，所以仅仅需要填写正向部分。Positive Button填left ctrl，Alt Positive Button填mouse 0，也就是键盘左侧的Control键或者鼠标左键都对应开火键。 □ 手柄。步骤和键盘鼠标完全一样，只是键位名称不一样而已，这里Positive Button填写的是joystick button 0。 □ 脚本。当在Input Manager界面中设置好键位后，我们可以通过脚本监测输入。 123456789101112131415using UnityEngine;using System.Collections;public class DetectInput : MonoBehaviour&#123; void Update() &#123; // 按下Fire1键 if (Input.GetButtonDown("Fire1"))&#123;&#125; // 按住Fire1键 if (Input.GetButton("Fire1"))&#123;&#125; // 松开Fire1键 if (Input.GetButtonUp("Fire1"))&#123;&#125; &#125;&#125; ** 2.方向轴 ** 方向轴常用于控制玩家角色的左右移动或上下移动。它的设置界面和按钮是完全一样的，但用法却不一样，方向轴有两个按钮分别对应正负两个方向。以Horizontal方向轴为例，如下图所示，按下键盘右箭头是正值，按下键盘左简头是负值。输出的范围是[-1,1]的浮点数，我们可以用它来控制角色的左右移动。下面就来介绍如何实现。 □ 键盘鼠标。前几步和按钮一样，只是需要额外设置Gravity、Dead、Sensitivity、Snap等参数。 Gravity填写3表示当松开对应按钮后，输出值会以3/秒的速度迅速归零。Dead填写0.001表示当输出在[-0.001,0.001]之间时会被忽略不计，强制输出0。Sensitivity填写3表示当按钮下对应按钮后，输出值会以3秒的速度变化，当按下的是正向按钮时会迅速到达1，当按下的是负向按钮时会迅速到达-1。 □ 手柄。如下图所示，这里对应的不再是手柄的按钮而是手柄轴。 第一步：设置类型。首先将Type设置为Joystick Axis。第二步：填写名字。这里Name填的是Horizontal,第三步：设置手柄。Joy Num栏如果填Get Motion from all Joysticks表示对应所有手柄，也可以填lystick I等手柄序号。第四步：设置轴，Axis栏这里填的是Xaxis，也就是手柄十字键的横向。 □ 脚本。脚本中获得轴的代码非常简单。 1234567891011using UnityEngine;using System.Collections;public class AxisDemo : MonoBehaviour&#123; void Update() &#123; // 得到Horizontal轴的值 float axisH = Input.GetAxis("Horizontal"); &#125;&#125; 移动设备输入移动设备也就是手机、平板等通过手指点击屏幕操作的设备。Unity有专门的接口检测与屏幕互动的各个手指的位置状态等信息。 与屏幕接触的手指的信息对应名为Touch类的对象，可以通过Input.Touches变量得到所有Touch。Touch常用的参数见下表。 参数 说明 FingerId 手指的编号，整型 Phase 手指的阶段，枚举类型。分为这几个阶段：Began开始接触屏幕Moved移动Stationary静止Ended手指离开屏幕Canceled系统关闭触控 Position 手指触碰屏幕的位置，Vetor2类型。坐标以屏幕左下角为原点1像素对应一个单位，例如iPhone 4s的分辨率是960*640。所以如果应用是横屏的话，那么左下角的Position是(0,0)，右上角的Position是(960,640) ** 1.实测 ** 如下代码所示，我们得到手指的信息并输出到屏幕。 123456789101112131415using UnityEngine;using System.Collections;public class MobileTouchDemo : MonoBehaviour&#123; void OnGUI() &#123; // 遍历所有的Touch foreach (Touch touch in Input.touches) &#123; // 输出Touch信息 GUILayout.Label(string.Format("手指：&#123;0&#125; 状态：&#123;1&#125; 位置：&#123;2&#125;", touch.fingerId, touch.phase.ToString(), touch.position)); &#125; &#125;&#125; ** 2.重力感应 ** Acceleration，即加速度传感或者重力感应。有很多著名的手机游戏的主要操作是基于重力感应的；在手机赛车游戏中重力感应也可用于控制赛车的转向。重力感应的原理是当手握移动设备晃动时，移动设备内的加速度计会计算设备在X、 Y、Z这3个方向上的线性加速度变化。以设备为基准，X轴正向为设备向右的方向，Y轴正向为设备向上的方向，Z轴正向为设备向使用者的方向。在Unity中可以通过Input.acceleration得到重力感应的值，类型为vector3。每个轴向的值域是[-1, 1]。 可以通过以下代码将重力感应信息输出至屏幕。可以在设备上运行此场景，并观察设备以不同朝向转动时Input.acceleration值的变化。 123456789101112using UnityEngine;using System.Collections;public class AccelerationDemo : MonoBehaviour&#123; void OnGUI() &#123; GUILayout.Label("X:" + Input.acceleration.x); GUILayout.Label("Y:" + Input.acceleration.y); GUILayout.Label("Z:" + Input.acceleration.z); &#125;&#125; ** 3.其他 ** Input还有一些接口可以在设备运行游戏时得到关于设备输入的信息。 通过Input.deviceOrientation可以得到当前游戏运行的朝向。 通过Input.touchSupported可以得到当前游戏是否支持手指触控操作。 通过Input.multiTouchEnabled可以设置游戏是否支持多点触控。 习题1.使用OnGUI()函数做一个调查问卷，要求填写名字、性别以及年龄并在提交后将信息输出至控制台。2.在平台上创建一个球体，实现通过键盘的WASD键对其进行前后左右移动操作。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网格Mesh]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%BD%91%E6%A0%BCMesh%2F</url>
    <content type="text"><![CDATA[Unity提供了一个Mesh类，允许通过脚本来创建和修改Meshes的类。通过Mesh类生成或修改物体的网格能够做出非常酷炫的物体变形特效。 网格过滤器（Mesh Filter）网格过滤器从资源中拿出网格并将其传递给网格渲染器（Mesh Renderer），用于在屏幕上渲染。网格过滤器中有一个重要的属性“Mesh”用于储存物体的网格数据。在导入模型资源时，Unity会自动创建一个网格过滤器组件。 Mesh属性和方法介绍网格过滤器组件中有一个重要的属性“Mesh”。“Mesh”是网格过滤器实例化的Mesh，Mesh中有一些用于储存物体的网格数据的属性和生成或修改物体网格的方法。 (1)Mesh中有一些用于储存物体的网格数据的属性，这些属性主要用于储存网格各种数据的数组。属性的详细说明如下表所示。 属性 说明 vertices 网格的顶点数组 normals 网格的法线数组 tangents 网格的切线数组 uv 网格的基础纹理坐标 uv2 如果存在，这是为网格设定的第二个纹理坐标 bounds 网格的包围体 colors 网格的顶点颜色数组 triangles 包含所有三角形顶点索引的数组 vertexCount 网格中顶点的数量(只读的) subMeshCount 子网格的数量，每种材质都有一个独立的网格列表 boneWeights 每个顶点的骨骼权重 bindposes 绑定的姿势，每个索引绑定的姿势使用具有相同索引的骨骼 (2)Mesh中有生成或修改物体网格的方法，这些方法主要用于设置储存网格各种数据的数组。方法的详细说明如下表所示。 方法 说明 Clear 清空所有顶点数据和所有三角形索引 RecalculateBounds 重新计算从网格包围体的顶点 RecalculateNormals 重新计算网格的法线 Optimize 显示优化的网格 GetTriangles 返回网格的三角形列表 SetTriangles 为网格设定三角形列表 CombineMeshes 组合多个网格到同一个网格 Mesh的使用网格包括顶点和多个三角形数组。三角形数组仅仅是顶点的索引数组，每个三角形包含三个索引。每个顶点可以有一条法线、两个纹理坐标以及颜色和切线，显然这些是可选的，但是也可以去掉。所有的顶点信息被储存在单独的同等规格的数组中。 通过为顶点数组赋值并为三角形数组赋值来新建立一个网格，通过获取顶点数组修改这些数据并把这些数据放回网格来改变物体形状。调用Clear函数在赋予新的顶点值和三角形索引值之前是非常重要的，因为Unity总是检查三角形的索引值，判断它们是否超出边界。 使用Mesh使物体变形(1)新建一个场景，命名为“test”。(2)创建地形，光源的具体参数如图10-11所示。 (3)创建水。选中Assets文件夹，单击鼠标右键选择”Import Package-&gt;Water(Pro Only)”导入标准水资源包，然后拖曳DaylightWater到场景中。 (4)创建两个空对象，分别命名为“zhang”和“sanjiao”。具体步骤为GameObject-&gt;Create Empty。为两个空对象添加网格过滤器，具体步骤为选中对象然后依次单击“Component-&gt;Mesh-&gt;Mesh Filter”。 (5)为两个空对象的网格过滤器组件设置网格属性。将Assets\Meshes文件夹下的sanjiao.FBX和zhang.FBX模型文件中的网格“Box01”分别拖曳到sanjiao和zhang对象的网格过滤器组件的“Mesh”属性中。如图10-15所示。 (6)创建一个空对象，并且命名为“g1”，调整该对象的位置和大小，具体参数如图10-16所示。为g1对象添加网格过滤器，然后为g1对象添加网格渲染器（具体步骤为选中对象然后依次单击菜单“Component-&gt;Mesh-&gt;Mesh Renderer”）。 (7)为g1对象添加纹理，将Assets\Textures文件夹下的纹理文件“wenli.tga”拖曳到g1对象上，这时g1对象的网格渲染器的“material”属性就设置为“wenli”材质，如图10-18所示。然后按照相同的方法再创建5个对象。 (8)在Scripts文件夹中，创建脚本并命名为”XiFen.cs”。本脚本主要用于控制物体变形，脚本代码如下： 123456789101112131415161718192021222324252627using UnityEngine;using System.Collections;using System.Collections.Generic;public class XiFen : MonoBehaviour&#123; Mesh mesh; // 物体的网格对象 int time; // 用于记录时间 public GameObject[] g; // 包含网格的对象数组 Mesh[] m; // 网格对象数组 public List&lt;Vector3&gt; vertice; // 网格的顶点数组 public List&lt;int&gt; triangle; // 包含所有三角形顶点索引的数组 public List&lt;Vector2&gt; uv; // 网格的基础纹理坐标 public List&lt;Vector3&gt; normal; // 网格的法线数组 public List&lt;Vector4&gt; tangent; // 网格的切线数组 bool bian = true; // 物体一次变形是否完成 int s = 0; // 物体变形形状标志位 void Start() &#123; &#125; void Update() &#123; &#125;&#125; 口第5-8行的主要功能是声明变量。主要声明了物体的网格对象、包含网格的对象数组以及网格对象数组等变量。在下面控制物体变形的代码中会用到这些变量。 口第9-15行的主要功能是声明变量。主要声明了用于储存网格数据的各个数组以及物体一次变形是否完成标志位和物体变形形状标志位。 口第16-18行实现了Start方法的重写，该方法在游戏加载时执行。主要功能是游戏加载时细化物体的网格。 口第19-21行实现了Update方法的重写，该方法系统每帧调用一次，主要功能是通过不断改变网格数据使物体不断变形。 (9)在XiFen.cs脚本中通过场景加载时系统调用Start方法来实现细化物体的网格. Start方法的具体代码如下。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity游戏开发技术详解与典型案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D基础知识]]></title>
    <url>%2F2019%2F04%2F07%2F3D%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[任何3D画面都是由两个基础部分组成的：观察者/摄像机和被观察物。 Camera摄像机 摄像机的参数如下表所示。 摄像机参数 参数 说明 Clear Flags 清除标记。决定屏幕的哪部分将被清除。该项一般用于使用多台摄像机来描绘不同游戏对象的情况。□ Skybox：天空盒。该模式为默认设置，在屏幕中空白的部分将显示当前摄像机的天空盒。如果当前摄像机没有设置天空盒，它会默认使用背景色。□ Solid Color：纯色。选择该模式后，屏幕上的空白部分将显示当前摄像机的背景色。□ Depth Only：深度相机，只渲染采集到的画面。□ Don’t Clear：不清除，每帧渲染画面叠加在上一帧画面之上。 Background 背景颜色 Culling Mask 剔除遮罩。摄像机将看到勾选的层，忽略未被勾选的层 Projection 投射方式。□ Perspective：透视。摄像机以透视方式渲染画面，拍摄区域是一个截锥体。□ Orthographic：正交。摄像机以正交方式渲染画面，拍摄区域是一个长方体。 Field of View 透视模式的视野范围 Size 正交模式摄像机视口大小 Clipping Planes 剪裁平面。□ Near：近点。可视区域距离摄像机最近的点□ Far：可视区域距离摄像机最远的点 Viewport Rect 视口矩形。决定摄像机画面显示在屏幕的区域。参数X、Y决定区域起点，W、H决定区域宽高。屏幕坐标系是左下角为原点X=0，Y=0，屏幕最上方Y=1，屏幕最右方X=1。例如X=0，Y=0，W=1，H=1（默认）表示画面显示于整个屏幕。X=0.5，Y=0，W=0.5，H=1表示画面显示于右半屏幕。 Depth 该项用于控制多个摄像机的渲染优先级，数值越大优先级越高。优先级高的摄像机拍摄的画面将覆盖在优先级低的摄像机的画面上 Rendering Path 渲染路径。该项用于指定摄像机的渲染方法。□ Use Graphics Settings：摄像机将使用设置的渲染方法，即Project Settings下Graphics中的设置。□ Forward：快速渲染。摄像机将对所有游戏对象将按每种材质一个通道的方式来渲染。□ Deferred：延迟光照。摄像机先对所有游戏对象进行一次无光照渲染，再进行光照渲染。□ Legacy Vertex Lit：旧的顶点光照。摄像机将对所有的游戏对象作为顶点光照对象来渲染。□ Legacy Deferred（light prepass）：旧的延迟光照。 Target Texture 目标纹理。将摄像机画面输出到一张贴图而不是屏幕，可用于实现画中画或者画面特效 Occlusion Culling 是否删除物体背向摄像机的部分 HDR 高动态光照渲染。该项用于启用摄像机的高动态范围渲染功能。因为人眼对低范围的光照强度更为敏感，所以使用高动态范围渲染能够让场景更为真实，光照的变化不会显得太突兀 摄像机投射** 1.透视摄像机 ** 透视摄像机所能看到的是一个截锥体。如下图所示。 离相机最近的截平面由上表中的Clipping Planes里的Near参数决定，数值代表的是距离摄像机原点的距离。Far参数决定的是最远的截平面，而Field of View决定截锥体的宽度。所以，和真实的人眼或摄像机不同，3D引擎中的摄像机并不是真正的无限视距，只能看到截锥体以内的物体。 Field of View是透视摄像机的视野范围，默认值是60，改变此值观察截锥体形状的变化。值越小，截锥体越窄，视野范围越小；值越大，截锥体越宽，视野范围越大。再改变Clipping Planes的Near和Far，并观察截锥体的变化。 ** 2.正交摄像机 ** 正交摄像机所能看到的是一个长方体，如下图所示。 调整Size和Clipping Planes的Near和Far并观察长方体的变化。 3D模型介绍了观察者摄像机，下面来讲解被观察物，也就是3D模型。无论是人物、场景还是特效粒子系统等，归根结底都是3D模型。 Mesh网格模型首先点击主菜单栏-&gt;Assets-&gt;Import Package-&gt;Characters，将此资源包导入工程。将Constructer拖入场景，然后点击Scene标签下的Shaded按钮，选择渲染模式为Wireframe，如下图所示。 观察此模式下的人物，大腿部分会看得最清楚。人物模型是由一个个三角形组成的，这种模型叫Mesh网格模型，如下图所示，3D Max、Maya等做出来的均是网格模型。在Project窗口中展开Constructer文件，白色网格覆盖的圆筒图标代表的是网格模型，construction_worker就是此人物的网格模型。 Texture贴图有了网格模型，我们还需要知道物体表面的颜色。将所有模型表面画到一张图片上，如下图所示，这类图片叫作Texture贴图。 但是我们还不知道网格模型是如何与贴图对应的，所以网格模型需要额外的信息，首先贴图的坐标规定为（x，y），x和y的范围都是[0，1]。网格模型上每一个三角形顶点都对应着贴图上的一个坐标，那么每一个三角形的中间部分可以通过对该三角形所有顶点插值得到贴图里的颜色。 Material材质尽管是近似的灰色，但灰色T恤衫和不锈钢是那么地不相同，因为它们对光照的反应不一样。T恤衫是由纺织物编织而成的，表面是凹凸起伏的，属于漫反射；而不锈钢的表面很平滑，属于镜面反射。 Material材质就是定义物体表面信息的，而物理信息通过Shader渲染器定义，如下图所示。Inspector窗口的第二栏Shader显示此材质使用的是Bumped Specular这个Shader。Unity自带了很多Shader，标准Shader适用范围很广，你也可以自己编写Shader。有兴趣的读者可以在熟练使用Unity后自己去学习这部分内容，推荐从Nvidia的《CG教程：可编程实时图形权威指南》开始入手。 在Project窗口下找到球体图标的constructor_done，这就是材质，在三维建模工具或3D引擎里，通常默认以球体网格模型来展示材质，所以材质也叫材质球。把贴图装在材质上与网格模型对应。我们有了人物的几何信息、表面颜色信息和物理光照信息，就可以显示比较真实的人物模型了。 对应组件网格模型、贴图、材质就是3D物体的基本组成部分。在游戏对象上添加相关组件来使用它们。如果使用了骨骼动画，那么就是Skinned Mesh Renderer组件，如下图所示，在Materials栏指定所使用的材质，在Mesh栏指定所使用的网格模型。 如果没有使用骨骼动画，那么使用Mesh Filter组件指定网格模型，使用Mesh Renderer组件指定材质，如下图所示。 骨骼动画重要的是，我们还需要让人物能够动起来。人体是由骨骼链接的，如下图所示，骨骼信息包含在网格模型文件里。有了骨骼信息，我们可以播放人物动画让人物动起来。Constructor下的idle、jump_pose、run、walk都是Animation动画。 习题1.Unity的摄像机分为哪两种类型？2.简述模型、贴图、材质三者的关系。3.从网上下载一个人物模型并导入Unity，然后用4个摄像机分别从4个不同的角度观察人物并显示在屏幕的左上、左下、右上、右下4个区域。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D数学与Unity]]></title>
    <url>%2F2019%2F04%2F06%2F3D%E6%95%B0%E5%AD%A6%E4%B8%8EUnity%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 向量的基本运算包括哪些？ 本章涵盖： 用Unity引擎开发游戏就是在引擎的上层再封装一层游戏架构，在游戏开发的逻辑中需要根据需求重新封装一些数学算法以便于逻辑调用。 Unity坐标系3D坐标系表示的是三维空间，3D坐标系存在三个坐标轴，分别为x轴、y轴、z轴，如图1-1所示。 3D坐标系分为左手坐标系和右手坐标系。Unity使用的是左手坐标系。 Unity引擎的左手坐标系也被称为世界坐标系，做游戏开发时需要美工制作美术模型，运用MAX工具把建好的模型放到游戏场景中。在默认情况下，局部坐标和世界坐标系的原点是重合的，不能把所有的模型都叠加在世界坐标系的原点上，因此需要移动模型。模型移动时就会发生模型的局部坐标到世界坐标的转换，这个移动过程就是把模型的局部坐标转化成世界坐标。只是这个转化过程是在引擎编辑器内部实现的，实际上它就是将模型的各个点与世界矩阵相乘得到的。 Unity编辑器中的物体都在世界坐标系里面，比如我们通常使用的函数transform.position，它就是获取到当前物体的世界坐标位置，用户无须自己去计算，因为引擎内部已经计算好了。明白了原理后，再使用编辑器解决问题更有助于理解，做到知其然且知其所以然。如果要获取物体自身的坐标，也就是局部坐标，可以使用函数transform.localPosition获取当前模型的局部坐标。 用Unity引擎开发移动端手游会经常用到屏幕坐标系，屏幕坐标系就是通常使用的电脑屏幕，它是以像素为单位的，屏幕左下角为（0, 0）点，右上角为（Screen.Width, Screen.Height）点，Z的位置是根据相机的Z缓存值确定的。通常使用鼠标在屏幕上单击物体，它就是屏幕坐标。通过函数Input.mousePosition可以获得鼠标位置的坐标。我们使用的虚拟摇杆可以在屏幕上滑动，它也是屏幕坐标，可以通过函数Input.GetTouch(0).position获取到手指触摸屏幕坐标。 在游戏开发中，比如单击场景中的3D物体就需要从屏幕上发射一条射线与物体的包围盒相交，用于判断是否选中物体，对于UI的操作也都是基于屏幕坐标系的。 通过相机才能看到虚拟世界的物体。相机有自己的视口坐标，物体要转换到视口坐标才能被看到。相机的视口左下角为（0, 0）点，右上角为（1, 1）点，Z的位置是以相机的世界单位来衡量的。（0, 0）点和（1, 1）点是通过公式进行缩放计算的，这里面存在一个变换，读者了解就可以了。这也是为什么视口的大小通常都是（0, 0）和（1, 1），效果如图1-2所示，图的中心点是摄像机。 下面介绍世界坐标、屏幕坐标、相机坐标之间的转换方式。举一个简单的例子，在一个空场景里面放置一个立方体，物体在编辑器中也就是世界坐标系中的摆放如图1-3所示。 获取物体位置的通常写法是transform.position，它表示的是立方体在3D世界中的世界坐标的位置。如果使用的是触摸屏幕，那么可以通过函数Input.GetTouch(0).position获取到屏幕坐标。它们之间的转换方式如下。 世界坐标到屏幕坐标的转化函数：camera.WorldToScreenPoint(transform.position)。 屏幕坐标到视口坐标的转化函数：camera.ScreenToViewportPoint(Input.GetTouch(0).position)。 世界坐标到视口坐标的转化函数：camera.WorldToViewportPoint(obj.transform.position)。 这些转换也是固定流水线的矩阵变换，只是Unity将其封装好了而已。如果想学习固定流水线，可以参考《手把手教你架构3D游戏引擎》一书，里面有固定流水线的详细讲解，下面介绍向量运算。 向量向量的基本运算包括加法、减法、点乘、叉乘、单位化运算等，其中减法、点乘、叉乘、单位化运算在游戏开发中使用得最为广泛。 首先介绍一下向量，向量的表示如图1-4所示。 向量是具有方向和长度的矢量，它并不是一条射线，向量有2D、3D、4D等的。在游戏开发里面一般使用的是2D向量和3D向量。2D向量表示为&lt;x，y&gt;两个数值，而3D向量是由&lt;x，y，z&gt;三个数值表示的。3D游戏开发中经常使用的3D向量的几何表示如图1-5所示。 图中向量a在3D坐标系中用三个值表示：&lt;ax, ay, az&gt;，下面介绍向量的加法运算。 向量的加法顾名思义，向量的加法就是两个向量相加，几何表示如图1-6所示。 图1-6是两个向量相加的示意图，二者相加后得到的值还是一个向量，其运算方法就是两个向量对应项的相加。向量的加法在游戏开发中一般表示物体从一个位置移动到另一个位置，如图1-7所示。 图1-6 向量加法的几何表示 图1-7 向量的加法在游戏中的表示 如果立方体移动到球体的位置，通常的做法是先计算出二者的方向，也就是从V1指向V2的向量，计算公式是Vector3 dir = (V2V1).normalized，公式的含义是将两个向量相减并且单位化，normalized表示向量单位化，这是使用Unity自带的接口实现的，方向是没有大小的。假设V1表示的物体为obj的位置，那么它当前的位置表示为obj.transform.position，它移动到V2的位置，用Unity的计算公式表示为obj.transform.position=obj.transform.position+dir*0.5（系数）。系数的大小是可以任意设置的，要根据效果表现设置系数大小。读者可能比较熟悉这个公式，它的原型正是直线方程y=ax+b，在不知不觉中我们把数学运算公式就用上了，所以编程还是非常有趣的，接下来再看看向量的减法。 向量的减法向量的减法在几何图上的表示如图1-8所示。 图1-8中的黑色箭头表示的是向量a和向量b。为了做减法，将向量b取反，再相加得到的是ab。向量的减法在游戏开发中主要应用在计算方向上，正如图1-7所示，一个物体从位置V1移动到位置V2，首先要做的就是确定其移动的方向，这个方向的计算公式是Vector3dir=(V2V1).normalized。除了计算方向外，计算两个物体之间的距离也是向量相减然后求平方根得到的，在Unity中可以使用函数Vector3.Distance(Vector3a，Vector3b)获取两个向量之间的距离。两个物体之间的距离的计算在游戏中运用得非常多，比如导弹要击中某个物体，需要根据导弹的射程也就是距离计算，MMOARPG游戏中玩家与怪物之间进行战斗也要判断两个物体之间的距离，从而决定是否击中对方，只有在两者相距小于某个设定的数值时，也就是在攻击范围内才能发起攻击。玩家攻击怪物的游戏效果如图1-9所示。 向量点乘网上流传着这样一句话：向量点乘计算角度，向量叉乘计算方位。在游戏开发中通常使用点乘计算角度，点乘得到的值是个弧度常量，当然也可以将其转化成角度值。形象地说就是，当一个怪物在你身后时，叉乘可以判断你是往左转还是往右转才能更快地转向怪物，点乘得到当前面的朝向和到怪物的方向所成的角度大小。点乘向量的几何图表示如图1-10所示。 其中，|a|表示向量a的长度，|b|表示向量b的长度。θ表示向量a和向量b的角度。计算公式a×b=|a|×|b|×cosθ，也可以通过算式a×b=ax×bx+ay×by计算。 公式的几何意义是：向量a在向量b上的投影。为了让读者更好地理解，形象的表示为一个手电筒照射两个向量，可以看到光束照射的位置就是向量的投影，如图1-11所示。 还有一个问题，为什么是cosθ，看图1-12就会立刻明白了，在使用向量点乘时，必须确保向量是有意义的。 图1-12 向量点乘的计算表示 上面讲述的都是在2D空间上的向量点乘，在Unity游戏开发中可以直接调用Unity提供的库函数Vector2.Dot（Vector2a，Vector2b），返回值是一个float型的数值。接下来介绍向量在3D空间的表示，如图1-13所示。 计算方法跟2D空间是一样的，只是3D空间多了一个z轴。当然，在Unity3D开发中计算点乘不用这么复杂，可以直接使用Unity提供的库函数Vector3.Dot（Vector3a，Vector3b）。之所以介绍这么多也是为了让开发者更容易理解向量的点乘计算。在游戏中，比如玩家转向NPC（非玩家角色）、玩家转向怪物等都与向量的点乘相关，它的游戏效果如图1-14所示。 1.2.4 向量叉乘两个向量叉乘得到的是一个向量，这个向量主要用于表示两个向量的位置关系，比如一个物体是在另一个物体的哪个方位？是前方、后方，还是左方、右方？向量叉乘表示如图1-15所示。 向量叉乘的计算公式是a×b=|a||b|sinθ。其中|a|表示a的长度值，|b|表示b的长度值。θ表示两个向量之间的夹角，a×b得到的是一个垂直于向量a和向量b的向量。在Unity3D空间的表示如图1-16所示。 图1-15 向量叉乘表示 图1-16 向量叉乘计算 假定向量a和向量b始于原点（0，0，0），那么的计算公式如下所示。 通过上面的公式可求出ab的值，以上是理论阐述。在Unity中可以直接调用引擎提供的接口Vector3.Cross（Vector3a，Vector3b）得到值类型是Vector3，也就是垂直于向量a和b的向量。向量叉乘如何在游戏中运用，在一个平面内的两个非平行向量叉乘的结果是这个平面的法向量，这个法向量是有方向的，它的方向可以用“右手定则”来判断。具体的判断方法是：若坐标系是满足右手定则的，当右手的四指从向量a以不超过180°的转角转向向量b时，竖起的大拇指的指向是向量n的方向，也就是上图中的a×b的方向。在右手坐标系中，当向量a和向量b作叉乘运算时，利用“右手定则”可以知道：当法向量n与某一坐标轴同向时，四指方向为逆时针方向；当法向量n与该坐标轴反向时，四指方向为顺时针方向。同时“右手定则”要求转角不超过180°的方向，所以用叉乘判断的转向一定是最优转向（所要转动的角度最小，转动的代价也就最小）。在游戏中可利用这点来判断一个角色是顺时针转动还是逆时针转动才能更快地转向一个敌人，而点乘计算得到的是角度，与叉乘还是有区别的。下面再举个例子给读者讲解一下，如图1-17所示的方向盘转向。 图1-17 方向盘转向 为了便于学习，先把代码给大家展示一下： 123456789101112131415161718192021void RotateWheel (Vector3 pos)&#123; currVec = pos - wheelPos;//计算方向盘中心点到触控点的向量 Vector3 normalVec = Vector3.Cross(currVec, oldVec);//计算法向量 float vecAngle = Vector2.Angle(currVec, oldVec);//计算两个向量的夹角 //使用“右手定则”可知，当大拇指方向指向我们时，四指方向为逆时针方向 //当大拇指方向远离我们时，四指方向为顺时针方向 //这里叉乘后的法向量平行于z轴，所以用法向量的z分量的正负判断法向量方向 if (normalVec.z &gt; 0)//和z轴同向，则顺时针转 &#123; wheelObj.transform.Rotate(Vector3.forward, -vecAngle);//顺时针转 &#125; else if (normalVec.z &lt; 0)//和z轴反向，则逆时针转 &#123; wheelObj.transform.Rotate(Vector3.forward, vecAngle);//逆时针转 &#125; oldVec = currVec;//赋值&#125; 在赛车游戏中通常会用方向盘，以上代码就是运用向量叉乘判断一个方向盘的转向问题，希望读者能够真正掌握向量的基本运算。这些都是最基础的知识，关于向量的运算就给大家介绍到这里，下面开始介绍矩阵运算。 矩阵向量和矩阵是线性代数非常重要的组成部分，3D引擎底层对于矩阵的使用非常多，比如局部坐标到世界坐标的转化、世界坐标到投影坐标的转化等。它们之间的转化是通过与矩阵相乘得到的，这里面就涉及3D固定流水线。作为3D游戏开发者，必须要知道两个流水线：一个是固定流水线，另一个是可编程流水线。下面简单介绍一下二者。先说固定流水线，简单地说就是一个3D物体在显示器上成像的过程，读者可能会有疑问，这与矩阵有什么关系呢？先给大家看一下固定流水线，如图1-18所示。 图1-18 固定流水线 下面介绍一下如何将物体从最初的局部坐标经过一系列矩阵变换转换到另一个坐标系，转换矩阵中最重要的是模型矩阵、视图矩阵、投影矩阵这三个矩阵。首先，顶点坐标开始于局部空间也称为局部坐标，然后经过世界坐标、观察坐标、裁剪坐标，最后以屏幕坐标结束，这些变换最终目的是将物体在屏幕上展现出来，整个流程如图1-19所示。 图1-19 矩阵变换 如果大家还感觉迷惑，我把图1-19再给大家详细解释一遍，为了让读者更好地领会它的含义，我将其总结成以下五点： 局部坐标是对象相对于局部原点的坐标，也是对象开始的坐标。将局部坐标转换为世界坐标，世界坐标是作为一个更大空间范围的坐标系。这些坐标是相对于世界原点的。接下来我们将世界坐标转换为观察坐标，观察坐标是指以摄像机或观察者的角度观察的坐标。在将坐标处理到观察坐标之后，我们需要将其投影到裁剪坐标上。裁剪坐标是在1.0到1.0范围内判断哪些顶点将会出现在屏幕上的。最后，我们需要将裁剪坐标转换为屏幕坐标，我们将这一过程称为视口变换（Viewport Transform）。视口变换将位于1.0到1.0范围内的坐标转换到由视口函数所定义的坐标范围内。转换的坐标将会送到光栅器中，由光栅器将其转化为片段。在这里结合案例给大家描述一下，将上述思想运用到游戏开发中。比如用Unity编辑器搭建一个游戏场景，首先请美工用MAX工具建好需要的模型并将其导成fbx文件格式。建好的模型其实就是一个简单的个体，也就是个体的坐标，即局部坐标，从MAX导出模型时要将其模型位置重置成（0，0，0），然后将其拖放到Unity编辑器里面。在默认情况下，它是与世界坐标系位置重合在世界坐标的（0，0，0）位置上的。因为物体不能都堆放在世界中心点（0，0，0）的位置上，需要拖动将其摆放在编辑器的不同位置上，拖放的过程就是在Unity引擎内部实现一个把模型从局部坐标到世界坐标的变换，这个变换其实就是模型的点与世界矩阵相乘转化到世界坐标上的过程。接下来要在程序中看到这个场景，就需要放置一个虚拟摄像机，将物体放到摄像机里面，这个过程就是把物体从世界坐标转换到观察坐标，这中间是与摄像机矩阵相乘得到的，当然后面就要做消隐，也就是背面消除，因为只能看到物体的正面，背面是看不到的，这也是程序中为了优化效率考虑的，背面不需要绘制。为了使场景明亮，需要打上灯光，场景点亮之后，就可以通过虚拟摄像机来观察虚拟世界了，虚拟摄像机其实跟现实生活中人的眼睛一样。人眼有观察距离，眼睛两侧的物体是看不到的，在虚拟世界中也是一样的，看不到的物体我们就可以将其裁减掉，这里面就涉及观察坐标到透视坐标的转换，为了方便计算将物体做投影计算。为了在显示屏幕上看到，我们将其转化到视口坐标上。最后就是光栅化。这样整个固定流水线就完成了，这中间涉及的变换都与矩阵有关。 再介绍一下可编程流水线。随着硬件的发展，显卡的运算能力得到了很大提升，这也就是通常说的GPU编程。在显卡不发达时，绘制3D物体都是通过固定流水线实现的，随着显卡的提高，就出现了可编程流水线，可编程流水线其实就是把CPU上进行的运算搬到显卡的GPU中运算。也就是说，将矩阵之间的换算放到GPU中计算，这样就可以把CPU解放出来。关于可编程流水线，我会在第14章给大家详细介绍。 矩阵的运算包括矩阵加法、矩阵减法、矩阵乘法等，在游戏开发中使用最多的还是矩阵乘法，本书的编写以实用为主，因此主要介绍矩阵乘法。上面介绍了固定流水线和可编程流水线，矩阵的运用远远不止这些。下面就介绍一下矩阵在Unity编辑器中的使用，在讲解的过程中同时给大家展现一下Unity引擎内部是如何处理的。 平移矩阵在3D空间中，把一个对象从一个位置移到另一个位置，在引擎底层进行了平移矩阵的换算，下面给大家具体讲一下，如图1-20所示。 图1-20 3D空间位置平移 在3D空间中，把对象从P点移动到P’点，运用数学公式，可以计算出二者的转换关系，如下所示。 以上是多项式，根据这个多项式可以将它们换算成一个通用的并且可以使用矩阵表示的公式，如下所示。 细心的读者可能会发现一个问题，在3D空间中，点都是三维的，为什么上面矩阵换算公式是四维的？这涉及齐次坐标的概念，在这里先给大家简单介绍一下。在进行矩阵计算时，需要将三维的点转化成齐次坐标，也就是转化成4D进行计算，因为如果不转换，矩阵的线性变换是很难实现的，比如物体的平移变换、缩放变换等三维矩阵是无法完成的，这个大家可以自己测试一下。 向量和点都是三维的，那怎样区分二者呢？如果使用的是点，那就在点的最后再加一项1，齐次坐标就表示为（x，y，z，1）。如果使用的是向量，那就在向量的最后加一项0，齐次坐标就表示为（x，y，z，0）。但是向量是不可以通过矩阵换算的，点是可以的，所以以上公式表示的都是对三维的点进行换算的。在使用Unity编辑器时，通常会把物体从一个位置移动到另一个位置。由于Unity提供了非常简单的操作方式，初学者只要在编辑器中拖拉一下物体就可以变换位置，也可以单击放大缩小按钮对物体进行缩放操作。在Unity中的操作方式如图1-21所示，此图为将一个白色的物体放到Unity编辑器里面拖放。下面介绍矩阵的另一个运算——缩放。 图1-21 物体位移示意图 矩阵缩放在3D游戏中，经常需要对物体进行缩放变换，先从理论上介绍一下如何缩放，再通过Unity给大家介绍一下。物体的缩放和平移类似，也需要缩放矩阵，如图1-22所示。 图1-22 3D物体缩放示意图 在3D空间中对于物体的缩放并不是凭空产生的，它也是经过运算得到的。运算公式如下所示。 上述公式可以写成矩阵换算，如下所示。 在Unity编辑器的实际操作过程中，引擎为开发者提供了非常便利的接口，只需要在编辑器里面简单操作就可以达到缩放的效果。它实际运行的是调用引擎内部的缩放变换矩阵，也就是用上面的矩阵公式表示的，在Unity中缩放效果如图1-23所示。 两个机器人彼此之间是经过缩放变换大小的，它就是引擎内部通过矩阵缩放实现的，类似的还有矩阵旋转。 图1-23 Unity编辑器中缩放效果 矩阵旋转在3D游戏开发中，游戏中的3D物体旋转可以通过矩阵旋转、四元数旋转、欧拉角旋转得到。在本节中主要介绍矩阵旋转，矩阵旋转最基本的是绕x、y、z轴旋转。矩阵旋转在引擎中使用得比较多，编程时一般采用四元数或者欧拉角实现。下面分别介绍绕x、y、z轴旋转矩阵。绕x轴旋转如图1-24所示。 在这里我直接给出旋转结果矩阵，如下所示。 接下来绕y轴旋转，如图1-25所示。 图1-24 绕x轴旋转 图1-25 绕y轴旋转 绕y轴旋转矩阵如下所示。 绕z轴旋转如图1-26所示。 图1-26 绕z轴旋转 对应绕z轴旋转矩阵如下所示。 以上是矩阵在3D游戏中的计算方式，Unity引擎已经为开发者提供了旋转接口，函数transform.Rotate（newVector3（0，1，0））表示绕y轴旋转，在Rotate函数中使用了向量，它们的参数分别表示x、y、z，上述算式中y的值为1表示的是绕y轴旋转，如果是x轴为1表示的是绕x轴旋转，依此类推。接下来将其在Unity编辑器中的表现给大家展示一下，如图1-27所示。 图1-27 绕x、y、z轴旋转效果图 从右到左依次是正常摆放的角色、绕x轴旋转的角色、绕y轴旋转的角色、绕z轴旋转的角色。虽然通过工具可以很容易地将其旋转，其实在引擎内部是进行了上面列出的关于旋转矩阵的乘法计算。 物体也可以绕x、y、z轴旋转或者x、y轴旋转，它的计算方式就是绕x、y、z轴的矩阵一起相乘，当然Unity也已经为开发者封装好了，开发者只负责使用即可。为什么不厌其烦地介绍这些知识，主要目的是告诉开发者原理，这样更有助开发者编写逻辑。接下来介绍一下四元数。 四元数首先介绍一下什么是四元数，四元数本质上是个高阶复数，表达式为y=a+bi+cj+dk。在讲矩阵时提到了旋转，四元数在Unity里面主要也是用于旋转的，在Unity编辑器里面有个Transform组件，它包括位置（Position）、旋转（Rotation）和缩放（Scale）。Rotation就是一个四元数，但是不能直接对Quaterian.Rotation赋值。可以使用函数Quaterian.Eular（Vector3angle）获取四元数，该函数返回的就是四元数。 欧拉角表示为Quaternion.eulerAngles，欧拉角可以对其进行赋值，赋值表示如下所示。 Quaternion.eulerAngles = new Vector3(0, 30, 0);四元数可以用来进行旋转，它的表达式是Quaternion.AngleAxis（float angle，Vector3axis），调用这个函数可以对物体进行旋转，当然还需要调用函数Quaternion.Lerp（）在旋转时进行插值运算，这些函数都是在编写逻辑时调用的。四元数是不可以直接被赋值的，四元数推理比较麻烦，读者如果想了解可以自己在网上查阅资料，本节的主要目的是告诉读者用四元数解决问题，接下来说一下欧拉角。 欧拉角欧拉角也是用于旋转的，只是它有一个致命的缺点，就是万向节死锁，欧拉角旋转我们在Unity开发中通常使用的函数是transform.Rotate（Vector3angle）。 现在介绍一下万向节死锁，其实就是在3D空间中某两个轴在旋转时重叠了，不论你如何旋转，三个轴就变成了两个轴，给大家举个会出现万向节死锁的例子： transform.Rotate(new Vector3(0, 0, 40));transform.Rotate(new Vector3(0, 90, 0));transform.Rotate(new Vector3(80, 0, 0));我们只需要固定中间一句代码，即使y轴的旋转角度始终为90°，那么你会发现无论怎么调整x轴和z轴的旋转角度，它们会像一个钟表的表针一样总是在同一个平面上运动。 万向节锁中的“锁”，其实是给人一种误导，这可能也是让很多人觉得难以理解的一个原因。实际上，它并没有锁住任何一个旋转轴，只是在这种旋转情况下我们会感觉丧失了一个维度。以上面的例子来说，尽管固定了第二个旋转轴的角度为90°，但我们原以为依靠改变其他两个轴的旋转角度是可以得到任意旋转位置的（因为按我们的理解，两个轴应该控制的是两个空间维度），而事实是它被“锁”在了一个平面上，即只有一个维度了，缺失了一个维度。而只要第二个旋转轴不是±90°，我们就可以依靠改变其他两个轴的旋转角度来得到任意旋转位置。 从最简单的矩阵来理解，还是使用x、y、z的旋转顺序。当y轴的旋转角度为90°时，我们会得到下面的旋转矩阵。 我们对上述矩阵进行左乘可以得到下面的结果： 当我们改变第一次和第三次的旋转角度时，是同样的效果，而不会改变第一行和第三列的任何数值，从而缺失了一个维度。我们再尝试着理解下它的本质，万向节锁出现的本质原因，是因为从欧拉角到旋转的映射并不是一个覆盖映射，即它并不是在每个点处都是局部同胚的。通俗地解释一下，这意味着从欧拉角到旋转是一个多对一的映射（即不同的欧拉角可以表示同一个旋转方向），而且并不是每一个旋转变化都可以用欧拉角来表示。 小结数学的基础知识已经给大家讲完了，这些最基本的数学知识开发者要熟练掌握。对于图形学的一些高级算法大家有兴趣可以学习一下，用得比较多的是贝济埃曲线、B样条曲线等，二者都可以应用到刀光拖尾算法、曲线插值算法中。在Unity中有iTween曲线插件和DotTween曲线插件等，下面开始讲解开发3DMMORPG游戏经常使用的Avatar换装开发技术。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity 3D实战核心技术详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建一个让你置身3D空间的演示-3]]></title>
    <url>%2F2019%2F04%2F04%2F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AE%A9%E4%BD%A0%E7%BD%AE%E8%BA%AB3D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%BC%94%E7%A4%BA-3%2F</url>
    <content type="text"><![CDATA[键盘输入组件：第一人称控件 玩家需要响应键盘输入移动。下面编写键盘控件组件来补充鼠标控件组件；新创建一个称为FPSInput的C#脚本并把它附加到玩家上，目前暂时设置Mouselok组作只做水平旋转。使用之前的旋转代码，并做些许修改 123456789101112using UnityEngine;using System.Collections;public class FPSInput : MonoRehaviour&#123; public float speed = 6.0f; // 不是必要的,但是你可能想要递增速度 void Update() &#123; transform.Translate(0, speed, 0); // 修改Rotate()为Translate() &#125;&#125; 响应按下的键根据按下的键来移动的代码和根据鼠标旋转的代码是相似的，这里也以相似的方式使用GetAxis()方法。如下代码展示了如何使用GetAxis命令。 响应按键的位移 123456void Update()&#123; float deltaX = Input.GetAxis("Horizontal") * speed; // Horizontal和Vertical是键盘映射的间接名称 float deltaZ = Input.GetAxis("Vertical") * speed; transform.Translate(deltaX, 0, deltaZ);&#125; 为了确定运动量，GetAxis()的值乘以一个速度。然而请求的轴都是”Mousesomething”，现在我们传入Horizontal或Vertical。这些名称是Unity中输入设置的抽象；如果查看Editor菜单下的Project Settings中的Input菜单，将发现抽象输入名称和映射到那些名称的具体控件的列表。左/右箭头按键和字母键AD都映射到Horizontal，而所有的up/down箭头按键和字母键W/S都映射到Vertical。 注意，运动的值应用到X和Z坐标。正如你可能在Translate()实验中观察到的一样，X坐标从屏幕一边移动到另一边，Z坐标从前面移动到后面。 输入这些新的移动代码，你将能通过按下箭头键或WASD字母键四处移动，这和大多数FPS游戏的标准一样。移动脚本几乎完成了，但我们还要做一些调整。 设置独立于计算机运行速度的运动速率现在还不明显，因为你只是在一台（你自己）的电脑上运行代码，但如果在不同的机器上运行代码，则会以不同的速度运行，这就是为什么一些计算机处理代码和图形的速度比其他的变快的原因所在。现在玩家在不同的计算机上会以不同的速度移动，因为移动代码是根据计算机的速度决定的。这称为帧率依赖（frame rate dependent），因为移动代码是依赖于游戏的帧率。 例如，想象你在两台不同的计算机上运行这个示例，一个是30fps（frames per second，帧每秒）而另一个是60fps。这意味着在第二台计算机上Update()将会被调用两倍，而相同的速度值6将会在每帧被应用。在30fps机器上的移动将会是180单位/秒，而在6ofps的机器上移动速度则是360单位/秒。对于大多数游戏而言，这样带来的速度不同其实并不是一件好事情。 解决方案是调整运动代码，使得它和频率独立，这意味着移动速度不依赖游戏的帧率。为此就不能在每帧应用相同的速度值。而是根据计算机运行的快慢缩放速度，使得更快或更慢，这通过把速度值和另一个称为deltaTime的值相乘来实现。 使用deltaTime使得运动独立于帧率 123456void Update()&#123; float deltaX = Input.GetAxis("Horizontal") * speed; float deltaZ = Input.GetAxis("Vertical") * speed; transform.Translate(deltaX * Time.deltaTime, 0, deltaZ * Time.deltaTime);&#125; Time类有一些用于计算时间的属性和方法，而其中就包括属性deltaTime。因为我们知道delta意味着变化量，所以这说明deltaTime是时间的变化量。明确地说，deltaTime是经过两帧之间的时间。不同的帧率两帧之间的时间是不同的（例如，30fs是每秒中的deltaTime为1/30），所以通过把速度值乘以deltaTime将使得速度值在不同计算机上缩放。 现在移动速度在所有的计算机上都是一样的，但是移动代码还没有全部完成；当你移动到房间时还能穿过墙，因此我们需要调整代码来阻止这种情况。 为了碰撞检测，移动CharacterController直接修改对象的变换不会应用碰撞检测，因此角色将穿过墙。为了应用碰撞检测，需要使用CharacterController来替代。CharacterController是一个让对象移动起来更像是角色在游戏中一样的组件，包括和墙壁碰撞。回想一下，我们设置玩家时，附加了一个CharacterController。所以现在将使用该组件来处理FPSInput中的移动代码。 使用CharacterController而不是Transform移动 123456789101112131415161718private CharacterController _charController; // 用于引用CharacterController的变量 void Start() &#123; _charController = GetComponent&lt;CharacterController&gt;(); // 使用附加到相同对象上的其他组件&#125;void Update() &#123; float deltaX = Input.GetAxis("Horizontal") * speed; float deltaZ = Input.GetAxis("Vertical") * speed; Vector3 movement = new Vector3(deltaX, 0, deltaZ); movement = Vector3.ClampMagnitude(movement, speed); // 将对角移动的速度限制为和沿着轴移动的速度一样 movement.y = gravity; movement *= Time.deltaTime; movement = transform.TransformDirection(movement); // 把movement向量从本地变换为全局坐标 _charController.Move(movement); // 告知CharacterController通过movement向量移动&#125; 这段代码引入一些新概念。第一个要指出的概念是引用CharacterController的变量。这个变量简单创建一个到对象的本地引用；多个脚本都能引用这个CharacterController实例。 变量开始是空的，因此在你使用这个引用之前需要将一个对象赋值给它，让它指向对象。这就是下面GetComponent()的作用，这个方法返回附加到相同GameObjet上的其他组件。不是将参数传入圆括号中，而是使用C#在尖括号&lt;&gt;中来定义类型的语法。 一旦拥有了CharacterCantroller引用，就能调用控制器的Move()方法。向Move()传入一个向量，就像鼠标旋转代码使用一个向量作为旋转值一样。同时像限制旋转值一样，使用Vector3.ClampMagnitude()限制向量的大小为移动速度，在此使用clamp，否则对角线的movement将会比沿着轴移动的大（想象直角边和直角三角形的斜边）。 但此处的移动向量还有一个棘手的地方，如之前讨论旋转时，需要指明基于本地坐标还是全局坐标工作，我们创建一个向量用于移动，并告诉它左移。这里是指玩家的左边，然而，它可能和世界的左边完全不同。即我们讨论的左边是本地空间中的，而不是全局空间中的。我们需要给Move()方法传入一个定义在全局空间中的移动向量，因此需要把本地空间向量转为全局空间的向量。转换是一个很复杂的数学过程，但我们很幸运，Unity已经帮我们完成了这个数学过程，而我们只需要简单调用方法TransformDirection()就可以变换方向。 Transform（变换）作为一个动词意味着从一个坐标空间转换为另一个坐标空间。不要对变换的其他定义感到困惑，包括Transform组件和移动场景这个行为。它们是这个术语的一些重载，因为所有这些都指向同一个基本概念。 设置MouseLook组件为同时水平和垂直旋转。可以通过键盘控制浏览整个场景并在场景中飞来飞去。 调整组件为走路而不是飞翔现在碰撞检测已经奏效，脚本能有一个重力而玩家将一直停留在地面。声明一个重力变量并把这个重力变量赋值给Y轴。 123456public float gravity = -9.8f;...void Update()&#123; ... movement = Vector3.ClampMagnitude(movement, speed); movement.y = gravity; // 使用重力值而不只是0 现在玩家身上有一个固定的向下的力，但它不是永远竖直向下的，因为玩家对象能通过鼠标上下倾斜。幸运的是，我们需要修复的东西已经有了，因此只需要对玩家身上组件的设置进行些许调整即可。首先设置玩家身上的MouseLook仅仅为水平旋转。接着给Camera对象添加一个MouseLook组件，并设置它为垂直旋转。现在，你已经有两个响应鼠标的不同对象! 因为玩家对象现在只能水平旋转，所以不再有竖直向下的重力被倾斜的问题。Camera对象的父对象是玩家对象，所以尽管它独立于玩家垂直旋转，但摄像机还是会跟着玩家做水平旋转。 使用RequireComponent()方法确保脚本附加了其他需要的组件。有时一些组件是可选的（也就是，代码指明“如果附加了这个组件，则。。。），但有时你想强制让这个组件依赖其他组件。在脚本的顶部添加RequireComponent()方法来执行这种依赖并把需要的组件作为参数。 与此类似，如果将方法AddComponentMenu()添加到脚本的顶部，脚本将在Unity编辑器中添加组件菜单。若将你想添加菜单告诉命令，那么当单击Inspector底部的AddComponent时就能选择这个脚本。 1234567891011121314151617181920212223242526272829303132using UnityEngine;using System.Collections;// basic WASD-style movement control// commented out line demonstrates that transform.Translate instead of charController.Move doesn't have collision detection[RequireComponent(typeof(CharacterController))][AddComponentMenu("Control Script/FPS Input")]public class FPSInput : MonoBehaviour &#123; public float speed = 6.0f; public float gravity = -9.8f; private CharacterController _charController; void Start() &#123; _charController = GetComponent&lt;CharacterController&gt;(); &#125; void Update() &#123; //transform.Translate(Input.GetAxis("Horizontal") * speed * Time.deltaTime, 0, Input.GetAxis("Vertical") * speed * Time.deltaTime); float deltaX = Input.GetAxis("Horizontal") * speed; float deltaZ = Input.GetAxis("Vertical") * speed; Vector3 movement = new Vector3(deltaX, 0, deltaZ); movement = Vector3.ClampMagnitude(movement, speed); movement.y = gravity; movement *= Time.deltaTime; movement = transform.TransformDirection(movement); _charController.Move(movement); &#125;&#125; 小结 3D坐标空间由X、Y、Z轴定义 房间中的对象和灯光构成场景 第一人称场景中的玩家本质上是一个摄像机 移动代码不停地在每帧应用小的变换 FPS控件由鼠标旋转和键盘移动构成]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5实战-使用C#和Unity开发多平台游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建一个让你置身3D空间的演示-2]]></title>
    <url>%2F2019%2F04%2F04%2F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AE%A9%E4%BD%A0%E7%BD%AE%E8%BA%AB3D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%BC%94%E7%A4%BA-2%2F</url>
    <content type="text"><![CDATA[用于观察周围的组件脚本：MouseLook 现在你将响应鼠标的输入来进行旋转（就是说，旋转的对象是这个脚本附加到的对象，在这个例子中即玩家）。首先玩家只能从一边旋转到一边，然后玩家能上下旋转。最后玩家能观察任意方向（水平旋转的同时也能垂直旋转），这个行为称为鼠标观察（mouse-look）。 考虑到有三种不同类型的旋转行为（水平、垂直、水平且垂直），首先将编写支持这3种旋转行为的框架。创建新的C#脚本，命名为MouseLook。 使用枚举设置旋转类型的Mouselook框架 12345678910111213141516171819202122232425262728using UnityEngine;using System.Collections;public class MouseLook : MonoBehaviour &#123; // 定义枚举数据结构，将名称和设置关联起来 public enum RotationAxes &#123; MouseXAndY = 0, MouseX = 1, MouseY = 2 &#125; public RotationAxes axes = RotationAxes.MouseXAndY; // 声明一个公有变量，以便能在Unity编辑器中对其进行设置 void Update() &#123; if (axes == RotationAxes.MouseX) &#123; // 此处仅放置水平旋转的代码 &#125; else if (axes == RotationAxes.MouseY) &#123; // 此处仅放置垂直旋转的代码 &#125;else &#123; // 此处放置水平且垂直旋转的代码 &#125; &#125;&#125; 注意，枚举是用于MouseLook脚本选择水平或垂直旋转。定义枚举（enum）数据类型允许你使用名称设置值，而不是输入数字并且尝试记住每个数字的意义（水平旋转是0？还是1？）。如果接着声明一个公有变量类型为枚举，它将作为下拉菜单显示在Inspector中，这有利于选择设置。 移除Spin组件并将这个新的脚本添加到player对象上。使用Inspector中的Axes下拉菜单切换旋转的方向。设置horizontal/vertical旋转后，就能为每个条件分支填充代码。 跟踪鼠标运动的水平旋转第一个且最简单的分支是水平旋转。先使用Spin中用来让对象旋转的一样的命令。不要忘记用旋转的速度声明一个公有变量；在axes之后，Update()之前声明一个新变量，并把该变量命名为sensitivityHor，因为一旦涉及多个旋转速度，speed这个词就太通用了。这次把这个变量的值增加到9，因为一旦代码启用缩放，就需要这个值更大（这将会旋转得更快）。调整后的代码类似于如下代码。 设置MouseLook组件的Axes菜单为水平旋转并运行脚本；视图将如之前一样旋转。下一步是让旋转响应鼠标的运动，那么让我们介绍一个新方法：Input.GetAxis()。Input类有一系列方法用于处理输入设备（例如鼠标），而方法GetAxis()返回和鼠标运动相关的数字（是正数还是负数，取决于移动的方向）。GetAxis()需要轴向的名称作为参数，而水平轴称为Mouse X。 水平旋转，还没响应鼠标 12345678910public RotationAxes axes = RotationAxes.MouseXAndY;public float sensitivityHor = 9.0f; // 为旋转的速度声明一个变量void Update()&#123; if (axes == RotationAxes.MouseX) &#123; transform.Rotate(0, sensitivityHor, 0); // 在此放置旋转代码，因此它能在每帧运行 &#125;&#125; 如果将旋转速度乘以轴向的值，旋转将响应鼠标的移动。速度将根据鼠标的移动旋转，缩小到0甚至是相反方向。Rotate命令现在看起来如下所示。为响应鼠标而调整后的旋转命令 1transform.Rotate(0, Input.GetAxis("Mouse X") * sensitivityHor, 0); // 注意使用GetAxis()获取鼠标的输入 单击Play按钮并四处移动鼠标。随着你把鼠标从一边移向另一边，视角也将会从一边旋转到另一边。下一步介绍垂直旋转而不是水平旋转。 在一定范围内的垂直旋转我们已经使用Rotate()方法用于水平旋转，但对于垂直旋转我们将使用不同的方法。尽管Rotate()方法对于应用变换很方便，但它不太灵活。它仅对没有限制地增加旋转有用，对于水平旋转它工作得很好，但垂直旋转需要限制视野能看多低或多高。如下展示了MouseLook中垂直旋转的代码。 1234567891011121314151617181920212223public float sensitivityHor = 9.0f;public float sensitivityVert = 9.0f; // 为垂直旋转声明一个变量public float minimumVert = -45.0f;public float maximumVert = 45.0f;private float _rotationX = 0; // 为垂直角度声明一个私有变量void Update()&#123; if (axes == RotationAxes.MouseX) &#123; transform.Rotate(0, Input.GetAxis("Mouse X") * sensitivityHor, 0); &#125;else if (axes == RotationAxes.MouseY) &#123; _rotationX -= Input.GetAxis("Mouse Y") * sensitivityVert; // 鼠标增加垂直角度 _rotationX -= Mathf.Clamp(_rotationX, minimumVert, maximumVert); // 将垂直角度限制在最小值和最大n之间 float rotationY = transform.localEulerAngles.y; // 保持Y的角度一样（也就是水平没有旋转） transform.localEulerAngles = new Vector3(_rotationX, rotationY, 0); // 使用存储的旋转值创建新的Vector &#125;&#125; 设置MouseLook组件的Axes菜单为垂直旋转并运行新脚本。现在视图不会往两侧旋转，但当你上下移动鼠标时它会上下倾斜。在上下限的位置停止倾斜。 首先，这次没有使用Rotate()，所以需要一个变量（这里为_rotationX，因为它用于保存沿着X轴的垂直旋转）来保存旋转的角度。Rotate()方法增加当前的旋转，然后这段代码直接设置旋转的角度。换句话说，它的区别是“给角度增加5”和“设置角度为30”。我们依然需要增加旋转角度，这就是为什么代码有-=操作符：从旋转角度减去一个值，而不是设置旋转角度为那个值。若不使用Rotate()，我们就能以除了增加旋转之外的不同方式自己处理旋转角度。像水平旋转的代码一样旋转值乘以Input.GetAxis()，只是现在我们要求的是MouseY，因为它是鼠标的垂直轴。 第二行进一步处理了旋转角度。我们使用Mathf.Clamp()将旋转角度保持在minimum和maximum之间。在之前代码声明的公有变量中声明了这些变量，它们确保视角只能上下倾斜45°。Clamp()方法不只是针对角度，它通常在确保一个数字在限制范围内时很有用。如果想查看Clamp()方法的作用，可以尝试注释掉Clamp()那一行；现在倾斜不会在上下限停止，你甚至可以完全旋转到上下颠倒！显然，看到世界颠倒这不符合需求，因此要对旋转进行限制。 由于transform的angles属性是一个Vector3，因此需要使用传给Vector3构造方法的角度值来创建一个新的Vector3。Rotate()方法会自动帮我们处理这一步，递增旋转角度并创建一个向量。 向量把多个数字存储为一个单元。例如，Vector3有3个数字（称为X，Y，Z）。 我们需要创建一个新的Vector3而不是修改transform已经存在的向量值，因为transform的那些值是只读的。这是一个常犯的错误。 欧拉角（Euler angle）和四元数（Quaternion）你可能想知道为什么属性命名为localEulerAngles而不是localRotation。首先，你需要知道四元数的概念。 四元数是一种描述旋转的不同的数学概念，它和我们之前讨论的X轴、Y轴、Z轴的欧拉角不同。还记得航向偏角、偏航和侧滚的讨论吗？很好，描述旋转的方法便是欧拉角。四元数和欧拉角不同，很难解释四元数是什么，因为它是高等数学中一个晦涩的概念，涉及通过四维表示运动。 对于为什么四元数用于表示旋转有个比较简单的解释：使用四元数在旋转值之间插值（就是通过一些中间值来慢慢从一个值变为另一个值）看起来更平滑和自然。 回到最初的问题，这是因为localRotation是一个四元数，而不是欧拉角。而Unity也提供欧拉角属性让处理旋转更容易理解；因此使用localEulerAngles命名旋转属性。欧拉角属性和四元数之间可以来回自动转换。Unity在应用场景背后帮你处理了数学难题，因此你不必担心自己去处理。 MouseLook还有一个旋转设置需要编写代码：同时水平和垂直旋转。 同时水平和垂直旋转这最后一块代码也不使用Rotate()，其原因和前面介绍的一样：垂直旋转角度在递增之后要限制在某个范围内。这意味着水平旋转现在也需要直接计算。记住Rotate()是自动处理递增旋转角度的。 123456789&#123; _rotationX -= Input.GetAxis("Mouse Y") * sensitivityVert; _rotationX = Mathf.Clamp(_rotationX, minimumVert, maximumVert); float delta = Input.GetAxis("Mouse X") * sensitivityHor; // delta是旋转的变化量 float rotationY = transform.localEulerAngles.y + delta; // 使用delta递增旋转角度 transform.localEulerAngles = new Vector3(_rotationX, rotationY, 0);&#125; 处理rotationX的前几行代码完全和上一部分一样。只是要记住沿着对象x轴的旋转是垂直旋转。因为水平旋转不再通过Rotate()方法处理,这就是delta和rotationy的作用所在. delta是一个通用的数学术语,用于描述“变化量”,因此dela计t算的正是应该改变的角度,接着把变化量加到当前的旋转角度上,这样就获取了最新的旋转角度。 最后沿着水平轴和垂直轴旋转的角度值,都被用于创建一个新的向量,接着将它赋值给变换组件的角度属性。 禁止对玩家进行物理旋转 尽管这个项目还不需要,但在大多数现代FPS游戏中,场景中的所有事物都会受到复杂物理仿真的影响,这会导致对象被弹开和跌倒,这种碰撞的行为看起来不错且能很好地处理大多批对章,但玩家的旋转需要单独由鼠标拉制并且不能受物理仿真的影响。 因此,鼠标输入脚本通常设置玩家的Rigidbody的freezeRotation属性,将下面的Star()方法添加到MouseLook脚本: 1234567void Start() &#123; // Make the rigid body not change rotation Rigidbsody body = GetComponent&lt;Rigidbody&gt;(); if (body != null) &#123; // 检查这个组件是否存在 body.freezeRotation = true; &#125;&#125; Rigidbody（刚体）是对象能拥有的一个额外组件。物理仿真作用于刚体并处理它们接触到的对象。 完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859using UnityEngine;using System.Collections;// MouseLook rotates the transform based on the mouse delta.// To make an FPS style character:// - Create a capsule.// - Add the MouseLook script to the capsule.// -&gt; Set the mouse look to use MouseX. (You want to only turn character but not tilt it)// - Add FPSInput script to the capsule// -&gt; A CharacterController component will be automatically added.//// - Create a camera. Make the camera a child of the capsule. Position in the head and reset the rotation.// - Add a MouseLook script to the camera.// -&gt; Set the mouse look to use MouseY. (You want the camera to tilt up and down like a head. The character already turns.)[AddComponentMenu("Control Script/Mouse Look")]public class MouseLook : MonoBehaviour &#123; public enum RotationAxes &#123; MouseXAndY = 0, MouseX = 1, MouseY = 2 &#125; public RotationAxes axes = RotationAxes.MouseXAndY; public float sensitivityHor = 9.0f; public float sensitivityVert = 9.0f; public float minimumVert = -45.0f; public float maximumVert = 45.0f; private float _rotationX = 0; void Start() &#123; // Make the rigid body not change rotation Rigidbody body = GetComponent&lt;Rigidbody&gt;(); if (body != null) body.freezeRotation = true; &#125; void Update() &#123; if (axes == RotationAxes.MouseX) &#123; transform.Rotate(0, Input.GetAxis("Mouse X") * sensitivityHor, 0); &#125; else if (axes == RotationAxes.MouseY) &#123; _rotationX -= Input.GetAxis("Mouse Y") * sensitivityVert; _rotationX = Mathf.Clamp(_rotationX, minimumVert, maximumVert); transform.localEulerAngles = new Vector3(_rotationX, transform.localEulerAngles.y, 0); &#125; else &#123; float rotationY = transform.localEulerAngles.y + Input.GetAxis("Mouse X") * sensitivityHor; _rotationX -= Input.GetAxis("Mouse Y") * sensitivityVert; _rotationX = Mathf.Clamp(_rotationX, minimumVert, maximumVert); transform.localEulerAngles = new Vector3(_rotationX, rotationY, 0); &#125; &#125;&#125; 当设置Axes菜单并运行新代码时，可以移动鼠标时观看周围所有方向。但你依然卡在一个地方，好像被固定在一个炮塔上。下一步是在场景中移动。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5实战-使用C#和Unity开发多平台游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光照烘焙技术-2]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%85%89%E7%85%A7%E7%83%98%E7%84%99%E6%8A%80%E6%9C%AF-2%2F</url>
    <content type="text"><![CDATA[本章涵盖： “高动态光照”反射探头技术 Light Probes概述 “高动态光照”反射探头技术在现实世界中，当太阳光照到场景物体上时，物体会有一些间接光反射到地面上，或者地面上的光反射到物体上，或者物体与物体之间光反射。在Unity中反射探头技术使我们可以模拟自然界中光线与光线之间的相互融合的特点，使物体可以接受其他物体光源的影响，这样可以更好地模拟自然界的光照的特点。 在Hierarchy视图中添加Reflection Probe，如下图所示。 添加Reflection Probe以后，场景中会出现一个圆球，圆球外围会有一个Box形状的框，框内的场景都会受到Reflection Probe的影响。我们可以通过Inspector面板更改Reflection Probe的属性，如下图所示。 通过调整边界按钮和调整位置按钮，调整Reflection Probe的探索范围，使探索范围在Refletion Probe的包围范围之内，如下图所示，Refletion Probe可以更好地模拟范围内物体与物体之间间接光的影响。 设置好Reflection Probe以后还需要再设置两个步骤才能实现光照探头效果。第一，场景中静态物体还需要再烘焙一次。选中场景中的静态物体，单击Lighting面板上的“Build”按钮，烘焙完成以后在Project视图文件夹中会生成一个名称为ReflectionProbe-0的反射探头贴图文件，如下图所示。 第二，生成反射探头贴图以后，还需要单击Lighting面板的“Bake Reflection Probes”（烘焙反射探头）按钮，如下图所示。 完成烘焙反射探头以后，选中Reflection Probes会发现它已经能反射周围的环境，如下图所示。 选择Directional Light，把Mode模式设置为Realtime，通过调整Bounce Intensity的大小，就可以很好地模拟出物体与物体间接光相互的影响。 Light Probes概述尽管使用光照贴图可以大大提升场景的真实程度，但是它有一个缺点，那就是场景中非静态物体缺少真实的渲染，看上去就好像和场景格格不入。实时为移动物体计算光照贴图是不可能的，但是通过使用灯光探测器我们可以模拟类似的效果。 原理在场景中的标记为探测器的静态点的位置采样光照，然后对相邻几个光照探测器位置所采样的灯光照明进行差值，在游戏进行的过程中计算差值的速度很快，玩家察觉不到。这样就可以帮助我们避免移动物体的光照和烘焙场景格格不入的感觉。 优点 1.性能佳，对比实时阴影性能高很多，适合移动平台。 2.配合烘焙，配合烘焙效果很好。 3.可视化，可以可视化编辑Light Probes的分布，不需要代码。 缺点 1.烘焙后才能有效果，不能实时改变。 2.只能整体进行明暗变化。 使用如场景里面有一个烘焙好的简单场景，有一个第三人称控制器，第三人称控制器是作为动态物体的存在。 由于动态物体不受烘焙的影响，所以第三人称控制器和场景格格不入，如下图所示。 添加灯光探测器，打开菜单栏中的GameObject-&gt;Lighting-&gt;Light Probe Group选项，如下图所示。 在Light Probe Group选项里面，有添加、选择、删除和复制探头的按钮，如下图所示。 单击“Add Probe”按钮添加探头，放一些探头在场景里面，也可以建一个，然后复制多几个。探测器在场景中用黄色的球体表示，并且可以像其他游戏物体那样编辑移动它的位置，被选择的探测器可以通过键盘快捷键进行复制。最简单的方法为，先在各个角落放一个，把一定范围内的场景包起来。只要选择了Light Probe物体，那么这些探头点就可见，直接用鼠标点选这些探头，可以使用位移工具来移动它们，如下图所示。 在烘焙之前，还需要把场景中的静态物体再烘焙一遍，烘焙之前把Baking模式改变为Baked，然后单击Lighting面板上的“Build”按钮来烘焙场景。烘焙完成以后，Light Probes Group探头点变为白色，烘焙完成，如下图所示。 单击开始游戏按钮，按W、A、S、D键移动第三人称控制器，我们可以发现人物的颜色已经受到环境的影响而发生变化了，这就是说明第三人称控制器受到了Light Probe影响了，如下图所示。 小结Light Probe Group是Unity里面专用于模拟物体靠近发光或反射光物体时，在物体表面映射出发光或反射光物体的颜色。但Light Probe Group在Unity中并不作为实时光的补充部分，而是作为Power VR光源追踪技术和实时全局光照的补充。在进行实时检测之前，必须要添加LightProbe Group，在添加之后会出现许多的圆形探头，用于检测哪些发光或反射光物体周围光的颜色以及强度，所以对这些探头位置的摆放直接关系到后面的检测效果，如果探头的数量不够用，在监视面板中单击“Add Probe”按钮来添加探头的数量。接着就是调出Lighting面板，单击“Build”按钮进行烘焙处理。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X 完全自学手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光照烘焙技术-1]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%85%89%E7%85%A7%E7%83%98%E7%84%99%E6%8A%80%E6%9C%AF-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.光的3个基本组成部分是哪些？2.光有几种渲染模式？区别在哪？3.提升阴影画面质量和性能有哪两种方法？4.Shadow Cascade是数量越低效果越好吗？在Scene怎么查看？3.Pixel Light Count是干嘛用的？ 本章涵盖： 光照基础 光的使用 阴影 渲染模式 光照烘焙技术在Unity 4.x中是基于Beast插件技术实现的，但是，Beast只能烘焙静态的光照贴图，而不支持动态光照，烘焙过程耗时过长，还不一定得到正确的结果，势必会影响工作效率。而新版Unity 5.x则更新为PowerVR Ray Tracing方法与Enlighten的混合方法实现，使得光照烘焙的质量与烘焙的效率有了进一步的增强。 Unity 5.x光照烘焙参数选中要烘焙的物体，勾选Inspector面板的Lightmap Static选项，设置为静态物体。 从菜单中选择Window-&gt;Lighting，打开Lighting窗口。 静态物体参数 Lightmap Static：（确认）必须把烘焙的物体设置成静态。Scale in Lightmap：数值的大小与该物体的表面积有关，这个值影响烘焙时间，值越大时间越长。 Scene面板参数 1.Environment Lighting：控制场景总体的光线信息，包括天空盒的设置，可以赋予一个天空盒材质。2.Skybox：天空盒，会直接影响环境光。3.Sun：如果天空盒材质是SkyboxProcedural，那么这里允许指定一个Directional Light。4.Ambient Source：环境源一般都是天空盒，天空盒会在游戏运行中实时变化。5.Ambient Intensity：环境光的强度值，也就是环境光的亮度值。6.Reletion Source：射源，烘焙后会在场景文件的同名文件夹中多出一个名为LightmapSnapshot的文件。7.Reflection Bounces：当使用Reflection Probe时，最多允许镜面来回反弹几次。8.Realtime Resolution：实时分辨率，物体所产生的GI对其他物体的影响程度，值越大影响越大。9.CPU Usage：一般场景先选择默认项即可（Low、Medium、High、Unlimited）10.Baked Resolution：烘焙分辨率，如果数值是40，那么就是每个单位里分布40个纹理元素。11.Baked Padding：防止光照贴图的像素在物体之间溢出。12.Compressed：是否压缩光照贴图，提高性能，缩小容量，但画质会降低。13.Final Gather：开启后效果有很大的提升，但是会让烘焙变慢。14.Indireet Intensity：间接强度，可以简单地理解为光的反射强度。15.Bounce Boost：反弹强度，同一单位面积内增大光的反射数量，相比较来说，这个值增大会直接影响渲染时间。16.Default Parameters：默认参数，这里还可以创建自己的参数。17.Atlas Size：烘焙图的大小。 实时全局光照Enlighten是目前业界唯一一款能够在PC和移动平台上全部做到实时全局光照的引擎，包括运动光源、发光材质、环境光照都可以采用动态实时的方式进行控制。其基本原理是全局辐射度的算法，能够实时计算LightMaps和LightProbes，我们采用从底层API方面的结合，在使用Enlighten的时候，完全不觉得它是第三方的插件，而是Unity引擎内部所嵌入的一个核心功能。实时全局光照是Unity默认的光照渲染方式，在Unity中有一个Main Camera，一个Directional Light，一个Cube和Plane组成的简单场景。当我们转动Light的时候，Unity界面的右下角就会出现一个进度条，如下图所示，相当于在计算机内部做了一个实时的计算。 单击菜单中Window菜单中的Lighting选项，打开Lighting面板，在Lighting面板上有一个Continous Baking实时烘焙选项，通过取消打钩来关闭实时烘焙。再移动直线光的方向，就不会出现如上图所示的进度条，这样就关闭了实时烘焙。 Unity对环境的模拟也是十分不错的，当转动Directional Light的光线的时候，Unity场景的环境也会发生变化。当光线与地面平行的时候就会模拟出黄昏的场景，如果Directional Light的光线向上照的时候，就相当于光线没有照到地球，天空就会成为黑色。如果Directional Light的光线向下照的时候，就可以模拟出白天的场景。 在Unity 5.x中，Directional Light面板上多出了Baking（烘焙的类型）和Bounce Intensity（反弹强度）两个参数，如下图所示。 Baking选项:通过选择Baking,可以选择用哪种方式烘培。1.Realtime：全局实时光照。2.Baked：烘焙光照。3.Mixed：混合。 实时光照贴图预览Unity 5.x导入了PowerVR光源追踪技术。这为游戏带来更即时的交互光源追踪代表未来透过编辑器的场景视图就可以看到游戏中最后的光照贴图精确预览，这个功能所见即所得地回馈全局光源所产生的光照贴图。利用此技术，美工可继续迭代和细化关卡外观，同时在背景中更新和烘焙最终光照贴图，从而大量减少调整场景艺术效果所需的时间。 实时全局光照技术比较消耗系统性能，移动端使用实时全局光照会使效率下降，所以我们要对场景进行烘焙处理。 选中场景中静态的物体，在Inspector面板中，把这些物体标记为Static（静态），告诉Unity这些对象不会移动或更改，可进行光照贴图。 选中场景中静态的物体，在lighting面板中选择Object，查看Lightmap Static、Preserve UVs是否勾选，根据场景大小调整Scale In Lightmap的参数值。 做好前期准备以后，选中Directional Light，从菜单中选择Window-&gt;Lighting，打开Lighting面板，选择Object。设置Baking为Baked模式，如下图所示，同时取消勾选Continuous Baking选项，不进行实时光照贴图预览。 单击上图所示的“Build”按钮进行烘焙贴图。Unity编辑器的状态栏上出现个进度条，烘焙时间由场景大小决定，我们的场景很小所以很快。 烘焙完成时，会在Project视图出现一个与场景名称一致的文件夹用来存放正式的光照烘焙贴图，如下图所示。此时就可以把Directional Light禁用。场景内容和Directional Light禁用前的效果是一样的，场景完成烘焙。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X 完全自学手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI游戏界面-3]]></title>
    <url>%2F2019%2F04%2F04%2FUGUI%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2-3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Canvas组件是UI的基础画布，所有UI元素都必须放在Canvas对象下面，并且它支持嵌套。Canvas支持3种绘制方式--Overlay（最上层）、Camera和World Space（3D）布局，其中用得最多的是Canvas，它可以把正交摄像机投影出来的UI元素绘制在Canvas面板上。 Canvas组件自适应屏幕锚点对齐方式Atlas]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI游戏界面-2]]></title>
    <url>%2F2019%2F04%2F04%2FUGUI%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2-2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 实现UGUI按钮点击事件有几种方式？怎么操作？ 接口形式引入什么命名空间？ UGUI所有的事件系统都是依赖EventSystem组件来完成的，Unity新版的事件系统已经全面代替了之前的SendMessage系统了。操作的事件是非常庞大的。鼠标、键盘和手势能产生太多事件了，而且不同的UI操作事件还不太一样。就拿按钮来说，点击事件、按下事件和抬起事件都各不相同。可想而知，所有的UI系统加在一起能产生的事件将有多少。需要在全局添加一个EventSystem对象，运行起来后，在面板中还可以查看操作的一些详细信息，便于日后调试。 事件系统不仅会抛出点击一类的事件，还可以取到最基本的操作信息，例如鼠标在屏幕中的坐标、滑动开始的坐标以及滑动结束的坐标等。新版的EventSystem不仅供UI使用，3D游戏对象也可以使用它，并且使用方法都比较接近。 UI事件UI事件依赖于Graphic（图解的） Raycaster组件，如下图所示，它必须绑定在Canvas组件上，表示这个Canvas下所有UI元素支持的事件。比如游戏中同时有很多Canvas，如果想让游戏中某些UI不可接收点击事件，那么可以考虑把部分Canvas上的Graphic Raycaster组件设置成enable=false，或者直接删掉Graphic Raycaster组件即可。 其实UGUI已经帮我们封装好了一些UI元素的事件，比如前面提到的Button、Toggle、Slider等，但像Image、Text这种特别基础的UI元素是没有事件封装的，如果非要监听的话，只能手动添加监听方法。 首先，来看看UGUI有多少事件监听方法。 IPointerEnterHandler - OnPointerEnter：进入该区域时调用。 IPointerExitHandler - OnPointerExit：离开该区域时调用。 IPointerDownHandler - OnPointerDown：按下时调用。 IPointerUpHandler - OnPointerUp：抬起时调用。 IPointerClickHandler - OnPointerClick：按下并且抬起时调用，好比按钮的点击。 InitializePotentialDragHandler - OnInitializePotentialDrag：拖动初始化。 IBeginDragHandler - OnBeginDrag：拖动开始时调用，并且可以取到拖动的方向，而OnInitializePotentialDrag只表示滑动初始化，无法取到方向。 IDragHandler - OnDrag：滑动持续时调用。 IEndDragHandler - OnEndDrag：滑动结束时调用。 IDropHandler - OnDrop：落下时调用。 IScrollHandler - OnScroll：鼠标滚轮持续时调用。 IUpdateselectedHandler - OnUpdateselected：选择时续调用，只针对Selectab起作用 ISelectHandler - OnSelect：选择后调用，只针对Selectable起作用。 IDeselectHandler - OnDeselect：取消选择，由于只能选择一个Selectable，当选择新的后，之前选择的就会回调取消选择事件。 IMoveHandler - OnMove：选择后，可监听上下左右WSAD方向键。如果访问eventData.moveDir，可以取到具体移动的方向。 ISubmitHandler - OnSubmit：按钮按下事件。 ICancelHandler - OnCancel：按钮取消事件，按下时按Esc键可取消。 1234567891011121314151617181920212223242526272829303132333435363738// 绑定在Button上using UnityEngine;using System.Collections;using UnityEngine.EventSystems;public class Bind2Btn : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler, IPointerClickHandler, IScrollHandler&#123; public void OnPointerEnter(PointerEventData eventData) &#123; Debug.Log("进入按钮区域"); &#125; public void OnPointerExit(PointerEventData eventData) &#123; Debug.Log("离开按钮区域"); &#125; public void OnPointerDown(PointerEventData eventData) &#123; Debug.Log("按下按钮"); &#125; public void OnPointerUp(PointerEventData eventData) &#123; Debug.Log("抬起按钮"); &#125; public void OnPointerClick(PointerEventData eventData) &#123; Debug.Log("点击按钮"); &#125; public void OnScroll(PointerEventData eventData) &#123; Debug.Log("滚动中。。。"); &#125;&#125; 运行结果： UI事件管理UnityAction和UnityEventRaycastTarget优化渗透UI事件]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遮挡剔除技术]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是遮挡剔除？ 有几种遮挡剔除技术？分别描述。 occluder、occludee和occlusion分别是什么意思？ 利用Occlusion Culling（遮挡剔除）技术，渲染对象会在被送进渲染流水线之前，将因被遮挡而不会被看到的隐藏面或隐藏对象进行剔除，从而减少了每帧的渲染数据量，提高了渲染性能。在遮挡密集的场景中，性能提升会更加明显。Unity整合了相关功能及用户界面，同时还提供了三种不同的遮挡剔除技术供用户选择。 使用遮挡剔除1.首先在场景中创建多个Cube来建立一个密集的建筑场景。将所有的Cube都标记为Static（静态），如下图所示。 2.单击菜单栏中Window菜单中的Occlusion Culling选项，打开Occlusion Culling视窗。此时我们在Scene视窗中会看到出现空间划分的网格，如下图所示。 3.单击Occlusion视窗中Bake栏右下方的“Bake”按钮，进行烘焙，如下图所示。 4.单击Occlusion视窗中的Visualization标签页，选中Cameras，拖动场景中的相机，此时便可以在场景视窗中观察到剔除结果，如下图所示。 如下图所示，可以看到很多Cube对象都被剔除了，同时在相机预览视窗中可以看到实际的渲染结果。 如下图所示，勾选Visibility Lines，可以看到在相机对象视锥出现绿色的线，这样我们就能更好地观察相机的视角，并且可以看到实际的渲染结果。 如下图所示，勾选Portals（入口），可以看到在相机对象视锥出现绿色的线，并且可以看到实际的渲染结果。 5.使用Occlusion Culling需要预先烘焙好运行时所需的场景数据。Occlusion Culling相关数据无法动态实时地生成，因此，如果在运行时场景中有变动，那么需要在烘焙时为会变动的游戏对象勾选Occludee Static（被遮挡体）选项。 烘焙参数设置1.Smallest Occluder：一边检视，一边调整，直到遮挡剔除的感觉完美。如果发现遮挡剔除开始影响效能或是遮挡数据过大,，你应该停止往下调整。 2.Smallest Hole：开始可以给予较大的值，并边做边往下调到适合的感觉。值调大一点有助于开始时有快的烘焙速度，当在游戏体验中看到错误的遮挡才开始往下调整，直到整体感觉没有问题。 3.Backface Threshold：可以从100开始，如果遮挡数据过大或是当镜头很接近遮挡器时所呈现的结果怪异，试着把数值往下调90或更小。 4.Occluder Static与Occludee Static，如下图所示。 通过勾选Occluder Static或Occludee Static来将对象参与到遮挡剔除烘焙。另外，也可以在对象Inspector视窗右上角的Static中勾选，如下图所示。 Occlude即遮挡体，Occludee即被遮挡体。透明的、特别小的以及被控制器移动的游戏对象通常不会遮挡其他对象，因此，只需要勾选Occludee Static选项即可。 使用Occlusion Area组件Occlusion Area（遮挡区域）组件的用途是：在某些较大的游戏场景中，部分区域是相机对象无法到达的，那么可以采用在相机对象可以到达的区域布置Occlusion Area的方式，从而减少烘焙出来的数据。或者为了剔除某些移动的游戏对象，也可以建立一些Occlusion Area，并调整其范围到移动对象可能达到的地方，如下图所示。 1.启动Unity，在Occlusion视窗的Object标签页中，选择Occlusion Areas类，如果此时没有选择任何对象，则出现Create New Occlusion Area选项，单击“Occlusion Area”按钮，即可创建一个Occlusion Area，如下图所示。另外，也可新建一个或选中一个游戏对象，并单击菜单栏中Component-&gt;Rendering-&gt;Occlusion Area选项来创建。 2.保持游戏对象被选中，在Inspector面板中的Occlusion Area组件属性面板中，启用Is View Volume选项后，当相机对象在Occlusion Area内时，才会剔除被遮挡的静态对象，如下图所示。 使用Occlusion Portals组件在某些游戏场景中，可以通过创建一些独立的Portal来剔除一些对象，或者在PVS不能很好地剔除动态对象的地方做一个剔除精度的补充，如下图所示，如果想在运行时动态开启和关闭Portal，则需要采用Automatic Portal Generation技术。 1.启动Unity在场景中新建或选中一个游戏对象，单击菜单栏中的Component-&gt;Rendering-&gt;Occlusion Portal选项，为选中的游戏对象添加Occlusion Portal组件，即创建一个Occlusion Portal。 2.在Inspector视窗中的Occlusion Portal组件面板中，可以更改Occlusion Portal的大小及位置，如下图所示。 遮挡剔除技术应用实例1.创建一个新场景。创建模型，建造一座建筑密集的城市，效果如下图所示。 2.为了方便我们观看，给建筑添加颜色。创建两个材质，选择颜色，把颜色赋予Cube和Plane，如下图所示。 3.要想在这个场景中漫游，需要添加角色控制器。首先导入角色控制器资源，单击Project-&gt;Import Package-&gt;Character Controller选项，这时Project面板中会出现Standard Assets资源文件夹。 4.我们要使用第一人称视角，所以把First Person Controller拖入场景。因为是第一人称，所以我们要删掉原来的Main Camera，运行后就可以在这个场景中漫游了。 5.现在开始进行遮挡剔除操作，把场景中的Cube更改为Occluder Static和Occludee Static，如下图所示。 6.接下来是烘焙场景，在Occlusion面板的Bake面板中单击右下方的“Bake”按钮，如图10-29所示。烘焙场景后，选择Visualizatior面板中的Cameras选项，如图10-30所示。 7.运行程序，查看效果，如图10-31所示。为了更好地观看，单击Occlusion Culling中的”Visibility Lines”按钮,如图10-32所示。 如图10-33所示，为单击”Visblity Lines”按钮后的视图显示效果。 图10-33是使用遮挡剔除的效果，图10-34是未使用遮挡剔除的效果，对比两张图可知，在线外的物体被剔除，在线内的物体还会在场景中渲染。 occluder static和occludee static的区别occluder是“遮挡物”，occludee是“被遮挡物”。 “遮挡物”所遮挡的“被遮挡物”，就不会显示在场景中。效果跟Active为False的时候一致。 如果两个都勾选的话，就代表这个物体既是“遮挡物”，也是“被遮挡物”。 举个例子，假如A B C三个立方体，排成一列，摄像机在A的正前方,从摄像机的视角中看不到B和C，因为它俩被A挡住了。 如果这时候A是“遮挡物”，B和C是“被遮挡物”。那B和C就不会显示在场景中（不仅是摄像机看不见，而是完全不在场景中出现）。 但如果摄像机穿过A，而移动到B的正前方，B和C都会显示。为什么？因为B是“被遮挡物”，却没有被“遮挡物”挡住（此时作为遮挡物的A，在摄像机背面，并没有挡住B） 那C为何会显示呢？因为B只是“被遮挡物”，而不是“遮挡物”，所以它无法遮挡C。摄像机里看不到C，但C依然会显示在场景中。 如果此时把B同时勾选为“遮挡物”。那么C就不会显示了。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X 完全自学手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity插件之Unity调用C#编译的DLL]]></title>
    <url>%2F2019%2F04%2F04%2FUnity%E6%8F%92%E4%BB%B6%E4%B9%8BUnity%E8%B0%83%E7%94%A8C-%E7%BC%96%E8%AF%91%E7%9A%84DLL%2F</url>
    <content type="text"><![CDATA[Unity插件分为两种：托管插件（Managed Plugins）和本地插件（Native Plugins）。本文先来说说Unity中的托管插件，本地插件的文章留到下一篇文章再说。有时候我们会有这样的需求：给第三方公司提供Unity插件，而又不希望第三方看到具体代码，这时就可以将核心代码编译成dll文件供第三方调用。或者说，同一个公司多个项目都用到某个模块，则可以把该模块封装成dll，方便在不同项目之间共用和维护。 一、创建DLL打开VS，选择文件 -&gt; 新建 -&gt; 项目后打开新建项目对话框。接着操作如下： 点击确定后，编写如下代码： 1234567891011121314151617using System;namespace MyLib&#123; public class MyClass &#123; public static string GetBlogName() &#123; return "Sheh伟伟的简书"; &#125; public static TimeSpan GetBlogTime(DateTime time) &#123; return (time - DateTime.Parse("2016/11/14")); &#125; &#125;&#125; 然后生成dll文件，操作如下图： 二、导入DLL将MyLib项目目录下的bin/Debug目录下的MyLib.dll文件拷贝到Unity项目的Plugins目录下。这时，Unity控制台报Unhandled Exception: System.Reflection.ReflectionTypeLoadException: The classes in the module cannot be loaded的错误，报错详细信息如下： 这是因为我用的Unity版本是5.3.4f1，支持的.NET Framework的版本为3.5。而我创建的MyLib项目的默认.NET Framework 3.5版本为4.5.2。选择项目，然后右键选择属性 -&gt; 应用程序，将目标框架改为 .NET Framework 3.5或以下 ，如下图： 接着重新生成一下dll文件，重新导入到Unity就行了。 三、调用DLL 在Unity新建一个TestDll的脚本，并挂到主摄像机上，脚本代码如下： 12345678910111213141516using UnityEngine;using System;using MyLib; // 导入dllpublic class TestDll : MonoBehaviour &#123; private string blogUrl = "http://www.jianshu.com/users/fd3eec0ab0f2/latest_articles"; void Start () &#123; string myBlog = string.Format("&#123;0&#125;:&#123;1&#125;", MyClass.GetBlogName(), blogUrl); Debug.Log(myBlog); TimeSpan span = MyClass.GetBlogTime(DateTime.Now); Debug.Log("写这篇博客到现在的时间间隔：" + span.TotalDays); &#125;&#125; 注意，调用Dll中的方法一定要使用using语句引入导入到unity中的dll类库。 四、导入Unity DLL 怎么导入Unity原生类库呢？别急，接下来就说说怎么在自定义的dll类库中调用Unity中的类。首先选中项目，接着右键选择添加 -&gt; 引用后，弹出引用管理器，如下图： 在应用管理器界面点击浏览按钮，找到UnityEngine.dll文件点击确认按钮导入，如下图所示： Unity类库在Windows上的路径为Program Files\Unity\Editor\Data\Managed\UnityEngine.dll。 接着，将项目中无用的类库都移除掉，只保留用到的System和UnityEngine两个类库，如下图： 然后，修改MyClass脚本，代码如下： 12345678910111213141516171819202122232425using System;using UnityEngine;namespace MyLib&#123; public class MyClass &#123; public static string GetBlogName() &#123; return "Sheh伟伟的简书"; &#125; public static TimeSpan GetBlogTime(DateTime time) &#123; return (time - DateTime.Parse("2016/11/13")); &#125; public static void CreateCube() &#123; GameObject go = GameObject.CreatePrimitive(PrimitiveType.Cube); int random = UnityEngine.Random.Range(-5, 5); go.transform.position = new Vector3(random, random, 0); &#125; &#125;&#125; 代码编写完成后，重新生成一下dll，然后导入到Unity中，接着修改Unity脚本TesDll，具体代码如下： 12345678910111213141516171819202122232425262728293031using UnityEngine;using System;using MyLib;public class TestDll : MonoBehaviour &#123; private string blogUrl = "http://www.jianshu.com/users/fd3eec0ab0f2/latest_articles"; string myBlog; double time; void Start () &#123; myBlog = string.Format("&#123;0&#125;:&#123;1&#125;", MyClass.GetBlogName(), blogUrl); Debug.Log(myBlog); TimeSpan span = MyClass.GetBlogTime(DateTime.Now); time = span.TotalDays; Debug.Log("写这篇博客到现在的时间间隔：" + time); &#125; void OnGUI() &#123; GUILayout.Label(myBlog); GUILayout.Label(time.ToString()); if(GUILayout.Button("Create Cube")) &#123; MyClass.CreateCube(); &#125; &#125;&#125; 运行后的效果图如下：]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向量在游戏开发中的应用-3]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%90%91%E9%87%8F%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[向量在游戏开发中的应用-2]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%90%91%E9%87%8F%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[向量在游戏开发中的应用-1]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%90%91%E9%87%8F%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Unity常用英文]]></title>
    <url>%2F2019%2F04%2F04%2FUnity%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%2F</url>
    <content type="text"><![CDATA[常用英文的翻译 英文 中文 ray 射线 cast 投射 Gizmo 可视化辅助工具 trigger 触发 overlap 重叠 culling 剔除 mask 面具，遮罩 Threshold 阈值 entry 条目 tint 着色 delta 增量 Axis 轴 Magnitude 大小 mapped 映射，对应 Conventional 常规 arrow keys 方向键 linear 线性 Additive 添加物 Vertex 顶点 duration 持续时间 Lerp 线性插值 Frustum 视锥体 cutscene 过场动画 obligation 义务 PostProcessing 后期处理 tiling 平铺 unlit 无灯光的 elapsed 过去的 Slerp 球面线性插值 rect 矩形 Projectile 抛射体 formula 公式，方案，方法 host 托管 compound 复合，合成 polygon 多边形 portals 入口 stretch 伸展 solid color 纯色 Rotate和rotation 是两种东西 Obstacle 障碍 Agent 代理 mute 静音 embed 嵌入的，内含的 cascade 级联，一对多关系 Volume 体积，音量 Visualization 可视化 torque 扭矩：使物体发生转动的一种特殊的力矩 blend 混合 Snapshot 快照 Procedural 程序 Clockwise 顺时针 intersect 相交，交集 bias 偏差 Algorithm 算法 aspect 屏幕纵横比 cluster 集群，簇 shade 着色 dopesheet 关键帧清单，简报 Curves 曲线 Elastic 弹性 Clamped 固定的 Unrestricted 没有限制的 weld 合并 Dispose 释放 chunk 分块 gesture 手势 swipe 滑动 pinch 捏 tap 轻击 twist 转动，旋转 preset 预设，事先安排 unconstrained 自由的 preferred size 理想的大小，属意大小 inertia 惯性 Deceleration 减速 scroll sensitivity 滚动灵敏度 tween 平滑 Altas 图集 backdrop 背景 crop 裁切 transparent 透明]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Colliders]]></title>
    <url>%2F2019%2F04%2F03%2FColliders%2F</url>
    <content type="text"><![CDATA[Collider components define the shape of an object for the purposes of physical collisions. A collider, which is invisible, need not be the exact same shape as the object’s mesh and in fact, a rough（粗糙） approximation（近似） is often more efficient and indistinguishable（不易察觉的） in gameplay. The simplest (and least processor-intensive（处理器密集型）) colliders are the so-called primitive collider types. In 3D, these are the Box Collider, Sphere Collider and Capsule Collider. In 2D, you can use the Box Collider 2D and Circle Collider 2D. Any number of these can be added to a single object to create compound colliders. With careful positioning and sizing, compound colliders can often approximate the shape of an object quite well while keeping a low processor overhead（额外开销）. Further flexibility can be gained by having additional colliders on child objects (eg, boxes can be rotated relative to the local axes of the parent object). When creating a compound collider like this, there should only be one Rigidbody component, placed on the root object in the hierarchy. Note, that primitive colliders will not work correctly with shear transforms（剪切变换） - that means that if you use a combination of rotations and non-uniform（非均匀） scales in the Transform hierarchy so that the resulting shape would no longer match a primitive shape, the primitive collider will not be able to represent it correctly. There are some cases, however, where even compound colliders are not accurate（准确） enough. In 3D, you can use Mesh Colliders to match the shape of the object’s mesh exactly. In 2D, the Polygon Collider 2D will generally not match the shape of the sprite graphic perfectly but you can refine the shape to any level of detail you like. These colliders are much more processor-intensive than primitive types, however, so use them sparingly to maintain good performance. Also, a mesh collider will normally be unable to collide with another mesh collider (ie, nothing will happen when they make contact). You can get around this in some cases by marking the mesh collider as Convex in the inspector. This will generate the collider shape as a “convex hull” which is like the original mesh but with any undercuts filled in. The benefit of this is that a convex mesh collider can collide with other mesh colliders so you may be able to use this feature when you have a moving character with a suitable shape. However, a good general rule is to use mesh colliders for scene geometry and approximate the shape of moving objects using compound primitive colliders. Colliders can be added to an object without a Rigidbody component to create floors, walls and other motionless elements of a scene. These are referred to as static colliders. In general, you should not reposition static colliders by changing the Transform position since this will impact heavily on the performance of the physics engine. Colliders on an object that does have a Rigidbody are known as dynamic colliders. Static colliders can interact with dynamic colliders but since they don’t have a Rigidbody, they will not move in response to collisions. The reference pages for the various collider types linked above have further information about their properties and uses. Physics materialsWhen colliders interact, their surfaces need to simulate the properties of the material they are supposed to represent. For example, a sheet of ice will be slippery while a rubber ball will offer a lot of friction and be very bouncy. Although the shape of colliders is not deformed during collisions, their friction and bounce can be configured using Physics Materials. Getting the parameters just right can involve a bit of trial and error but an ice material, for example will have zero (or very low) friction and a rubber material with have high friction and near-perfect bounciness. See the reference pages for Physic Material and Physics Material 2D for further details on the available parameters. Note that for historical reasons, the 3D asset is actually called Physic Material (without the S) but the 2D equivalent is called Physics Material 2D (with the S). TriggersThe scripting system can detect when collisions occur and initiate actions using the OnCollisionEnter function. However, you can also use the physics engine simply to detect when one collider enters the space of another without creating a collision. A collider configured as a Trigger (using the Is Trigger property) does not behave as a solid object and will simply allow other colliders to pass through. When a collider enters its space, a trigger will call the OnTriggerEnter function on the trigger object’s scripts. Collision callbacks for scriptsWhen collisions occur, the physics engine calls functions with specific names on any scripts attached to the objects involved. You can place any code you like in these functions to respond to the collision event. For example, you might play a crash sound effect when a car bumps into an obstacle. On the first physics update where the collision is detected, the OnCollisionEnter function is called. During updates where contact is maintained, OnCollisionStay is called and finally, OnCollisionExit indicates that contact has been broken. Trigger colliders call the analogous OnTriggerEnter, OnTriggerStay and OnTriggerExit functions. Note that for 2D physics, there are equivalent functions with 2D appended to the name, eg, OnCollisionEnter2D. Full details of these functions and code samples can be found on the Script Reference page for the MonoBehaviour class. With normal, non-trigger collisions, there is an additional detail that at least one of the objects involved must have a non-kinematic Rigidbody (ie, Is Kinematic must be switched off). If both objects are kinematic Rigidbodies then OnCollisionEnter, etc, will not be called. With trigger collisions, this restriction doesn’t apply and so both kinematic and non-kinematic Rigidbodies will prompt a call to OnTriggerEnter when they enter a trigger collider. Collider interactionsColliders interact with each other differently depending on how their Rigidbody components are configured. The three important configurations are the Static Collider (ie, no Rigidbody is attached at all), the Rigidbody Collider and the Kinematic Rigidbody Collider. Static ColliderThis is a GameObject that has a Collider but no Rigidbody. Static colliders are used for level geometry which always stays at the same place and never moves around. Incoming rigidbody objects will collide with the static collider but will not move it. The physics engine assumes that static colliders never move or change and can make useful optimizations based on this assumption. Consequently, static colliders should not be disabled/enabled, moved or scaled during gameplay. If you do change a static collider then this will result in extra internal recomputation by the physics engine which causes a major drop in performance. Worse still, the changes can sometimes leave the collider in an undefined state that produces erroneous physics calculations. For example a raycast against an altered Static Collider could fail to detect it, or detect it at a random position in space. Furthermore, Rigidbodies that are hit by a moving static collider will not necessarily be “awoken” and the static collider will not apply any friction. For these reasons, only colliders that are Rigidbodies should be altered. If you want a collider object that is not affected by incoming rigidbodies but can still be moved from a script then you should attach a Kinematic Rigidbody component to it rather than no Rigidbody at all. Rigidbody ColliderThis is a GameObject with a Collider and a normal, non-kinematic Rigidbody attached. Rigidbody colliders are fully simulated by the physics engine and can react to collisions and forces applied from a script. They can collide with other objects (including static colliders) and are the most commonly used Collider configuration in games that use physics. Kinematic Rigidbody ColliderThis is a GameObject with a Collider and a kinematic Rigidbody attached (ie, the IsKinematic property of the Rigidbody is enabled). You can move a kinematic rigidbody object from a script by modifying its Transform Component but it will not respond to collisions and forces like a non-kinematic rigidbody. Kinematic rigidbodies should be used for colliders that can be moved or disabled/enabled occasionally but that should otherwise behave like static colliders. An example of this is a sliding door that should normally act as an immovable physical obstacle but can be opened when necessary. Unlike a static collider, a moving kinematic rigidbody will apply friction to other objects and will “wake up” other rigidbodies when they make contact. Even when immobile, kinematic rigidbody colliders have different behavior to static colliders. For example, if the collider is set to as a trigger then you also need to add a rigidbody to it in order to receive trigger events in your script. If you don’t want the trigger to fall under gravity or otherwise be affected by physics then you can set the IsKinematic property on its rigidbody. A Rigidbody component can be switched between normal and kinematic behavior at any time using the IsKinematic property. A common example of this is the “ragdoll” effect where a character normally moves under animation but is thrown physically by an explosion or a heavy collision. The character’s limbs can each be given their own Rigidbody component with IsKinematic enabled by default. The limbs will move normallly by animation until IsKinematic is switched off for all of them and they immediately behave as physics objects. At this point, a collision or explosion force will send the character flying with its limbs thrown in a convincing way. ** Collision action matrix ** When two objects collide, a number of different script events can occur depending on the configurations of the colliding objects’ rigidbodies. The charts below give details of which event functions are called based on the components that are attached to the objects. Some of the combinations only cause one of the two objects to be affected by the collision, but the general rule is that physics will not be applied to an object that doesn’t have a Rigidbody component attached.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditorPrefs]]></title>
    <url>%2F2019%2F04%2F02%2FEditorPrefs%2F</url>
    <content type="text"></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持久化数据-3]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE-3%2F</url>
    <content type="text"><![CDATA[本章涵盖： XML YAML XMLXML在开发中使用也很频繁，此时要以标签的形式来组织数据结构。C#提供了创建、解析、修改和查询等方法，可以很方便地操作它。 创建XML操作XML时，需要用到System.Xml命名空间。我们可以在运行时动态创建XML字符串，并且在节点下添加数据。 123456789101112131415161718192021222324252627282930313233using UnityEngine;using System.IO;using System.Xml;public class Script_08_13 : MonoBehaviour&#123; void Start() &#123; // 创建XmlDocument XmlDocument xmlDoc = new XmlDocument(); XmlDeclaration xmlDeclaration = xmlDoc.CreateXmlDeclaration("1.0", "UTF-8", null); xmlDoc.AppendChild(xmlDeclaration); // 在节点中写入数据 XmlElement root = xmlDoc.CreateElement("XmlRoot"); xmlDoc.AppendChild(root); XmlElement group = xmlDoc.CreateElement("Group"); group.SetAttribute("username", "Unity"); group.SetAttribute("password", "123456"); root.AppendChild(group); // 读取节点并输出XML字符串 using (StringWriter stringwriter = new StringWriter()) &#123; using (XmlTextWriter xmlTextWriter = new XmlTextWriter(stringwriter)) &#123; xmlDoc.WriteTo(xmlTextWriter); xmlTextWriter.Flush(); Debug.Log(stringwriter.ToString()); &#125; &#125; &#125;&#125; 输出结果： 1&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;XmlRoot&gt;&lt;Group username="Unity" password="123456" /&gt;&lt;/XmlRoot&gt; 读取与修改XML可作为字符串来传递。可以动态读取XML字符串中的内容，并且修改它的内容，以重新生成新的XML字符串。创建XmlDocument对象后，需要读取XML文件，通过循环可以遍历所有子节点对它们进行修改。 1234567891011121314151617181920212223242526272829303132333435363738using UnityEngine;using System.IO;using System.Xml;public class Script_08_14 : MonoBehaviour&#123; void Start() &#123; //xml字符串 string xml = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;XmlRoot&gt;&lt;Group username=\"Unity\" password=\"123456\" /&gt;&lt;/XmlRoot&gt;"; //读取字符串xml XmlDocument xmlDoc = new XmlDocument(); xmlDoc.LoadXml(xml); // 遍历节点 XmlNode nodes = xmlDoc.SelectSingleNode("XmlRoot"); foreach (XmlNode node in nodes.ChildNodes) &#123; string username = node.Attributes["username"].Value; string password = node.Attributes["password"].Value; Debug.LogFormat("username=&#123;0&#125; password=&#123;1&#125;", username, password); //修改其中一条数据 node.Attributes["password"].Value = "88888888"; &#125; // 读取节点并输出XML字符串 using (StringWriter stringwriter = new StringWriter()) &#123; using (XmlTextWriter xmlTextWriter = new XmlTextWriter(stringwriter)) &#123; xmlDoc.WriteTo(xmlTextWriter); xmlTextWriter.Flush(); Debug.Log(stringwriter.ToString()); &#125; &#125; &#125;&#125; 结果如下： 1username=Unity password=123456 1&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;XmlRoot&gt;&lt;Group username="Unity" password="88888888" /&gt;&lt;/XmlRoot&gt; XML文件XmlDocument类也提供了从文件中读取XML，或者将XML写入本地路径的方法。如下图所示，将XML写入本地文件，读取后再输出节点中的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using UnityEngine;using System.IO;using System.Xml;using UnityEditor;public class Script_08_15&#123; [MenuItem("XML/WriteXml")] static void WriteXml() &#123; string xmlPath = Path.Combine(Application.dataPath, "test.xml"); // 如果XML文件已经存在，就删除它 if (File.Exists(xmlPath)) &#123; File.Delete(xmlPath); &#125; // 创建XmlDocument XmlDocument xmlDoc = new XmlDocument(); XmlDeclaration xmlDeclaration = xmlDoc.CreateXmlDeclaration("1.0", "UTF-8", null); xmlDoc.AppendChild(xmlDeclaration); // 在节点中写入数据 XmlElement root = xmlDoc.CreateElement("XmlRoot"); xmlDoc.AppendChild(root); //循环写入3条数据 for (int i = 0; i &lt; 3; i++) &#123; XmlElement group = xmlDoc.CreateElement("Group"); group.SetAttribute("id", i.ToString()); group.SetAttribute("username", "车斌Carl"); group.SetAttribute("password", "123456"); root.AppendChild(group); &#125; // 写入文件 xmlDoc.Save(xmlPath); AssetDatabase.Refresh(); &#125; [MenuItem("XML/LoadXml")] static void LoadXml() &#123; string xmlPath = Path.Combine(Application.dataPath, "test.xml"); // XML文件只有存在，才能读取 if (File.Exists(xmlPath)) &#123; XmlDocument xmlDoc = new XmlDocument(); xmlDoc.Load(xmlPath); //遍历节点 XmlNode nodes = xmlDoc.SelectSingleNode("XmlRoot"); foreach (XmlNode node in nodes.ChildNodes) &#123; string id = node.Attributes["id"].Value; string username = node.Attributes["username"].Value; string password = node.Attributes["password"].Value; Debug.LogFormat("id=&#123;0&#125; username=&#123;1&#125; password=&#123;2&#125;", id, username, password); &#125; &#125; &#125; &#125; test.xml 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;XmlRoot&gt; &lt;Group id="0" username="Unity" password="123456" /&gt; &lt;Group id="1" username="Unity" password="123456" /&gt; &lt;Group id="2" username="Unity" password="123456" /&gt;&lt;/XmlRoot&gt; 123id=0 username=Unity password=123456id=1 username=Unity password=123456id=2 username=Unity password=123456 YAML前面我们介绍了JSON和XML其实已经在大量使用了，当数据多了以后，JSON有个最大的问题，那就是可读性很差。XML比JSON的可读性会好一些。无论JSON还是XML，编辑都会很麻烦，它们的数据格式要求很严格，少写括号或者逗号都不行。 Unity就没有使用JSON或者XML来描述结构，采取的是YAML格式。如下所示，它的预览性以及编辑性都非常好，数据与变量通过冒号来连接。例如，游戏中一些服务器列表的配置，或者调试性的开关，不太方便配置在表格中的数据，或者修改比较频繁的数据都可以使用YAML来配置，随时用随时改。 123456789101112131415house: family: name: Doe parents: - John - Jane children: - Paul - Mark - Simone address: number: 34 street: Main Street city: Nowheretown zipcode: 12345 YamlDotNetYAML提供了.NET的类库，即YamlDotNet。Unity中直接提供了插件，它可以在Asset Store中免费下载到。YamlDotNet支持PC和移动端，下载后导入工程就可以使用了。 序列化和反序列化YamlDotNet提供了运行时序列化和反序列化的接口。这里需要注意的是，对于参与序列化的类中的变量，其属性必须设置成get或者set，不然无法序列化。在程序运行中，可以序列化和反序列化数据。使用Serialize()和Deserialize()方法就可以进行序列化和反序列化操作。 1234567891011121314151617181920212223242526272829303132using System.Collections.Generic;using UnityEngine;using YamlDotNet.Serialization;public class Script_08_16 : MonoBehaviour&#123; private void Start() &#123; //创建对象 Data data = new Data(); data.name = "Unity"; data.password = "123456"; data.list = new List&lt;string&gt;() &#123; "a", "b", "c" &#125;; //序列化YAML字符串 Serializer serializer = new Serializer(); string yaml = serializer.Serialize(data); Debug.LogFormat("serializer : \n&#123;0&#125;", yaml); //反序列化成类对象 Deserializer deserializer = new Deserializer(); Data data1 = deserializer.Deserialize&lt;Data&gt;(yaml); Debug.LogFormat("deserializer : name=&#123;0&#125; password=&#123;1&#125;", data1.name, data1.password); &#125;&#125;class Data&#123; public string name &#123; get; set; &#125; public string password &#123; get; set; &#125; public List&lt;string&gt; list &#123; get; set; &#125;&#125; 输出结果： 123456789serializer: name: Unitypassword: 123456list:- a- b- cdeserializer : name=Unity password=123456 读取配置在游戏中，一些服务器列表或者一些临时调试的配置信息，可能需要频繁地添加、删除和修改等。由于这些测试数据都是临时性的，就不太适合配置在Excel表格中。当包打出来以后，直接修改配置文件就可以立即生效到游戏中。在YAML中，可以使用”#”符号来表示注释部分。yaml.txt 123456#服务器列表ServerList : 192.168.1.1#服务器端口Port : 8080#是否启动调试Debug : true 1234567891011121314151617181920212223242526272829using System.Collections.Generic;using System.IO;using UnityEngine;using YamlDotNet.RepresentationModel;public class Script_08_17 : MonoBehaviour&#123; private IDictionary&lt;YamlNode, YamlNode&gt; m_MappingData; private void Start() &#123; //读取YAML字符串 string document = File.ReadAllText(Path.Combine(Application.streamingAssetsPath, "yaml.txt")); var input = new StringReader(document); var yaml = new YamlStream(); yaml.Load(input); //读取root 节点 var mapping = (YamlMappingNode)yaml.Documents[0].RootNode; m_MappingData = mapping.Children; &#125; private void OnGUI() &#123; GUILayout.Label(string.Format("&lt;size=50&gt;服务器列表: &#123;0&#125;&lt;/size&gt;", m_MappingData["ServerList"])); GUILayout.Label(string.Format("&lt;size=50&gt;服务器端口: &#123;0&#125;&lt;/size&gt;", m_MappingData["Port"])); GUILayout.Label(string.Format("&lt;size=50&gt;是否启动调试: &#123;0&#125;&lt;/size&gt;", m_MappingData["Debug"])); &#125;&#125; 小结本章中，我们学习了游戏存档。存档可分为静态存档和动态存档。静态存档时，在游戏运行过程中，对它只能读取不能写入。这好比Excel表格数据，最终表格数据可在编辑模式下利用EPPlus转成程序可读文件类型。动态存档应用得就更多了，它在玩游戏的过程中记录玩家游戏的进度，或者一些设置选项， Unity提供了PlayerPrefs类来处理存档的读与写，我们也可以利用C#的File类来自行保存存档。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持久化数据-2]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE-2%2F</url>
    <content type="text"><![CDATA[我们需要一个不影响开发的存档，并且查看要非常方便（PlayerPref查看不方便）。可以自己写一个存档类，在编辑模式下将存档保存在Assets同级目录下，这样查看存档内容就方便多了。 如RecordUtil.cs所示，在编辑模式下将数据保存于Application.dataPath目录，而在真实环境下将数据保存在Application.persistentDataPath下。只有调用Save()方法时，数据才会被强制写入。 里面没有Update等回调方法，无需继承MonoBehavior，就是一个工具类。不是所有的类都需要继承MonoBehavior。作为组件的才需要。 Unity是可以直接访问硬盘上的文件和目录的。此时需要通过C#的函数来操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165using System.Collections;using System.Collections.Generic; using UnityEngine;using System.IO;using System;using System.Text;// 这个类的作用是把游戏信息存到一个文件中，这儿没有使用Unity自带的PlayerPref类。// 文件的目录，存储函数，得到函数// 对外提供的函数是RecordUtil.Set(key, value)和RecordUtil.Get(key [,defaultValue])和RecordUtil.Delete();// 因为是工具类，就用静态就好。public class RecordUtil&#123; //游戏存档保存的根目录 static string RecordRootPath &#123; get &#123; #if (UNITY_EDITOR || UNITY_STANDALONE) return Application.dataPath + "/../Record/"; #else return Application.persistentDataPath + "/Record/"; #endif &#125; &#125; //游戏存档 static Dictionary&lt;string, string&gt; recordDic = new Dictionary&lt;string, string&gt;(); //标记某个游戏存档是否需要重新写入 static List&lt;string&gt; recordDirty = new List&lt;string&gt;(); //标记某个游戏存档是否需要删除 static List&lt;string&gt; deleteDirty = new List&lt;string&gt;(); //表示某个游戏存档读取时需要重新从文件中读取 static List&lt;string&gt; readDirty = new List&lt;string&gt;(); static private readonly UTF8Encoding UTF8 = new UTF8Encoding(false); static RecordUtil() &#123; readDirty.Clear(); if (Directory.Exists(RecordRootPath)) &#123; foreach (string file in Directory.GetFiles(RecordRootPath, "*.record", SearchOption.TopDirectoryOnly)) &#123; string name = Path.GetFileNameWithoutExtension(file); if (!readDirty.Contains(name)) &#123; readDirty.Add(name); Get(name); &#125; &#125; &#125; &#125; //强制写入文件 public static void Save() &#123; foreach (string key in deleteDirty) &#123; try &#123; string path = Path.Combine(RecordRootPath, key + ".record"); if (recordDirty.Contains(key)) &#123; recordDirty.Remove(key); &#125; if (File.Exists(path)) &#123; File.Delete(path); &#125; &#125; catch (Exception ex) &#123; Debug.LogError(ex.Message); &#125; &#125; deleteDirty.Clear(); foreach (string key in recordDirty) &#123; string value; if (recordDic.TryGetValue(key, out value)) &#123; if (!readDirty.Contains(key)) &#123; readDirty.Add(key); &#125; string path = Path.Combine(RecordRootPath, key + ".record"); recordDic[key] = value; try &#123; Directory.CreateDirectory(Path.GetDirectoryName(path)); File.WriteAllText(path, value, UTF8); &#125; catch (Exception ex) &#123; Debug.LogError(ex.Message); &#125; &#125; &#125; recordDirty.Clear(); &#125; public static void Set(string key, string value) &#123; recordDic[key] = value; if (!recordDirty.Contains(key)) &#123; recordDirty.Add(key); &#125; #if UNITY_EDITOR || UNITY_STANDALONE Save(); #endif &#125; public static string Get(string key) &#123; return Get(key, string.Empty); &#125; public static string Get(string key, string defaultValue) &#123; if (readDirty.Contains(key)) &#123; string path = Path.Combine(RecordRootPath, key + ".record"); try &#123; string readstr = File.ReadAllText(path, UTF8); recordDic[key] = readstr; &#125; catch (Exception ex) &#123; Debug.LogError(ex.Message); &#125; readDirty.Remove(key); &#125; string value; if (recordDic.TryGetValue(key, out value)) &#123; return value; &#125; else &#123; return defaultValue; &#125; &#125; public static void Delete(string key) &#123; if (recordDic.ContainsKey(key)) &#123; recordDic.Remove(key); &#125; if (!deleteDirty.Contains(key)) &#123; deleteDirty.Add(key); &#125; #if UNITY_EDITOR || UNITY_STANDALONE Save(); #endif &#125;&#125; 在编辑模式下，数据发生改变时，会立刻写入文件并保存，而真实环境下出于性能考虑，以在某个特定的时间点保存数据。 如下代码所示，由于是自己写的存档类，处理起来会更加灵活。当然，我们也可仿照PlayerPrefs在应用程序即将进入后台时保存。当调用OnApplicationPause()时，表示应用进入后台后再保存数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System.Collections;using UnityEngine;using UnityEditor;/* * 这个脚本是挂载在GameController上作为组件的。 */public class Script_08_12 : MonoBehaviour&#123; // 脚本激活时就调用RecordUtil把数据写入。 // 也可以改成UGUI系统点击“保存进度”才写入。 void Start() &#123; Setting setting = new Setting(); setting.stringValue = "测试字符串"; setting.intValue = 10000; RecordUtil.Set("setting", JsonUtility.ToJson(setting)); &#125; private Setting m_Setting = null; void OnGUI() &#123; if (GUILayout.Button("&lt;size=50&gt;获取存档&lt;/size&gt;")) &#123; m_Setting = JsonUtility.FromJson&lt;Setting&gt;(RecordUtil.Get("setting")); &#125; if (m_Setting != null) &#123; GUILayout.Label(string.Format("&lt;size=50&gt; &#123;0&#125;, &#123;1&#125; &lt;/size&gt;", m_Setting.intValue, m_Setting.stringValue)); &#125; &#125; void OnApplicationPause(bool pausestatus) &#123; //当游戏即将进入后台时，保存存档 if (pausestatus) &#123; RecordUtil.Save(); &#125; &#125; [System.Serializable] class Setting &#123; public string stringValue; public int intValue; &#125;&#125; 默认情况下，应用进入后台后才会保存数据。如果应用进入后台之前发生了闪退现象，那么数据就无法保存了，所以某些非常重要的数据需要强制调用save()方法。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与纹理、模型和2D元素协同工作-2]]></title>
    <url>%2F2019%2F04%2F02%2F%E4%B8%8E%E7%BA%B9%E7%90%86%E3%80%81%E6%A8%A1%E5%9E%8B%E5%92%8C2D%E5%85%83%E7%B4%A0%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C-2%2F</url>
    <content type="text"><![CDATA[本章涵盖： 纹理绘制 纹理绘制某些实际问题需要在运行期内在纹理上绘制像素，有时，需求自身较为烦项，例如，利用Alpha透明度在另一个表面前绘制贴花纹理(如脚印或者书写的消息) ，其中，用户可通过位于另一个背景平面前方的Alpha剪裁平面实现此类效果。然而，某些需求则显得较为复杂，且需要依赖于实际的纹理绘制操作。例如，在街头格斗游戏中，搏击过程中飞漲的鲜血降落至地面上或射向周围环境中，且需要将其作为背景纹理的一部分内容，又如，在某些休闲类涂绘游戏中，玩家可在面部网格上绘制腮红或眼影. 期间,玩家并不希望作为独立对象在网格前方绘制纹理四边形,进而生成纹理贴花外观效果。相反,此处需要将源纹理(例如画剧)绘制在网格上的目标纹理上,绘制过程并未在两个独立纹理之间进行,而是利用网格以及二者间的UV映射结果。换而言之源纹理需应用于或投影至场景中的网格表面上:随后,画刷像素需通过网格UV映射投影回纹理上。这可确保画刷像素绘制到目标纹理的正确位置,如图9.11所示,因此,该方法确保任意尺寸的源纹理绘制到3D表面上,以及基于UV映射的、任意尺寸的目标纹理上. 本节将讨论上述过程的实现方法。在开始之前需要指出,在某些替代方案无法胜任的前提下(例如四边形剪裁操作),上述纹理绘制方法可作为最后的一种手段-真正的纹理绘制的计算量较大. 创建纹理混合着色器本节讨论两层渲染方案,首先,当用户单击场景中的网格,画刷源纹理自身将绘制到目标纹理上,如图9-12所示。随后,目标纹理应用于网格上,当绘制时画刷将于其上叠加,如图9-13所示 然而,在绘制操作过程中,并不希望画刷覆写或改变源目标纹理,其原因在于,目标纹理将应用于多个场景对象上(至少理论上如此) : 另外,源纹理像素的覆写或修改结果将会扩展至使用该纹理的其他对象上。 相反,可利用透明背景将绘制效果分离至独立的纹理上,即通过定制材质在目标纹理上实现分层效果,这将在目标纹理和绘制效果之间形成真正的分离结果,在外观上,这将呈现为合并后的统一纹理效果,对此,需要编写自定义着色器,如示例代码9-4所示.该着色器在背最纹理上混合上方纹理(利用Alpha透明度). 当着色器编码并保存完毕后,针对任意材质,将在Object Inspector的Material面板中呈现为可选的着色器类型。该着色器可用于任意对象,并在其上绘制细节内容,如图9-14所示. MainTex设置框表示为细节内容所叠加的背景纹理,且编辑材质不可对其进行修改: BlendTex设置框表示为叠加于MainTex上的纹理,其Alpha透明度不可被修改。,般情况下,上述设置项在运行期内通过脚本进行设置,即生成Alpha透明纹理以获取画刷。 创建纹理绘制脚本当前着色器接收两个输入参数(上方纹理和下方纹理) ,并在二者间执行混合操作,该过程将使用到Alpha透明度,这将产生与Photoshop软件类似的层效果。在保留下方原始背景像素的同时,可在上方纹理中执行单独的纹理绘制操作,如图9-15所示 在进一步讨论之前,需要在Object Inspetor 编辑画刷绞理资源数据。特别地,可在Unity Editor的面板Projet中选择画刷纹理,并将Texture Type修改为Advanced.此处需要选中Read Write Enabled复选框,以使纹理可通过纹理编辑函数进行访间 除此之外,还需要选中Alpha is Transpareney复选框,并禁用Generate Mip Maps复选框,如图9-16所示. 下面创建纹理绘制脚本,并利用鼠标在场景3D对象上绘制画刷纹理（通过UV纹理),具体脚本内容如示例代码9-5所示. 示例代码9-5的部分解释内容如下所示. 口 第008行代码: public变量维护指向有效纹理数据的引用,并在绘制操作过程中用作画刷。针对每一次鼠标单击操作,该纹理将绘制于SurfaceTexture上.口 第015行代码: SurfaceTexture引用动态生成的纹理。默认条件下,该纹理利用透明像素进行填充,并在绘制过程中接收全部画刷,简而言之,该纹理作为BlendTex变量传递至TextureBlender着色器中。 口第026-031行代码: Start函数中将生成新纹理,该纹理采用RGB32格式表示,且支持Alpha通道. SetlPrxels函数利用同一映射的像素批量填充纹理。稍后将进一步讨论GetPixels和SetPixels函数、 口 第046行代码:在Update函数中,将检测鼠标单击操作,并初始化纹理绘制功能 第048-059行代码:如果按下鼠标键,该函数将在目标处绘制画刷纹理。第052行调用的Physics.Raycast函数将执行多项操作,例如,场景中的网格对象是否与光线相交,为了确保操作正常进行,该对象应包含Collidr 组件. 第062-072行代码:如果检测到碰撞行为,相交位置的UV坐标可通过RaycastHit结构的textureCoord变量获取。关于textureCoord变量的更多信息,读者可参考Unity在线文档,对应网址为htp:/does.unitysd.com/SsripReference/RayeastHit-textureCoord.html .与其他碰撞器类型(例如BoxCollider或CapsuleCollider)不同,仅当相交网格包含MeshCollider时,该成员方为有效。这也意味者,用作纹理绘制目标的任意对象均应包含MeshCollider 件–该对象涵盖了UV数据,随后,第63-72行代码将UV坐标转换为绝对像素位置,并将鼠标位置作为画刷源纹理的中心位置,同时,代码确定了源画刷纹理上的某一位置(表示为原始点) ,进而构建像素的x,y坐标,据此,源纹理将绘制至目标纹理中。 第075行代码:将调用PaintSourceToDestTexture函数执行绘制操作。第081行代码: PaintSourceToDestTexture接收4个参数,即Source, Dest, Left和Top.该函数声明为staic函数,这也说明,不需要声明该类的实例.第084-087行代码:纹理绘制处理中的第一步是获取Source和 Dest纹理中的全部像素,并可通过GetPixels函数予以实现。 当前,虽然各幅图像在视觉上表示为二维像素数组,但GelPrxels函数中的返回数组实际上处于线性(一维)状态。对于GietPrielromArray和SetPixelFromArray而言,像素x, y位置将被转换为线性数组索引. 第106-107行代码:最后, 目标像素被置回目标纹理缓冲区中,可调用Apply函数以对该操作进行确认。除了SetPixels (复数)函数, Unity还支持SetPixel (单数)函数,由于将重复调用SetPixel函数,因而SetPixels函数具有更优的性能第111-114行代码: GetPixelFromArray函数接收像素数据数组、像素的x和y坐标,以及纹理数据的像素宽度,在此基础上,该函数将现行索引返回至像素数组中,进而获取像素颜色值.第117-131行代码: SetPixellnArray函数负责调整线性数组中的像素颜色值。对应的修改方法通过参数Blending加以确定,如果将Blending设置为false,则源像素将简单地替换目标像素:如果将Blending设置为true,源像素将混合或分层至目标像素上,并保留Alpha透明度。当在目标纹理上绘制Alpha透明度面刷时, Blending应设置为true,并以此支持颜色值的累计和混合操作。 设置纹理绘制待着色器、纹理绘制脚本和纹理配置完毕后,下面将逐步在Unity中实现纹理绘制流程。首先,空项目中包含了着色器、纹理绘制脚本以及两个配置完毕的纹理,即背景纹理和画刷纹理,如图9.17所示 在图9-18中,可将Projecti板中的画刷纹理调整为较小尺寸(例如32x32) ,并将其Format设置为RGBA 32 bir(包含了Alpha透明度).. 通过TextureBlender着色器创建新的材质,并将背景纹理赋予MainTexture设置框中,如图9-19所示。 向当前场景中添加新的Quad, Plane或Mesh,并移除其碰撞器(若存在) 。该对象将接收最终的绘制输出内容,虽然单击检测将产生于复制网格上。此处,最终的输出网格和单击检测网格将处于分离状态,以使目标网格在必要时包含其他类型的碰撞器类型。一旦添加了Quad,可利用TextureBlender着色器将自定义材质赋予其中,如图9-20听示.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity脚本设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与纹理、模型和2D元素协同工作-1]]></title>
    <url>%2F2019%2F04%2F02%2F%E4%B8%8E%E7%BA%B9%E7%90%86%E3%80%81%E6%A8%A1%E5%9E%8B%E5%92%8C2D%E5%85%83%E7%B4%A0%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C-1%2F</url>
    <content type="text"><![CDATA[本章涵盖： 天空盒 过程式网格 如何操控顶点和2D平面边这一类几何形状？如何调整纹理坐标并实现其动画效果？如何编辑纹理？如何利用绘制系统以实时方式渲染纹理，进而生成贴花或血液飞溅等效果？ 这一类问题多集中于2D范畴，即2D平面内的几何形状和纹理，但其相关性通常会涉及2D和3D游戏。 天空盒天空盒实际上表示为一类立方体背景，经与相机绑定后可显示云朵、天空以及其他远距离细节内容，并充当场景的背景，玩家通常可对其远瞻而不可靠近。 对于Unity中的天空盒，其主要问题在于：默认状态下，天空盒处于静止状态。然而，大多数开发人员希望处于缓慢的旋转状态，让相机保持静止，并以此展示时光流逝这一类效果。下面考察改进后的Skybox预制组件，其中涉及Unity Skybox资源数据、双层相机以及C#脚本文件。 针对第一人称控制器数据资源导入Character Controllers包，针对地形上绘制的地形纹理导入Terrain Assets包，针对天空盒纹理导入Skyboxs包。 随后，可创建旋转天空盒预制组件，并制作可复用的对象，该对象包含了3个主要部分或子对象，即第一人称控制器，可使玩家实现运动行为，并渲染大部分场景对象第二部相机（天空盒相机）在第一人称相机下方进行渲染，且仅渲染天空盒，包含逆置法线的立方体对象，该对象围绕天空盒相机，并显示各个表面上的每一个天空盒纹理在开始阶段，可在场景原点处生出新的空对象（命名为SkyBoxCamera），并作为子节点添加第一人称控制器对象。随后，可通过主菜单创建6个Quad对象（选择GameObjet13D Object Quad命令） ，且角点间彼此对齐，其中，顶点间对齐并形成一个逆置立方体，也就是说，立方体的各个表面面向内侧，如图9-3所示，即天空盒网格。 这里，可蒋天空盒各个面赋予至某一个新层，选取第一人称控制器相机，并于随后修改Culling MaskW框以搏除SkyBoxlayer层.第一人称相机应仅谊染前最对象，而非背景对象，对此，可在ObeetInspector内将设置框从Clear Flags调整为Depth only，如图9-4所示.这将以透明方式谊染相机背能，并显示其他相机（若存在）。 当前，可创建附加相机对象，点，且与其位置、E转和缩放状态相匹配，这将从第一人称相机中继承全部转换。当与第二个相机的位置和旋转状态彼此匹配时，作为该相机下方的一层，辅助相机仅谊染天空金对象.至比，可将新相机的Depth值修改为小于第一人称相机的深度，例如-1，同时移除音频盗听蠢维件。 ，牌结果如图9-5所示. 同时，可将各个天空盒纹理赋予某一个立方体表面，且彼此间无键对齐，即必要时旋转或调整Quad的对齐状态，随后，可将天空盒纹理的材质Shader类型调整为UnliVTexture，免受场景光照的影响，此时，天空盒网格的形状如图9-6所示， 最后，可将示例代码9-1应用于天空盒父对象上，构建其旋转行为并与相机位置持续游时，天空盒始终位于其中心位置. 当前阶段的天空盒相对完整并具各了某些增强型效果，如图9-7所示，并且围绕相机而旋转，进面在场录中生成较为逼真的效果，另外，用户还可在其中添加多个栈式天空套（均为透明），并生成菜些附加效果，例如雾效果等。 1234567891011121314151617181920212223242526using UnityEngine;using System.Collections;public class SkyBox : MonoBehaviour&#123; // Camera to follow public Camera FollowCam = null; // Rotate Speed (Degrees per second) public float RotateSpeed= 10.0f; // Transform private Transform ThisTransform = null; // Use this for initialization void Awake () &#123; ThisTransform = transform; &#125; void Update () &#123; // Update position ThisTransform.position = FollowCam.transform.position; // Update rotation ThisTransform.Rotate(new Vector3(0, RotateSpeed * Time.deltaTime, 0)); &#125;&#125; 过程式网格虽然Unity在应用菜单中提供了Quad图元(通过GameObject |3D Object (Quad予以访问)，但读者依然需要了解如何采用手动方式生成几何形状，例如Quad,其中涉及了多种原因。首先，用户常会在脚本中对顶点进行编辑，针对各类效果实现网格的移动、动画以及变形等操作，例如角色在凝胶状表面上的摇摆、晃动效果。其次，用户需要编辑网格的UV坐标,并以此实现动画或滚动纹理效果，如图9-8所示。 示例代码9-2位于项目的Editor文件夹中，用于创建编辑器附加组件，并采用全定制式在脚本中生成Quad，对应位置为网格的轴心点。 该示例代码为编辑器插件，因而需要包含相应的UnityEditor命名空间。 当用户在Unity Editor中通过鼠标或键盘调整其选取内容时，将调用OnselectionChanged事件。这里，GetAssetPath方法将被调用，以获取Project面板中的当前文件夹。 当在脚本中生成Quad网格时，将调用OnWizardCreate函数该过程将填充顶点和UV数组，随后将置于第196行代码创建的Mesh对象中。 严格地讲，网格自身将作为项目中的通用数据资源被保存，而非特定场景中的某一个对象。据此，多个实例可被制作为预制组件对象，该过程可利用AssetDatbse类完成，这对于多个场景间的网格复用十分重要，进而在场景间使其变化结果和细节内容保持一致。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity脚本设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2019%2F04%2F02%2FLinux%2F</url>
    <content type="text"><![CDATA[Linux的cheat sheets 查看Linux系统版本信息查看Linux内核版本命令（两种方法）：1cat /proc/version 1uname -a 查看Linux系统版本的命令（3种方法）：1lsb_release -a 即可列出所有版本信息。 1cat /etc/redhat-release 这种方法只适合Redhat系的Linux。 1cat /etc/issue CentOS 7中无信息。 用户由于日常使用时root用户权限过大，所以添加一个用户供日常使用，或者供他人使用。有些软件（例如Elasticsearch）不支持root用户启动。 查看用户和用户组用户列表文件：/etc/passwd用户组列表文件：/etc/group 查看系统中有哪些用户 1cut -d : -f 1 /etc/passwd 查看可以登录系统的用户 1cat /etc/passwd | grep -v /sbin/nologin | cut -d : -f 1 查看用户操作： 1w (需要root权限) 查看当前活跃的用户列表 查看某一用户 1w 用户名 查看登录用户 1who 查看用户登录历史记录 1last 查看登录日志 1who /var/log/wtmp 创建1、创建新用户 1adduser [用户名] 2、修改新用户的密码 1passwd [用户名] 授权新创建的用户并不能使用sudo命令，需要给此用户添加授权。1、添加sudoers文件可写权限 1chmod -v u+w /etc/sudoers 2、修改sudoers文件 12vim /etc/sudoers[用户名] ALL=(ALL) ALL（如需新用户使用sudo时不用输密码，把最后一个ALL改为NOPASSWD:ALL即可） 3、收回sudoers文件可写权限 1chmod -v u-w /etc/sudoers]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch]]></title>
    <url>%2F2019%2F04%2F02%2FElasticsearch%2F</url>
    <content type="text"><![CDATA[ES的配置 简介使用的Elasticsearch版本是7.0.1。 全文搜索属于最常见的需求，开源的Elasticsearch是目前全文搜索引擎的首选。它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github都采用它。 Elastic的底层是开源库Lucene。但是，你没法直接用Lucene，必须自己写代码去调用它的接口。Elastic是Lucene 的封装，提供了REST API的操作接口，开箱即用。 Elasticsearch是一个实时的分布式搜索和分析引擎。它可以帮助你用前所未有的速度去处理大规模数据。ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。 安装Linux因为是用Java开发，所以必须要先安装Java。 Elastic 需要 Java 8 环境。如果你的机器还没安装 Java，可以参考这篇文章，注意要保证环境变量JAVA_HOME正确设置。 CentOS7 1curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.0.1-linux-x86_64.tar.gz ** 开机启动 ** Windows基本概念有一些概念是Elasticsearch的核心。从一开始就理解这些概念将极大地帮助简化学习过程。 近实时（NRT）Elasticsearch是一个近实时搜索平台。这意味着从索引文档到可搜索文档的时间有一点延迟（通常是一秒）。 集群集群是一个或多个节点（服务器）的集合，它们共同保存您的整个数据，并提供跨所有节点的联合索引和搜索功能。集群由唯一名称标识，默认情况下为“elasticsearch”。此名称很重要，因为如果节点设置为按名称加入集群，则该节点只能是此集群的一部分。 确保不要在不同的环境中重用相同的集群名称，否则最终会导致节点加入错误的集群。例如，您可以使用logging-dev，logging-stage以及logging-prod用于开发，升级和生产集群。 请注意，拥有一个只包含单个节点的集群是完全正常的。此外，您还可以拥有多个独立的集群，每个集群都有自己唯一的集群名称。 节点节点是作为群集一部分的单个服务器，存储数据并参与群集的索引和搜索功能。与集群一样，节点由名称标识，默认情况下，该名称是在启动时分配给节点的随机通用唯一标识符（UUID）。如果不需要默认值，可以定义所需的任何节点名称。此名称对于管理目的非常重要，您可以在其中识别网络中的哪些服务器与Elasticsearch集群中的哪些节点相对应。 可以将节点配置为按群集名称加入特定群集。默认情况下，每个节点都设置为加入一个名为cluster的集群elasticsearch，这意味着如果您在网络上启动了许多节点并且假设它们可以相互发现 - 它们将自动形成并加入一个名为的集群elasticsearch。 在单个群集中，您可以拥有任意数量的节点。此外，如果您的网络上当前没有其他Elasticsearch节点正在运行，则默认情况下启动单个节点将形成一个名为的新单节点集群elasticsearch。 索引索引是具有某些类似特征的文档集合。例如，您可以拥有客户数据的索引，产品目录的另一个索引以及订单数据的另一个索引。索引由名称标识（必须全部为小写），并且此名称用于在对其中的文档执行索引，搜索，更新和删除操作时引用索引。 在单个群集中，您可以根据需要定义任意数量的索引。 文件文档是可以编制索引的基本信息单元。例如，您可以为单个客户提供文档，为单个产品提供另一个文档，为单个订单提供另一个文档。该文档以JSON（JavaScript Object Notation）表示，JSON是一种普遍存在的互联网数据交换格式。在索引中，您可以根据需要存储任意数量的文档。 碎片和副本索引可能存储大量可能超过单个节点的硬件限制的数据。例如，占用1TB磁盘空间的十亿个文档的单个索引可能不适合单个节点的磁盘，或者可能太慢而无法单独从单个节点提供搜索请求。 为了解决这个问题，Elasticsearch提供了将索引细分为多个称为分片的功能。创建索引时，只需定义所需的分片数即可。每个分片本身都是一个功能齐全且独立的“索引”，可以托管在集群中的任何节点上。 分片很重要，主要有两个原因： 它允许您水平分割/缩放内容量它允许您跨分片（可能在多个节点上）分布和并行化操作，从而提高性能/吞吐量分片的分布方式以及如何将其文档聚合回搜索请求的机制完全由Elasticsearch管理，对用户而言是透明的。 在任何时候都可以预期出现故障的网络/云环境中，非常有用，强烈建议使用故障转移机制，以防分片/节点以某种方式脱机或因任何原因消失。为此，Elasticsearch允许您将索引的分片的一个或多个副本制作成所谓的副本分片或简称副本。 复制很重要，主要有两个原因： 它在碎片/节点出现故障时提供高可用性。因此，请务必注意，副本分片永远不会在与从中复制的原始/主分片相同的节点上分配。它允许您扩展搜索量/吞吐量，因为可以在所有副本上并行执行搜索。总而言之，每个索引可以拆分为多个分片。索引也可以复制为零（表示没有副本）或更多次。复制后，每个索引都将具有主分片（从中复制的原始分片）和副本分片（主分片的副本）。 可以在创建索引时为每个索引定义分片和副本的数量。创建索引后，您还可以随时动态更改副本数。您可以使用_shrink和_splitAPI 更改现有索引的分片数，但这不是一项简单的任务，预先计划正确数量的分片是最佳方法。 默认情况下，Elasticsearch中的每个索引都分配了一个主分片和一个副本，这意味着如果群集中至少有两个节点，则索引将具有一个主分片和另一个副本分片（一个完整副本），总共两个每个索引的分片。 2.1 Node 与 ClusterElastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。 单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。 2.2 IndexElastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。 所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。 下面的命令可以查看当前节点的所有 Index。 1$ curl -X GET &apos;http://localhost:9200/_cat/indices?v&apos; 2.3 DocumentIndex 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。 Document 使用 JSON 格式表示，下面是一个例子。 12345&#123; "user": "张三", "title": "工程师", "desc": "数据库管理"&#125; 同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。 三、新建和删除 Index新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫weather的 Index。 $ curl -X PUT ‘localhost:9200/weather’服务器返回一个 JSON 对象，里面的acknowledged字段表示操作成功。 { “acknowledged”:true, “shards_acknowledged”:true}然后，我们发出 DELETE 请求，删除这个 Index。 $ curl -X DELETE ‘localhost:9200/weather’ 中文分词ik-analyzerjava开源中文分词器 IK Analyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。 Windows系统中Elasticsearch安装中文分词插件elasticsearch-analysis-ik前言系统：Windows10 elasticsearch版本：5.6.6 中文分词版本：5.6.6（需要与elasticsearch版本匹配） maven版本：3.5.5 安装step1 官网下载合适的版本下载页面地址：https://github.com/medcl/elasticsearch-analysis-ik 选择合适的版本，并下载： step2 解压到某个目录下目录结构如下： step3 使用maven进行编译打包打开dos命令行，进入解压后的根目录： 分别执行三个命令（前提是成功安装maven）： mvn clean mvn compile mvn package step4 解压编译后的zip包上述3个命令操作之后，多了一个target文件夹： 找到releases下面的zip包 在elasticsearch的plugins文件夹下新建一个文件夹，命名为ik： 把maven打包之后的zip文件解压到ik文件夹里，如下图： step5 检测是否安装成功重新启动elasticsearch，可以启动说明安装成功！ OK, GAME OVER ! Linux首先，安装中文分词插件。这里使用的是 ik，也可以考虑其他插件（比如 smartcn）。 $ ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip上面代码安装的是5.5.1版的插件，与 Elastic 5.5.1 配合使用。 接着，重新启动 Elastic，就会自动加载这个新安装的插件。 然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。 $ curl -X PUT ‘localhost:9200/accounts’ -d ‘{ “mappings”: { “person”: { “properties”: { “user”: { “type”: “text”, “analyzer”: “ik_max_word”, “search_analyzer”: “ik_max_word” }, “title”: { “type”: “text”, “analyzer”: “ik_max_word”, “search_analyzer”: “ik_max_word” }, “desc”: { “type”: “text”, “analyzer”: “ik_max_word”, “search_analyzer”: “ik_max_word” } } } }}’上面代码中，首先新建一个名称为accounts的 Index，里面有一个名称为person的 Type。person有三个字段。 usertitledesc这三个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。 Elastic 的分词器称为 analyzer。我们对每个字段指定分词器。 “user”: { “type”: “text”, “analyzer”: “ik_max_word”, “search_analyzer”: “ik_max_word”}上面代码中，analyzer是字段文本的分词器，search_analyzer是搜索词的分词器。ik_max_word分词器是插件ik提供的，可以对文本进行最大数量的分词。 数据操作5.1 新增记录向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向/accounts/person发送请求，就可以新增一条人员记录。 $ curl -X PUT ‘localhost:9200/accounts/person/1’ -d ‘{ “user”: “张三”, “title”: “工程师”, “desc”: “数据库管理”}’服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。 123456789&#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_version&quot;:1, &quot;result&quot;:&quot;created&quot;, &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;, &quot;created&quot;:true&#125; 如果你仔细看，会发现请求路径是/accounts/person/1，最后的1是该条记录的 Id。它不一定是数字，任意字符串（比如abc）都可以。 新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。 123456$ curl -X POST &apos;localhost:9200/accounts/person&apos; -d &apos;&#123; &quot;user&quot;: &quot;李四&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;系统管理&quot;&#125;&apos; 上面代码中，向/accounts/person发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，_id字段就是一个随机字符串。 123456789&#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;, &quot;_version&quot;:1, &quot;result&quot;:&quot;created&quot;, &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;, &quot;created&quot;:true&#125; 注意，如果没有先创建 Index（这个例子是accounts），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。所以，打字的时候要小心，不要写错 Index 的名称。 5.2 查看记录向/Index/Type/Id发出 GET 请求，就可以查看这条记录。 $ curl ‘localhost:9200/accounts/person/1?pretty=true’上面代码请求查看/accounts/person/1这条记录，URL 的参数pretty=true表示以易读的格式返回。 返回的数据中，found字段表示查询成功，_source字段返回原始记录。 12345678910111213&#123; &quot;_index&quot; : &quot;accounts&quot;, &quot;_type&quot; : &quot;person&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理&quot; &#125;&#125; 如果 Id 不正确，就查不到数据，found字段就是false。 12345678$ curl &apos;localhost:9200/weather/beijing/abc?pretty=true&apos;&#123; &quot;_index&quot; : &quot;accounts&quot;, &quot;_type&quot; : &quot;person&quot;, &quot;_id&quot; : &quot;abc&quot;, &quot;found&quot; : false&#125; 5.3 删除记录删除记录就是发出 DELETE 请求。 12$ curl -X DELETE &apos;localhost:9200/accounts/person/1&apos; 这里先不要删除这条记录，后面还要用到。 5.4 更新记录更新记录就是使用 PUT 请求，重新发送一次数据。 1234567891011121314151617$ curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;&#123; &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot;&#125;&apos; &#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_version&quot;:2, &quot;result&quot;:&quot;updated&quot;, &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;, &quot;created&quot;:false&#125; 上面代码中，我们将原始数据从”数据库管理”改成”数据库管理，软件开发”。 返回结果里面，有几个字段发生了变化。 1234&quot;_version&quot; : 2,&quot;result&quot; : &quot;updated&quot;,&quot;created&quot; : false可以看到，记录的 Id 没变，但是版本（version）从1变成2，操作类型（result）从created变成updated，created字段变成false，因为这次不是新建记录。 数据查询6.1 返回所有记录使用 GET 方法，直接请求/Index/Type/_search，就会返回所有记录。 1234567891011121314151617181920212223242526272829303132333435$ curl &apos;localhost:9200/accounts/person/_search&apos;&#123; &quot;took&quot;:2, &quot;timed_out&quot;:false, &quot;_shards&quot;:&#123;&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0&#125;, &quot;hits&quot;:&#123; &quot;total&quot;:2, &quot;max_score&quot;:1.0, &quot;hits&quot;:[ &#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;, &quot;_score&quot;:1.0, &quot;_source&quot;: &#123; &quot;user&quot;: &quot;李四&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;系统管理&quot; &#125; &#125;, &#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_score&quot;:1.0, &quot;_source&quot;: &#123; &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot; &#125; &#125; ] &#125;&#125; 上面代码中，返回结果的 took字段表示该操作的耗时（单位为毫秒），timed_out字段表示是否超时，hits字段表示命中的记录，里面子字段的含义如下。 total：返回记录数，本例是2条。max_score：最高的匹配程度，本例是1.0。hits：返回的记录组成的数组。返回的记录中，每条记录都有一个_score字段，表示匹配的程序，默认是按照这个字段降序排列。 6.2 全文搜索Elastic 的查询非常特别，使用自己的查询语法，要求 GET 请求带有数据体。 1234$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件&quot; &#125;&#125;&#125;&apos; 上面代码使用 Match 查询，指定的匹配条件是desc字段里面包含”软件”这个词。返回结果如下。 12345678910111213141516171819202122&#123; &quot;took&quot;:3, &quot;timed_out&quot;:false, &quot;_shards&quot;:&#123;&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0&#125;, &quot;hits&quot;:&#123; &quot;total&quot;:1, &quot;max_score&quot;:0.28582606, &quot;hits&quot;:[ &#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_score&quot;:0.28582606, &quot;_source&quot;: &#123; &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot; &#125; &#125; ] &#125;&#125; Elastic 默认一次返回10条结果，可以通过size字段改变这个设置。 12345$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;, &quot;size&quot;: 1&#125;&apos; 上面代码指定，每次只返回一条结果。 还可以通过from字段，指定位移。 123456$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;, &quot;from&quot;: 1, &quot;size&quot;: 1&#125;&apos; 上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。 6.3 逻辑运算如果有多个搜索关键字， Elastic 认为它们是or关系。 1234$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件 系统&quot; &#125;&#125;&#125;&apos; 上面代码搜索的是软件 or 系统。 如果要执行多个关键词的and搜索，必须使用布尔查询。 1234567891011$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;软件&quot; &#125; &#125;, &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;系统&quot; &#125; &#125; ] &#125; &#125;&#125;&apos; 数据同步首先是数据同步，将mysql数据同步到es的方式很多，经过测试，稳定且易用的是 logstash-input-jdbc 全量同步与增量同步 全量同步是指全部将数据同步到es，通常是刚建立es，第一次同步时使用。增量同步是指将后续的更新、插入记录同步到es。（删除记录没有办法同步，只能两边执行自己的删除命令） 二、安装logstash-input-jdbc插件logstash-input-jdbc插件是logstash 的一个插件。 Logstash是一个开源数据收集引擎，具有实时管道功能。Logstash可以动态地将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地。logstash是一个数据分析软件，主要目的是分析log日志。首先将数据传给logstash，它将数据进行过滤和格式化（转成JSON格式），然后传给Elasticsearch进行存储、建搜索的索引。logstash和Elasticsearch是用Java写的 使用ruby语言开发。 下载插件过程中最大的坑是下载插件相关的依赖的时候下不动，因为国内网络的原因，访问不到亚马逊的服务器。 解决办法，改成国内的ruby仓库镜像。此镜像托管于淘宝的阿里云服务器上 ： 三、实现样例。Linux目的 ： 监听数据表的数据，当我有新增时增加到elasticsearch，当我修改时，update到elasticsearch。 第一 前提： 1, 我有mysql数据库，我有一张hotel 表， hotel_account表（此表里有hotel_id）, 里面无数据。 2，已经启动 elasticsearch . 地址是 http://192.168.0.45 端口：9200. 3，已经安装 logstash, 地址在 /opt/logstash 第二 准备 两个文件： jdbc.conf jdbc.sql 。名字随便起啦。 一个 mysql 的java 驱动包： mysql-connector-java-5.1.36-bin.jar jdbc.conf 内容： 注意 statement_filepath =&gt; “jdbc.sql” 这个名字要跟下面的sql文件的名字对应上。 参考 logstash-input-jdbc官方参考文档 重点字段说明： schedule：设置监听间隔。可以设置每隔多久监听一次什么的。具体参考官方文档。 statement_filepath： 执行的sql 文件路径+名称 1234567891011121314151617181920212223242526272829303132333435363738394041input &#123; stdin &#123; &#125; jdbc &#123; # mysql jdbc connection string to our backup databse jdbc_connection_string =&gt; &quot;jdbc:mysql://192.168.0.49:3306/dfb&quot; # the user we wish to excute our statement as jdbc_user =&gt; &quot;test&quot; jdbc_password =&gt; &quot;test&quot; # the path to our downloaded jdbc driver jdbc_driver_library =&gt; &quot;/opt/logstash/mysql-connector-java-5.1.36-bin.jar&quot; # the name of the driver class for mysql jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot; jdbc_paging_enabled =&gt; &quot;true&quot; jdbc_page_size =&gt; &quot;50000&quot; statement_filepath =&gt; &quot;jdbc.sql&quot; schedule =&gt; &quot;* * * * *&quot; type =&gt; &quot;jdbc&quot; &#125;&#125;filter &#123; json &#123; source =&gt; &quot;message&quot; remove_field =&gt; [&quot;message&quot;] &#125;&#125;output &#123; elasticsearch &#123; host =&gt; &quot;192.168.0.199&quot; port =&gt; &quot;9200&quot; protocol =&gt; &quot;http&quot; index =&gt; &quot;mysql01&quot; document_id =&gt; &quot;%&#123;id&#125;&quot; cluster =&gt; &quot;logstash-elasticsearch&quot; &#125; stdout &#123; codec =&gt; json_lines &#125;&#125; jdbc.sql 12345678910select h.id as id, h.hotel_name as name, h.photo_url as img, ha.id as haId, ha.finance_personfrom hotel h LEFT JOIN hotel_account ha on h.id = ha.hotel_idwhere h.last_modify_time &gt;= :sql_last_start 第三： 启动 logstash 1sudo bin/logstash -f jdbc.conf 如果一切顺利 应该如图： 现在 logstash 已经开始监听mysql 的表了。查询哪些表 就在jdbc.sql 写sql语句就行了。 现在 手动的 hotel， hotel_account 分别增加一条数据： 1INSERT INTO hotel(hotel_name, photo_url) VALUES("马二帅酒店","images/madashuai.img"); 找到 hotel 的id 1INSERT INTO hotel_account(hotel_id, finance_person) VALUES(15627, "马二帅"); 大约30秒的时候查看es 很好马二帅酒店已经增加进来了。 现在修改下 hotel_account 1UPDATE hotel_account SET finance_person = "马二帅修改为马小帅" where id = 1601; WindowsLogstash-input-jdbc插件高效又方便，而且可以设置定时任务。 1、安装插件 在logstash的bin目录下执行命令： logstash-plugin install logstash-input-jdbc 2、配置文件和jar包 在bin目录下新建一个config-mysql目录,里面包含mysql.conf,在H:\software\logstash-6.1.2\logstash-6.1.2\lib 加入mysql的驱动 mysql-connector-java-5.1.38.jar mysql.conf的内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142input &#123; stdin &#123; &#125; jdbc &#123; # 数据库 jdbc_connection_string =&gt; &quot;jdbc:mysql://39.107.60.74:3306/db_plat3&quot; # 用户名密码 jdbc_user =&gt; &quot;root&quot; jdbc_password =&gt; &quot;letsgo123QWE&quot; # jar包的位置 jdbc_driver_library =&gt; &quot;H:\software\logstash-6.1.2\logstash-6.1.2\lib\mysql-connector-java-5.1.38.jar&quot; # mysql的Driver jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot; jdbc_paging_enabled =&gt; &quot;true&quot; jdbc_page_size =&gt; &quot;50000&quot; #statement_filepath =&gt; &quot;config-mysql/test02.sql&quot; statement =&gt; &quot;select * from information&quot; schedule =&gt; &quot;* * * * *&quot; #索引的类型 type =&gt; &quot;information&quot; &#125;&#125; filter &#123; json &#123; source =&gt; &quot;message&quot; remove_field =&gt; [&quot;message&quot;] &#125;&#125; output &#123; elasticsearch &#123; hosts =&gt; &quot;192.168.1.70:9200&quot; # index名 index =&gt; &quot;information&quot; # 需要关联的数据库中有有一个id字段，对应索引的id号 document_id =&gt; &quot;%&#123;id&#125;&quot; &#125; stdout &#123; codec =&gt; json_lines &#125;&#125; 3、启动logstash 然后通过以下命令启动logstash .\logstash.bat -f .\config-mysql\mysql.conf 过一会他就会自动的往ES里添加数据。 报错了，需要把mysql.conf改成ANSI格式。 4、增量索引 但是现在有一个问题是：往elasticsearch里面写入是全量的，需要改成增量。 修改mysql.conf的内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253input &#123; stdin &#123; &#125; jdbc &#123; # 数据库 jdbc_connection_string =&gt; &quot;jdbc:mysql://39.107.60.74:3306/db_plat3&quot; # 用户名密码 jdbc_user =&gt; &quot;root&quot; jdbc_password =&gt; &quot;letsgo123QWE&quot; # jar包的位置 jdbc_driver_library =&gt; &quot;H:\software\logstash-6.1.2\logstash-6.1.2\lib\mysql-connector-java-5.1.38.jar&quot; # mysql的Driver jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot; #使用其它字段追踪，而不是用时间 use_column_value =&gt; true #追踪的字段 tracking_column =&gt; id record_last_run =&gt; true #上一个sql_last_value值的存放文件路径, 必须要在文件中指定字段的初始值last_run_metadata_path=&gt;&quot;H:\software\logstash-6.1.2\logstash-6.1.2\bin\config-mysql\station_parameter.txt&quot; #开启分页查询 jdbc_paging_enabled =&gt; &quot;true&quot; jdbc_page_size =&gt; &quot;50000&quot; statement_filepath =&gt; &quot;config-mysql/information.sql&quot; #statement =&gt; &quot;select * from information where id &gt; :sql_last_value &quot; schedule =&gt; &quot;* * * * *&quot; #索引的类型 type =&gt; &quot;information&quot; &#125;&#125; filter &#123; json &#123; source =&gt; &quot;message&quot; remove_field =&gt; [&quot;message&quot;] &#125;&#125; output &#123; elasticsearch &#123; hosts =&gt; &quot;192.168.1.70:9200&quot; # index名 index =&gt; &quot;information&quot; # 需要关联的数据库中有有一个id字段，对应索引的id号 document_id =&gt; &quot;%&#123;id&#125;&quot; &#125; stdout &#123; codec =&gt; json_lines &#125;&#125; 修改的内容见红色。 station_parameter.txt中的内容如下： logstash执行时打印出来的sql如下： 其中遇到的一个问题是用： statement =&gt; “select * from information where id &gt; :sql_last_value “ 时会报:sql_last_value 的错 ，暂时不知道怎么解决。于是改用文件config-mysql/information.sql存在sql语句。 ps : 上述问题是因为从人家那里copy过来的时候是错的 把 :last_sql_value 改成 :sql_last_value 就可以了。 5、用时间来实现增量： 1234567891011121314151617181920212223242526272829303132333435363738394041input &#123;stdin &#123;&#125;jdbc &#123;# 数据库jdbc_connection_string =&gt; &quot;jdbc:mysql://39.107.60.74:3306/db_plat3&quot;# 用户名密码jdbc_user =&gt; &quot;root&quot;jdbc_password =&gt; &quot;letsgo123QWE&quot;# jar包的位置jdbc_driver_library =&gt; &quot;H:\software\logstash-6.1.2\logstash-6.1.2\lib\mysql-connector-java-5.1.38.jar&quot;# mysql的Driverjdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;#开启分页查询jdbc_paging_enabled =&gt; &quot;true&quot;jdbc_page_size =&gt; &quot;50000&quot;#statement_filepath =&gt; &quot;config-mysql/information.sql&quot;statement =&gt; &quot;select * from information where modify_time &gt; :sql_last_value&quot;schedule =&gt; &quot;* * * * *&quot;#索引的类型type =&gt; &quot;information&quot;&#125;&#125;filter &#123;json &#123;source =&gt; &quot;message&quot;remove_field =&gt; [&quot;message&quot;]&#125;&#125;output &#123;elasticsearch &#123;hosts =&gt; &quot;192.168.1.70:9200&quot;# index名index =&gt; &quot;information&quot;# 需要关联的数据库中有有一个id字段，对应索引的id号document_id =&gt; &quot;%&#123;id&#125;&quot;&#125;stdout &#123;codec =&gt; json_lines&#125;&#125; modify_time 是我表里的最后修改时间字段。而 :sql_last_value如果input里面use_column_value =&gt; true， 即如果设置为true的话，可以是我们设定的字段的上一次的值。默认 use_column_value =&gt; false， 这样 :sql_last_value为上一次更新的最后时刻值。也就是说，对于新增的值，才会更新。这样就实现了增量更新的目的。 管理工具可视化 ealsticsearch只是后端提供各种api，那么怎么直观的使用它呢？elasticsearch-head是一款专门针对于elasticsearch的客户端工具 elasticsearch-head配置包，下载地址：https://github.com/mobz/elasticsearch-head elasticsearch-head是一个基于node.js的前端工程，启动elasticsearch-head的步骤如下（这里针对的是elasticsearch 5.x以上的版本）： 1、进入elasticsearch-head的文件夹，如：D:\xwj_github\elasticsearch-head 2、执行 npm install 3、执行 npm run start 在浏览器访问http://localhost:9100，可看到如下界面，表示启动成功： 仔细观察，我们会发现客户端默认连接的是我们elasticsearch的默认路径。而此时elasticsearch服务未启动，所以集群健康值是未连接 集群健康值的几种状态如下： 绿色，最健康的状态，代表所有的分片包括备份都可用 黄色，基本的分片可用，但是备份不可用（也可能是没有备份） 红色，部分的分片可用，表明分片有一部分损坏。此时执行查询部分数据仍然可以查到，遇到这种情况，还是赶快解决比较好 灰色，未连接到elasticsearch服务 配合elasticsearch启动ElasticSearch-head 和 elasticsearch 是两个功能，如果互相访问，是跨域问题。解决跨域问题，后才可以正常用elasticsearch-head 管理 elasticsearch。 修改config/elasticsearch.yml 文件(增加如下配置,中间为英文符号空格) 12http.cors.enabled: truehttp.cors.allow-origin: "*" 启动服务重启elasticsearch-head 和 elasticsearch。访问elasticsearch-head 此时，我们启动elasticsearch服务，重新刷新浏览器，发现集群健康值变成了黄色，如下： 1、概览 通过上图可以看到我们的节点名称为elasticsearch，并且该节点下有两个索引test_index1、test_index2 在test_index2下，选择信息–&gt;索引信息，可以查看该索引的所有信息，包括mappings、setting等等 在test_index2下，选择动作–&gt;关闭/开启，可以关闭/开启该索引，关闭后的索引如图： 在该界面也可以模糊查询索引、设置刷新频率等操作。如下图： 2、索引 在这里，可以查看到所以的索引，并且还可以创建一个新的索引，如下图： 3、数据浏览 这里可看到索引、类型、字段、数据信息，如下图所示： 关于这些名词表示的意思，可以参考https://www.cnblogs.com/luxiaoxun/p/4869509.html 4、基本查询 在这个页签，可以做数据进项简单的查询 选择一个索引，然后再选择不同的查询条件，勾选“显示查询语句”，最后点击搜索，可以看到具体的查询json和查询结果 至于不同组合的查询条件表示的意思，可以参考https://www.cnblogs.com/ljhdo/p/5040252.html 5、复合查询 在这个页签，可以使用json进行复杂的查询，也可发送put请求新增及跟新索引，使用delete请求删除索引等等。如图所示： 该页签的简单使用可以参考https://blog.csdn.net/bsh_csn/article/details/53908406 logstash-input-jdbc配置说明Logstash由三个组件构造成，分别是input、filter以及output。我们可以吧Logstash三个组件的工作流理解为：input收集数据，filter处理数据，output输出数据。至于怎么收集、去哪收集、怎么处理、处理什么、怎么发生以及发送到哪等等一些列的问题就是我们接下啦要讨论的一个重点。我们今天先讨论input组件的功能和基本插件。前面我们意见介绍过了，input组件是Logstash的眼睛和鼻子，负责收集数据的，那么们就不得不思考两个问题，第一个问题要清楚的就是，元数据在哪，当然，这就包含了元数据是什么类型，属于什么业务；第二个问题要清楚怎么去拿到元数据。只要搞明白了这两个问题，那么Logstash的input组件就算是弄明白了。对于第一个问题，元数据的类型有很多，比如说你的元数据可以是日志、报表、可以是数据库的内容等等。元数据是什么样子的我们不需要关心，我们要关系的是元数据是什么类型的，只要你知道元数据是什么类型的，你才能给他分类，或者说给他一个type，这很重要，type对于你后面的工作处理是非常有帮助的。所以第一个问题的重心元数据在吗，是什么，现在已经是清楚了。那么进行第二个问题。第二个问题的核心是怎么拿到这些不同类型的原数据？这是一个真个input组件的核心内容了，我们分门别类的来看待这和解决个问题。首先，我们肯定需要认同的，什么样的数据源，就需要使用什么样的方式去获取数据。我们列举几种：1、文件类型：文件类型，顾名思义，文件数据源，我们可以使用input组件的file插件来获取数据。file{}插件有很多的属性参数，我们可以张开讲解一下。具体内容在下面的代码中展示： 12345678910111213141516171819202122input&#123; file&#123; #path属性接受的参数是一个数组，其含义是标明需要读取的文件位置 path =&gt; [‘pathA’，‘pathB’] #表示多就去path路径下查看是够有新的文件产生。默认是15秒检查一次。 discover_interval =&gt; 15 #排除那些文件，也就是不去读取那些文件 exclude =&gt; [‘fileName1’,‘fileNmae2’] #被监听的文件多久没更新后断开连接不在监听，默认是一个小时。 close_older =&gt; 3600 #在每次检查文件列 表的时候， 如果一个文件的最后 修改时间 超过这个值， 就忽略这个文件。 默认一天。 ignore_older =&gt; 86400 #logstash 每隔多 久检查一次被监听文件状态（ 是否有更新） ， 默认是 1 秒。 stat_interval =&gt; 1 #sincedb记录数据上一次的读取位置的一个index sincedb_path =&gt; ’$HOME/. sincedb‘ #logstash 从什么 位置开始读取文件数据， 默认是结束位置 也可以设置为：beginning 从头开始 start_position =&gt; ‘beginning’ #注意：这里需要提醒大家的是，如果你需要每次都从同开始读取文件的话，关设置start_position =&gt; beginning是没有用的，你可以选择sincedb_path 定义为 /dev/null &#125; &#125; 2、数据库类型：数据库类型的数据源，就意味着我们需要去和数据库打交道了是吗？是的！那是必须的啊，不然怎么获取数据呢。input组件如何获取数据库类的数据呢？没错，下面即将隆重登场的是input组件的JDBC插件jdbc{}。同样的，jdbc{}有很多的属性，我们在下面的代码中作出说明； 1234567891011121314151617181920212223242526272829303132333435input&#123; jdbc&#123; #jdbc sql server 驱动,各个数据库都有对应的驱动，需自己下载 jdbc_driver_library =&gt; &quot;/etc/logstash/driver.d/sqljdbc_2.0/enu/sqljdbc4.jar&quot; #jdbc class 不同数据库有不同的 class 配置 jdbc_driver_class =&gt; &quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot; #配置数据库连接 ip 和端口，以及数据库 jdbc_connection_string =&gt; &quot;jdbc:sqlserver://200.200.0.18:1433;databaseName=test_db&quot; #配置数据库用户名 jdbc_user =&gt; #配置数据库密码 jdbc_password =&gt; #上面这些都不重要，要是这些都看不懂的话，你的老板估计要考虑换人了。重要的是接下来的内容。 # 定时器 多久执行一次SQL，默认是一分钟 # schedule =&gt; 分 时 天 月 年 # schedule =&gt; 22 表示每天22点执行一次 schedule =&gt; &quot; *&quot; #是否清除 last_run_metadata_path 的记录,如果为真那么每次都相当于从头开始查询所有的数据库记录 clean_run =&gt; false #是否需要记录某个column 的值,如果 record_last_run 为真,可以自定义我们需要表的字段名称， #此时该参数就要为 true. 否则默认 track 的是 timestamp 的值. use_column_value =&gt; true #如果 use_column_value 为真,需配置此参数. 这个参数就是数据库给出的一个字段名称。当然该字段必须是递增的，可以是 数据库的数据时间这类的 tracking_column =&gt; create_time #是否记录上次执行结果, 如果为真,将会把上次执行到的 tracking_column 字段的值记录下来,保存到 last_run_metadata_path 指定的文件中 record_last_run =&gt; true #们只需要在 SQL 语句中 WHERE MY_ID &gt; :last_sql_value 即可. 其中 :sql_last_value 取得就是该文件中的值 last_run_metadata_path =&gt; &quot;/etc/logstash/run_metadata.d/my_info&quot; #是否将字段名称转小写。 #这里有个小的提示，如果你这前就处理过一次数据，并且在Kibana中有对应的搜索需求的话，还是改为true， #因为默认是true，并且Kibana是大小写区分的。准确的说应该是ES大小写区分 lowercase_column_names =&gt; false #你的SQL的位置，当然，你的SQL也可以直接写在这里。 #statement =&gt; SELECT * FROM tabeName t WHERE t.creat_time &gt; :sql_last_valuestatement_filepath =&gt; &quot;/etc/logstash/statement_file.d/my_info.sql&quot; #数据类型，标明你属于那一方势力。单了ES哪里好给你安排不同的山头。 type =&gt; &quot;my_info&quot; &#125; #注意：外载的SQL文件就是一个文本文件就可以了，还有需要注意的是，一个jdbc&#123;&#125;插件就只能处理一个SQL语句， #如果你有多个SQL需要处理的话，只能在重新建立一个jdbc&#123;&#125;插件。 &#125; 好了，废话不多说了，接着第三种情况： 123456789input &#123; beats &#123; #接受数据端口 port =&gt; 5044 #数据类型 type =&gt; &quot;logs&quot; &#125; #这个插件需要和filebeat进行配很这里不做多讲，到时候结合起来一起介绍。&#125; 现在我们基本清楚的知道了input组件需要做的事情和如何去做，当然他还有很多的插件可以进行数据的收集，比如说TCP这类的，还有可以对数据进行encode，这些感兴趣的朋友可以自己去查看，我说的只是我自己使用的。一般情况下我说的三种插件已经足够了。今天的ELK种的Logstash的input组件就到这。后面还会讲述Logstash的另外另个组件filter和output。 注意：如果看到这样的报错信息 Logstash could not be started because there is already another instance using the configured data directory. If you wish to run multiple instances, you must change the “path.data” setting. 请执行命令：service logstash stop 然后在执行就可以了。 123456789101112131415161718192021222324252627282930313233343536input&#123; stdin&#123; &#125; jdbc&#123; jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/yld&quot; jdbc_user =&gt; &quot;root&quot; jdbc_password =&gt; &quot;root&quot; jdbc_driver_library =&gt; &quot;D:\Downloads\logstash-7.1.0\logstash-7.1.0\lib\mysql-connector-java-5.1.38.jar&quot; jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot; jdbc_paging_enabled =&gt; &quot;true&quot; jdbc_page_size =&gt; &quot;50000&quot; statement =&gt; &quot;select Ems_kctitle,tags from study_indextag&quot; schedule =&gt; &quot;* * * * *&quot; type =&gt; &quot;jdbc&quot; &#125;&#125;filter &#123; json&#123; source =&gt; &quot;message&quot; remove_field =&gt; [&quot;message&quot;] &#125;&#125;output &#123; elasticsearch&#123; hosts =&gt; &quot;127.0.0.1:9200&quot; index =&gt; &quot;ceshi&quot; document_id =&gt; &quot;%&#123;id&#125;&quot; &#125; stdout&#123; codec =&gt; json_lines &#125;&#125; PHP操作Elasticsearch]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI综合示例--音乐播放器的UI搭建]]></title>
    <url>%2F2019%2F03%2F31%2FUGUI%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E7%9A%84UI%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本章将给出一个由UGUI系统搭建的音乐播放器的UI。 (1)首先导入需要用到的图片资源。图片列表以及图片用途如下表所示。 (2)需要注意的是，导入的图片类型是PNG类型的，在使用前需要在Inspector面板中设置为精灵模式Sprite(2D and UI)，这样才能通过Image控件正常显示出来。 (3)搭建UI。下面将用表格的形式介绍场景中Canvas下的MusicPlayer及其子对象，可以按照下表中的内容及层级关系依次进行创建。 (4)按照上面的表格内容创建MusicPlayer游戏对象及其子对象，为每个控件赋予相应的贴图后，在Game窗口中应该可以看到下图所示的UI。其子对象结构如下图所示。下面将对部分特殊控件的设置进行介绍。 在搭建MusicPlayer时，若子对象中有Image组件，需要赋予贴图，每个控件对应的贴图可以自行查表。 (5)首先将图4-105中所示的Canvas组件中的Render Mode设置为”World Space”,如图4-106所示。这样,该画布就可以在3D场景中进行旋转等变换了。然后将SoundBT下的子对象BackGroundMask中的Image组件的颜色设置为黑色,透明度设置为半透明。如图4-107所示。 12]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity游戏开发技术详解与典型案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第12章 场景的分离与合并]]></title>
    <url>%2F2019%2F03%2F30%2F%E7%AC%AC12%E7%AB%A0%20%E5%9C%BA%E6%99%AF%E7%9A%84%E5%88%86%E7%A6%BB%E4%B8%8E%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 场景分离本章将对之前开发的场景进行分离，实际开发中这样做可以使分工更明确。也就是说，UI开发人员、等级设计师、主要开发人员可以先根据需求在各自领域内进行开发，实际运行游戏时再合并。 下面将要开发的场景分为游戏逻辑场景和舞台场景。对于Project视图，可以建立多个文件夹，并将相关项目等按照文件夹进行分类。但对于Hierarchy视图，因为其内部元素只能是游戏对象，所以需要采用父子关系对游戏对象分门别类。建立空游戏对象并将其重命名为-STAGES，然后将场景舞台相关项目全部拖曳到-STAGES下，成为其子节点。GameManager、GameUI、Canvas、EventSytem、MainCamera、Player等都是设计领域相关元素，故不需要拖曳到STAGES下，如下图所示。 将舞台场景相关对象整理到-STAGES后，必须先保存所有脚本和场景，然后再进行后续的分类工作。另外，为防止在场景分类过程中发生失误，可以先复制场景作为备份，然后再分类。 先选择项目视图的01. ScenescPlay并复制（Windows: Crl + D），将复制的场景重合名为sePlay backup。 场景合并游戏开发过程中，初次进入的画面除了游戏视频或Cut-Scene动画外，通常都是主菜单画面。第7章制作了seMain场景的Start按钮，下面编写脚本，使玩家可以通过点击该按钮而合并上述两个场景。打开seMain场景，如脚本12-1所示修改UMgr脚本。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第11章 光照贴图，灯光探测器]]></title>
    <url>%2F2019%2F03%2F30%2F%E7%AC%AC11%E7%AB%A0%20%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE%EF%BC%8C%E7%81%AF%E5%85%89%E6%8E%A2%E6%B5%8B%E5%99%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Unity 5的最大变化之一就是光照部分，这个版本的Unity统一管理并处理光照，包括实时全局光照（RealTime Global Illumination），实时光照（RealTime Lightmapping）、灯光探测器（Light Probe）、反射探头（Reflection Probe）等等。同时，新版本采用新引擎Enlighten，以代替Beast引擎。 光照光照功能可使用一张或多张纹理，事先烘焙场景内所有对3D模型有影响的直接光照、间接光照、光反射以及阴影等，然后在游戏运行时使之混合显示于画面。因此，这种预先烘焙技术可以在游戏进行时实时渲染，且不影响运行速度，用于构建高质量光照效果。Unity 4.x版本中只能看到烘焙光照，而从Unity 5开始，可以在编辑器中直接查看实时光照效果。 Generate Lightmap UVs选项 要想使用光照贴图，需要首先从外部导入3D模型Uvs，并勾选Barrel模型的FBX Import setting的Generate Lightmap UVs选项，这样才能使用光照贴图效果。 勾选3D模型的Import setting的Generate Lightmap UVs选项 Lightmap Static标记要想使用光照贴图功能，需要通知光照引擎处理哪个模型。因此，依次选择Barrel、Floor、Wall、Slope等模型，分别将其在Inspector视图的Static选项设为Lightmap Static。 设置Lightmap Static标记 光照视图选择菜单Window-&gt;Lighting打开光照视图，然后选择Scene选项卡，之后即可看到光照视图窗口中提供了对Skybox、Reflection、GI、Fog等细节进行设置的选项。 光照视图的多种设置选项 完成上述各种光照设置后，为了能够肉眼看到光照效果，可以先暂时禁用Directional Light。但这样设置后，Scene视图中还是可以隐约看到场景。因此，为了表现漆黑的天空，还需要继续设置环境光照（Environment Lighting）。 禁用Directional Light也能隐约看到场景 首先，光照视图中的Ambient Source选项可以指定环境光源，其默认值为Skybox。Unity 4.x版本中只能将该选项指定为Color，Unity 5中有3种选项（Skybox/Gradient（梯度）/Color）可选择。 将此选项更改为Color，然后将下方出现的Ambient Color选项设置为黑色。Ambient Intensity为调节光源亮度的选项，将其设置为0，然后与上图比较。可以发现，设置为0后好像画面稍暗，但地面仍然可以看到天空颜色的反射，看上去有些亮。 Reflection Source属性是设置3D模型表面光源反射相关属性的选项，默认值Skybox表示反射天空的光照。将此选项更改为Custom，Reflection intensity选项设置为0，这样地面的反射效果也会消失。完成设置后再次查看Scene视图，可以看到地面一片漆黑，如下图所示。 更改Ambient Source和Reflection Source属性后的场景 准备烘焙光照的过程在菜单中依次选择GameObject-&gt;Light-&gt;Point Light，生成点光源。如下表所示设置其属性，设置完成后复制点光源，分别置于油桶周边。 设置点光源的属性 属性 说明 设置值 Baking 是否烘焙光照 Baked Color 光照颜色 指定为红色、绿色、青色等原色 Intensity 光照亮度（光亮） 3 Shadow Type 阴影类型 Soft Shadow 在油桶周边生成点光源以查看光照效果 Light组件的Baking选项有Realtime/Baked/Mixed这3种取值。 Light组件的Baking选项 Baking选项 说明 是否使用光照贴图 Realtime 实时光照 X Baked 使用光照贴图，需要预先烘焙，非实时光照 √ Mixed 混合模式，使用光照贴图，non-static对象可具备实时光照效果 √ Auto选项为了烘焙光照贴图，需要先停止实时光照烘焙功能，所以取消光照视图下方的Auto选项的勾选。该选项在新建项目时会默认勾选，勾选后，Unity会使用实时光照。如下图所示，放置点光源时即可看到实时光照效果。 如果计算机性能不高，实时光照可能引发画面断断续续，所以此处一定要关闭Auto选项后再进行后续操作。 构建光照贴图构建光照贴图前需要先对烘焙品质进行设置。将光照视图中Baked GI选项中的Baked Resolutiont设置为10（默认值为40，表示像素密度）。另外，将General GI选项中的Atlas Size属性设置为512（光要烘焙的光照贴图大小）。 设置光照贴图的品质和图像大小 点击光照视图底端Build按钮后，光照贴图的烘焙就会开始。根据场景大小和光照分辨率的不同，构建少则需要1-2分钟，多则需要数十分钟。可在编辑器下端状态栏查看构建进度，烘焙时，也可以同时在Unity IDE中进行其他工作。 烘焙光照贴图 完成光照贴图的烘焙后，可在下方预览区或光照视图窗口的Lightmaps选项卡中查看光照纹理等。光照贴图使用的纹理可以预先在photoshop中进行各种处理，比如改变图像颜色或使用各种滤镜效果，保存后即可直接在Unity中使用。 烘焙光照贴图后，场景中的点光源将不再在场景中产生实时光照效果。因此，如果需要更改或添加光照位置，则需要再次烘焙光照贴图，这样光照效果的变动才能反映到光照贴图纹理。 光照贴图烘焙完成后的油桶模型周边阴影效果 如果Barrel模型周边不生成阴影或仅能看见黑色，则需要查看以下内容。 Barrel模型的FBX Import Setting中，需要勾选Generate Lightmap UVs选项。需要为Barrel、Floor、Wall、Slope模型设置Lightmapping Static。 Area Light区域光照是不具备实时光照效果的。区域光照的特性就是只能通过光照贴图实现间接光照效果。 区域光照的效果只能通过预先烘焙实现 可以调整区域光照的长度和宽度，在场景中的墙壁附近放置区域光照光源，并设置其X轴角度为0，使光照朝向墙壁。 Area Light属性设置值 属性 说明 设置值 Color 光源颜色 指定为红色、绿色、青色等原色 Intensity 光源亮度（光亮） 0.6 Width 光源长度 50 Height 光源高度 3 设置属性后需要烘焙光照贴图，烘焙完成后即可看到墙壁上的光照效果，如下图所示。另外墙和地面的警戒线也会表现出相应的反光效果。 灯光探测器使用光照贴图虽然可以表现近乎真实的光照效果，但如果游戏场景中有移动对象，则无法使用光照贴图表现光照效果。因为光照贴图只对静态对象产生影响，几乎不可能使其为移动对象赋予光照效果。 为了解决这个问题，Unity提供了灯光探测器功能。灯光探测器可放置于场景光源周边，烘焙光照贴图时，Unity可以预先保存各灯光探测器的光源数据。游戏运行时，这些灯光探测器会将保存的数据传递给其附近的移动对象，实时改变其颜色，表现出实时光照一样的效果。 灯光探测器的概念 Light Probe Group首先新建空游戏对象，重命名为LightProbeGroup，然后选择菜单Component-&gt;Rendering-&gt;Light Probe Group，添加Light Probe Group组件，将其Transform Position设置为(0, 1.3, 0)。 建立LightProbeGroup游戏对象并添加Light Probe Group组件 选择LightProbeGroup游戏对象，可以在Inspector视图中看到Light Probe Group组件提供了4个按钮。 Light Probe Group组件中各按钮功能 按钮名称 功能 Add Probe 新建灯光探测器 Delete Selected 删除选择的灯光探测器 Select All 选择当前Scene视图的所有灯光探测器 Duplicate Selected 复制所选灯光探测器，可以选择多个并复制 制作灯光探测器时的按钮界面可能用户体验不是很友好，但按照下列步骤操作即可轻松配置灯光探测器。 1.点击Light Probe Group组件的Select All按钮，即可选定默认的4个灯光探测器，它们在Scene视图中显示为蓝色球体。 选择所有灯光探测器 2.点击Duplicate Selected按钮后，前面选择的4个灯光探测器都将被复制。复制后点击Transform轴，将新的灯光探测器移动到旁边位置。 复制灯光探测器并移动 3.重复执行第2步，将灯光探测器布满半个场景。点击Select All按钮全选，点击Duplicate Selected复制，这样可以快速创建灯光探测器。 复制所有灯光探测器后移动并放置 4.放置灯光探测器后，再次点击Select All按钮全选，再点击Duplicate Selected按钮，在剩余场景放置灯光探测器。 场景地面的一半使用灯光探测器 打开光照视图窗口，点击底端Build按钮，同时烘焙光照贴图和灯光探测器。Unity 5去掉了以前版本中的单独的烘焙灯光探测器的选项，因此，光照图烘焙时间长的场景中，应当先放置灯光探测器后再进行。 灯光探测器表面根据周边光源的不同而呈现不同颜色。 下面选择Player模型，勾选Skinned Mesh Renderer组件的Use Light Probes选项，使其受灯光探测器的影响。从Unity 5开始，所有Mesh Renderer组件的Use Light Probe属性为默认勾选。 在最接近玩家的4个光照贴图中呈现灯光探测器的影响 Anchor Override如下图所示，处于玩家中央位置的灯光探测器可向其周边的4个灯光探测器传达光照值数据。可以将其原理理解为，以中间灯光探测器为中心，周边灯光探测器的光向中心聚集。这些灯光探测器从其周边光源获取光照数据，以更改玩家模型上的纹理颜色。 将Inspector视图中的Anchor Override属性设置为头部关节Bip001 Head，这样玩家移动时，其周围的灯光探测器也会改变，反映到玩家身上的光照会从头部开始变化。 Anchor Override更改为头部后，灯光探测器的光照值变化会反映到该属性设置的模型位置 小结同时使用灯光探测器与光照贴图即可实现实时光照效果，它们可以提供更自然、更高质量的游戏视觉环境。Unity提供的这些特性在实际的移动游戏开发中大受欢迎，灯光探测器可以为其提供非常好的实时光照效果。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第10章 导航仪高级技巧]]></title>
    <url>%2F2019%2F03%2F30%2F%E7%AC%AC10%E7%AB%A0-%E5%AF%BC%E8%88%AA%E4%BB%AA%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第9章 灵活运用射线投射]]></title>
    <url>%2F2019%2F03%2F29%2F%E7%AC%AC9%E7%AB%A0%20%E7%81%B5%E6%B4%BB%E8%BF%90%E7%94%A8%E5%B0%84%E7%BA%BF%E6%8A%95%E5%B0%84%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 怎么让射线可见？ 之前实现的子弹发射逻辑是，子弹模型飞出后与怪兽产生碰撞时进行探测感知，然后处理使玩家看到物理碰撞。与之不同，现在大部分FPS最常用的方式是在射击的同时使敌人出现血迹效果。如果是刚刚进入游戏开发界的读者，那么肯定还不了解如何实现这种方式。Unity对此提供了射线投射（Raycast）功能，其原理是，玩家开枪时会模拟射出看不到的射线，然后引擎判断被该射线击中的物体是否为敌对角色，之后再进行被击中处理。如图9-1所示，发射原点、发射角度、距离等因素决定发射射线的方式。 射线投射射线投射不但常用于发射逻辑，还可用于游戏中的传感器以及通过鼠标移动、旋转玩家角色。例如，《暗黑》和《天堂》等游戏的玩家可以在其中以俯视视角进行，玩家通过点击鼠标右键操作。移动游戏角色时，游戏引擎实际上模拟用射线找射到鼠标点击的位置，并读取三维空间中的坐标值，然后将玩家角色移动到对应的坐标。 投射出的射线在实际游戏过程中无法用肉眼观察，但开发游戏时需要肉眼可见，可以使用Debug.DrawRay函数使射线在场景视图中显示。 在FireCtrl脚本的Update函数中添加Debug.DrawRay函数，并运行游戏。 12345678910void Update()&#123; // 使用以下函数在场景中显示射线 Debug.DrawRay(firePos.position, firePos.forward * 10.0f, Color.green); // 点击鼠标右键时调用Fire函数 if (Input.GetMouseButtonDown(0)) &#123; Fire(); &#125;&#125; 运行游戏后，可在场景视图中看到从玩家枪口前的FirePos游戏对象向前发射绿色射线。 下面继续修改脚本，使怪兽被射线击中时受伤。首先如脚本9-1所示，对FireCtrl脚本的Update函数进行修改。 脚本9-1 FireCtrl：修改Update函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869using UnityEngine;using System.Collections;// 必须明确标注必要的组件，防止删除相应组件[RequireComponent(typeof(AudioSource))]public class FireCtrl: MonoBehaviour &#123; public GameObject bullet; // 子弹预设 public Transform firePos; // 子弹发射坐标 public AudioClip fireSfx; // 子弹发射声音 private AudioSource source = null; // 保存AudioSource组件的变量 public MeshRenderer muzzleFlash; // 声明MuzzleFlash的MeshRenderer组件 void Start() &#123; source = GetComponent&lt;AudioSource&gt;(); // 获取AudioSource组件并分配到变量 muzzleFlash.enabled = false; // 启动时禁用MuzzleFlash MeshRenderer &#125; void Update() &#123; // 使用以下函数在场景中显示射线 Debug.DrawRay(firePos.position, firePos.forward * 10.0f, Color.green); // 点击鼠标右键时调用Fire函数 if (Input.GetMouseButtonDown(0)) &#123; Fire(); &#125; // 获取被射线击中的游戏对象 RaycastHit hit; // 通过Raycast函数发射射线，有游戏对象被击中时返回true if (Physics.Raycast(firePos.position, firePos.forward, out hit, 10.0f) &#123; // 判断被射线击中的游戏对象Tag值是否为怪善 if (hit.collider.tag == "MONSTER") &#123; // sendNeasage函数要传递的参数数组 object[] _params = new object[2]; _params[0] = hit.point; // 被射线击中的位置（Vector3） _parama[1] = 20; // 怪兽将受到的伤害值 // 调用怪兽被击中并受伤的处理函数 hit.collider.gameObject.SendMessage("OnDamage", _params, SendMessageOptions.DontRequireReceiver); &#125; &#125; &#125; void Fire() &#123; // 更改为Raycast方式,所以注释制作子弹的例程 // CreateBullet(); // 发声函数 // source.Playoneshot (firesEx, o.9f); GameMgr.instance.Playsfx(firePos.position, firesfx); // 调用协程函数以实现稍作等待的例程 StartCoroutine(this.ShowMuzzleFlash()); &#125; void CreateBullet() &#123; //动态生成子弹预设 Instantiate(bullet, fixePos.position, firePos.rotation); &#125;&#125; 油桶爆炸实现激光束]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人物选择光圈]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%8A%95%E5%BD%B1%E4%BB%AA%E5%92%8C%E4%BA%BA%E7%89%A9%E9%80%89%E6%8B%A9%E5%85%89%E5%9C%88%2F</url>
    <content type="text"><![CDATA[投影仪（Projector）和我们日常生活中使用的投影仪类似，将贴图投影至任意物体上。Effects包中包含Projectors文件夹，该文件夹包括常用的一些投影仪以及资源。 在3D游戏开发中，经常需要实现选取人物后人物脚下的旋转光圈。 投影仪原理Projector能将一个Material投影到所有在设定的平截头体内的物体上，通常包含两张贴图Cookie和Fallofr，Cookie就是投影的图案，Fallofr的作用主要是根据距离来决定投影的明暗（Alpha），Falloff边为白色，Alpha值为1，表示投影距离最近时最亮，右边接近全黑。Alphat为0，表示投影距离变远时投影会渐渐接近透明甚至看不见。 2.使用范围Projector适用于角色脚下的黑色圆点阴影（Blob Shadow）、角色选择光圈、投影仪和手电筒等 3.圆点阴影Unity的实时阴影效果是非常好的，但是在旧的设备上实时阴影会造成卡顿甚至不能显示我们可以用Projector在人物脚下投射一个大黑圈作为阴影 打开场景11.10并另存为17.5.3,将场景中Directonal Light和Point Light的Shadow Type设置为No Shadows.关闭实时阴影,如图17-12所示,角色脚下已没有阴影。 选中Player父游戏对象,在Inspector窗口的右上角点击Layer右侧的下拉按钮,在下拉菜单中点击”Add Layer..”.,并将User Layer&amp;设置为Player,再次选中Player父游戏对象,将Layer设置为Player并应用于所有子游戏对象。 新建空的游戏对象,命名为Projector并置于Player下,为其添加Projectort件,新建材质并命名为projcctor shadow,将Shader设置为”Projector/Multiply”,将Cookie设置为Shadow贴图,将Fallor设置为Fallof站图,将Projector里的Material设置为projector shadow,在Scene窗口中调整Projector的位置为人物头上方,并使Z轴朝下,设置Field OfView.使阴影匹配人物的大小,如阁17-13所示。 和图17-12对比可以发现,人物的脚底下已经有了影子,但是人物本身也被打上了黑色,这并不是我们要的效果,于是在Inspector窗口中的Ignore Layers栏勾选Player,如图17-14所示再运行场景,效果是不是不错呢? 人物选择光圈如果用普通面片模型来选择光圈，并置于地面上方，就会被物体挡住，达不到效果。而用Projector实现的选择光圈则不会有这个问题。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段渲染器和拖尾渲染器]]></title>
    <url>%2F2019%2F03%2F28%2F%E7%BA%BF%E6%AE%B5%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8C%E6%8B%96%E5%B0%BE%E6%B8%B2%E6%9F%93%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Unity自带的Effect资源包包含了不少Effects和Image Effects的资源。首先，点击导航菜单栏-&gt;Assets-&gt;Import Package-&gt;Effects，导入Effects包。 Effects的功能可以新建空的游戏对象，再添加相关组件实现。Effects组件位于导航菜单栏-&gt;Component-&gt;Effects下。 线段渲染器LineRenderer，线渲染器，作用是用于渲染显示“线特效”。 线：就是一根线。我们要想绘制一根线，需要至少两个点，在游戏中也不例外。 现实生活中比如玩具激光灯照射出来的线。 运用线特效在游戏中常用于渲染激光效果，或者用于子弹瞄准。 创建线特效①新建一个空游戏物体；②给这个空游戏物体添加LineRenderer组件，步骤如下：Component-&gt;Effects-&gt;Line Renderer 2.LineRenderer 材质球1.Materials（材质球）设置“线渲染器”这个组件使用哪个材质球来渲染线。 2.制作透明材质球①创建一个材质球；②设置该材质球的Shader为Particles/Additive；（粒子/添加物）③给材质球拖曳赋予贴图； 3.常用属性1.Positions（位置） 设置线的开始点和结束点的位置。2.Start Width（开始宽度） 设置线开始时的宽度。3.End Width（结束宽度） 设置线结束时的宽度。4.Start Color（开始颜色） 设置线的开始颜色。5.End Color（结束颜色） 设置线的结束颜色。 线段渲染器（Line Renderer）使用一组3D点，在每个点之间使用材质绘制一条线。当使用特殊贴图的时候，可以实现很酷炫的效果，如一道闪电等。如果该闪电使用一张普通的贴图，用面片也能显示，但是形状是固定的，劈下来的过程也是固定的。而使用线段渲染器的话，这道闪电可以以不同的形状路径劈下来。线段渲染器绘制的线组总是连续的，如果要实现分开的线组，要使用多个线段渲染器游戏对象。它不能绘制一个像素的线（可以使用GL）。 实现新建一个场景，并新建一个空游戏对象，点击导航菜单栏-&gt;Component-&gt;Effects-&gt;Line Renderer添加Line Renderer组件。新建材质并命名为LineMat，设置Shader为“Unlit/Texture”，设置Line Renderer参数，如下图所示。 效果如图17-5所示。将贴图设置为Colorful贴图，效果如图17-6所示。 线段渲染器由起始点至终点，按照线段显示贴图从左至右的图案，如17-7所示。 实例--闪电效果新建场景，并点击导航菜单栏&gt; “Window” &gt;”Lighting”,在Lighting视图中点选Scene选项卡,将Skybox设置为None,将摄像机的背景颜色设置为黑色,模拟黑夜的效果。新建材质并命名为LighteningMat,将Shader设置为”Particles/Additive”,并将贴图设置为Lightening 新建空游戏对象,命名为Lightening并添加Line Renderer组件,将材质设置为LighteningMat 新建脚本LighteningManager.es并添加至游戏对象,如代码清单17-2所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061using UnityEngine;using System.Collections;/// &lt;summary&gt;/// 实现从上劈下的闪电/// &lt;/summary&gt;public class LighteningManager : MonoBehaviour&#123; public Vector3 startPos; // 闪电起始位置 public Vector3 endPos; // 闪电终止位置 public int steps; // 闪电阶段数 public float duration; // 劈下花费的时间 private LineRenderer lineRenderer; private int stepNow; void Awake() &#123; // 得到LineRenderer lineRenderer = GetComponent&lt;LineRenderer&gt;(); &#125; void OnGUI() &#123; if (GUILayout.Button("Start")) &#123; Reset(); NextStep(); &#125; &#125; void NextStep() &#123; // 设置LineRenderer的路径点数 lineRenderer.positionCount= stepNow + 1; // 计算当前阶段百分比，并得到当前点的坐标 float pcg = (float)(stepNow + 1) / (float)steps; Vector3 pos = Vector3.Lerp(startPos, endPos, pcg) + new Vector3(Random.Range(-0.5f, 0.5f), Random.Range(-0.1f, 0.1f), 0); // 设置路经点 lineRenderer.SetPosition(stepNow, pos); // 未结束时，过一段时间后进行下一步 if (stepNow &lt; steps) &#123; stepNow++; Invoke("NextStep", duration / (float)steps); // 持续时间除以步数，就是每隔多少秒执行下一步。 &#125; &#125; /// &lt;summary&gt; /// 重置LineRenderer /// &lt;/summary&gt; void Reset() &#123; CancelInvoke(); stepNow = 0; lineRenderer.positionCount = 0; &#125;&#125; 拖尾渲染器拖尾渲染器，作用是用于渲染显示“拖尾特效”。拖尾：物体后面拖着的尾巴，如流星。 在游戏中的运用比如发射出去的炮弹，子弹，只要这些物体是高速运动的，为了体现他们的运动快，往往都会在他们的后面加上一个拖尾特效。体现物体的运动速度。 创建添加组件Component-&gt;Effects-&gt;Trail Renderer，之后reset。在Scene面板中移动物体，可以看到基本的拖尾特效。Unity中所有以“Renderer‘为后缀进行命名的组件，都需要给他们指定材质球，比如Mesh Renderer。当这类组件身上没有材质球或材质球丢失的时候，默认就会显示成“粉红色”。制作透明材质球①创建一个材质球②设置该材质球的Shader为Particles/Additive；（粒子/添加物）③给材质球拖曳赋予贴图 3.TrailRenderer常用属性1.Time（时间）设置拖尾特效的持续时间。2.Start Width（开始宽度）设置拖尾开始时的宽度。3.End Width（结束宽度）设置拖尾结束时的宽度。4.Color（颜色） 设置拖尾显示的颜色。 在实际开发中，美工人员给我们的贴图往往是“黑白图”，这种图片中黑色是透明区域，白色是不透明区域，可以简单记忆为“黑透白不透”。我们可以通过设置这里的Color属性值，来让白色区域显示成特定的颜色。 给空物体添加拖尾，然后把拖尾拉到物体下成为子物体。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8章 游戏管理器]]></title>
    <url>%2F2019%2F03%2F27%2F%E7%AC%AC8%E7%AB%A0%20%E6%B8%B8%E6%88%8F%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 如何在场景中每隔一段时间在指定的多个位置生成怪兽？ 脚本应该放在哪个游戏对象下？ 脚本如何使用预设？ 如何组织生成位置？ 如何控制生成数量？ 如何让怪兽在生成之后运行奔跑动画，追击玩家？ 如何在怪兽死亡之后继续生成至指定数量？ 如何寻找到所有的怪兽对象？ 如何访问游戏管理器？ 如何设置为单例模式？ 什么是对象池？ 对象池使用什么数据结构？ 本章涵盖： 1.怪兽出现逻辑 2.访问游戏管理器 3.单例模式 4.对象池 5.共享函数:声音处理 游戏管理器（Game Manager）负责管理游戏整体流程，还可以系统管理用于游戏的全局数据以及游戏中判断胜败的条件。游戏管理器并不是单一的模块，更像是能控制游戏的功能集合。 怪兽出现逻辑游戏管理器的第一个作用就是以一定时间为间隔，使怪兽出现在游戏场景中的随机位置。生成怪兽随机位置的最简单的方法就是随机生成怪兽的Vector3坐标，但现在最好在场景中设置一些区域，专门用于随机生成怪兽。 首先删除场景视图中的怪兽，注意务必先确认怪兽是否为预设，然后再删除，如果没有预设就删除怪兽，那么就会删除原版模型，并且无法复原。因此，将动态生成的游戏对象从场景视图中删除时，必须确认其是否为预设。 怪兽生成点（Spawn Point）制作流程如下。 1.生成空游戏对象后，命名为SpawnPoint。 2.将生成的SpawnPoint的Transform.Position设置修改为(0, 0, 0)。 3.选择SpawnPoint，在上下文菜单中选择Create Empty。在其下方新建空游戏对象，重命名为Point。 4.将子对象Point复制多次（Ctrl + D），用作怪兽出现的位置。 因为Point是使用空游戏对象制作的，所以为了在场景视图中看到Point并便于放置，需要添加MyGizmo脚本，为Point指定适当的颜色和大小。下面复制多个Point游戏对象，安放于场景中各个位置，如下图所示。 下面为SpawnPoint下的Point制作生成怪兽的游戏管理器。首先添加空游戏对象，重命名为GameManager。新建脚本，命名为GameMgr，并将该脚本添加到GameManager，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445using UnityEngine;using System.Collections;public class GameMgr : MonoBehaviour&#123; public Transform[] points; // 保存怪兽出现的所有位置的数组 public GameObject monsterPrefab; // 要分配怪兽预设的变量 public float createTime = 2.0f; // 生成怪兽的周期 public int maxMonster = 10; // 生成怪兽的最大数量 public bool isGameOver = false; // 控制是否终止游戏的变量 void Start() &#123; // 获取Hierarchy视图SpawnPoint下的所有Transform组件 points = GameObject.Find("SpawnPoint").GetComponetsInChildren&lt;Transform&gt;(); if (points.Length &gt; 0) &#123; StartCoroutine(CreateMonster()); // 调用生成怪兽的协程函数 &#125; &#125; // 生成怪兽的协程函数 IEnumerator CreateMonster() &#123; // 无限循环直到游戏结束 while (!isGameOver) &#123; // 当前已生成的怪兽数量 int monsterCount = (int)GameObject.FindGameObjectsWithTag("MONSTER").Length; // 只有比怪兽最大数量小时才需要继续生成怪兽 if (monsterCount &lt; maxMonster) &#123; // 程序挂起一段时间（怪兽生成周期） yield return new WaitForSeconds(createTime); // 计算随机位置 int idx = Random.Range(1, points.Length); // 动态生成怪兽 Instantiate(monsterPrefab, points[idx].position, points[idx].rotation); &#125; else &#123; yield return null; &#125; &#125; &#125;&#125; Start函数中，首先在Hierarchy视图中查询SpawnPoint，获取其所有子节点的Transform组件，存入Points数组中。 12// 获取SpawnPoint下所有Transform组件points = GameObject.Find("SpawnPoint").GetComponentsInChildren&lt;Transform&gt;(); 协程函数CreateMonster判断游戏是否结束，循环生成怪兽直到isGameOver变量为true，然后查询Tag为MONSTER的游戏对象的数量。 12// 当前已生成的怪兽数量int monsterCount = (int)GameObject.FindGameObjectsWithTag("MONSTER").Length; 只有当前已生成的怪兽数量比怪兽最大数量maxMonster小时，脚本才会生成怪兽。为了生成随机位置值，脚本将数组长度值作为随机数种子，计算出的位置上会生成怪兽。 123456789101112// 只有比怪兽最大数量小时才需要继续生成怪兽if (monsterCount &lt; maxMonster)&#123; // 程序挂起一段时间（怪兽生成周期） yield return new WaitForSeconds(createTime); // 计算随机位置 int idx = Random.Range(1, points.Length); // 动态生成怪兽 Instantiate(monsterPrefab, points[idx].position, points[idx].rotation);&#125; else &#123; yield return null;&#125; 将GameMgr脚本的monsterPrefab预设变量设置为项目视图中的monster预设。 运行游戏后，可以看到游戏场景中的各个位置安放的Point游戏对象。在Inspector视图中可以看到此时Point的父节点SpawnPoint也被添加到数组，并且处于第0个位置。但脚本运行后生成随机数时，Index从1号位置开始。 怪兽在生成的同时开始追击。选择怪兽预设，将Trace Dist属性设置为50。再次运行游戏，可以看到怪兽以2秒为间隔依次出现在场景中的各个Point位置，并马上开始追击玩家。 GameMgr脚本中实时计算了当前已经生成的怪兽个数，并在其比Max Monster值小时才生成怪兽。但这样并没有将玩家杀死怪兽这种情况考虑在内，所以需要在怪兽死后修改怪兽的Tag，这样就能使得GameMgr脚本不断生成怪兽。修改MonsterCtrl脚本的MonsterDie函数，如脚本所示。 MonsterCtrl脚本：修改MonsterDie函数。 123456789101112131415161718192021222324// 怪兽死亡时的处理例程void MonsterDie()&#123; // 将死亡的怪兽Tag更改为Untagged gameObject.tag = "Untagged"; // 停止所有协程 StopAllCoroutines(); isDie = true; monsterState = MonsterState.die; nvAgent.Stop(); animator.SetTrigger("IsDie"); // 禁用为怪兽添加的Collider gameObject.GetComponentInChildren&lt;CapsuleCollider&gt;().enabled = false; foreach(Collider coll in gameObject.GetComponentsInChildren&lt;SphereCollider&gt;() &#123; coll.enabled = false; &#125; // 调用GameUI的积分和显示函数 gameUI.DispScore(50);&#125; 再次运行游戏，死亡的怪兽将不再计入Max Monter值，而会一直生成。 访问游戏管理器下面需要设置停止生成怪兽的条件，此处设置为，游戏结束或玩家死亡时，脚本不再生成怪兽。修改PlayerCtrl脚本的Start函数和OnTriggerEnter函数，使其不再生成怪兽。 PlayerCtrl：添加游戏停止逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344using UnityEngine;using UnityEngine.UI; // 必须添加才能访问UI元素using System.Collections;（省略…）public class PlayerCtrl : MonoBehaviour&#123; （省略…） // 访问游戏管理器的变量 private GameMgr gameMgr; （省略…） void Start() &#123; （省略…） // 获取Transform组件 tr = GetComponet&lt;Transform&gt;(); // 获取GameMgr脚本 gameMgr = GameObject.Find("GameManager").GetComponet&lt;GameMgr&gt;(); （省略…） &#125; void Update() &#123; （省略…） &#125; // 勾选碰撞的Collider的IsTrigger选项时发生 void OnTriggerEnter(Collider coll) &#123; （省略…） &#125; // Player的死亡处理例程 void PlayerDie() &#123; Debug.Log("Player Die !! "); // 触发事件 OnPlayerDie(); // 更新游戏管理器的isGameOver变量值以停止生成怪兽 gameMgr.isGameOver = true; &#125;&#125; 为了访问游戏管理器，脚本中声明GameMgr类型的变量。频繁访问其他脚本的变量或函数时最好首先在Start函数中分配为局部变量。 12// 访问游戏管理器的变量private GameMgr gameMgr; 也可以事先在游戏管理器中设置Tag，并在其他脚本中使用FindGameObjectWithTag，但此处用游戏对象名查询GameMgr组件。 12// 获取GameMgr组件gameMgr.GameObject.Find("GameManager").GetComponent&lt;GameMgr&gt;(); 玩家死亡时，将GameMgr的isGameOver变量值设置为true，这样就会停止生成怪兽。 12// 更新游戏管理器的isGameOver变量值以停止生成怪兽gameMgr.isGameOver = true; 单例模式前面要访问游戏管理器时才初始化游戏管理器变量，这种方法多少有些琐碎复杂。因为为了在其他脚本中访问，每次都需要声明变量并进行初始化工作。 有10个脚本，每个都需要这样写： 12345// 访问游戏管理器的变量private GameMgr gameMgr;// 获取GameMgr组件gameMgr.GameObject.Find("GameManager").GetComponent&lt;GameMgr&gt;(); 下面将其改为单例模式（Singleton），这样更便于访问游戏管理器。 顾名思义，该设计模式下只有一个对象或实例，可以获得全局访问。因此，在GameMgr脚本中声明单例模式，可以使其他脚本以更便捷的方式访问GameMgr脚本。 GameMgr：将游戏管理器的实例修改为单例模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using UnityEngine;using System.Collections;public class GameMgr : MonoBehaviour&#123; public Transform[] points; // 保存怪兽出现的所有位置的数组 public GameObject monsterPrefab; // 要分配怪兽预设的变量 public float createTime = 2.0f; // 生成怪兽的周期 public int maxMonster = 10; // 生成怪兽的最大数量 public bool isGameOver = false; // 控制是否终止游戏的变量 public static GameMgr instance = null; // 声明单例模式的实例变量 void Awake() &#123; // 将GameMgr类代入实例 instance = this; &#125; void Start() &#123; // 获取Hierarchy视图SpawnPoint下的所有Transform组件 points = GameObject.Find("SpawnPoint").GetComponetsInChildren&lt;Transform&gt;(); if (points.Length &gt; 0) &#123; StartCoroutine(CreateMonster()); // 调用生成怪兽的协程函数 &#125; &#125; // 生成怪兽的协程函数 IEnumerator CreateMonster() &#123; // 无限循环直到游戏结束 while (!isGameOver) &#123; // 当前已生成的怪兽数量 int monsterCount = (int)GameObject.FindGameObjectsWithTag("MONSTER").Length; // 只有比怪兽最大数量小时才需要继续生成怪兽 if (monsterCount &lt; maxMonster) &#123; // 程序挂起一段时间（怪兽生成周期） yield return new WaitForSeconds(createTime); // 计算随机位置 int idx = Random.Range(1, points.Length); // 动态生成怪兽 Instantiate(monsterPrefab, points[idx].position, points[idx].rotation); &#125; else &#123; yield return null; &#125; &#125; &#125;&#125; 只需要两步。脚本为了方便其他脚本访问游戏管理器，将保存GameMgr实例的变量声明为static，使之成为类变量；并声明为public，使其他脚本也可以自由访问该变量。在Awake函数中，将GameMgr类的实例代入instance变量。 12345678// 声明单例模式的实例变量public static GameMgr instance = null; void Awake()&#123; // 将GameMgr类代入实例 instance = this;&#125; 修改PlayerCtrl脚本的PlayerDie函数。 12345// 更新游戏管理器的isGameOver变量值以停止生成怪兽gameMgr.isGameOver = true;// 访问GameMgr的单例并更改其isGameOver变量值GameMgr.instance.isGameOver = true; 对象池对于移动平台上开发的游戏，如果动态生成游戏对象或预设，则会导致设备负荷相当高。因此对于需要在游戏中反复生成的模型，可以在游戏一开始运行并加载场景时就全部生成，后续运行时可从中直接取出并使用。这种事先生成模型并在需要时直接使用的方式，在软件开发中称为对象池（Object Pooling）。 下图是AngryBot游戏运行画面，不难发现，角色发射子弹时，场景中生成了6个Bullet预设，它们依次被激活/禁用。 将之前添加到游戏管理器脚本MonsterCtrl的怪兽生成逻辑更改为对象池方式。首先建立List，保存游戏中需要的10个怪兽并全部禁用，之后根据需要依次重新激活。然后更改死亡的怪兽处理逻辑，将简单的Destroy处理改为放回对象池，以供后续使用。如下脚本所示，修改GameMgr脚本。 GameMgr：实现对象池 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using UnityEngine;using System.Collections;using System.Collections.Generic; // 使用List数据类型前需要添加的命名空间public class GameMgr : MonoBehaviour&#123; public Transform[] points; // 保存怪兽出现的所有位置的数组 public GameObject monsterPrefab; // 要分配怪兽预设的变量 public float createTime = 2.0f; // 生成怪兽的周期 public int maxMonster = 10; // 生成怪兽的最大数量 public bool isGameOver = false; // 控制是否终止游戏的变量 public static GameMgr instance = null; // 声明单例模式的实例变量 void Awake() &#123; // 将GameMgr类代入实例 instance = this; &#125; void Start() &#123; // 获取Hierarchy视图SpawnPoint下的所有Transform组件 points = GameObject.Find("SpawnPoint").GetComponetsInChildren&lt;Transform&gt;(); if (points.Length &gt; 0) &#123; StartCoroutine(CreateMonster()); // 调用生成怪兽的协程函数 &#125; &#125; // 生成怪兽的协程函数 IEnumerator CreateMonster() &#123; // 无限循环直到游戏结束 while (!isGameOver) &#123; // 当前已生成的怪兽数量 int monsterCount = (int)GameObject.FindGameObjectsWithTag("MONSTER").Length; // 只有比怪兽最大数量小时才需要继续生成怪兽 if (monsterCount &lt; maxMonster) &#123; // 程序挂起一段时间（怪兽生成周期） yield return new WaitForSeconds(createTime); // 计算随机位置 int idx = Random.Range(1, points.Length); // 动态生成怪兽 Instantiate(monsterPrefab, points[idx].position, points[idx].rotation); &#125; else &#123; yield return null; &#125; &#125; &#125;&#125; 共享函数:声音处理小结]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Input.GetAxis]]></title>
    <url>%2F2019%2F03%2F27%2FInput-GetAxis%2F</url>
    <content type="text"><![CDATA[public static float GetAxis(string axisName); static 类名.方法名 DescriptionReturns the value of the virtual axis identified by axisName. The value will be in the range -1…1 for keyboard and joystick input. If the axis is setup to be delta mouse movement, the mouse delta is multiplied by the axis sensitivity and the range is not -1…1. This is frame-rate independent; you do not need to be concerned about varying frame-rates when using this value. To set up your input or view the options for axisName, go to Edit &gt; Project Settings &gt; Input. This brings up the Input Manager. Expand Axis to see the list of your current inputs. You can use one of these as the axisName. To rename the input or change the positive button etc., expand one of the options, and change the name in the Name field or Positive Button field. Also, change the Type to Joystick Axis. To add a new input, add 1 to the number in the Size field.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Input]]></title>
    <url>%2F2019%2F03%2F27%2FInput%2F</url>
    <content type="text"><![CDATA[class in UnityEngine/Implemented in:UnityEngine.CoreModule DescriptionInterface into the Input system. Use this class to read the axes set up in the Conventional Game Input, and to access multi-touch/accelerometer data on mobile devices. To read an axis use Input.GetAxis with one of the following default axes: “Horizontal” and “Vertical” are mapped to joystick, A, W, S, D and the arrow keys. “Mouse X” and “Mouse Y” are mapped to the mouse delta. “Fire1”, “Fire2” “Fire3” are mapped to Ctrl, Alt, Cmd keys and three mouse or joystick buttons. New input axes can be added. See Input Manager for this. If you are using input for any kind of movement behaviour use Input.GetAxis. It gives you smoothed and configurable input that can be mapped to keyboard, joystick or mouse. Use Input.GetButton for action like events only. Do not use it for movement. Input.GetAxis will make the script code more small and simple. Note also that the Input flags are not reset until Update. It is suggested you make all the Input calls in the Update Loop. See Also: KeyCode which lists all of the key press, mouse and joystick options. Mobile Devices: iOS and Android devices are capable of tracking multiple fingers touching the screen simultaneously.iOS和Android设备能够跟踪多个手指同时触摸屏幕。 You can access data on the status of each finger touching screen during the last frame by accessing the Input.touches property array.通过访问Input.touches属性数组，您可以访问最后一帧期间每个手指触摸屏状态的数据 As a device moves, its accelerometer hardware reports linear acceleration changes along the three primary axes in three-dimensional space. You can use this data to detect both the current orientation of the device (relative to the ground) and any immediate changes to that orientation. 当设备移动时，其加速计硬件报告沿三维空间中的三个主轴的线性加速度变化。 您可以使用此数据来检测设备的当前方向（相对于地面）以及对该方向的任何即时更改。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7章 UnityUI]]></title>
    <url>%2F2019%2F03%2F26%2F%E7%AC%AC7%E7%AB%A0%20UnityUI%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章将利用UGUI制作游戏中的主要UI界面，包括如何在游戏场景中实现显示得分、生命条、暂停等按钮的功能。 首先创建名为scMain的新场景，导入资源包UI_Textures.unitypackage。导入后，将生成的UI Textures文件夹移动到Images。 Canvas对象Canvas是Unity提供的游戏对象之一，所有游戏界面的UI元素（纹理、图像、按钮、滑动条等）都必须位于Canvas之下，成为其子对象。Canvas拥有的是Rect Transform组件，而并非其他游戏对象拥有的Transform组件。另外，一个场景中可以有多个Canvas对象，也可以导入其他Canvas对象作为当前Canvas对象的子节点。 生成Canvas对象后，EventSystem对象会自动生成。EventSystem对象可将系统中发生的键盘、游戏杆、触摸屏等输入信息传递给Canvas包含的UI元素。 EventSystem对象EventSystem对象包含EventSystem组件、Standalone Input Module组件等，其中EventSystem组件的First Selected属性可以设置哪个UI元素将会第一个获得焦点。EventSystem对象很重要，如果没有它，UI元素就无法响应各种输入事件并执行相应动作。 EventSystem对象包含的处理输入事件相关的组件 Canvas对象包含Rect Transform、Canvas、Canvas Scaler和Graphic Raycaster这4个组件。UI元素必须拥有Rect Transform组件，它保存着锚点（Anchors）、枢纽（Pivot）、大小（W、H）、位置（Pos X、Pos Y、Pos Z）、旋转以及比例等很多信息。简言之，Rect Transform组件可以理解为专用于UI界面的Transform组件。不可以直接修改Canvas对象的Rect Transform组件的属性，系统会根据画布大小自行设置。 Canvas对象的Rect Transform组件为禁用状态。 Canvas对象的基本组件 Canvas组件Canvas组件可将游戏所需的各种UI元素放置到画面，并对其进行渲染。根据渲染模式的不同，UI元素的画面配置方式有如下几种。 1.Screen Space-OverlayCanvas组件默认设置值，UI元素置于画面最表层，可以根据画面分辨率的设置自动调节位置。 2.Screen Space-Camera此选项虽然与前一个选项类似，但可以设置渲染UI元素的摄像机。也就是说，可以为其指定一个与（直接朝向游戏全部场景的）主摄像机不同的专用摄像机。将渲染模式属性更改为此选项后，Inspector视图中就会出现可以指定其他摄像机的Render Camera属性。 如果将渲染UI界面的摄像机的Projection属性设置为Perspective并旋转UI元素的Y轴，则可以使UI界面表现透视感。 为了避免因渲染UI元素而添加的摄像机与现有主摄像机冲突，必须适当设置其Clear Flag、Culling Mask、Depth等属性。 3.World Space如果设置为World Space选项，则可以向场景内的其他游戏对象直接添加UI元素，其最具代表性的案例就是制作HUD（Head Up Display，平视显示器）。向特定游戏对象添加Canvas对象后，如果将渲染模式设置为World Space，则该Canvas对象不再受其Rect Transform组件设置的影响，而受相应游戏对象位置的影响。 Rect Transform组件UI元素默认包含Rect Transform组件，其作用与之前讲过的Transform组件相同，此处通过Panel元素了解Rect Transform组件的属性。Panel主要用于编组其他UI元素，例如，如果想将用户ID、用户Password以及加入会员等UI元素绑定为1个组时，可以使用Panel。也就是说，制作UI菜单时可以将各个按钮放入1个Panel。 添加Panel后，Scene视图中会出现矩形面板。Panel对象默认具有Image组件，其4角均有蓝色圆形图标和三角形Gizmos。如果Scene视图当前为2D模式，那么在Rect工具栏中选择如下图所示按钮并使用鼠标即可将Panel移动到想要的位置；3D模式下，拖曳当前3D坐标轴即可移动Panel。 将光标移动到Panel边框后，可拖曳调节其大小。 拖曳Panel的4角蓝色圆形图标，也可以向相应方向调节其大小。点击鼠标并按Alt键拖曳，可以同时调节Panel的4边大小。 Panel中间的圆形为其正中心，是布局、排列UI元素时参考的基准位置。另外，这个中心圆圈也起到旋转轴心的作用。将鼠标光标移动到Panel外侧就会出现旋转图标，此时按住鼠标拖曳即可旋转Panel。 其他UI元素的移动、大小调节、旋转等操作与上述方式一致。如下图所示，Panel周围有4个小的白色三角形，以Panel的父对象Canvas为基准，称为定位点（Anchor Point），其与Panel的布局排列和大小调节均相关。定位点通常以Panel的父节点的Rect Transform组件属性值为基准，所以请牢记，选择某个UI元素时，其定位点不是以自身Rect Transform为基准，而是以其父对象的Rect Transform为基准。 Anchor PresetAnchor Preset可将各UI元素的排列与大小等设置定义为预设，这是UGUI的基本概念，必须熟记。 现在，Panel的锚点预设功能支持Stretch模式。该模式下，即使屏幕分辨率发生变化，Unity也会自动调节大小以适应新的分辨率。 横竖均可自由伸缩的Anchor Preset Stretch模式下，如果将游戏视图从Unity IDE中分离并调整视图大小，可以发现Panel的大小也会随之变化。 点击Anchor Preset按钮，出现事先定义的Anchor Preset。 默认Anchor Preset（只点击鼠标时） 按Alt键时 按Shift键时 Alt + Shift 锚点（定位点）由4个三角形组成，每个都可以分别移动。上图为这4种设置界面下Panel在Canvas对象内排列方式的缩略示意图。 1.默认锚点预设点击鼠标可更改锚点位置 2.点击鼠标并按Alt键进行设置打开Anchor Preset界面并按Alt键，此模式可将当前选定的UI元素移动到Anchor Preset中选择的预设位置并进行排列。 3.点击鼠标并按Shift键进行设置按Shift键并点击Anchor Preset之后出现设置界面，此处只会更改锚点和所选UI元素的中心点位置，不会移动UI元素位置。 4.点击鼠标后同时按Alt + Shift键进行设置将UI元素中心点移动到与锚点相同的位置。 anchoredPosition属性RectTransform属性顶端的Pos X、Pos Y、Pos Z以相应UI元素锚点为基准，显示UI元素当前位置，在Unity中称为anchoredPosition。下图的Panel的位置表示，以Anchor Point为基准时，X轴方向-130、Y轴方向+60的位置。 设置锚点为middle、right时的anchoredPosition属性值 anchoredPosition的属性为Vector2类型，不涉及Z轴，所以Pos Z值为0。Width和Height属性则是相应UI元素的宽和高的值。Pos X、Pos Y、Width、Height这些属性值表示当前UI元素的中心点相对锚点位置的偏移量。 下图是将锚点设置为左边排列与宽高自适应后的界面截图。因为选择了宽高自适应，所以UI元素的高度可以根据场景当前分辨率改变，故Inspector视图中的Pos Y值和Height值分别变为Top值和Bottom值，二者分别表示当前UI元素的顶端留空值（Top Margin）与下端留空值（Bottom Margin）。 Anchor属性 Unity UI用4个小箭头表示Anchor属性，通过它可设置并调整UI元素的大小和对齐方式。RectTransform组件的Anchor属性中的Min(X, Y)、Max(X, Y)值是锚点位置，取值范围均为0.0f ~ 1.0f，例如，0.5f表示50%。 UI元素四周均设置锚点后，该UI元素就只能在锚点设置的范围内调整大小。下图中，锚点的Min值设置为(0.2, 0.2)，Max值设置为(0.8, 0.8)，这样可以使Panel大小随画面分辨率的变化而变化。 上面设置的锚点值表示从画面左边20%、画面下端20%到画面左边80%、画面下端80%的范围。也就是说，画面按照比例分割为20%，60%，20%，如下图所示。 Image组件Panel对象默认带有Image组件，Image组件可为画面附上纹理，在Unity中必须将纹理先转换为Sprite格式后才能使用。现在将Panel的Image组件的Source Image属性设为之前下载的SF Window文件。 设置纹理后，如下图所示，设置Panel的位置和锚点预设。 Image组件是制作游戏UI界面时最常用的UI元素，仔细观察其属性，尤其要注意Image Type选项不同导致的图像变化。 属性 功能 Source Image Panel要使用的图像（仅允许Sprite格式的文件） Color 指定图像的颜色（RGBA） Material 渲染图像时使用的材质（使用法线贴图时可用） Image Type 显示图像的方式有4种。Simple：不需要重复显示图像或需要使图像长宽比例固定；Sliced：调整图像大小也不会使其周围图像变形；Tiled：可以平铺图像；Filled：可以只显示部分图像。 下面讲解Image组件的Image Type属性提供的4种选项的不同之处。 Simple用于固定图像长宽比例，主要适用于装饰画面的图片。选择Simple时，Inspector视图中会出现Preserve Aspet选项，勾选后，图像即可按照其原有长宽比例进行调整。通过Set Native Size按钮可设置原版图像大小。 按住Shift键后，可按照既有长宽比例对所有UI元素进行等比调整。 Sliced将Panel中的Image组件的Image Type设置为Sliced后，即使调整图像大小，其边框外围部分的图像也不会变形，只有中间切片的图像才会随着调整的大小而缩放。要想使用Sliced选项设置图像，需要在Sprite Editor中事先设置要使用的图像的九宫格线。选择项目视图的Images/UI Textures/Textures and Sprites/SF Window，点击Inspector视图的Sprite Editor按钮打开Sprite Editor视图，如下图所示。SF Window图像是背景透明的白色图像，所以为了便于查看，点击控制栏的RGB/Alpha按钮选择Alpha。 调整4条绿色实线的位置，即可设置九宫格大小。 按照边线将图像切分为9块后，即使调整整个图像的大小，4条边附近的图像也不会变形，如下图所示。设置为Sliced类型的图像常用于制作登录对话框等窗口。 选择Sliced选项后，Inspector视图会出现Fill Center属性。如果勾选，则显示原图像切片的九宫格中间图像；如果不勾选，则最终图像只显示中间轮廓。如下图所示，原始图像切片后的中间9号区域是透明的，没有图像。 TiledTiled选项可以使设置的图像不断重复，平铺整个画面，不受Image大小影响，如下图所示。 Filed选择Filed选项可以使图像沿着特定方向逐渐显示，直至填满整个Panel。在Fill Method属性中设置填充方式，Fill Origin属性可以选择从哪个位置开始填充。 Fill Method属性 选项 说明 Clockwise属性 Horizontal 横向填满图像 无 Vertical 纵向填满图像 无 Radial90 图像以90°填满 有 Radial180 图像以180°填满 有 Radial360 图像以360°填满 有 选择Radial90、Radial180或者Radial360选项时，可以继续设置Clockwise属性，Clockwise决定图像以顺时针方向还是逆时针方向进行填充。另外，设置填充比例的选项为Fill Amount，其取值范围是0.0f ~ 1.0f，可以看出，Filed选项在游戏开发中可用于表现生命条或技能冷却时间。 RawImage组件RawImage组件与Image组件相似，但其主要用于设置UI界面的静态背景。可以在Raw Image组件的Texture属性中设置纹理文件或者Sprite文件。 选择Hierarchy视图的Canvas对象，点击鼠标右键后，在上下文菜单中选择RawImage，Scene视图中会生成RawImage对象。将Project视图Images/SkyBox Volume 2/中用于Skybox的一个纹理设置到RawImage组件的Textuue属性，然后按住Shift键，利用鼠标拖曳等比调整RawImage，使其比Scene视图的Canvas区域更大，如下图所示。 UV Rect选项的X、Y属性可以设置图像位置的偏移量，而W，H属性设置其宽和高相对于原始大小的缩放比例。 如下图所示，之前添加的Panel的图像会被RawImage覆盖，所以需要调整。Unity UI系统各元素的Z-Order值由其各自在Hierarchy视图中的顺序决定，故将Hierarchy视图的排列选项更改为TransformSort，并将Panel对象拖曳至RawImage下方。这样，Panel的Z-Order值将比后者更高，从而使Panel能够在RawImage之上正常显示。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将游戏连接到互联网]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%B0%86%E6%B8%B8%E6%88%8F%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%BA%92%E8%81%94%E7%BD%91%2F</url>
    <content type="text"><![CDATA[本章涵盖 使用天空盒为天空生成视觉效果 在协程中使用WWW对象下载数据 解析诸如XML和JSON这种常见的数据 显示从互联网下载的图像 将数据发送到Web服务器 本章将学习如何通过网络发送和接收数据。 Unity支持多种方式的网络通信，因为不同的方式适用于不同的需求。然而，本章将主要介绍最常用的互联网通信：发出HTTP请求。 在Unity中开发围绕HTTP请求建立的在线游戏本质上是和服务器以Ajax方式通信。 Web应用程序和视频游戏中时间的衡量不同。更新一个网站花费半秒看起来很短，但在一个高强度动作游戏中暂停甚至只是半秒的时间都是一种折磨。“快速”这个概念是根据情况定义的。 在线游戏通常连接到该游戏特定的服务器。为了便于学习，我们连接到一些免费且可用的互联网数据源，包括天气数据和可以下载的图像。本章最后部分会要求你设置一个自定义Web服务器。 本章计划介绍HTTP请求的多种用法，以便可以学习它们在Unity中的工作原理：(1)创建户外场景（特别是，构建一个可以响应天气数据的天空）(2)编写代码，从互联网请求天气数据(3)解析响应并基于数据修改场景(4)从互联网下载并显示图像(5)将数据发送到服务器（本例中是天气日志） 创建户外场景由于我们将下载天气数据，因此接下来创建一个可以显示天气的户外场景。最复杂的部分是天空，但首先花点时间将户外贴图应用到关卡的几何体上。 从www.cgtextures.com 上获取一些图像，将这些图像应用到关卡的墙壁和地板。记住将下载的图像的大小修改为2的N次幂，例如256256。接着将图像导入到Unity项目中，创建材质，并将图像赋予到材质上（也就是将图像拖动到材质的贴图槽）。将材质拖动到场景中的墙壁或地板上，接着增加材质的平铺（尝试设置平铺的一个或两个方向使用8或9），以便图像不会以丑陋的方式被拉伸。一旦地板和墙壁处理完毕，就可以开始装饰天空。 使用天空盒生成天空视觉效果首先导入天空盒图像：下载DarkStormy系列和TropicalSunnyDay，将这些贴图导入到Project视图中，并设置贴图的Wrap Mode为Clamp。现在创建用于这个天空盒的新材质。在这个材质设置的顶部，单击Shader菜单查看可用的着色器（shader）列表，将鼠标移动到Skybox部分并选择子菜单中的6-Slided。随着这个着色器激活，材质现在有6个贴图档（而不像标准材质只有一个小的Albedo贴图槽）。将SunnyDay天空盒图像拖动到新材质的贴图槽中。图像名称和它们赋予的贴图槽名称相对应（top、 front等）。一旦6个贴图都被连接好，就可以将这个新材质用作场景的天空盒。 在Lighting窗口(Window | Lighting)中赋予这个天空盒材质，将天空盒材质赋予到窗口顶部的Skybox槽(将材质拖动到Skybox槽上或者单击Skybox槽旁边的小圆圈按钮),单击Play,则可以看到如图9-1所示的画面。 很好,现在已经拥有一个室外场景!天空盒是一种用于创建一个无际环绕玩家大气环境的错觉的优雅方式。但Unity内置的天空盒着色器有一个明显的限制:天空盒材质的图像不能改变,这导致天空完全是静态。接下来将通过创建自定义着色器来消除这个限制. 9.1.2通过代码设置大气环境TropicalSunnyDay系列中的图像对于晴天看起来很好,但如果我们想要在晴天和阴天过渡呢?这将需要第二套天空图像(一些阴天的图片),因此需要新的着色器来实现天空盒。如第4章所述,着色器是用于渲染图像的简短的程序指令。这意味着可以编写新着色器,而事实上正是如此。接下来将创建新的着色器,使用两个天空盒图像集并在它们之间过渡,幸运的是,实现这个目的的着色器已经存在于Unify Community维基的脚本集合中 http://wiki.unity3d.com/index.php?title-SkyboxBlended 在Unity中创建新着色器脚本:像创建C#脚本一样,在Create菜单中选择Shader,而不是选择一个标准Shader.命名资源为SkyboxBlended并双击着色器打开脚本,复制维荐页面上的代码并粘贴到着色器脚本中,顶部一行声明了Shader “Skybox/Blended”,这告诉Unity将新着色器添加到Skybox外类的着色器列表下(和常规天空盒同一个分类).注意 换下来将不会涉及着色器程序的所有细节, Shader编程是高级计算机图形的话题而且超出了本书的讨论范围:如果你在阅读完本书后想进一步学习,可以以http:/docs.unity3d.com/Manual/ShadersOverview.html为起点. 现在你可以设置材质的着色器为Skybox Blended.有12个贴图槽,用于两组图像,其中每组六张图像。将TropicalSunnyDay图像赋予到前六张贴图:剩下的贴图使用DarkStormy系列天空盒图像。 这个新着色器也在设置的项部附近添加了一个Blend滑动条, Blend值控制了如何显示天空盒图像集:当将滑动条从一端调整到另一箱时,天空盒将从睛天过渡到阴天。可以通过调整滑动条并运行游戏来进行测试,但当游戏运行时手动调整天空没有什么作用,因此接下来编写一些代码使天空过渡。 在场景中创建一个新的空对象并命名为Controller.创建一个新脚本并命名为WeatherController.将脚本拖到空对象上,接着编写代码清单9.1中的代码。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5实战-使用C#和Unity开发多平台游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将各部分整合为一个完整的游戏]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%B0%86%E5%90%84%E9%83%A8%E5%88%86%E6%95%B4%E5%90%88%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[本章涵盖 从其他项目装配对象和代码 编程创建指向-单击的控件 将UI从旧系统升级为新系统 加载新关卡响应目标 设置胜利/失败条件 保存和加载玩家进度 本章的项目是一个角色扮演RPG的demo,在这类游戏中,摄像机是被放置在较高的位置,形成一个直接俯视的视角(如图11-1所示),可以通过单击鼠标来控制角色的移动。 游戏项目主要有以下这些功能:自上而下的一个可单击的指向移动的视图可以通过单击来操作的设备散落的可被收集的游戏装备 显示在UI窗口中的物件当前关卡中在玩家附近游荡的敌人可以保存游戏和恢复游戏的进度游戏中三个关卡的完成顺序 11.1 再次利用项目来构建角色扮演RPG 之前项目的简述;一个已设定好动画控制器的角色一个跟随该角色的第三视角摄像机地面、墙壁和坡道的标注已设置好的光照和阴影可操作的设备,包括一个变色显示器可收集存储的装备后端管理器代码框架 这个庞大的功能列表已经包含了相当多的PRG demo功能,但是还有更多的地方需要我们去添加或者进行修改。 11.1.1将多个项目的资源和代码装配在一起第一个修改是更新管理器框架并加入计算机控制的敌人。对于前一个任务,回想第9章对框架所做的更新,这意味着第8章并没有包含那部外更新。对于后一个任务,回想第3章编写的敌人。更新管理器框架更新管理器是一项相当简单的任务,因此先解决这个任务. IGameManager接口已经在第9章中做了修改(见代码清单11.1). 代码清单11.1调整后的IGameManager 12public intexface IGameManager tManagerstatus status fget;lvoid startup (NetworkService service); 代码清单11.1中的代码添加了对NetworkService的引用,因此也要确保复制那个额外的NetworkService脚本;将该文件从第9章(记住,一个Unity项目是位于磁盘上的一个文件夹,因此可以从文件夹中获得文件)的位置拖放到新项目上,现在修改Manager.cs,使得和修改过的接口一起工作(见代码清单11.2).代码清单11.2 稍微修改Managers脚本中的代码 123private IEnumerator StartupManagers ()NetvorkService network-new NetworkService ():对该方法的开头进行了调整foreach (IGameManager manager in startSequence) tmanager.startup (network): 最终,调整了InventoryManager和PlayerManager以反映接口的变化。代码清单11.3展示了InventoryManager中修改的代码,对PlayerManager需要进行相同的修改,但使用的是不同的名称。代码清单11.3调整InventoryManager以反映IGameManager的改变 123456private NetworkService network:public void startup (Networkservice service) (Debug.Log ("Inventory manager starting...");^对两个管理器进行同样的 调整,但需要改变名称hetwork- service;items - new Dictionarycstring, int&gt;0); 一旦所有次要代码的修改就绪,所有东西将和前面表现的一样。此处的更新中应该看不出区别,游戏将和之前一样运行,这个调整很简单,但接下来的调整将比较复杂。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5实战-使用C#和Unity开发多平台游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 制作敌对角色]]></title>
    <url>%2F2019%2F03%2F25%2F%E7%AC%AC6%E7%AB%A0%20%E5%88%B6%E4%BD%9C%E6%95%8C%E5%AF%B9%E8%A7%92%E8%89%B2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： Mecanim动画系统 导入怪兽3D模型 转换为Mecanim动画 动画控制器 导航：怪兽追击例程 实现人工智能 怪兽攻击例程 怪兽被袭时的反应 血迹效果 贴图：地面上的血迹效果 赋予怪兽攻击技能 特定层之间的碰撞感知 优化Mecanim动画角色的骨骼结构 怪兽停止攻击：Tag 怪兽停止攻击：Delegate、Event 怪兽的死亡处理 敌对角色在游戏中是NPC（Non Playable Character，非玩家角色）的一种，是玩家无法控制的角色。也就是说，其应该具备自己的人工智能，可以在游戏中与玩家互动，这样才会使游戏更加逼真。 要想实现NPC的人工智能，需要用到有限状态机（FSM，Finite State Machine）。使用有限状态机后，敌对角色便会自动适应周边环境，并对周围发生的事件产生适当反应。本章要制作的敌对角色会在生成后自动在场集中巡查，一旦发现玩家角色便会开始追击。如果追到其射击范围内，便会攻击玩家角色。另外，敌对角色会受伤，如果生命条消耗殆尽就会死亡。 有限状态机 Mecanim动画系统为了根据FSM的状态控制敌对角色进行上述反应和动作，需要利用Unity的Mecanim动画系统制作动画。Mecanim动画系统是一种动画中间件引擎，使用其可以轻松制作柔和、平滑的动画效果。 Mecanim动画系统提供了重新设定目标（re-targeting）的功能，如果类人（Humanoid）模型的骨骼构造一致，那么可以直接使用其他模型的动画，或者使用动作捕捉该模型动画以制作自己的动画。随之就可以重复使用其他模型的动画，还可以通过模型的高画质动作捕捉操作以提高自身画质。这是Mecanim的一大优点。 导入怪兽3D模型导入Monster资源包，导入后，将Monster文件夹移到Models文件夹。 这个怪兽模型包含了游戏中需要的基本动画idle、walk、run、jump、fall、attack等，这些动画虽然不是用动画捕捉制作的，但都可以转换为Mecanim类型。 转换为Mecanim动画选择Project视图中的Monster模型后，点击Inspector视图的Rig选项卡，如下图所示。 更改Monster的动画类型 Rig选项卡中可以设置动画类型，分为Legacy Animation、Generic、Humaniod这3种类型，各类型特征如下表所示。 动画类型 类型 特征 Legacy 旧动画系统 Generic Mecanim动画系统（非人形模型），无法使用重新设定目标功能 Humaniod Mecanim动画系统（人形模型、2足步行模型），可以重新设定目标 Monster模型是2足步行（Biped）模型，所以此处选择动画类型为Humaniod。变更动画类型后，不要忘记点击底部Apply按钮保存。点击Apply之后，Unity开始分析当前模型的骨骼结构。一段时间过后，Configure按钮就会激活，按钮前面也会出现确认标记。如果模型不是Humanoid类型的骨骼结构，按钮前会出现X标记，表示不可以在该模型上使用Mecanim分析骨骼结构。 点击Configure按钮，出现Unity映射的骨骼结构图，可以查看骨骼是否映射成功，如下图所示。此时如果弹出保存场景对话框，可以点击按钮进行保存。 Avatar中保存着模型骨架的映射信息，可以反复映射模型信息。 Inspector视图的monsterAvatar呈现了对模型骨骼映射之后的结果，其中15个实线圆圈是必须与模型对应的骨骼连接的节点，而虚线圆圈是附加的节点，可以不与模型连接。因此，即使是看上去完全不同的模型，只要这些实线圆圈代表的骨骼一致，即可重新使用这些模型的动画。 自动映射模型骨骼的Avatar信息 点选Inspector视图中Avatar设置画面顶端Muscles选项卡，可以在该界面拖曳各项条目以活动各个关节，并可以在Scene视图中查看。 查看各个关节的动作是否自然 另外，还可以在Pre-Muscle Settings旋转各个关节，并设置关节可以活动的最小角度和最大角度。 设置各个关节的旋转范围 点击Animations选项卡可以看到该模型拥有的动画列表，在此修改各个动画片段的属性。其中Loop Time选项表示当前动画片段可反复播放，而Loop Pose选项可以使动画在反复播放过程中更加平滑、柔和。 如下图所示，可以将idle、walk、attack、fall这些动画片段依次勾选Loop Time选项，并点击底端Apply按钮保存。 设置动画片段使其循环播放 如上图所示，如果动画目录中没有动画片段，或者由于误操作而将动画片段删除，此时可以使用之前介绍的将主人公角色进行动画分割的方法依次分割本章节的怪兽动画。 现在已经设置了默认Mecanim属性，请将Monster拖曳到场景视图。 Monster模型使用了Animator组件，该组件是制作敌对角色动画必需的组件，与前面制作Player模型时所需的Animation组件一样。可以靠3D模型中添加的组件类型轻松区分是Mecanim类型的动画还是旧版动画，如下表所示。 根据添加组件判别动画类型 组件 动画类型 具体选项 Animator Mecanim Animation GenericHumanoid Animation Legacy Animation &nbsp; 动画控制器下面为怪兽添加动画。如果为模型制作Mecanim类型的动画，需要Unity提供的动画控制器（Animator Controller）。 动画控制器可以为动画类型是Mecanim的模型制作动画，还提供了界面，可以根据特定条件设计能够转换不同动画状态的规则。 选定Project视图的文件夹，选择Assets-&gt;Create-&gt;Animator Controller菜单；或者在Project视图的上下文菜单中选择Create-&gt;Animator Controller，新建动画控制器New Animator Controller。 将其重命名为MonsterAnim，然后双击，IDE显示Animator视图，如下图所示。 首次打开Animator视图时，默认生成3个状态图标，其作用如下表所示。 各默认状态的作用 状态分类 作用 Entry 开始状态，状态机最初进入点 Exit 结束状态，所有状态结束的终态 Any State 无论当前正在以何种状态运行，只要满足条件，都需要分离的任一状态 将Project视图Monster模型下面的动画片段中的idle动画拖曳到Animator视图。如下图所示，刚添加的动画片段呈橘黄色，表示这是该模型第一个要执行的动画片段，所以Unity自动为它与Entry状态之间添加了一条连接线。 如果想将其他动画片段设为第一个动画片段，需要鼠标右击该动画片段，然后在上下文菜单中选择Set As Layer Default State。 向Animator视图添加的这种动画片段称为State，而idle动画片段可称为idle State。 向Animator视图添加idle动画片段 初始动画已设置好，请在Hierarchy视图中选择Monster，然后将Inspector视图内Animator组件的属性设置为新建的动画控制器MonsterAnim。 为Monster模型设置动画控制器 运行游戏，可以看到怪兽执行了idle动画，并且Animator视图中的idle图标下端出现动画执行进度条。 运行游戏后执行Animator视图添加的idle动画 请注意，如果想在Animator视图中查看动画执行进度条，需要先在Hierarchy视图中选定怪兽模型。下面添加怪兽走路的动画片段，直接拖曳walk动画片段到Animator图中即可，如下图所示。 添加walk动画片段 动画状态转换要想使怪兽模型从基本动画idle转换为执行下一个动画walk，需要连接这2个状态。请在idle上右击鼠标，在上下文菜单中选择Make Transition菜单，出现可以连接其他状态的白色连接线。将此线带到walk图标上并点击，即可连接这2个状态。Unity中，这种连接线称为Transition。 此时，为了控制idle动画与walk动画之间的转换方向，需要新建一个变量。点击Animator视图控制栏的Parameters选项卡，然后点击+按钮，弹出四种变量（Float、Int、Bool、Trigger）。选择Bool型，并将此参数命名为IsTrace。 此处设置为，如果IsTrace为true，则模型从idle状态转换为walk状态；如果IsTrace变量为false，模型则从walk状态回到idle状态。 先用鼠标点选idle状态与walk状态之间的Transition，然后点击Conditions属性下方的+按钮添加转换条件。Unity会自动弹出刚刚添加的参数IsTrace，之后自动选择最早生成的参数。确认控制参数为IsTrace后，将旁边的值设置为true。 要想使模型在IsTrace变量值为true时立刻切换状态，就不能勾选Inspector视图中的Has Exit Time属性。如果勾选该属性，模型会在idle动画全部执行结束后才会执行walk动画。 设置从idle状态转换为walk状态的条件 以上设置了从idle状态到walk状态的转换条件，下面可以在实现游戏逻辑的脚本中更改Animator的IsTrace参数，以控制动画状态的转换。 下面尝试逆向连接。添加一条从walk状态到idle状态的Transition，并将条件IsTrace设置为false，如下图所示。 添加从walk状态转换到idle状态的条件并设置属性 以上设置了idle状态和walk状态之间的互换条件。运行游戏，并在Animator视图的参数列表中反复勾选/取消勾选IsTrace变量，查看模型能否按照预期正确执行idle动画和walk动画。可以看到，如果勾选IsTrace变量，模型开始从idle状态向walk状态转换。Animator中的Transition也会瞬间标记为蓝色，如下图所示。 运行游戏时更改Animator视图的参数值以进行测试 现在可以开始编写脚本，以此向Animator视图添加各种动画状态。首先制作怪兽追击功能。 Animator视图的参数需要区分大小写。Unity不会自动删除参数名后面的空格，所以新建参数时需要特别注意。 导航：怪兽追击例程游戏开发中有很多实现寻路的算法，其中最广为人知的是A* Path Finding。添加到Unity导航功能前，该算法已在业界得到广泛应用。 Unity提供可以分析3D模型并使之实现追击的导航功能，下面使用该功能制作追击例程。本示例中，要想使怪兽开始追击，需要将动画转换为walk动画，怪兽接近玩家角色时，需要更改为attack动画。 在Unity中使用导航功能时，需要先分析构成场景的3D网格信息中角色可以自由活动的区域（Walkable Area）和因为有障碍物而无法越过的区域（Non Walkable Area）。也就是说，需要先在Unity编辑器模式中进行烘焙，并生成上述可用于导航的信息，然后再运行A* Path Finding算法，从而计算最短距离并使模型照此追击玩家。 生成导航网格并烘焙如果想要烘焙导航信息，首先要将Floor模型设置为Static。 先在Hierarchy视图中选择Floor模型，然后勾选Inspector视图右上端的Static复选框。Unity中，可以将很多功能设置为Static，此处只设置Floor在导航功能激活时Static，所以只勾选下拉框中Navigation Static即可。 另外，因为油桶在游戏中也会被识别为障碍物，所以需要将其设置为Navigation Static。因为Barrel是预设，所以修改Hierarchy视图的Barrel后务必点击Apply按钮才能保存更改。 选择Project视图的Barrel预设后，选择Navigation Static选项时，如果出现下图所示的询问“是否也应用到子对象”的对话框，请点击“Yes,change children”按钮，因为烘焙导航信息是以3D模型的网格信息为基准的。Barrel预设需要具有Mesh Renderer组件。 Static选项提示Unity引擎某个游戏对象是固定不动的。如果将油桶的所有功能都设置为Static选项，那么油桶在爆炸时也不会飞起来，所以此处只能选择Navigation Static选项。 选择菜单Window-&gt;Navigation会出现导航视图，点击右下角的Bake按钮，Unity开始烘焙导航信息，如下图所示，可以看到蓝色导航网格。 油桶周围没有填充蓝色，所以敌对角色追击时会将油桶判断为“无法越过的区域”。 Nav Mesh Agent下面为Monster游戏对象添加NavMeshAgent组件，使其可以追击玩家。选择Component-&gt;Navigation-&gt;Nav Mesh Agent菜单添加NavMeshAgent，其作用是分析烘焙生成的导航网格信息并回避障碍物，计算到目标物位置的最短距离并追击目标物。 Nav Mesh Agent组件的Stopping Distance属性表示离目标距离还有多远时停止。显然，如果此属性为0，那么二者会重叠。既然需要在追击一段距离时停止，此处将之设置为2。 在场景中生成怪兽的同时，需要得到要追击的对象，即玩家的位置信息，所以需要为玩家指定Tag。如下图所示。 很遗憾，Inspector视图Nav Mesh Agent组件的属性中没有可以直接设置追击对象的属性，所以需要在脚本中用代码为其指定要追击的对象。如下脚本所示，编写控制怪兽行为的MonsterCtrl脚本。 Start函数获取要追击的玩家，并将其位置信息赋给NavMeshAgent.destination属性。NavMeshAgent.destination指定要追击目标的位置，也可以用NavMeshAgent.SetDestination(Vector3 pos)函数设置位置信息。 1234567891011121314151617181920212223using UnityEngine;using System.Collections;public class MonsterCtrl : MonoBehaviour&#123; // 为提高速度而向变量分配各种组件 private Transform monsterTr; private Transform playerTr; private NavMeshAgent nvAgent; void Start() &#123; // 获取怪兽的Transform组件 monsterTr = this.gameObject.GetComponent&lt;Transform&gt;(); // 获取怪兽要追击的对象--玩家的Transform playerTr = GameObject.FindWithTag("Player").GetComponent&lt;Transform&gt;(); // 获取NavMeshAgent组件 nvAgent = this.gameObject.GetComponent&lt;NavMeshAgent&gt;(); // 设置要追击对象的位置后，怪兽马上开始追击 nvAgent.destination = playerTr.position; &#125;&#125; GameObject.FindWithTag(“Tag名”)函数能够寻找Hierarchy视图中所有游戏对象内具有指定Tag的游戏对象。如果Tag名大小写不一致或有拼写错误，或者没有为玩家游戏对象指定“Player”Tag，游戏运行时就会发生Null Reference…错误。 12// 获取怪兽要追击的对象--玩家的TransformplayerTr = GameObject.FindWithTag("Player").GetComponent&lt;Transform&gt;(); GameObject.Find类型的函数处理速度比较慢，所以最好不要在Update函数中使用，而在Awake、Start这类函数中使用。 将MonsterCtrl脚本添加到Monster并运行游戏，可以看到，Monster开始追击玩家。蓝色NavMesh上的红色实线表示怪兽到追击对象的最短距离，怪兽将沿着这根线进行追击；绿色和蓝色箭头表示怪兽的前进方向及其与追击对象间的角度。请注意，需要先开启Navigation视图，然后才能在场景视图中看到这些NavMesh信息。 仔细观察正在追击的怪兽，可以发现其脚底距地面有一定距离。因为Nav Mesh Agent组件附在导航网格表面，所以Monster模型的Y值也不断变化。 要想解决这个问题，需要将Nav Mesh Agent组件附粘在与Navigation Mesh表面相近的位置进行烘焙，或者调整Nav Mesh Agent组件的Base Offset属性。如下图所示，右图为将Base Offset设置为-0.1后的画面，怪兽的3D模型贴在地面上，而Nav Mesh Agent组件向Y轴下方移动了一段距离。 实现人工智能怪兽状态有休眠、追击、攻击、死亡这4种。怪兽生成时执行休眠动画，玩家接近并进入追击范围时，怪兽开始进入追击状态，到达可攻击的范围内则执行攻击动画。因此，需要测量怪兽和玩家之间的距离，并定期更新怪兽状态，使其执行相应动画。 如下图所示，编写MonsterCtrl脚本。 实现怪兽人工智能的协程函数流程图 怪兽状态根据其与玩家之间距离的变化而变化，即需要判断当前距离是否属于攻击范围，还要根据怪兽状态将执行相应动作的函数变为二元函数。Start函数中，可以将一开始就追击玩家的逻辑删除或者为其添加注释。 12// 设置要追击对象的位置后，怪兽会马上开始追击。nvAgent.destination = playeTr.position; 如下所示修改MonsteCtrl脚本。 MonsterCtrl：实现FSM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788using UnityEngine;using System.Collections;public class MonsterCtrl : MonoBehaviour&#123; // 声明表示怪兽状态信息的Enumerable变量 public enum MonsterState&#123;idle, trace, attack, die&#125;; // 保存怪兽当前状态的Enum值 public MonsterState monsterState = MonsterState.idle; // 为提高速度而向变量分配各种组件 private Transform monsterTr; private Transform playerTr; private NavMeshAgent nvAgent; // 追击范围 public float traceDist = 10.0f; // 攻击范围 public float attackDist = 2.0f; // 怪兽是否死亡 private bool isDie = false; void Start() &#123; // 获取怪兽的Transform组件 monsterTr = this.gameObject.GetComponent&lt;Transform&gt;(); // 获取怪兽要追击的对象--玩家的Transform playerTr = GameObject.FindWithTag("Player").GetComponent&lt;Transform&gt;(); // 获取NavMeshAgent组件 nvAgent = this.gameObject.GetComponent&lt;NavMeshAgent&gt;(); // 设置要追击对象的位置后，怪兽马上开始追击 // nvAgent.destination = playerTr.position; // 运行定期检查怪兽当前状态的协程函数 StartCoroutine(this.CheckMonsterState()); // 运行根据怪兽当前状态执行相应例程的协程函数 StartCoroutine(this.MonsterAction()); &#125; // 定期检查怪兽当前状态并更新monsterState的值 IEnumerator CheckMonsterState() &#123; while(!isDie) &#123; // 等待0.2秒后再执行后续代码 yield return new WaitForSeconds(0.2f); // 测量怪兽与玩家之间的距离 float dist = Vector3.Distance(playerTr.position, monsterTr.position); if (dist &lt;= attackDist) // 查看玩家是否进入攻击范围 &#123; monsterState = MonsterState.attack; &#125; else if (dist &lt;= traceDist) // 查看玩家是否进入追击范围 &#123; monsterState = MonsterState.trace; // 将怪兽状态设置为追击 &#125; else &#123; monsterState = MonsterState.idle; // 将怪兽状态设置为idle &#125; &#125; &#125; // 根据怪兽当前状态执行适当的动作 IEnumerator MonsterAction() &#123; while(!isDie) &#123; switch (monsterState)&#123; case MonsterState.idle: // idle状态 nvAgent.Stop(); // 停止追击 break; case MonsterState.trace: //追击状态 nvAgent.destination = playerTr.position; // 传递要追击对象的位置 nvAgent.Resume(); // 重新开始追击 break; case MonsterState.attack: // 攻击状态 break; &#125; &#125; yield return null; &#125;&#125; 脚本中定义了一个Enum（枚举型）变量，Inspector视图中也以下拉框形式标注了该枚举型变量，如下图所示。编写程序时，使用这种Enum类型的变量要比使用int、string等类型的变量的可读性更好，更有助于理解代码。 1234// 声明表示怪兽状态信息的Enumerable变量public enum MonsterState&#123;idle, trace, attack, die&#125;;// 保存怪兽当前状态的Enum值public MonsterState monsterState = MonsterState.idle; 始终检查怪兽状态的逻辑使用了协程函数，当然，也可以在Update()函数中实现同样的逻辑。但与其在每一帧都调用Update()函数查看怪兽状态，不如使用例程，以更加适当的周期间隔进行操作会更加高效，也能使代码更简洁。 CheckMonsterState()函数以0.2秒为间隔反复测量玩家与怪兽之间的距离，然后更新怪兽状态。这个函数添加了一个while语句isDie，换言之，只要怪兽活着，下列循环就会一直执行；而如果怪兽死掉，当然就无需更新状态变量。 12345678910111213141516171819202122// 定期检查怪兽当前状态并更新monsterState的值IEnumerator CheckMonsterState()&#123; while(!isDie) &#123; // 等待0.2秒后再执行后续代码 yield return new WaitForSeconds(0.2f); // 测量怪兽与玩家之间的距离 float dist = Vector3.Distance(playerTr.position, monsterTr.position); if (dist &lt;= attackDist) // 查看玩家是否进入攻击范围 &#123; monsterState = MonsterState.attack; &#125; else if (dist &lt;= traceDist) // 查看玩家是否进入追击范围 &#123; monsterState = MonsterState.trace; // 将怪兽状态设置为追击 &#125; else &#123; monsterState = MonsterState.idle; // 将怪兽状态设置为idle &#125; &#125;&#125; 其中，yield return new WaitForSeconds(0.2f)这行代码可以使程序逻辑暂时挂起，其传入的参数即为挂起时间，单位为秒(sec)。也就是说，yield return语句能够实现逻辑待机。可以将之理解为其他编程语言的Sleep功能，一般在需要等待一定时间间隔时使用。 12//等待0.2秒后再执行后续代码yield return new WaitForSeconds(0.2f); 玩家接近怪兽时，怪兽需要选择追击还是攻击，这就需要计算两个游戏对象之间的距离。Vector3.Distance(Vector3 a， Vector3 b)函数测量并返回a，b之间的距离，MonsterCtrl脚本向该函数传入2个参数，分别是玩家当前位置playerTr.position和怪兽当前位置monsterTr.position。 12// 测量怪兽与玩家之间的距离float dist = Vector3.Distance(playerTr.position, monsterTr.position); MonsterAction()协程函数中，根据保存怪兽状态的变量monsterState值的不同实现游戏的追击逻辑 12345678910111213141516171819202122// 根据怪兽当前状态执行适当的动作IEnumerator MonsterAction()&#123; while(!isDie) &#123; switch (monsterState)&#123; case MonsterState.idle: // idle状态 nvAgent.Stop(); // 停止追击 break; case MonsterState.trace: //追击状态 nvAgent.destination = playerTr.position; // 传递要追击对象的位置 nvAgent.Resume(); // 重新开始追击 break; case MonsterState.attack: // 攻击状态 break; &#125; &#125; yield return null;&#125; MonsterAction()函数可以在变量isDie为true时跳出循环，并根据monsterState变量值的不同而利用Switch语句产生分支。 如果将场景视图中的Monster与Player事先分开一定距离（大于追击范围），那么游戏运行开始，怪兽会是idle状态。如果使Monster靠近Player，游戏一开始怪兽便会追击。如果重新将Player置于较远距离以模拟跑出追击范围的场景，则怪兽会停止而不再追击。游戏运行过程中，可以查看Inspector视图中的monsterState怪兽状态值的变化。 怪兽状态为MonsterState.idle时，应该停止追击，进入idle状态。脚本中的NavMeshAgent.Stop()函数即可实现停止追击。 123case MonsterState.idle: // idle状态 nvAgent.Stop(); // 停止追击 break; 玩家重新进入怪兽追击范围内，怪兽状态值会变为MonsterState.trace，此时通过NavMeshAgent.destination设置玩家当前位置值，以使怪兽开始追击。NavMeshAgent.Resume()方法可以重启处于停止状态的NavMeshAgent。 1234case MonsterState.trace: //追击状态 nvAgent.destination = playerTr.position; // 传递要追击对象的位置 nvAgent.Resume(); // 重新开始追击 break; 根据怪兽状态值不同而变化的switch分支语句将在之后完成全部逻辑时跳出。 下面运行使怪兽适时执行idle和trace状态的动画。前面已经为Animator设置控制变量IsTrace，现在可以向MonsterCtrl脚本添加访问Monster的Animator组件，并向MonsterAction函数添加更改IsTrace变量值的逻辑。 MonsterCtrl：分配Animator组件并修改MonsterAction函数 12345678910111213141516171819202122232425262728293031323334353637383940using UnityEngine;using System.Collections;public class MonsterCtrl : MonoBehaviour&#123; private Animator animator; void Start() &#123; // 获取Animator组件 animator = this.gameObject.GetComponent&lt;Animator&gt;(); &#125; // 根据怪兽当前状态执行适当的动作 IEnumerator MonsterAction() &#123; while(!isDie) &#123; switch (monsterState)&#123; case MonsterState.idle: // idle状态 nvAgent.Stop(); // 停止追击 // 将Animator的IsTrace变量设置为false animator.SetBool("IsTrace", false); break; case MonsterState.trace: //追击状态 nvAgent.destination = playerTr.position; // 传递要追击对象的位置 nvAgent.Resume(); // 重新开始追击 // 将Animator的IsTrace变量设置为true animator.SetBool("IsTrace", true); break; case MonsterState.attack: // 攻击状态 break; &#125; &#125; yield return null; &#125;&#125; 使用下表中的函数可以访问Animator视图中显示的各种类型的变量。 访问Animator中变量的函数 Set函数 Get函数 Animator.SetBool Animator.GetBool Animator.SetFloat Animator.GetFloat Animator.SetInteger Animator.GetInteger Animator.SetTrigger Animator.GetTrigger 怪兽状态值为MonsterState.idle时，需要将其状态设为idle。怪兽处于追击状态时，将IsTrace变量设为false可以使怪兽转换为idle状态。 12// 将Animator的IsTrace变量设置为falseanimator.SetBool("IsTrace", false); 反之，怪兽状态值为MonsterState.trace时，IsTrace需要设为true，这样就会从idle状态转换为walk状态。 12// 将Animator的IsTrace变量设置为trueanimator.SetBool("IsTrace", true); 运行游戏后移动玩家，使其接近怪兽。进入追击范围时，怪兽开始追击玩家，此时怪兽执行的是我walk动画。如果玩家选择远离怪兽，怪兽就会停止追击，执行idle动画。 怪兽攻击例程下面为怪兽赋予攻击技能。双击MonsterAnim打开Animator视图，将attack动画片段拖曳至此，如下图所示，连接attack动画和walk动画。 添加用于控制attack状态转换的Bool型参数IsAttack，设置IsAttack为true时，怪兽从walk状态转换为attack状态；IsAttack为false时，怪兽回到walk状态。选择从walk状态到attack状态的Transition，将Inspector视图Conditions条件的IsAttack参数设为true。注意，不要勾选Has Exit Time选项。 walk状态与attack状态之间的Transition条件 Transition Conditions 设置值 Has Exit Time选项 walk-&gt;attack IsAttack true 不勾选 attack-&gt;walk IsAttack false 不勾选 将从attack状态到walk状态的转换条件设置为IsAttack=false，同样不勾选Has Exit Time选项，如上表所示。 连接Animator视图中的各个状态并设置好条件后，需要修改MonsterCtrl脚本的MonsterAction()函数，调整IsAttack变量的值。 MonsterCtrl：向MonsterAction()函数添加攻击逻辑 123456789101112131415161718192021222324252627282930313233343536373839// 根据怪兽当前状态执行适当的动作IEnumerator MonsterAction()&#123; while(!isDie) &#123; switch (monsterState) &#123; // idle状态 case MonsterState.idle: // 停止追击 nvAgent.Stop(); // 将Animator的IsTrace变量设置为false animator.SetBool("IsTrace", false); break; // 追击状态 case MonsterState.trace: // 设置要追击对象的位置 nvAgent.destination = playerTr.position; // 重新开始追击 nvAgent.Resume(); // 将Animator的IsAttack变量设置为false animator.SetBool("IsAttack", false); // 将Animator的IsTrace变量设置为true animator.SetBool("IsTrace", true); break; // 攻击状态 case MonsterState.attack: // 停止追击 nvAgent.Stop(); // 将IsAttack设置为true后，转换为attack状态 animator.SetBool("IsAttack", true); break; &#125; yield return null; &#125;&#125; 修改脚本后运行游戏，操控玩家接近怪兽。如果玩家进入攻击范围，怪兽将如期执行attack动画；如果玩家退出攻击范围，怪兽将执行walk动画。 怪兽被袭时的反应下面学习制作怪兽被玩家发射的子弹击中时的反应。首先，要想感知被子弹击中的碰撞，怪兽模型必须有Collider组件。选择Hierarchy视图的Monster，添加Capsule Collider组件，并如下表所示修改属性。 属性 值 Height 2 Center X=0 Y=1 Z=0 各位如果直接运行游戏将会发现，向怪兽发射子弹后，子弹会直接弹出去，这正是因为刚刚为Monster添加了Capsule Collider。 下面添加并设置怪兽被子弹击中时的反应动画。首先打开MonsterAnim，添加gothit动画片段，并连接AnyState和gothit状态。gothit动画片段是怪兽被击中时的反应动画，无论怪兽在何种状态下被击中都应该得到执行。也就是说，无论怪兽当前处于idle、walk还是attack状态，只要AnyState到gothit的转换条件成立，怪兽就会马上转换为gothit状态。 如下图所示连接各个状态，并新建Trigger类型的参数IsHit，然后如下表所示设置各个状态之间的转换条件。 No. Transition Conditions 设置值 ① Any State-&gt;gothit IsHit 无 ② gothit-&gt;idle Exit TimeIsTrace 0.9false ③ gothit-&gt;walk Exit TimeIsTrace 0.9true ④ gothit-&gt;attack Exit TimeIsAttack 0.9true 为了使gothit动画执行到90%时即可回到之前的状态，②、③、④号转换条件都需要勾选Has Exit Time选项。点开Settings区域，将Exit Time设置为0.9。Exit Time取值范围是0.0-1.0，0.9表示90%。 为了处理碰撞事件并实现对动画片段转换的控制，需要再次修改MonsterCtrl脚本。OnCollisionEnter()函数中，子弹与怪兽碰撞时，删除表示该子弹的Bullet对象，同时触发前面添加的IsHit Trigger。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using UnityEngine; using System.Collections;public class MonsterCtrl : MonoBehaviour&#123; // 声明表示怪兽状态信息的Enumerable变量 public enum MonsterState &#123; idle, trace, attack, die &#125;; // 保存怪兽当前状态的Enum变量 public MonsterState monsterState = MonsterState.idle; // 为提高速度而向变量分配各种组件 private Transform monsterTr; private Transform playerTr; private NavMeshAgent nvAgent; private Animator animator; // 追击范围 public float traceDist = 10.0f; // 攻击范围 public float attackDist = 2.0f; // 怪兽是否死亡 private bool isDie = false; void Start () &#123; &#125; // 定期检查怪兽当前状态并更新monsterState变量值 IEnumerator CheckMonsterState() &#123; &#125; // 根据怪兽当前状态执行适当的动作 IEnumerator MonsterAction() &#123; &#125; // 检查怪兽是否与子弹发生碰撞 void onCollisionEnter(Collision coll) &#123; if (coll.gameObject.tag == "BULLET") &#123; // 删除子弹对象Bullet Destroy(coll.gameObject); // 触发IsHit Trigger，使怪兽从Any State转换为gothit状态 animator.SetTrigger("IsHit"); &#125; &#125;&#125; 修改脚本后运行游戏，操控玩家向怪兽发射子弹。如果子弹打中怪兽，那么怪兽会转换为gothit状态，并执行被击中的反应动画。之后，怪兽应该回到被击中之前的状态，继续执行被击中之前的动画。 血迹效果下面添加怪兽被玩家开枪击中时的流血效果，其中又分为子弹命中部位的血迹效果和地面上散落的血迹效果。可以使用Particle实现，也可以通过在Plane Mesh上附着纹理实现。 导入BloodEffect.unitypackage资源包，并将生成的BloodEffect文件夹移到Prefabs文件夹。 第一种血迹效果，即怪兽身上命中子弹部位的血迹效果可通过在被击中位置生成BloodEffect预设的方式实现。如下脚本所示修改MonsterCtrl脚本的void OnCollisionEnter()函数，并添加CreateBloodEffect()函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970using UnityEngine; using System.Collections;public class MonsterCtrl : MonoBehaviour&#123; // 声明表示怪兽状态信息的Enumerable变量 public enum MonsterState &#123; idle, trace, attack, die &#125;; // 保存怪兽当前状态的Enum变量 public MonsterState monsterState = MonsterState.idle; // 为提高速度而向变量分配各种组件 private Transform monsterTr; private Transform playerTr; private NavMeshAgent nvAgent; private Animator animator; // 追击范围 public float traceDist = 10.0f; // 攻击范围 public float attackDist = 2.0f; // 怪兽是否死亡 private bool isDie = false; // 血迹效果预设 public GameObject bloodEffect; // 血迹贴图效果预设 public GameObject bloodDecal; void Start () &#123; &#125; // 定期检查怪兽当前状态并更新monsterState变量值 IEnumerator CheckMonsterState() &#123; &#125; // 根据怪兽当前状态执行适当的动作 IEnumerator MonsterAction() &#123; &#125; // 检查怪兽是否与子弹发生碰撞 void onCollisionEnter(Collision coll) &#123; if (coll.gameObject.tag == "BULLET") &#123; // 调用血迹效果函数 CreateBloodEffect(coll.transform.position); // 删除子弹对象Bullet Destroy(coll.gameObject); // 触发IsHit Trigger，使怪兽从Any State转换为gothit状态 animator.SetTrigger("IsHit"); &#125; &#125; void CreateBloodEffect(Vector3 pos) &#123; // 生成血迹效果 GameObject blood1 = (GameObject)Instantiate(bloodEffect, pos, Quaternion.identity); Destroy(blood1, 2.0f); &#125;&#125; 修改脚本后，Inspector视图显示bloodEffect属性，将其设置为Prefabs/BloodEffect/中的BloodEffect预设。 生成血迹效果的CreateBloodEffect函数以子弹坐标为参数，使怪兽被子弹击中的位置出现血迹效果，可以通过coll.transform.position获取子弹坐标。 123456void CreateBloodEffect (Vector3 pos)&#123; // 生成血迹效果 GameObject blood1 = (GameObject)Instantiate(bloodEffect, pos, Quaternion.identity); Destroy(blood1, 2.0f); &#125; 运行游戏并发射子弹，击中怪兽即可看到血迹效果。 贴图：地面上的血迹效果为了表现怪兽中枪后血流到地面上的效果，需要使用贴图（Decal）方法。 贴图指的是在物体表面描绘某种图案或花纹以制作效果，在游戏中常用于制作弹痕、爆炸后被照黑的地面、道路上的纸屑或墙面上的海报等。贴图的实现方式很简单，在Plane Mesh上附上需要的纹理，然后将其垂直贴到地面或墙壁即可。如果要在移动的物体或曲面上使用贴图，则需要采用Projector方式。 在菜单中依次选择GameObject-&gt;3D Object-&gt;Quad生成Quad模型，重命名为BloodDecal。必须删除默认添加Quad模型的Mesh Collider。为了后续步骤，请在Hierarchy视图中将刚添加的BloodDecal（Quad ）的X轴旋转90°。 将前面导入的BloodEffect文件夹中的BloodDecal镜像文件移到Images文件夹，并在Materials文件夹中新建材质，将此材质重命名为BloodDecal。 将BloodDecal材质的着色器更改为Unlit/Transparent。 将BloodDecal材质拖曳到场景视图中刚刚添加的BloodDecal（Quad），并为其附上纹理。 将BloodDecal移动到项目视图Prefabs文件夹中做成预设，再选择Hierarchy视图中的Monster，将MonsterCtrl脚本的BloodDecal属性设为BloodDecal预设，并如下脚本所示，修改MonsterCtrl脚本的CreateBloodEffect函数。 123456789101112131415161718void CreateBloodEffect(Vector3 pos)&#123; // 生成血迹效果 GameObject blood1 = (GameObject)Instantiate(bloodEffect, pos, Quaternion.identity); Destroy(blood1, 2.0f); // 贴图生成位置：计算在地面以上的位置 Vector3 decalPos = monsterTr.position+ (Vector3.up*0.05f); // 随机设置贴图旋转值 Quaternion decalRot = Quaternion.Euler(90, 0, Random.Range(0,360)); // 生成贴图预设 GameObject blood2 = (GameObject)Instantiate(bloodDecal, decalPos, decalRot); // 调整贴图大小，使其每次生成的尺寸不同 float scale = Random.Range(1.5f, 3.5f); blood2.transform.localScale = Vector3.one * scale; // 5秒后删除血迹效果预设 Destroy(blood2, 5.0f);&#125; 贴图生成于怪兽的Pivot位置，但地面与Y轴处于同一水平面时，贴图附着的网格表面可能出现闪烁现象，所以需要将贴图稍微向上移动，使其不与地面贴在一起。 12// 贴图生成位置：计算在地面以上的位置Vector3 decalPos = monsterTr.position + (Vector3.up*0.05f); 为了使BloodDecal呈现不规则形状，可将其随机旋转一定角度。Quaternion.Euler(x, y, z)函数指定了相应轴的旋转角度值，并返回Quaternion类型的最终旋转值。例如，Quaternion.Euler(0, 30, 0)是指以Y轴为基准旋转30°，并返回Quaterion类型的值。 由于BloodDecal源自Quad，所以如果以Quaternion.identity作为Instantiate函数的第三个参数，那么生成的贴图会垂直于地面。因此，脚本中同时将其以轴为基准旋转90 ，并以Z轴为基准进行不规则旋转。 1234// 随机设置贴图旋转值Quaternion decalRot = Quaternion.Bullet(90, 0, Random.Range(0,360));// 生成贴图预设GameObject blood2 = (GameObject)Instantiate(bloodDecal, decalPos, decalRot); 运行游戏后发射子弹，可以看到怪兽下方动态生成的BloodDecal(Clone)，这些贴图与地面的Y轴坐标值不，如下图所示，而且这些动态生成的预设的大小也不一样。 123// 调整贴图大小，使其每次生成的尺寸不同float acale = Random. Range(1.5f, 3.5f);blood2.transform.localScale = Vector3.one * Scale; 向怪兽发射子弹后，地面上会动态生成BloodDecal，5秒后即被删除。 12// 5秒后删除血迹效果预设Destroy(blood, 5.0f) ; 赋予怪兽攻击技能前面已经制作了怪兽与玩家在一定距离内时执行攻击动画的逻辑，现在添加玩家被攻击时受到损伤而导致生命力逐渐下降的逻辑。 要想实现怪兽的攻击能力，需要为怪兽的双手添加Collider，以使其在执行攻击动画时与玩家的Collider发生碰撞。如下图所示，从怪兽的骨骼结构中找到手腕部分，分别为双手手腕添加Sphere和Rigidbody组件。为了使受到攻击的玩家能够识别该Collider，需要为其新建名为PUNCH的标签。 在Inspector视图中勾选Sphere Collider的Is Trigger属性，这样可以避免之前添加的Capsule Collider与Sphere Collider产生物理干涉。还需要取消勾选Rigidbody组件的Use Gravity属性，使其不受重力影响。也要勾选Is Kinematic属性，使其不受模拟物理力的影响。 设置Monster各组件属性值 组件 属性 设置值 Sphere Collider Is Trigger true Rigidbody Use GravityIs Kinematic falsetrue 同时也需要为玩家添加Collider，只有这样才能与怪兽发生碰撞事件。选择玩家，添加Capsule Collider，并如下表所示设置属性。 为玩家添加的组件设置属性值 组件 属性 设置值 Capsule Collider CenterHeight X=0，Y=1，Z=2 Rigidbody Freeze Rotation X=true, Y=false, Z= true 一般开发FPS或TPS时，主人公角色通常都会添加Character Controller组件。Capsule Collider和Rigidbody组件撞墙时，该组件可以使模型不发生颤抖现象（Jittering），也不会因外力而产生挤压。 为了确保玩家不会在移动时拌倒，需要在添加到玩家身体的Rigidbody组件的属性中勾选Constrains-Freeze Rotation属性的X和Z轴。 运行游戏并更改场景视图为Top View，查看怪兽手中添加的Sphere Collider和玩家身体上添加的Collider之间是否发生碰撞。如果因怪兽和玩家之间距离过远面无法发生碰撞，可以在MonsterCtrl.cs脚本中将AttackDist变量调整为更小的数字。如图6-58所示，在层次视图中同时选择Monster和Player游戏对象，点击坐标轴Gizmos的Y轴以设置为Top View。 在场景视图中查看是否发生碰撞后，还需要修改PlayerCrl脚本，为其添加发生碰撞时需执行的回调函数。由于之前已经勾选了怪兽手上的Sphere Collider的Is Trigger选项，所以碰撞发生时执行的是OnTriger-为前缀的函数，而不是OncCollision-为前缀的函数。 运行游戏后，如果怪兽攻击玩家，则可以在控制台视图中看到输出的日志，其中显示玩家hp值降低。hp小于0时，就会调用处理玩家死亡的函数。不过，因为之前导入的资源包中并没有玩家模型死亡动面，所以此处使怪兽跳舞以宣告玩家死亡。 特定层之间的碰撞感知之前制作的怪兽攻击逻辑虽然看似没有任何异常，但怪兽身体中添加的Capsule Collider及其手上添加的Sphere Collider在每次活动时都会不断发生碰撞，所以会不断调用碰撞回调函数。因为怪兽双手中添加的Sphere Collider包含Rigidbody组件，所以它会与自身的Collider发生碰撞。 为了确认这一点，可以在MonsterCtrl脚本中添加下列脚本，之后再次运行游戏。可以发现，怪兽追击时，自己身上也会不断发生碰撞。 1234void OnTriggerEnter(Collider coll)&#123; Debug.Log(coll.gameObject.tag);&#125; 这无疑为物理引擎添加了不必要的负荷。为了修正这个问题，可以特别设置不感知某些Collider之间的碰撞。这种设置需要使用到Unity中的另一个概念--层。首先为各个Collider指定不同的层。 点击Inspector视图顶端Layer组合框，然后选择Add Layer…菜单，添加名为BODY和PUNCH的层，如下图所示。通过Edit-&gt;Project Settings-&gt;Tags and Layers菜单调出Tags&amp;Layers区域。 添加新层后，选定Hierarchy视图中的Monster游戏对象，在Inspector视图中将层设置为刚刚添加的BODY。此时出现弹窗，询问是否将此应用到Monster下的所有游戏对象。请务必选择“No，this object only”以使之仅应用于Monster对象。 在Hierarchy视图中的monster下找到Monster游戏对象的双手骨骼L_wrist和R_wrist，并将其层设置为刚刚添加的PUNCH。 分别指定Collider的层后，选择Edit-&gt;Project Settings-&gt;Physics菜单，Inspector视图中会显示PhysicsManager的设置界面，其底端呈矩阵排列的复选框表示层之间是否需要检测物理碰撞。如下图所示，如果不需要感知BODY层和PUNCH层之间的复选框，那么解除二者即可。 完成设置后运行游戏，可以在Console视图中通过日志查看怪兽身上的2个Collider已不再感知碰撞。 优化Mecanim动画角色的骨骼结构如前所述，通过Mecanim动画系统设置的游戏模型已经被设置了骨骼结构。导入的怪兽模型可能已经设置了这种名为Rig（骨骼结构、骨架）的关节，可以选中后在Hierarchy视图中查看。Hierarchy视图的每级节点都是游戏对象，均拥有Transform组件。像monster这样的3D模型，它所具有的Transform组件运行时需要引擎进行多种运算处理，可能耗费很多资源，所以需要对其进行优化。因此，可以将实际游戏中不会用到骨骼设置为隐藏，这样有助于提高游戏运行速度、降低引擎计算量。 怪兽模型所需的骨骼是添加了Sphere Collider和Rigidbody组件的双手，所以可以在Hierarchy视图中进行设置，使引擎只暴露怪兽双手上的骨骼节点。首先在Project视图中选定monster原版模型，点选Inspector视图的Rig选项卡，然后勾选其中的Optimize Game Objets选项，这样其下方就会出现Extra Transforms to Expose功能区域。 下面在Hierarchy视图中添加需要暴露的双手关节。点击Extra Transforms to Expose下端的+按钮后，Project视图中选定的模型所拥有的关节会以上下文菜单形式出现。如下图所示，依次找到代表双手的节点并点选，之后就会添加到Extra Transforms to Expose下方的列表。 用同样方式添加右手关节，添加完成后需要点击底端Apply按钮保存。保存后，如果点开Hierarchy视图中的monster节点就会发现，现在只能看到两手关节L_wrist和R_wrist，无法看到其他关节。 Optimize Game Objects功能可以只显示3D模型举着武器（刀、枪）的关节，从而提高运算处理速度。 怪兽停止攻击：Tag玩家hp小于0时，游戏会执行玩家死亡动画，或跳转到Game Over画面。但由于尚未为怪兽添加停止攻击的逻辑，所以即使玩家死亡，怪兽依然在忘我地攻击。显然，需要添加程序逻辑以通知怪兽模型玩家已死，怪兽们接受停止攻击的命令后会立刻停止追击和攻击。另外，如果游戏中有多个怪兽，则需要向所有怪兽传达停止攻击的命令。 如果想在脚本中引用场景里的某个特定游戏对象，可以使用事先为该游戏对象定义的Tag。 12GameObject.FindGameObjectWithTag(string tag);GameObject.FindGameObjectsWithTag(string tag); FindGameObjectWithTag(string tag)函数只返回1个游戏对象，而FindGameObjectsWithTag(string tag)函数以数组类型返回所有带有传入tag值的游戏对象。 新添加标签MONSTER，并在Hierarchy视图中选定monster，然后将其Tag指定为刚添加的新标签。 修改PlayerCtrl脚本中处理玩家死亡时执行的PlayerDie函数，在该函数中寻找所有怪兽游戏对象，并执行终止攻击函数，如下脚本所示。 修改PlayerCtrl脚本的PlayerDie函数 123456789101112// 玩家的死亡处理例程void PlayerDie()&#123; Debug.Log("Player Die !!"); // 获取所有拥有MONSTER Tag的游戏对象 GameObject[] monsters = GameObject.FindGameObjectsWithTag("MONSTER"); // 依次调用所有怪兽的OnPlayerDie函数 foreach(GameObject monster in monsters) &#123; monster.SendMeasage("OnPlayerDie", SendMessageOptions.DontRequireReceiver); &#125;&#125; 查找场景中所有怪兽游戏对象并将其保存到monsters数组，然后针对该数组中的每个对象调用OnPlayerDie函数。 1GameObject.SendMessage(string methodName, SendMessageOption option) monster.SendMessage(“OnPlayerDie”, SendMessageOptions.DontRequireReceiver)函数可以调用特定游戏对象的函数，一般用于需要使很多游戏对象都执行某个函数的逻辑，这样可以使代码更简洁高效。这个函数的第二个参数为SendMessageOptions.DontRequireReceiver选项，即使当前游戏对象没有第一个参数所代表的函数也无需进行额外处理。因此，为了使游戏运行时能够快速调用当前函数，必须使用该选项。 12345// 依次调用所有怪兽的OnPlayerDie函数foreach(GameObject monster in monsters)&#123; monster.SendMessage("OnPlayerDie", SendMessageOptions.DontRequireReceiver); &#125; 上述逻辑调用了怪兽模型的OnPlayerDie函数，如下脚本所示添加该函数。将该函数添加到MonsterCtrl脚本后，会停止所有协程函数，以防怪兽再次执行攻击例程或追击例程。 MonsterCtrl脚本：添加OnPlayerDie函数 12 OnPlayerDie函数更改怪兽状态，停止所有可让怪兽行动的协程函数。同时停止实现让怪兽追踪的NaMeshAgent组件，并让怪兽执行跳舞的动画。 最后，需要为怪兽设置跳舞的动画。打开MonsterAnim并添加fall动画片段，然后从Any State图标连接到fall图标，并为这个Transition添加Trigger类型的IsPlayerDie变量。 如下表所示，设置Any State动画到fall动画的转换条件 Transition Conditions 设置值 Any State-&gt;fall IsPlayerDie 无 从Any State到fall状态的Transition设置值 图片 脚本和动画均已设置完成，下面在场景中复制多个怪兽。注意，需要先将怪兽模型转换为预设后再复制。将Hierarchy视图的monster拖曳到Project视图Prefabs文件夹并进行预设。复制完成后运行游戏，怪兽会攻击玩家。玩家hp为0时，所有怪兽停止攻击，开始执行fall动画。 怪兽停止攻击：Delegate, Event上节中，玩家死亡时，为了使怪兽停止攻击，我们通过foreach循环语句反复调用停止攻击函数，调用时也使用了SendMessage方式。但如果场景中的怪兽非常多，依次调用就会导致执行效率低下。本节将介绍Event Driven方式。玩家死亡时，通过脚本通知Unity引擎“我死了”，系统便会触发事件，使注册该事件的所有怪兽停止动作。这种事件驱动方式要比依次通知的方式更高效。 委派（Delegate） 可以将“委派”理解为指派函数的变量。下列代码先在声明语句中声明了委派方法原型，之后在Start()函数中分别委派了其他方法，如下图所示。 在PlayerCtrl脚本的声明语句声明委派和事件函数，并如脚本所示修改OnTriggerEnter函数。PlayerDie函数不再需要通过标签获取所有怪兽，再通过循环以SendMessage函数传递信息，此处仅使其调用事件OnPlayerDie。 PlayerCtrl脚本：添加定义并调用事件的逻辑 12 前面已经完成了声明并触发事件的逻辑，下面在MonsterCrl脚本中编写响应事件的特定函数。事件必须在脚本激活时注册，在脚本结束时解除。如下脚本所示，修改MonsterCtrl脚本。 MonsterCtrl：添加注册及解除事件的逻辑 12 OnEnable()和OnDisable()是脚本激活或结束时执行的函数，事件的注册和解除必须在这两个函数内完成，使用的语法如下所示。 函数 语法 注册事件 （声明此事件的类名）.（事件名称）+=（事件发生时调用的函数） 解除事件 （声明此事件的类名）.（事件名称）+-（事件发生时调用的函数） 运行游戏后可能不会感到与之前使用方式的差别，但即使转换事件驱动方式也依然能够实现相同逻辑。 怪兽的死亡处理前面已经制作了怪兽被击中时的视觉效果，下面添加怪兽死亡时的动画。与玩家一样，也要为怪兽指定表示生命值的变量，并在OnCollisionEnter函数中判断hp是否小于0，以此判断怪兽是否死亡。 MonsterCtrl：添加处理怪兽死亡的逻辑 12 被子弹击中时触发的OnCollisionEnter函数中，子弹的伤害值会参考BulleCtrl脚本中定义的damage变量值。Unity中，脚本也是组件的一种，可以用以下方式获取。 GetComponent&lt;脚本名称&gt;().变量 GetComponent&lt;脚本名称&gt;().函数()因此，可以通过coll.gameObject.GetComponent().damage函数获取子弹伤害值，然后减少怪兽的hp。如果怪兽hp小于0，则调用MonsterDie函数。 处理怪兽死亡的逻辑中，一定要禁用怪兽身体上的Capsule Collider及其双手上的Sphere Collider，否则玩家继续射击死去的怪兽时，仍然会产生血迹效果，而且玩家从怪兽上面走过时也会受到伤害。通过GetComponent().enabled=false语句禁用怪兽身体的Collider组件。怪兽双手上的Sphere Collider在怪兽Rig层次结构中较深，所以为了获取特定游戏对象下的特定子游戏对象的组件，此处使用GetComponentsInChildren&lt;&gt;()函数。即使如前所述优化怪兽模型的骨骼结构后只留下手部关节，仍然需要使用这种方式获取手腕上的Collider组件。 GetComponentInChildren，GetComponentsInChildren 这2个方法都可以获取子对象中的特定组件，只是获取的组件数量不同。 GetComponentInChildren 子游戏对象中只返回指定的1个组件。如果有多个组件，则以各组件拥有的TransformSort为基准排序，返回顶端组件。 GetComponentsInChildren返回子游戏对象中指定的全部组件。因为返回的组件数量超过1个，所以返回的类型为数组。此时需要注意，返回的数组中同时也包含父游戏对象自己的组件。 GetComponentInParent，GetComponentsInParent其功能与返还GetComponentInChildren下端组件截然相反。也就是说，这2个方法获取的是指定对象的父节点中的组件。 将Monster的die动画片段添加到Animator视图，并从Any State连接到die状态。添加Trigger类型的参数IsDie，并将从Any State到die状态的Transition设置为IsDie。新建Exit状态，将die状态连接到Exit状态。 设置转换条件 Transition Conditions 设置值 Has Exit Time选项 Any State-&gt;die IsDie 无 取消勾选 die-&gt;Exit IsDie 无 无关 运行游戏后可以发现，怪兽被子弹击中并受伤，其hp小于0时执行die动画。但如下图所示现在怪兽死亡后会飘在空中。 执行die动画后飘在空中的怪兽 选择Project视图中的monster模型原件，在预览窗口中用慢动作观看die动画，可以发现怪兽模型飘在空中执行动画，而Pivot坐标轴在其下方。 原版动画的Pivot位置 请勾选Inspector视图中Root Transform Position(Y)属性的Bake Into Pose，或将Base upon设置为feet，这样Pivot坐标轴会始终固定在怪兽足部。执行游戏前可以预览动画，确认后再点击Apply按钮保存。现在，再次运行游戏，怪兽执行die动画后不会飘在空中。 设置Root Transform Position()值后的怪兽死亡动画 小结本章完成了拥有复杂逻辑的敌对角色——怪兽的制作，还学习了如何利用Mecanim动画系统制作FSM，也利用导航使怪兽追击玩家。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Player Settings]]></title>
    <url>%2F2019%2F03%2F25%2FPlayer-Settings%2F</url>
    <content type="text"><![CDATA[Player SettingsUse the Player settings to set various options for the final game built by Unity.使用player setting为Unity最后构建游戏设置各种选项 There are a few general settings that are the same regardless of the build target. These are covered below.无论构建目标如何，都有一些相同的常规设置。 Most settings, however, are platform-specific and divided into the following sections:但是，大多数设置都是特定于平台的，并分为以下几个部分： Icon: the game icon(s) as shown on the desktop. 桌面上显示的游戏图标 Resolution and Presentation: settings for screen resolution and other presentation details such as whether the game should default to fullscreen mode. 屏幕分辨率和其他显示详细信息的设置，例如游戏是否应默认为全屏模式。 Splash Image: the image shown while the game is launching. This section also includes common settings for creating a Splash Screen, which are documented in the Splash Screen section.游戏启动时显示的图像。此部分还包括用于创建启动画面的常用设置，这些设置在“启动画面”部分中进行了介绍。 Other Settings: any remaining settings specific to the platform. Publishing Settings: details of how the built application is prepared for delivery from the app store or host webpage. XR Settings: settings specific to Virtual Reality, Augmented Reality, and Mixed Reality applications. 特定于虚拟现实，增强现实和混合现实应用程序的设置。 You can find information about the settings specific to individual platforms in the platform’s own manual section. Not all sections are supported on every platform.您可以在平台自己的手册部分中找到有关各个平台特定设置的信息。 并非每个平台都支持所有部分。 This table provides a breakdown of which platform support these sections:此表提供了哪些平台支持这些部分的细分： General Settings Player settings that are available for all platforms Property Function Company Name Enter the name of your company. This is used to locate the preferences file. 这用于找到配置文件 Product Name Enter the name that appears on the menu bar when your game is running. Unity also uses this to locate the preferences file. 输入游戏运行时菜单栏上显示的名称 Version Enter the version number of your application. Default Icon Pick the the Texture 2D file that you want to use as a default icon for the application on every platform. You can override this for specific platforms. Default Cursor（光标） Pick the the Texture 2D file that you want to use as a default cursor for the application on every supported platform. Cursor Hotspot（热点） Set the offset value (in pixels) from the top left of the default cursor to the location of the cursor hotspot. 将偏移值（以像素为单位）从默认光标的左上角设置为光标热点的位置 Player settings for the Android platform automatic 自动 Icon Property FunctionAdaptive Set up textures for the Android Adaptive icons in your app.Round Set up textures for the Android Round icons in your app.Legacy Set up textures for the Android Legacy icons in your app.Enable Android Banner Enables a custom banner for Android TV builds. Resolution（分辨率） and PresentationUse the Resolution and Presentation section to customize aspects of the screen’s appearance.（自定义屏幕外观的各个方面） splash screen 启动画面 Setting Function Start in fullscreen mode Hide the navigation bar while the splash screen or first scene loads. When not set, the navigation bar appears while the splash screen or first scene loads. 在启动画面或第一个场景加载时隐藏导航栏。未设置时，导航栏会在启动画面或第一个场景加载时出现。 Preserve framebuffer alpha Enable this option if you want Unity to render on top of native the Android UI. The camera’s Clear Flags have to be set to Solid color with an alpha less than 1 for this to have any effect. (OpenGL ES only).]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Character Controller]]></title>
    <url>%2F2019%2F03%2F24%2FCharacter-Controller%2F</url>
    <content type="text"><![CDATA[The Character Controller is mainly used for third-person or first-person player control that does not make use of Rigidbody physics.角色控制器组件主要用于不使用刚体物理的第三人称或第一人称控制器。 是一个组件，和Rigidbody一样。添加之后会自带胶囊碰撞器。 slope 坡度steep 陡indicated 指示degrees 度essentially 基本相同jitter 抖动 Property Property Function Slope Limit Limits the collider to only climb slopes that are less steep (in degrees) than the indicated value. Step Offset The character will step up a stair only if it is closer to the ground than the indicated value. This should not be greater than the Character Controller’s height or it will generate an error. 角色控制器的能爬上的台阶高度 Skin width Two colliders can penetrate each other as deep as their Skin Width. Larger Skin Widths reduce jitter. Low Skin Width can cause the character to get stuck. A good setting is to make this value 10% of the Radius. 两个对撞机可以在它们的皮肤宽度上穿透彼此。较大的皮肤宽度可减少抖动。低皮肤宽度可能导致角色卡住。 一个好的设置是将此值设为Radius的10％ Min Move Distance If the character tries to move below the indicated value, it will not move at all. This can be used to reduce jitter. In most situations this value should be left at 0. Center This will offset the Capsule Collider in world space, and won’t affect how the Character pivots. 角色控制器的中心位置 Radius Length of the Capsule Collider’s radius. This is essentially the width of the collider. 胶囊碰撞器半径的长度。 这基本上是对撞机的宽度 Height The Character’s Capsule Collider height. Changing this will scale the collider along the Y axis in both positive and negative directions. 角色的胶囊碰撞器的高度。更改此设置将沿Y轴在正方向和负方向缩放碰撞器 The Character Controller halt 暂停constrained 受限Fine tuning 微调turn on a dime 灵活 DetailsThe traditional Doom-style first person controls are not physically realistic. The character runs 90 miles per hour, comes to a halt immediately and turns on a dime. Because it is so unrealistic, use of Rigidbodies and physics to create this behavior is impractical and will feel wrong. The solution is the specialized Character Controller. It is simply a capsule shaped Collider which can be told to move in some direction from a script. The Controller will then carry out the movement but be constrained by collisions.解决方案是专门的角色控制器。 它只是一个胶囊形状的碰撞器，可以通过脚本被告知向某个方向移动。然后，控制器将执行运动但受到碰撞的约束。 It will slide along walls, walk up stairs (if they are lower than the Step Offset) and walk on slopes within the Slope Limit.它将沿着墙壁滑下来，走上楼梯（如果它们低于Step Offset）并在Slope Limit内的斜坡上行走 The Controller does not react to forces on its own and it does not automatically push Rigidbodies away.控制器不会对施加在其身上的力作出反应，也不会自动推动刚体。 If you want to push Rigidbodies or objects with the Character Controller, you can apply forces to any object that it collides with via the OnControllerColliderHit() function through scripting.如果要使用角色控制器推动刚体或对象，可以使用脚本通过OnControllerColliderHit()函数将力施加到它碰撞的任何对象。 On the other hand, if you want your player character to be affected by physics then you might be better off using a Rigidbody instead of the Character Controller.另一方面，如果你想让你的玩家角色受到物理影响，那么你可能最好使用Rigidbody而不是Character Controller。 Fine-tuning your characterYou can modify the Height and Radius to fit your Character’s mesh. It is recommended to always use around 2 meters for a human-like character. You can also modify the Center of the capsule in case your pivot point is not at the exact center of the Character.您可以修改高度和半径以适合角色的网格。 建议总是使用大约2米的人类角色。如果您的枢轴点不在角色的正中心，您也可以修改胶囊的中心。 Step Offset can affect this too, make sure that this value is between 0.1 and 0.4 for a 2 meter sized human.Step Offset也会对此产生影响，对于2米大小的人，请确保此值介于0.1和0.4之间。 Slope Limit should not be too small. Often using a value of 90 degrees works best. The Character Controller will not be able to climb up walls due to the capsule shape.坡度限制不应太小。通常使用90度的值最好。由于胶囊形状，角色控制器将无法爬上墙壁。 Don’t get stuckcritical 关键的penetrate 穿透 The Skin Width is one of the most critical properties to get right when tuning your Character Controller.Skin Width是调整Character Controller时最关键的属性之一。 If your character gets stuck it is most likely because your Skin Width is too small. The Skin Width will let objects slightly penetrate the Controller but it removes jitter and prevents it from getting stuck. 皮肤宽度会让物体稍微穿透控制器，但它会消除抖动并防止卡住。 It’s good practice to keep your Skin Width at least greater than 0.01 and more than 10% of the Radius.保持皮肤宽度至少大于0.01且大于半径的10％是一种很好的做法。 We recommend keeping Min Move Distance at 0. See the Character Controller script reference here You can download an example project showing pre-setup animated and moving character controllers from the Resources area on our website. Hints 提示Try adjusting your Skin Width if you find your character getting stuck frequently. The Character Controller can affect objects using physics if you write your own scripts.如果编写自己的脚本，Character Controller可以使用物理影响对象。 The Character Controller can not be affected by objects through physics.角色控制器不会受到物理对象的影响。 Note that changing Character Controller properties in the inspector will recreate the controller in the scene, so any existing Trigger contacts will get lost, and you will not get any OnTriggerEntered messages until the controller is moved again.请注意，在inspecto视图中更改“Character Controller”的属性将在场景中重新创建控制器，因此任何现有的触发器联系都将丢失，并且在再次移动控制器之前，您不会收到任何OnTriggerEntered消息。 下面是脚本CharacterController&lt;-Collider&lt;-Component&lt;-Object 继承自Collider，其实就一个碰撞器。 DescriptionA CharacterController allows you to easily do movement constrained by collisions without having to deal with a rigidbody.CharacterController允许您轻松地进行受碰撞约束的运动，而无需处理刚体 A CharacterController is not affected by forces and will only move when you call the Move function. It will then carry out the movement but be constrained by collisions. Properties center The center of the character’s capsule relative to the transform’s position. collisionFlags 在最后一次CharacterController.Move调用期间，胶囊的哪个部分与环境相撞。 detectCollisions Determines whether other rigidbodies or character controllers collide with this character controller (by default this is always enabled). enableOverlapRecovery Enables or disables overlap recovery. Enables or disables overlap recovery. Used to depenetrate character controllers from static objects when an overlap is detected. height The height of the character’s capsule. isGrounded Was the CharacterController touching the ground during the last move? minMoveDistance Gets or sets the minimum move distance of the character controller. radius The radius of the character’s capsule. skinWidth The character’s collision skin width. slopeLimit The character controllers slope limit in degrees. stepOffset The character controllers step offset in meters. velocity The current relative velocity of the Character (see notes).]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Skybox]]></title>
    <url>%2F2019%2F03%2F24%2FSkybox%2F</url>
    <content type="text"><![CDATA[Skyboxes are a wrapper around your entire scene that shows what the world looks like beyond your geometry. Properties Property Function Tint Color The tint color Exposure Adjusts the brightness of the skybox. Rotation Changes the rotation of the skybox around the positive y axis. Front,etc The textures used for each face of the cube used to store the skybox. Note that it is important to get these textures into the correct slot. DetailsSkyboxes are rendered around the whole scene in order to give the impression of complex scenery at the horizon.Skyboxes围绕整个场景渲染，以给人以地平线上复杂风景的印象。 Internally skyboxes are rendered after all opaque objects;在所有不透明对象之后渲染内部天空盒 and the meshused to render them is either a box with six textures, or a tessellated（棋盘格） sphere. To implement a Skybox create a skybox material. Then add it to the scene by using the Window-&gt; Rendering-&gt;Lighting Settings menu item and specifying your skybox material as the Skybox on the Scene tab. Adding the Skybox Componentto a Camera is useful if you want to override the default Skybox. E.g. You might have a split screen game using two Cameras, and want the Second camera to use a different Skybox. To add a Skybox Component to a Camera, click to highlight the Camera and go to Component-&gt;Rendering-&gt;Skybox. Hints（提示）If you have a Skybox assigned to a Camera, make sure to set the Camera’s Clear mode to Skybox.It’s a good idea to match your Fog color to the color of the skybox. Fog color can be set in the Lighting window.]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为3D游戏添加敌人和子弹]]></title>
    <url>%2F2019%2F03%2F24%2F%E4%B8%BA3D%E6%B8%B8%E6%88%8F%E6%B7%BB%E5%8A%A0%E6%95%8C%E4%BA%BA%E5%92%8C%E5%AD%90%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[本章涵盖 讨论瞄准和开火，同时适用于玩家和敌人 碰撞检测和反馈 让敌人四处走动 在场景中生成对象 我们将设计第一人称射击游戏。如果现在考虑一下我们需要什么，则可以归结为需要射击的能力和一些可以射击的东西。 首先我们将编写代码，使得玩家能在场景中发射对象。接着开始构建敌人来填充场景，包括漫无目的徘徊的敌人和对受击做出反应的代码。 最后将让敌人回击，向玩家发射火球。 创建用于射击的徘徊目标让我们有一个好的理由来探索计算机控制的角色的代码和使用技术来发送消息并生成对象。步骤：(1)编写代码允许玩家向场景发射。(2)创建能对受击进行反应的静态对象。(3)让目标四处走动。(4)自动产生四处走动的目标。(5)让目标敌人向玩家发射火球。 通过射线射击3D演示中第一个要介绍的新特性是射击。四处看看并移动确实是第一人称射击中的重要特性，但仅当玩家能影响仿真并应用他们的技能时它才是游戏。3D游戏中的射击可以通过很多不同的方法实现，但最重要的方法是射线发射。 什么是射线发射顾名思义，射线发射就是你发射一个射线到场景中。定义：射线是虚拟的或者说场景中看不见的线，它从一些原点开始并往指定方向延伸出去。当创建一条射线，并判断它和什么对象相交，这就是射线发射； 图3-1阐述了这个概念。 考虑一下从枪发射子弹的情景：子弹从枪口开始并直线向前飞行，直到它撞到一些东西。射线类似子弹的路径，射线发射则模拟发射子弹并看它碰撞到何处。 射线是虚拟的线，射线发射是找到线和哪里相交了。 射线发射背后的数学通常很复杂。不只是线和3D平面相交的计算棘手，你还需要对场景中所有网格对象的所有多边形进行计算（网格对象是由一些连接的线和形状构成的3D可视化结构）。幸运的是，Unity处理了射线发射背后复杂的数学，但你依然需要在高级功能关心发射从哪里开始和为什么发射。 这个项目中，后者（为什么发射）的答案是模拟子弹射向场景。对于第一人称射击，射线通常开始于摄像机位置并沿着摄像机视图中心往外延伸。换句话说，,你正在检查摄像机正前方的对象：Unity提供的命令可以使得这个任务变得简单。下面介绍这些命令。 使用命令ScreenPointToRay来发射你将通过投射一个源于摄像机并通过摄像机视野中心往前方延伸的射线来实现射击。通过摄像机视野中心投射一个射线是被称为鼠标拾取（mouse picking）行为的一个特例。 定义：鼠标拾取是在3D场景中挑选出鼠标光标下对象的行为。 Unity提供了ScreenPointToRay()方法来执行这个行为。图3-2阐述了该方法所做的事情。该方法创建一个从摄像机开始的射线并向给定屏幕坐标进行发射。通常，坐标是用于鼠标拾取的鼠标位置，但对于第一人称射击，则使用屏幕中心。一旦有了射线，它就能被传入Physics.Raycast()方法中，从而执行该射线的射线发射。 摄像机是射线的原点，类似之前的枪。 屏幕（也就是3D场景的摄像机视口） 射线从摄像机投射并穿过屏幕上的这个点 图3-2 ScreenPointToRay()从摄像机投射射线，穿过给定的屏幕坐标 创建新的C#脚本，把脚本附加到摄像机上（不是玩家对象），然后在其中编写代码清单3.1中的代码。 使用ScreenPointToRay()在摄像机所在位置创建射线Racast给引用的变量填充信息。 首先，摄像机组件在Start()中被获取。接着剩下的代码被放到Update()中，因为它需要重复检查鼠标，而不只是检查一次。Input.GetMouseButtonDown()方法是返回true还是false，这取决于鼠标是否被单击了，因此把Input.GetMouseButtonDown()放到一个条件中，这意味着当鼠标被单击时才会运行其中的代码。由于当玩家单击鼠标时你想要射击，因此该条件检查了鼠标按钮。 向量被创建用于定义射线的屏幕坐标（记住向量把相关数字保存在一起），摄像机的pixelWidth和pixelHeight值告诉你屏幕的大小，因此将这两个值除以2可以获得屏幕的中心。尽管屏幕坐标是二维的，只有水平和垂直分量而没有深度，但我们依然要创建三维向量Vector3，因为ScreenPointToRay()需要Vector3数据类型（推测原因为计算射线的算法基于3D向量），ScreenPointToRay()使用传入的坐标来调用，产生一个Ray对象（代码对象，而不是GameObject：有时候会混淆这两者）。 射线接着被传入Raycast()方法，但它不是唯一传入的对象，还传入了RaycastHit数据结构。RaycastHit是关于射线交叉信息的包装，包括在哪里交叉和与哪个对象发生交叉。 C#语法out确保一个数据结构在命令内被操作时和它在命令外是同一个对象，这和那些在不同函数作用域中被复制的对象相反。 最后代码调用Phyics.Raycast()方法。这个方法使用给出的射线进行交叉检测，把交叉信息填充到data中，并且在碰撞到任何事物时返回true。因为返回的是布尔值，所以这个方法能放到一个条件检查中，就像你前面使用Input.GetMouseButtonDown()时那样。 现在代码发出一个控制台消息来表明交叉何时发生。控制台消息显示射线击中点的3D坐标。但这很难形象地表示射线具体击中了何处，同样，现在也很难知道屏幕的中心（即射线穿过的地方）在何处。下面添加一些可视化指示器来处理这两个问题。 为准心和击中点添加可视化提示-步是添加两种类型的可视化指示器:在屏幕中心的准心和场景中射线碰撞的位置标记。对于第一人称射击,后者通常是弹孔,但现在你只要放一个空球体在该点即可(并使用一个协程在1秒后移除球体)。图3-3展示了结果。定义：协程(coroutines)是Unity特有的处理任务的方式,这些任务随着时间推移逐步执行这种方式与大多数函数让程序等待直到它们完成相反。 首先,让我们添加指示器来标记射线碰撞到何处。代码清单3.2展示了制作这个附加功能之后的代码。在场景中四处开枪,将看到很有趣的球体指示器!球体指示击中了墙的哪个位置 屏幕中心的目标点 图3-3 在为准心和击中点添加可视化指示器之后反复射击代码清单3.2添加球体指示器的RayShooter脚本]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5实战-使用C#和Unity开发多平台游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity2D游戏开发]]></title>
    <url>%2F2019%2F03%2F24%2FUnity2D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Unity 2D功能主要包括2D游戏对象Sprite、2D游戏换帧动画图片的制作工具以及2D游戏物理引擎。 1.2D游戏对象SpriteUnity为2D游戏开发提供了专门的2D游戏对象Sprite。Sprite对象上有一个Sprite Renderer组件用于Sprite对象的渲染，该组件用一张需有Alpha通道的图片渲染到平面上。此外，Sprite Renderer组件上专门提供了一个设置2D游戏遮挡层的参数。 2.2D游戏换帧动画图片的制作工具Unity专门提供了一个制作2D游戏换帧动画图片的工具–Sprite Editor，该工具可以将带有动画每帧图片的一张整图片分割成每帧一张图片，通过该工具就可以将包含Sprite动画每帧图片的整张图片制作成2D换帧动画。 3.2D游戏物理引擎Unity为2D游戏开发集成了Box2D物理引擎并提供了一系列的2D物理组件，通过这些组作可以非常简单地在2D游戏中实现物理特性。这些组件可以添加到Sprite对象上，使Sprite对象具有某种物理特性（如刚体等）。 Unity 2D游戏开发工作流程 (1)首先需要创建一个2D项目。打开2D项目场景中的摄像机（默认使用平行投影）。Scene界面默认选中2D选项，该界面显示了一张平面网格作为显示在屏幕上的显示范围，如下图所示。 (2)创建Unity 2D游戏开发的核心对象Sprite。创建一个Sprite对象的具体步骤为“GameObject-&gt;2D Object-&gt;Sprite”，如下图所示。这时场景的平面中就会出现一个Sprite对象，它可以和3D物体一样可以进行平移、旋转和缩放，只是对Z轴的操作无效。 (3)为Sprite对象指定贴图。首先需要在项目中导入一张带有Alpha通道的贴图，设置贴图的Texture Type为Sprite，如下图所示。将Sprite对象的Sprite Renderer组件的Sprite参数设置为该贴图，这时场景中的Sprite对象就会出现这张贴图。 (4)通过不断改变Sprite Renderer组件的Sprite参数实现动画的换帧效果，通过脚本控制Sprite对象就可以开发出2D游戏。 Unity 2D核心功能对象-SpriteSprite对象的创建和基本用法1.Sprite对象的创建Sprite对象的创建方法有两种。一种是通过依次单击“GameObject-&gt;2D Object-&gt;Sprite”来创建一个空的Sprite对象，这种方法创建的Sprite对象包含一个Sprite Renderer组件（用于在场景中渲染这个Sprite对象），但是这个Sprite Renderer组件的Sprite参数是空的。 另一种创建Sprite对象的方法是在项目中导入一张带有Alpha通道的贴图，设置贴图的Texture Type为“Sprite”，然后将这种贴图拖曳到场景中，这时场景中就会出现带有这种贴图的Sprite对象。通过这种方法创建的Sprite对象的Sprite Renderer组件的Sprite参数就是这种贴图。 2.Sprite对象的基本用法 创建出来的Sprite对象和3D对象一样可以进行平移、旋转和缩放等基本变换，只是因为Sprite对象是2D对象所以对Z轴的基本变换无效。Sprite对象通过Sprite Renderer组件绘制在屏幕上，而绘制的是Sprite参数设置的带有Alpha通道的贴图。 Unity专门提供了Sorting Layer用于设置Sprite对象之间的遮挡关系。通过在Tag&amp;Layers界面的Sorting Layer中添加层，并且通过拖曳调整层遮挡的前后关系，然后设置Sprite Renderer组件的Sorting Layer参数，将Sprite对象放在某个层中。 换帧动画的制作1.换帧图片的制作换帧动画制作之前首先需要制作换帧动面所需的图片。使用图片制作软件制作出包含每帧换帧贴图的整张图片，然后将图片导入到项目中，设置图片的Texture Type为“Sprite”，设置Sprite Mode为“Multiple”，如下图所示，表明该图片包含多帧换帧贴图。 换帧图片中的每帧贴图通过Sprite Editor工具分离出来。点击Sprite Editor打开Sprite Editor工具，如下图所示，Unity默认通过图片Alpha通道的值自动分割贴图，但是系统默认切割的可能不符合实际的要求，因此可以通过手动调整每个分离框的大小和位置调节分割的贴图。 2.换帧动画的制作Unity 2D中制作换帧动画的方法有多种，但原理基本一样，都是通过定时改变Sprite Renderer组件的Sprite贴图来实现换帧动画的。常用的一种方法是通过脚本定时改变Sprite Renderer组件的Sprile参数来实现。 Unity专门提供了一个制作动画的工具可以制作换帧动画。将制作换帧需要的贴图同时选中，一起指曳到场景中就会弹出保存该换帧动画的对话板，保存完成后就会在场景中出现一个包含拖曳到场景中的贴图的换帧动画的精灵。 选中该精灵，依次单击“Window-&gt;Animation”就会弹出修改该动画的Animation工具，如下图所示。通过Animation工具可以修改换帧动画的每帧贴图和换帧动画的播放速度，如果有需要还可以添加帧和修改帧的顺序。 制作换帧动画的具体步骤(1)新建一个2D项目，创建一个场景，命名为“text”。(2)创建背景图片精灵。将Assesisprite件夹中的background图片文件导入到项目中,设置background图片的Texture Type为”Sprite”,设置Sprite Mode为”Single”.其他设置如图14-10所示。 (3)将backgroundI图片拖变到background精尺对象的Sprite Renderer组件的Sprite参数上.单击Sprite Renderer姐件的Sorting Layer选项,单击”Add Sorting Layer..最加层,如图1411所示。 (4)显示出TapsdLayers界面后,在Sorting Layers中点击“4”添加两个层,上面一个层命名为”beiingn”作为背景层,下面一个层命名为”wui”作为物体对象层,如图14-12所示。层位置越往上越深,下面的层遠挡住上面的层.]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2D游戏基础]]></title>
    <url>%2F2019%2F03%2F24%2F2D%E6%B8%B8%E6%88%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.Generate Mip Maps是什么意思？ 本章涵盖：1.正交摄像机2.精灵 一般来说，3D游戏以透视摄像机作为观察者，以3D模型作为被观察物；2D游戏以正交摄像机作为观察者，以面片模型作为被观察物，而这种2D游戏专用的面片模型是精灵。 正交摄像机新建工程后，设置默认摄像机Projection参数为Orthographic，如下图所示，摄像机所能看到的是一个立方体。立方体的大小由图1中的Size大小决定。 精灵在2D游戏中，被观察物是精灵。屏幕上显示的2D图片都叫作精灵，例如游戏里的角色（如主角和敌人）、场景装饰（如花草）等散布在场景中的道具都是精灵。 精灵实现精灵实现分为3步：编辑器设置、图片导入和精灵显示。 ** 编辑器设置 ** 首先在编辑器设置中将开发模式设置为2D，点击导航菜单栏-&gt;Edit-&gt;Projet Settings-&gt;Editor，打开Editor编辑器设置。如下图所示，将Default Behavior Mode下的Mode参数设置为2D，设置后向Unity工程导入图片资源，将默认为Sprite类型。 ** 图片导入 ** 任意拖入一张图片到Project窗口中完成导入。选中导入的图片查看Inspector视图下的设置信息。Texture Type（贴图类型）已经是Sprite（2D and UI）。 ** 精灵显示 ** 将图片拖入Hicrarchy视图内，即完成了精灵的显示，可以看到生动的精灵已经在我们的Scene窗体内了。 调整精灵尺寸点击Scene窗内顶部菜单栏2D按钮，可以看到Scene场景的视角已经锁定为正交模式（如下图所示）。 在下图中，有4个圆点围绕在精灵的4个顶角上。拖动任意一个圆点，精灵都会随着鼠标的移动变大或缩小。同时观察Inspector窗口中Transform组件的Position和Scale，它们也跟随着变化，可以很方便地调节精灵的大小。当点击键盘的Shift键拖动时，精灵呈现长宽比规则缩放，再点击Alt键，就会中心等比例缩放。当鼠标靠近圆点鼠标时，会出现旋转提示，这时就可以旋转精灵了。使用Shift键旋转会出现固定的角度旋转。 在实现了精灵的显示后，下面来详细说明精灵实现过程中的各个功能参数。 精灵渲染器精灵渲染器（Sprite Renderer）是添加在游戏对象上用以渲染精灵的组件，将图片渲染在场景世界里。当我们将图片拖入到Hierarchy视图，其实就是Unity为我们创建了一个游戏对象，并添加了Sprite Renderer组件，指定Sprite参数为拖曳的图片。 如果游戏中需要显示隐藏精灵，可以设置Sprite Renderer的enable参数为true或者false，下表是Sprite Renderer的参数说明。 参数 说明 Sprite 选择其他的精灵 Color 设置精灵颜色 Material 精灵的默认材质 Sorting Layer 所属层 Order in Layer 渲染顺序 在Scene视图中，点击左上角的Shaded按钮，选择Wireframe线框模式。观察图19-5中的精灵可以看到精灵实际上就是一个面片，如下图所示。 图片导入设置下面就来看看图片导入时的各个参数，在Project视图中选中之前的图片，Inspector视图中的导入设置如下图所示。 Sprite Mode：有两种模式：Single和Multiple，分别用来处理一张图承载单个美术元素和多个美术元素的资源。 Packing Tag：标示Sprite Packer的标示字符。 Pixels Per Unit：指多少像素对应一个Unity单位。2D游戏所使用的图片以像素为单位，Unity的单位是Unit，这个参数就是设定图片像素和Unity单位的对应关系。例如在美术设计时，规定人物的高度是32像素，其他图片资源按照这个比例设计。资源导入Unity后设置Pixels Per Unit为32（默认是100），那么这个人物的高度等于一个Unity单位。创建一个立方体，它的长宽高默认为1，将其与人物对比，高度一致，如下图所示。像素比例大小以及摄像机的Size设置是2D游戏开发初期非常重要的规划。 Sprite Editor：精灵编辑器按钮。 Generate Mip Maps：是根据图片远离透视摄像机的程序呈现不同的渲染效果，勾选后图片会创建多个层次大小的图片，如图1所示。2D游戏开发不会出现这种远近差别。如果不是特殊情况，建议不要勾选。读者可以通过开关此参数在下方的预览图中对比图片。另外，需要注意的是，图片需要POT（Power Of Two）2的幂次方大小，才能支持这个技术。 Filter Mode：过滤模式和Texture2D一样，点模糊、线性模糊和三线性模糊。 精灵编辑在图片导入的过程中，有时候还需要对图片承载的精灵进行处理，例如一张图片中包含多个精灵，或者将多个道具放在一张图片里，或者主角挥刀的动作，按照动作的时间点被拆解成多张图片。这种播放动画的方式叫帧动画，每个时间点为一帧，通常一组帧动画会全部放入一张图片中，如19-10所示。这时我们就需要在精灵编辑器中设置，并将图片切割成一个个精灵。 选中导入图片，在Inspector视图中点击Sprite Editor按钮，打开精灵编辑界面。点击左上方的Slice按钮，弹出裁剪方式面板，如图19-11所示。 设置Type参数为Grid，Pixel Size参数X和Y均为32，Pivot（锚点）参数为Center，点击Slice按钮进行切割，点击右上角Apply按钮生成精灵组。图片下切割好的精灵在Project视图中，如图所示。 任意选择其中一个拖入Hierarchy面板中，就可以创建精灵对象了。选中所有精灵，拖入Hierarchy窗体中生成精灵动画。选中生成动画文件，点击菜单栏-&gt;Window-&gt;Animation，打开动画编辑工具，如图19.13所示。 点击播放按钮（黑色三角形）就可以播放精灵动画了。 精灵图集我们也可以将多个精灵打入一张图集里，这样做可以提高渲染效率（参照关于DrawCall合并的内容）。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章 制作子弹发射效果]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%AC%AC5%E7%AB%A0%20%E5%88%B6%E4%BD%9C%E5%AD%90%E5%BC%B9%E5%8F%91%E5%B0%84%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Physics Manager是干嘛的？ 脚本和其他组件挂载在哪里？ 如何让子弹相对于自身坐标系移动？ 碰撞感知需要满足什么条件？ 碰撞事件是哪些？ Tag在碰撞中起到什么作用？如何使用？ Is Trigger属性是干嘛用的？Trigger应用场景是什么？ coll.gameObject的含义是什么？ 有几种方法在场景中标示没有网格的游戏对象？ 如何检测并处理发射事件？ 如何制作子弹尾迹？ 粒子系统如何使用？ 如何修改桶模型的比例？ 制造爆炸效果的脚本放在哪，用什么回调函数？ 如何实现被击中3次时发生爆炸？ 如何表现爆炸效果？ 如何知道子弹射中了桶？ 如何让周围的物品被炸飞？使用什么组件和函数？ 如何给多个桶随机分配纹理？使用哪个组件分配纹理？ 制作发射子弹的音效的步骤？ 制造枪声需要用到什么组件？ 脚本挂载到哪个对象上？关键函数是什么？ 如何解决枪声还未播放完整便断开的现象？ 制造枪口火焰效果使用粒子效果还是图片？如何使用？ 如何实现一开枪就闪光？ 本章涵盖： 准备子弹模型 Rigidbody组件 设置物理引擎属性：Physics Manager Collider组件 碰撞感知条件 碰撞事件 Tag应用 子弹发射逻辑 游戏中，枪械类发射子弹的方式大体分为Projectile和Ray Casting两种。 Projectile方式： Projectile方式模拟子弹的物理发射，子弹直接飞出以打击敌方。这种方式下，子弹必然会出现在视线范围内。但其缺点在于，短时间内生成多个子弹会导致游戏负荷过高，从而降低运行速度。为了弥补这个缺点，最好使用低多边形（Low Poly）模型或平面网格模型的子弹，然后为其附上纹理。另外，尽量避免使用动态生成，最好先引入对象池设计方法。即先生成子弹池，之后再使用这些子弹以轮番发射。这对提高速度是很有利的。 Ray Casting方式： Ray Casting方式常用于在FPS中制作狙击类枪械的子弹发射效果。这种方式并不模拟实际物理环境中子弹的发射，而是像镭射光束一样，模拟发射肉眼看不见的光线，以探测敌人或物体。也就是说，使用该方式制作开枪效果时，首先需要制作枪口火焰；与此同时，远距离的敌人也需要有被击中的动画效果。Ray Casting方式不仅可以用于制作子弹发射，还可以用于制作探索迷宫的机器人的感知功能或追击功能。 本章将首先用Projectile方式在游戏中发射子弹，完成击中敌对角色的效果后，将其更改为RayCasting方式。 准备子弹模型首先导入Bullet.unitypackage资源包，Project视图中生成Bullet文件夹，将此文件夹拖曳到Project视图的Models文件夹。 将Bullet文件夹中的lowpolybullet模型添加到Scene视图，可以看到，lowpolybullet模型以X轴为基准，旋转-90°，如下图所示，此即为子弹站立的状态。3D模型制作工具（3D Max、Maya、Blender、C4D等）的Z轴设置为Up方向，所以用于Unity时，轴会旋转90°。 此问题的最佳解决方案是，使用3D模型制作工具时，将Up方向轴设为Y轴，并以FBX文件格式导出，这样可与Unity坐标系对齐。另一种方法是，先创建空游戏对象，并将相应模型拖曳到此对象下，使其成为后者的子对象。将该模型旋转90°，使之与Unity基本轴对齐。 通过第二种方法使用lowpolybullet模型。首先在Hierarchy视图中新建空游戏对象，重命名为Bullet，并将lowpolybullet模型拖曳到Bullet游戏对象下。请时刻牢记，模型成为某个游戏对象下的子对象后，必须将其Transform的Position属性设置为(0, 0, 0)。 最后，选定Bullet游戏对象下的lowpolybullet模型，设置其Transform的Rotation属性中的X值为90，使其旋转90°。 开发人员经常产生的一个失误是，发射效果制作完成后，子弹会向下发射。这是因为，将子弹3D模型拖曳到Bullet下方后，调整角度时错选了父对象Bullet游戏对象，并将其旋转了90°。正确的做法是，选定子对象lowpolybullet模型，将其旋转90°。 Rigidbody组件在Unity中移动游戏对象时，一般使用Transform的Position属性，或者添加Rigidbody组件，使用其物理模拟装置。将Rigidbody组件添加到游戏对象后，相应游戏对象便会开始受物理引擎的影响。 选择Bullet游戏对象，然后选定菜单Component-&gt;Physics-&gt;Rigidbody，添加Rigidbody组件。 运行游戏即可看到子弹受重力影响面掉落至地面，这是因为Unity默认勾选了Rigidbody组件的Use Gravity属性。为了使子弹不再受到重力影响而能够飞出，需要关闭Rigidbody组件的Use Gravity选项。 Rigidbody组件是模拟碰撞等物理效果的重要组件，具备以下属性，如下表所示。 Rigidbody组件的属性 属性 含义 Mass 相对质量，其单位不是现实中的1kg、1g等。假设A物体的质量为1，B物体的质量为10，那么可以解释为“B物体的质量是A物体的10倍” Drag 用于移动的摩擦系数 Angular Drag 用于旋转的摩擦系数 Use Gravity 是否模拟重力效果 Is Kinematic 如果勾选该属性，Unity将不进行物理模拟使模型移动，而是通过Transform组件移动。也就是说，模型此时不受物理引擎的影响 Interpolate 使用物理模拟时，模型如果发生停止、暂停等现象，可以使用该属性使画面更为流畅。Interpolate：使当前帧适应前一帧的位置，使模型移动更自然；Extrapolate：推测下一帧的位置变化，使模型移动更自然 Collision Detection 游戏中模型运动过快时，可能导致物理引擎来不及检测到碰撞。因此，该属性帮助引擎进行更细致的检测碰撞。检测顺序为：Discrete-&gt;Continuous-&gt;Continuous Dynamic Freeze Position 阻止模型X、Y、Z轴中某一轴向上移动 Freeze Rotation 阻止模型X、Y、Z轴中以某一轴为基准旋转 将制作子弹所需的所有组件以及脚本添加到Bullet游戏对象。需要注意，lowpolybullet模型无需添加任何组件，因为它只是单纯的视觉模型。 下面编写脚本程序，并将其添加到Bullet游戏对象。新建C#脚本，重命名为BulletCtrl，具体程序如脚本所示。 123456789101112131415using UnityEngine;using System.Collections;class BulletCtrl : MonoBehaviour&#123; // 子弹破坏力 public int damage = 20; // 子弹发射速度 public float speed = 1000.0f; void Start() &#123; GetComponent&lt;Rigidbody&gt;().AddForce(Vector3.forward * speed); &#125;&#125; 编写完成后，向Bullet游戏对象添加此脚本。 BulletCtrl脚本声明了要保存子弹破坏力和发射速度的public变量，并使用了运行游戏时可为Rigidbody组件添加初始推动力的函数AddForce。脚本运行时最先调用Start函数，所以运行后即可看到，子弹生成的同时便向Z轴方向飞去。 Rigidbody组件有两个函数提供Force： void AddForce(Vector3 force); void AddRelativeForce(Vector3 force); BulletCtrl脚本中使用的AddForce函数的参数是Vector3类型。本示例中，向AddForce函数传入Vector3.forward * speed作为参数，则Unity将以全局坐标为基准给子弹加力。因此，即使Bullet游戏对象的Y轴旋转，子弹也会向全局坐标的Z轴方向飞去。如果想要以游戏对象的局部坐标为基准对子弹施加力，则需要使用transform.forward * speed，或者使用AddRelativeForce函数。AddRelativeForce以局部坐标为基准向Rigidbody施加力，其用法如下所示。 1GetComponent&lt;Rigidbody&gt;().AddRelativeForce(Vector3.forward * speed); 设置物理引擎属性：Physics Manager在菜单中选择Edit-&gt;Project Settings-&gt;Physics后，调出Physics Manager，可在此査看Unity中搭载的物理引擎的设置。下面介绍其几个重要属性。 Gravity如果勾选了Rigidbody的Use Gravity选项，物理引擎即会按照此处Gravity设置的值模拟重力。其中Y轴方向的默认值为-9.81；也就是说，物理引擎模拟现实世界的重力加速度参数为9.8m/s^2。 Default Material设置两个物体碰撞时的反作用属性。如果不设置为None，也可在发生碰撞的各Rigidbody属性中分别进行设置。 Sleep Velocity、Sleep Angular Velocity模型的移动速度或旋转加速度下降到一定数值以下后，物理引擎将不再控制该模型，这可以降低CPU运算负荷，通常称为Rigidbody休眠（Sleeping）。 Unity会自动处理Rigidbody的休眠操作，处于休眠状态的Rigidbody可以在以下情况重新唤醒：1)与（包含Collider的）其他Rigidbody游戏对象发生碰撞；2)更改Rigidbody属性；3)用AddForce函数对该Rigidbody加力时。 Raycasts Hit Triggers如果不勾选该选项，Unity将忽略与Raycast的碰撞。 Layer Collision Matrix设置是否捕捉各Unity内建层或自定义层发生的碰撞，即可以使Rigidbody仅在特定层发生碰撞时才触发某个事件。 Collider组件游戏中，感知碰撞是非常重要的要素之一，Unity为感知碰撞提供了Collider组件。可以将Collider组件理解为能够感知碰撞的一种传感器，具体分为以下几种形态。 Box Collider实际开发中最常用的Collider，可以在Inspector视图中修改Center和Size属性以调节形态。还可以点击Edit Collider按钮，在Scene视图中直接调整大小。 Sphere Collider处理速度最快的Collider，可通过修改Radius属性调整其半径。实际开发中，除需要精密感知碰撞的情况外，一般都使用Sphere Collider。 Capsule Collider主要用于玩家角色或敌对角色等人形模型碰撞体，可通过调整Height属性调整Capsule Collider的高度，Direction属性决定了Capsule Collider的放置形态，默认将Y轴作为竖边方向。 Mesh Collider这种Collider的CPU负荷最高，适用于非常精细的碰撞感知。 Unity默认设置无法感知Mesh Collider之间的碰撞，这是为了防止游戏运行时负荷过高导致运行速度低下。如果需要感知精细碰撞，则需要勾选Mesh Collider属性中的Convex（凸）选项。 制作像迷宫一样复杂的游戏场景时，如果为了让玩家角色与场景更好地融合而放置多个Box Collider，开发工作量会很大，有时也会遗漏。此时可以使用Mesh Collider，先制作像游戏场景一样的低多边形网格，使之与场景重叠。 Wheel ColliderWheel Collider是专用于车辆轮胎的Collider。可以精细设置轮胎的悬架高度（Suspension Distance）、与地面的摩擦系数等。Unity 5增加了很多Wheel Collider设置，使其更加接近物理现实。 Terrain ColliderTerrain Collider可用于Unity内建的Terrain Engine生成的地形。如果地形比较复杂，Terrain Collider的负荷也会变高，此时可以使用低多边形网格构造Mesh Collider。 碰撞感知条件子弹发射并飞行一定距离后，便会碰到墙壁或敌对角色。此时如果想感知碰撞，需要满足以下两个条件： 发生碰撞的两个游戏对象都要添加Collider组件； 两个游戏对象中移动的一方必须有Rigidbody组件。 为了符合以上碰撞条件，需要首先在Bullet游戏对象中添加Sphere Collider组件。将Radius属性修改为0.2f。此时Sphere Collider的大小与子弹的大小一致。 前面制作的Wall使用了Unity提供的原始模型（Primitive Model）Cube，在Unity中，原始模型会默认添加符合各自形状的Collider。选择一个Wall后，可以在Inspector视图中看到Box Collider。 我们已经为Bullet添加了Rigidbody组件、Sphere Collider组件，Wall中也有了BoxCollider组件，这样就满足了感知两个游戏对象碰撞的必备条件。 碰撞事件所有Collider组件均有Is Trigger属性，勾选此属性可以使引擎感知检测到碰撞，但游戏对象不会实际模拟物理碰撞。也就是说，不会发生物体间因碰撞而停止或弹开的物理现象。 因此，如果勾选Bullet对象的Sphere Collider的Is Trigger属性，则会造成子弹贯穿被射物体的效果。此时，OnTrigger函数处理触发的碰撞事件。反之，如果未勾选Is Trigger属性，碰撞时会触发OnCollision函数。Unity中，Is Trigger属性默认设置为不勾选。 Trigger Collider在实际游戏开发中主要用作传感器。比如，玩家角色走到一扇可以滑动打开的门前时，Trigger Collider会检测到碰撞事件，于是开启滑门，玩家进入特定区域时，游戏感知到碰撞并立即生成敌对角色。 Tag应用子弹碰撞于墙体时，需要明确是哪个拥有Collider组件的游戏对象飞来而引起碰撞。当然，可以直接查看发生碰撞的游戏对象的名称进行判断，但这并不是好方法。Unity开发中，通常预先给游戏对象指定Tag，发生碰撞时只需识别Tag值并进行适当处理即可。 想要添加Tag，首先要点击菜单的Edit-&gt;Project Setting-&gt;Tags &amp; Layers，或直接点击Inspector视图顶端Tag下按框，然后在弹出菜单中选定选择Add Tag…菜单。 选中Add Tag…菜单后，可以在Inspector视图中设置Tag、Setting Layer、Layer。点击Tags插槽下端的+，添加Tag0，在此输入BULLET。 脚本中通过字符串比较游戏对象的标签值，所以命名时需要注意区分大小写。 重命名后，在Hierarchy视图中选定Bullet游戏对象，并将Inspector视图顶端Tag设置为新增的BULLET。 碰撞发生时，调用OnCollisionEnter事件感知对墙体的碰撞。在Project视图中新建脚本WallCtrl。 12345678910111213141516using UnityEngine;using System.Collections;public class WallCtrl : MonoBehaviour &#123; // 碰撞开始时触发的事件 void OnCollisionEnter(Collisilon coll) &#123; // 比较发生碰撞的游戏对象的Tag值 if (coll.collider.tag == "BULLET") &#123; // 删除发生碰撞的游戏对象 Destroy(coll.gameObject); &#125; &#125;&#125; 将编写的脚本拖曳到Project视图的Wall预设，并查看Hierarchy视图的4个墙体对象是否均自动添加了脚本。 调用OnCollisionEnter函数时，需要传递Collision类型的参数，该类参数包含了发生碰撞的游戏对象的信息、碰撞位置以及碰撞速度等信息。如果不需要这些信息，则可省略该参数。 1234void OnCollisionEnter(Collision coll)&#123;&#125; coll.collider.tag返回碰撞游戏对象的Rigidbody的Tag值，脚本将此值与BULLET字符串进行比较。如果相同，则判断此为子弹Bullet对象发射过来而引发的碰撞。 123456// 比较发生碰撞的游戏对象的Tag值if(coll.collider.tag == "BULLET")&#123; // 删除发生碰撞的游戏对象 Destroy(coll.gameObject); &#125; Destroy方法可以在碰撞到墙体后删除Bullet游戏对象，这是一个通用的、可以从游戏中删除游戏对象和组件的方法。该方法的第一个参数指定要删除的对象，第二个参数指定时间，即调用该方法一段时间后删除目标游戏对象。 static void Destroy(Object obj); static void Destroy(Object obj, float t); 因此，Destroy(coll.gameObject)删除的是发生碰撞的Bullet游戏对象。运行游戏后，可以看到子弹发射后先撞击到墙体，然后消失。 以上就是子弹的制作，请将Hierarchy视图的Bullet游戏对象拖曳到Project视图的Prefabs文件夹，使之成为预设。另外，先暂时不要删除Hierarchy视图的Bullet游戏对象。 注意回调函数的大小写以及文字错误 对OnCollisionEnter之类的事件处理函数（回调函数）名称而言，即使有大小写等文字错误，运行时也不会报错。但这样会导致碰撞发生时无法触发相应事件，也不会执行函数内的逻辑。因此，实际开发调试过程中，如果碰撞时游戏对象的行为和预想的不一致，则要查看首字母是否有大小写之类的文字错误。 coll.gameObject的含义 GameObject是一个类，而gameObject则是GameObject类型的一个实例。同样，前面的脚本中使用的coll.gameObject也是Collider类的一个实例，表示collider.gameObject。因此，（组件）.gameObject表示访问包含相应组件的游戏对象。 子弹发射逻辑下面制作玩家每次左击鼠标时都会发射子弹的逻辑，这个逻辑的开发将按照下列顺序进行： 制作子弹发射的位置（FirePos）; 检测并处理发射事件。 在Hierarchy视图中选定Player游戏对象，并新建空的子游戏对象，将其重命名为FirePos。 FirePos游戏对象将自身位置用作发射子弹的原点，因此，需要将其放置到Player Model的枪口前。Unity中，最简单的FirePos游戏对象放置方法是，将全局坐标轴Gizmos分别设置为Right、Front、Top视图，然后调整FirePos的位置。 Scene视图中，无法通过直接点击以选定FirePos这种有且仅有Transform组件的游戏对象。因此，如果想要选定FirePos游戏对象，需要先在Hierarchy视图中选定FirePos，然后在Inspector视图中修改Transform属性，比较麻烦。 既然无法在Scene视图中直接选定FirePos这种没有网格组件的空游戏对象，那么为了解决这种“看不到的”麻烦，可以在脚本中定义Gizmos以显示FirePos。 新建C#脚本MyGizmo并编写程序，然后将其添加到FirePos游戏对象，如下图所示，看到一个黄色球体。现在即可在Scene视图中用鼠标点击该黄色球体以选定FirePos游戏对象。Gizmos只会在开发游戏时的Unity中显示，实际运行时会消失。 12345678910111213141516using UnityEngine;using System.Collections;public class MyGizmo : MonoBehaviour&#123; public Color _color = Color.yellow; public float _radius = 0.1f; void OnDrawGizmos() &#123; // 设置Gizmos的颜色。 Gizmos.color = _color; // 创建球体Gizmos，函数参数为（Gizmos的位置，半径） Gizmos.DrawSphere(transform.position, _radius); &#125;&#125; 我们前面亲自编写脚本制作了Gizmos，其实，Unity提供了向游戏对象添加Icon和Label的功能。首先，如下图所示选定FirePos，然后在Inspector视图中选定Icon，这样就不需要另外编写脚本即可在Scene视图中查看FirePos，但这样无法调整某个特定FirePos的大小，只能调整所有添加了Icon的游戏对象。 还可以选定Hierarchy视图的玩家，然后在Inspector视图中为其指定Label。这样，Scene视图中相应的游戏对象名就变为指定的标签颜色。 在Scene视图中点击特定游戏对象的标签后，与Hierarchy视图中选定该游戏对象的效果一致。 在创建的同时向前发射的子弹以及生成子弹的坐标已经准备就绪，下面编写脚本，实现玩家每次左击鼠标都可以发射子弹。 也可以将子弹发射逻辑添加到已有的PlayerCtrl脚本，但下面尝试新建脚本以保存这段逻辑。如下脚本所示，新建FireCtrl脚本并将其添加到游戏对象。 123456789101112131415161718192021222324252627282930using UnityEngine;using System.Collections;public class FireCtrl : MonoBehaviour&#123; public GameObject bullet; // 子弹预设 public Transform firePos; // 子弹发射坐标 void Update() &#123; // 鼠标左击时调用Fire函数 if (Input.GetMouseButtonDown(0)) &#123; Fire(); &#125; &#125; void Fire() &#123; // 动态生成子弹的函数 CreateBullet(); &#125; void CreateBullet() &#123; // 动态生成Bullet预设 Instantiate(bullet, firePos.position, firePos.rotation); &#125;&#125; Unity中，处理外部输入的Input类提供了几种鼠标点击相关事件。 事件名称 含义 GetMouseButton(int button) 点击鼠标时触发 GetMouseButtonDown(int button) 按下鼠标时触发 GetMouseButtonUp(int button) 鼠标弹回时触发 Input.GetMouseButtonDown(0)在左击鼠标时触发1次，参数代表鼠标上具体的键（0：左键，1：右键，2：中间键）。 因为Fire函数会另外包含制作子弹发射的音效以及枪口火焰效果的逻辑，所以脚本中单独定义了生成子弹的函数。首先，在Fire函数中仅调用生成Bullet预设的函数。 函数中使用的Instantiate函数制作游戏对象或预设复件，此处传入该方法的参数为Instantiate(子弹预设, 子弹生成位置, 子弹生成角度); Instantiate函数原型如下所示。 1static Object Instantiate(Object original, Vector3 position, Quaternion rotation); 将FireCtrl脚本添加到Player后，Inspector视图会显示Bullet变量以及FirePos变量。如下图所示，分别将Bullet对象和FirePos对象设置到Inspector视图。 1.Bullet变量：设置为Project视图的Prefabs/Bullet Prefab。2.FirePos变量：设置为Hierarchy视图的Player/FirePos。 常见Null Reference错误 游戏运行时会动态生成子弹，所以必须在Inspector视图中设置Bullet预设。如果仅在脚本中使用Instantiate函数动态生成，子弹碰撞到墙体被Destroy后，会产生Null Reference错误。 运行游戏后点击鼠标左键，在Scene场景视图中查看子弹是否如期发射。可以在Hierarchy视图中看到Unity生成的多个以BulletClone()命名的Bullet预设，如下图所示。通过Instantiate函数动态生成的预设复件总以“预设名称(Clone)”的形式命名。 ** 欧拉角、万向节锁、四元数 ** 欧拉角（Euler Angle），以三维空间的绝对坐标为基准，确定被测物体的位置。使用欧拉角标示的旋转方式是，依次以X、Y、Z轴为基准进行旋转，但旋转期间如果X、Y、Z轴中有2个轴叠加，那么被测物体将不以任何轴为基准旋转，而产生被锁现象，该现象称为万向锁（Gimbal Lock）。 为了解决这个问题，数学家们提出了四元数（Quaternion），四元数即为四维复数（four-dimensional complex number），与欧拉角将物体依次以各轴为基准旋转不同，四元数将物体以3个轴叠加同时旋转，从而避免了万向锁现象。 Unity中所有物体的旋转都是通过四元数处理的。 下列示例就是以Y轴为基准旋转了30°的脚本，其中Rotate函数将传入的参数转换为四元数，rotation则是Transform的Quaternion类型的属性。此处的脚本使用了Quaternion.Euler(X, Y, Z)函数，将欧拉角转换为Quaternion类型，并将其设置为rotation属性的值。 12transform.Rotate(0, 30, 0);transform.rotation = Quaternion.Euler(0, 30, 0); 之前生成子弹时使用的Instantiate函数的第三个参数即为Quaternion类型，可以使子弹旋转需要的角度。 本章涵盖： 制作子弹发射轨迹：Trail Renderer 应用粒子系统 制作子弹发射轨迹：Trail RendererRPG游戏中，可以经常看到主人公角色挥剑时和发射子弹时的轨迹效果。这种视觉效果增加了游戏的趣味性，对于打击感的提升也有很大帮助。 实现这种效果的方式有很多，其中最常用的方法是在子弹移动的同时动态生成网格，然后在一定时间后删除网格。Unity提供了可以轻松处理动态生成网格的Trail Renderer组件，使用此组件可以更好地表现发射子弹的轨迹视觉效果。 在Hierarchy视图中选定Bullet预设，点击菜单Component-&gt;Effects-&gt;Trail Renderer添加Trail Renderer组件。添加组件后，拖曳Bullet预设使之向Z轴方向前进，可以看到Unity生成的动态网格。此时，如果将场景视图中的渲染模式更改为Shaded Wireframe，即可同时看到纹理和网格的形态，如下图所示。 动态生成的网格在Scene视图中的颜色如果是粉色，则表示尚未为其设置材质，所以需要先生成Trail Renderer需要的材质，然后为其设置纹理。 把Trail.png文件拖曳到Project视图 Images文件夹，并在Images/Materials/下新建BulletTrail材质。 将新建的BulletTail材质的着色器设置为Particle/Additive，并为该着色器Particle Texture属性设置纹理为Trail.png文件。 将Bullet对象的材质属性的子属性Elements 0设为BulletTrail，场景视图中的粉红色网格就会被该纹理覆盖，也可以直接将BulletTrail材质拖曳到Scene视图中的粉红色网格。 如前所述，Trail Renderer组件具有Time属性，使用其即可动态生成网格，经过一定时间后还会自动去掉该动态网格。请将Time属性值改为0.3，Start Width值为0.2，End Width值为0.01，子弹的拖尾看上去会越往后越尖锐。 Trail Renderer的主要属性 Trail Renderer属性 说明 Time 动态生成的网格的持续时间 Start Width 网格头部宽度 End Width 网格尾部宽度 Colors 材质的纹理颜色，Unity可以处理5个层次的渐变颜色效果 Min Vertex Distance 设置动态生成的网格间隔，数值越低，网格越密集 AutoDestruct Time时间过后，删除使用Trail Renderer的游戏对象 本示例中，Trail Renderer的Min Vertex Distance属性值需要调整。如果物体沿直线运动，则需要设置较大的值以减少动态生成的网格数量；如果物体进行抛物线运动，则需要设置较小的值以使轨道看上去更平滑。 Trail Renderer组件的Time属性值越大，轨迹持续时间越长，子弹后面的“尾巴”也越长。 应用粒子系统下面学习如何实现子弹碰撞墙壁时产生的火花效果。游戏中，火焰、火、烟等效果主要使用粒子系统实现。Unity通过粒子系统生成覆盖纹理的网格，然后使之以一定速度移动，表现上述效果。 但游戏在短时间内使用太多粒子会给引擎带来较高的负荷，因此，实际开发中需要适当使用。然而，为了提高游戏的打击感和视觉效果，使用粒子又是必须的，所以需要考虑如何在不带来太多负荷的情况下展现期望的视觉效果。 首先导入Unity默认提供的粒子资源包，鼠标右击Project视图，选择上下文菜单的Import Package-&gt;Particles，或者选择Unity主菜单的Assets-&gt;Import Package-&gt;Particles进行导入。如下图所示，需要选中并导入粒子系统资源包中的所有文件夹。 导入后，粒子资源包将安装到Project视图的Standard Assets Particles文件夹。 脚本编译优先顺序 导入的粒子资源包中的Standard Assets文件夹是Unity默认提供的资源包文件夹，该文件夹中的脚本将会比其他脚本被优先编译。 Unity中可以自定义脚本编译顺序。选择菜单的Editor-&gt;Project Settings-&gt;Script Execution Order，或者选择脚本并在Inspector视图中点击按钮Execution Order，即可打开MonoManager进行设置。 MonoManager中可以自行指定各脚本编译顺序。 子弹与墙壁碰撞时发生的粒子效果需要在墙体脚本中处理，修改WallCtr脚本。 WallCtrl：添加粒子效果 123456789101112131415161718192021using UnityEngine;using System.Collections;public class WallCtrl : MonoBehaviour&#123; // 表示火花粒子对象的变量 public GameObject sparkEffect; // 碰撞开始时触发的事件 void OnCollisionEnter(collision coll) &#123; // 比较发生碰撞的游戏对象Tag值 if (coll.collider.tag == "BULLET") &#123; // 动态生成火花粒子 Instantiate(sparkEffect, coll.transform.position, Quaternion.identity); // 删除发生碰撞的游戏对象 Destroy(coll.gameObject); &#125; &#125;&#125; Instantiate函数可用于动态生成粒子，参数中的position为子弹碰撞墙体时的位置，第三个参数角度需要设置为Quaternion.identity，用于生成不会旋转的粒子。 12// 动态生成火花粒子Instantiate(sparkEffect, coll.transform.position, Quaternion.identity); 选择Project视图的Wall预设，将WallCtrl脚本中的Spark Effect变量设为Flare预设。 Flare预设默认是无限循环的，在Project视图中选择Flare预设即可查看Inspector视图的粒子系统组件的各个属性。如下图所示，点击Open Editor…可以打开粒子效果编辑窗口。 Flare预设由Flare、Smoke、Spark这3个粒子效果组成，该预设有很多属性，其中Duration属性为0.3，Looping属性默认不勾选，Duration属性决定了粒子效果持续显示的时间，Looping属性则决定了是否循环显示粒子效果。 修改Flare粒子效果的属性并运行游戏，左击鼠标向墙壁发射子弹，可以看到子弹与墙壁碰撞的同时出现了火花四射的效果。 子弹与墙壁碰撞后，粒子效果持续0.3秒并消失，但Hierarchy视图中仍然会留下粒子预设的复件。因此，需要编写脚本使引擎在一定时间后强制删除动态生成的Flare预设。修改WallCtrl脚本的火花生成部分。 WallCtrl：一定时间后删除Flare预设 123456789101112131415161718192021222324using UnityEngine;using System.Collections;public class WallCtrl : MonoBehaviour&#123; // 表示火花粒子对象的变量 public GameObject sparkEffect; // 碰撞开始时触发的事件 void OnCollisionEnter(collision coll) &#123; // 比较发生碰撞的游戏对象Tag值 if (coll.collider.tag == "BULLET") &#123; // 动态生成火花粒子并将其保存到变量 GameObject spark = (GameObject)Instantiate(sparkEffect, coll.transform.position, Quaternion.identity); // 经过ParticleSystem组件的duration时间后删除 Destroy(spark, spark.GetComponent&lt;ParticleSystem&gt;().duration + 0.2f); // 删除碰撞的游戏对象 Destroy(coll.gameObject); &#125; &#125;&#125; Instantiate函数的返回类型为Object，脚本将其转换为GameObject类型。换言之，将动态生成的Flare预设保存到spark变量。脚本将火花粒子的持续时间在ParticleSystem组件的duration属性值基础上再追加了0.2秒，这样可以使火花产生掉落到地面上的效果。 12345// 动态生成火花粒子并将其保存到变量GameObject spark = (GameObject)Instantiate(sparkEffect, coll.transform.position, Quaternion.identity);// 经过ParticleSystem组件的duration时间后删除Destroy(spark, spark.GetComponent&lt;ParticleSystem&gt;().duration + 0.2f); 本章涵盖： 制作爆炸效果并设置爆炸威力 随机使用纹理 制作爆炸效果并设置爆炸威力导入Barrel模型，将其置于场景中，然后发射子弹使其爆炸。 Project视图的Models/Barrel文件夹中有2个Barrel资源，可以通过图标区分3D模型原版和预设。 删除资源包自带的Barrel预设，使用原版3D模型。将原版Barrel模型拖曳到Scene视图，可以看到比玩家角色还大的油桶。将油桶调整到符合主人公角色大小比例的尺寸。 对于从外部导入的3D模型，绝对不要修改Transform的Scale属性，而要在FBX Import Settings的Scale Factor菜单中修改其体积。 选定Project视图中的Barrel 3D模型，Inspector视图中会显示FBX Import Settings，选择第一个选项卡Model，将Scale Factor的值修改为0.4，然后点击底端Apply进行保存。 注意非均匀刻度（non-uniform scale） 实际游戏开发时，如果要调整从外部导入的所有3D模型的体积，则必须通过FBX Import Settings修改其Scale Factor属性值。因为如果直接修改Barrel模型的Transform Scale属性，那么游戏运行时，每帧都要生成符合Scale属性值的副本。显然，这种方式下的CPU运算量会增大，成为游戏运行速度低下的主要原因。 调整油桶大小后，为了实现其被子弹击中时的碰撞处理，需要向Barrel添加Capsule Collider和Rigidbody组件。添加后，请如下表所示修改Capsule Collider的属性。对于Rigidbody组件，只需将其mass属性设置为20。 属性 属性值 Center的Y轴 1.25 Radius 0.8 Height 2.5 Direction Y-Axis 设置酒桶被子弹击中3次时发生爆炸。新建脚本BarrelCtrl，将其添加到Barrel对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using UnityEngine;using System.Collections;public class BarrelCtrl : MonoBehaviour&#123; // 表示爆炸效果的变量 public GameObject expEffect; private Transform tr; // 桶的位置 // 保存被子弹击中次数的变量 private int hitCount = 0; void Start() &#123; tr = GetComponent&lt;Transform&gt;(); &#125; // 碰撞发生时触发的回调函数 void OnCollisionEnter(Collision coll) &#123; if (coll.collider.tag == "BULLET") &#123; // 删除子弹 Destroy(coll.gameObject); // 累加油桶被子弹击中的次数，3次以上则触发爆炸 if (++hitCount &gt;= 3) &#123; ExpBarrel(); &#125; &#125; &#125; // 实现油桶爆炸的函数 void ExpBarrel() &#123; // 生成爆炸效果粒子 Instantiate(expEffect, tr.position, Quaternion.identity); // 以指定原点为中心，获取半径10.0f内的Collider对象 Collider[] colls = Physics.OverlapSphere(tr.position, 10.0f); // 对获取的Collider对象施加爆炸力 foreach (Collider coll in colls) &#123; Rigidbody rbody = coll.GetComponent&lt;Rigidbody&gt;(); if (rbody != null) &#123; rbody.mass = 1.0f; rbody.AddExplosionForce(1000.0f, tr.position, 10.0f, 300.0f) &#125; &#125; // 5秒后删除油桶模型 Destroy(gameObject, 5.0f); &#125;&#125; BarrelCtrl脚本可使油桶被子弹击中3次时爆炸，并产生粒子效果，然后对以该油桶原点为中心，半径10.0f内的物体施加爆炸力。 碰撞发生时触发的OnCollisionEnter函数判断hitCount变量的值是否达到3，若达到则调用ExpBarrel()函数，此函数以爆炸原点为中心，使用Physics.OverlapSphere()函数获取爆炸效力波及半径内的游戏对象。 12// 以指定原点为中心，获取半径10.0f内的Collider对象Collider[] colls = Physics.OverlapSphere(tr.position, 10.0f); 利用Physics.OverlapSphere(原点, 半径)函数获取的游戏对象必须添加Collider组件，该函数的返回值为Collider类型的数组。为了将爆炸力施加到每个物体，脚本使用foreach语句从数组开始循环至结尾，依次对每个物体调用AddExplosionForce函数。 12345678910111213// 以指定原点为中心，获取半径10.0f内的Collider对象Collider[] colls = Physics.OverlapSphere(tr.position, 10.0f);// 对获取的Collider对象施加爆炸力foreach (Collider coll in colls)&#123; Rigidbody rbody = coll.GetComponent&lt;Rigidbody&gt;(); if (rbody != null) &#123; rbody.mass = 1.0f; rbody.AddExplosionForce(1000.0f, tr.position, 10.0f, 300.0f) &#125;&#125; AddExplosionForce函数的参数如下所示。 1Rigidbody.AddExplosionForce(爆炸力大小, 原点, 半径, 向上的力); 将脚本中的爆炸效果添加到Inspector视图的Standard Assets/Particles/Legacy Particles/explosion。Unity 5中新的爆炸效果默认含有模拟物理爆炸力的脚本，因此，为了应用上述脚本，需要先如下图所示，取消ExplosionPhysicsForce的勾选。 为BarrelCtrl脚本的ExpEffect属性中设置爆炸粒子效果 将Hierarchy视图的Barrel拖曳到Prefabs文件夹，使之成为预设。复制多个油桶并将其摆放到场景中。运行游戏，发射子弹使油桶爆炸。 随机使用纹理油桶预设复件会有相同纹理，而该油桶模型提供了3个纹理。可以编写脚本，使油桶随机使用其中之一。 在Mesh Renderer组件中指定纹理，子对象Barrel模型已经激活Mesh Renderer组件，而父对象Barrel模型是空的游戏对象。 虽然可以在界面上直接设置Mesh Renderer的纹理属性，然后在脚本中更改纹理。但此处使用在脚本中直接随机设置纹理的方式，代码如下所示。 1234567891011121314151617181920212223using UnityEngine;using System.Collections;public class BarrelCtrl : MonoBehaviour&#123; // 表示爆炸效果的变量 public GameObject expEffect; // 要随机选择的纹理数组 public Texture[] textures; private Transform tr; // 保存被子弹击中次数的变量 private int hitCount = 0; void Start() &#123; tr = GetComponent&lt;Transform&gt;(); int idx = Random.Range(0, textures.Length); GetComponentInChildren&lt;MeshRenderer&gt;().material.mainTexture = textures[idx]; &#125;&#125; 首先，声明要保存适用于油桶的各种纹理的数组。 12// 要随机选择的纹理数组public Texture[] textures; Start函数中，Random.Range()函数随机生成访问textures数组的Index值，获取子Barrel游戏对象的Mesh Renderer组件，然后将该组件的材质属性设为textures数组中保存的某个纹理。 GetComponentInChildren&lt;T&gt;()函数可获取子游戏对象的T类型的组件，该函数只返回1个组件对象。如果需要返回多个组件对象，请使用GetComponentsInChildren&lt;T&gt;()函数。 12int idx = Random.Range(0, textures.Length);GetComponentInChildren&lt;MeshRenderer&gt;().material.mainTexture = textures[idx]; Random.Range函数的返回值范围 根据传入的起始值和终止值参数的类型不同，Random.Range可返回不同范围、不同类型的随机数值。以脚本中使用的Random.Range(float min, float max)为例，参数为Float类型时，该方法会生成[min, max]区间的随机数；如果参数为Integer类型，该方法会生成[min, max-1]范围的随机数。 根据参数类型生成不同随机数值 使用方法 结果值 Random.Range(1.0f, 10.0f) 生成1.0f-10.0f的随机浮点数(包含max) Random.Range(1, 10) 生成1-9的随机整数(包含max-1) 修改脚本后，需要向Inspector视图的纹理数组逐个添加将被随机选择的3个纹理文件。因为Barrel已经是预设，所以添加纹理数组后必须点击Apply按钮进行保存，使之可应用到所有Barrel预设复件。 下图为尚未点击Apply按钮的截图。需要注意，Inspector视图中的BarrelCtrl脚本组件属性中显示为粗体的是Textures数组的各个成员。粗体显示表示刚刚对预设进行修改，尚未保存。点击Apply按钮后，Unity IDE会保存刚才进行的修改，粗体也会恢复为常规字体。虽然不需要另外保存针对项目视图中的预设进行的修改，但要想保存针对Hierarchy视图中的预设进行的修改，则必须点击Apply按钮。 为Textures数组成员分别设置3个纹理文件 运行游戏后，可以看到Scene视图中随机应用纹理的各个油桶。 本章涵盖 声音: AudioSource与AudioListener 枪口火焰效果：Muzzle Flash一般不使用粒子效果。 声音: AudioSource与AudioListenerUnity拥有音效中间件FMOD，可以呈现更加逼真的3D立体音效。 想要加入音效，必须拥有以下两种组件：像人的耳朵一样具有听声功能的AudioListener组件和具有发声作用的AudioSource组件。 场景中只可以使用1个AudioListener组件，而AudioSource组件则可以使用多个。除此之外，制作声音当然也需要可以播放的声音文件（wav、mp3、ogg等）。 AudioListener是主摄像机中默认添加的组件，一般需要将其添加到跟随主人公移动的摄像机或玩家角色。AudioListener组件中没有可以修改的属性。 场景中需要多个摄像机时，后添加的摄像机中因为也有自己的AudioListener组件，所以会看到如下提示：“场景中有多个AudioListener组件。”此时需要决定留下哪个AudioListener组件，将其余的都删除。 制作发射子弹的音效的步骤如下 导入枪声的声音文件； 向Bullet预设添加AudioSource组件； 向PlayerCtrl脚本添加播放声音的脚本。 将枪声的声音文件gun.wav导入Project视图的Sounds文件夹。导入后，可以在Inspector视图中设置声音文件的压缩品质、3D效果、立体声效果、单声道转换等，可以在Inspector视图底端Preview区域试听该声音，也可以查看该声音的波形。 IDE会将声音文件分为左右双声道2个单独的音源文件。如果对游戏音响效果要求不高，可以将之转换为单声道的声音。特别是开发移动游戏的时候，双声道声音并非十分必要，反而会占用很多容量，造成游戏性能低下。如下图所示，勾选Force To Mono选项，点击Apply按钮，即可将导入的声音文件转化为单声道。转换完成后，预览区域就会只显示1条波形图，如下图所示。 下面在Bullet中制作枪声效果。在Project视图中选择Bullet预设后，选择菜单Component-&gt;Audio-&gt;Audio Source添加AudioSource组件。如下表所示，修改AudioSource组件的属性。 Bullet预设的AudioSource组件的属性 属性 修改值 说明 Audio Clip gun.wav 设置的音源文件 Play On Awake 勾选 激活相应组件时是否自动播放 Min Distance 5 音量为100%时听到的音源最小范围 Max Distance 10 可以听到音源的最大范围 通过Min Distance和Max Distance属性设置AudioListener可以听到的范围，即AudioSource发出的声音所能传达的范围。Scene视图中，Min Distance和Max Distance均用蓝色球型线图表示，如下图所示。 内部小圆表示Min Distance设置的范围，外部大圆表示Max Distance设置的范围。 主摄像机中的AudioListener在AudioSource的Min Distance范围内时，AudioListener会听到其100%的音量；在Min Distance到Max Distance之间时，AudioListener侦听到的音量会根据Volume Rolloff选项的值逐渐减小；如果AudioListener的位置在Max Distance之外，则无法侦听声音。 Volume Rolloff选项提供了3种AudioSource逐渐变远时降低音量的方式，如下图所示，在Inspector视图中使用曲线编辑器（Curve Editor）可以具体调节音量减小效果。 Logarithmic Rolloff：以Log函数曲线形态减小（默认设置的值）。 Linear Rolloff：以线性方式减小音量。 Custom Rolloff：以自定义曲线形态减小音量。 下面运行游戏，测试发射子弹音效。左击鼠标发射子弹后暂停游戏，选择子弹预设复件BulletClone()，下图显示AudioSource的声音传播范围。当然，因为实际运行游戏时子弹速度太快，短时间内就会迅速远去，所以可能无法感觉Volume Rolloff效果。但如果为位置相对固定的物体设置音效，那么玩家接近时就会听到音量越来越大。 前面导入的枪声在Bullet预设中可以直接发声，但在距墙体较近的距离发射子弹时，二者一旦碰撞则随即被Destroy。因此，可能出现枪声还未播放完整便断开的现象，所以需要在脚本中对播放声音的逻辑进行处理。 首先删除上文添加到Bullet预设的AudioSource组件，然后将其添加到Player，之后修改FireCtrl脚本。 1234567891011121314151617181920212223242526272829303132333435363738394041424344using UnityEngine;using System.Collections;// 声明脚本需要的组件，以防止该组件被删除[RequireComponent(typeof(AudioSource))]public class FireCtrl : MonoBehaviour&#123; public GameObject bullet; //子弹预设 public Transform firepos; // 子弹发射坐标 public AudioClip firesfx; // 子弹发射声音 private AudioSource source = null; // 保存AudioSource组件的变量 void Start() &#123; // 获取Audiosource组件后分配到变量 source = GetComponent&lt;AudioSource&gt;(); &#125; void Update() &#123; // 鼠标左击时调用Fire函数 if(Input.GetMouseButtonDown(0)) &#123; Fire(); &#125; &#125; void Fire() &#123; // 动态生成子弹的函数 CreateBullet(); // 播放声音的函数 source.PlayOneShot(firesfx, 0.9f); &#125; void CreateBullet() &#123; // 动态生成Bullet预设 Instantiate(bullet, firePos.position, firePos.rotation); &#125;&#125; 为了自动添加脚本中必需的组件，并防止因误操作而删除该组件，脚本中使用了RequireComponent语法。 因为FireCtrl脚本使用了RequireComponent，所以如果想在别处删除已添加的AudioSource组件，则会出现“无法删除脚本依赖组件”的提示信息，如下图所示。 Fire函数中，脚本使用AudioSource组件的PlayOneShot方法播放枪声。 1AudioSource.PlayOneShot(音频对象, 音量); 修改FireCtrl脚本后，在Hierarchy视图中选定Player，并将Inspector视图显示的Fire Sfx变量设置为gun.wav文件，最后进行测试。与之前不同，无论是否删除Bullet，都不会出现声音中断的现象。 枪口火焰效果：Muzzle Flash制作枪击音效后，下面制作枪口火焰效果，这样可以使游戏效果更加逼真。通常情况下，考虑到游戏运行速度，Muzzle Flash一般不使用粒子效果。 根据游戏中的相机视角不同，可以在导入图像后自行选择使用1个Plane Mesh还是组合多个进行制作。也可以在发射子弹时以Z轴为基准进行不规则旋转时使用不同图像，或者在火焰大小方面添加变化。另外，可以使用连续的Sprite动画处理火焰效果。 单个Plane Mesh的方式适合FPS，多个Plane Mesh同时适合FPS和TPS，可根据相机视角需要选择适合的呈现方式。 选择Quad模型制作枪口火焰效果。在Hierarchy视图中选定Player底端FirePos，添加Quad模型，并将其重命名为MuzzleFlash，然后将MuzzleFlash的Scale属性中X、Y、Z分别设置为(2,2,2)，必须取消Mesh Collider组件的勾选。 下载MuzzleFlash.png文件，用作MuzzleFlash游戏对象中的火焰图像。将此文件导入Project视图Images文件夹，在Images/Materials/中新建材质，重命名为MuzzleFlash。 将MuzzleFlash材质的着色器设置为Particles/Additive，并将Particle Texture设置为MuzzleFlash纹理。 将Mesh Renderer的Materials属性设置为MuzzleFlash材质，或直接将MuzzleFlash拖曳到Scene视图的MuzzleFlash，这样即完成枪口火焰图像的添加，如下图所示。 为了使MuzzleFlash在每次发射子弹时都闪光，还需要修改FireCtrl脚本。可以将闪光效果简单理解为，在一瞬间以肉眼看到后马上消失，并不断重复此过程。因此，可以反复激活/禁用MuzzleFlash游戏对象的Mesh Renderer组件以实现该效果。 脚本中，要想修改其他游戏对象下的子游戏对象的Transform组件属性，可以使用localPosition、localRotation、localScale等属性。脚本中的Vector3.one是Vector3(1, 1, 1)的简写，所以Vector3.one*scale与new Vector3(scale, scale, scale)含义一样。 1234// 随机更改MuzzleFlash大小float scale = Random.Range(1.0f, 2.0f);muzzleFlash.transform.localScale = Vector3.one * scale; 将制作MuzzleFlash过程中使用的Quad模型以X轴为基准旋转-90°，然后将枪口火焰以Z轴为基准进行随机旋转。因为Transform组件的localRotation属性是Quaternion类型，所以脚本使用Quaternion.Euler(x, y, z)函数获取需要旋转的角度值。 12// MuzzleFlash以Z轴为基准随机旋转Quaternion rot = Quaternion.Euler(0, 0, Random.Range(0, 360));muzzleFlash.transform.localRotation = rot; 运行游戏后，可以看到MuzzleFlash的大小和旋转都在进行不规则变化。这种直接制作网格的方法在实际开发中很常用，也可以在运行时随机使用各种不同的枪口火焰纹理。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 制作主人公角色]]></title>
    <url>%2F2019%2F03%2F23%2F%E7%AC%AC4%E7%AB%A0%20%E5%88%B6%E4%BD%9C%E4%B8%BB%E4%BA%BA%E5%85%AC%E8%A7%92%E8%89%B2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是空游戏对象？为什么使用空游戏对象？ Awake在禁用脚本时能调用吗？Start呢？ 组件缓存是什么？ 如何使用键盘操作物体移动？ 如何使用鼠标控制旋转？ FollowCam的重要的变量和函数是哪些？ 摄像机跟随使用什么算法？ Animation Type有几种？区别是什么？ 如何切分动画？ Legacy如何用代码控制动画？什么关键类和函数？ 什么是Animation Blending？如何实现？关键函数是什么？ 如何使用投影器制作阴影？ 如何使用平面网格制作阴影？ 本章涵盖： 空游戏对象 导入3D模型并设置选项 生成脚本 下载键盘输入值 角色移动 处理组件缓存 游戏对象的移动 Translate函数 单位向量 角色旋转：Rotate 摄像机追踪：Follow Cam Legacy动画系统 动画片段 动画控件 动画合成 实时阴影 运用投影器制作阴影 运用平面网格制作阴影 空游戏对象将用于游戏的3D模型放置于场景视图有两种方法：一是直接使用相应的3D模型；二是先建立空游戏对象，然后将3D模型拖曳至新建的空游戏对象下，使之成为其子对象。 如果是用于舞台设计的静态模型，一般会使用第一种方法。而如果是用于主人公角色或者敌对角色（NPC）等需要实现各种逻辑的模型。则一般会使用第二种方法。 新建空游戏对象并重命名为Player。对于新建的GameObject，除非特殊情况，否则必须先将Transform的Position属性设置为(0, 0, 0)再操作。 Hierarchy视图列出的都是游戏对象，平行光、主摄像机都只是在空游戏对象中添加了光源组件和摄像机组件而已。 导入3D模型并设置选项点击下载文件 将用于主人公的Player3D模型拖曳到前面新建的Player游戏对象下并重命名为PlayerModel，主人公的Player模型就会变为其子模型。Unity中子3D对象在父3D对象中称编组（Grouping），父模型移动时，子模型会同时移动。 将重命名后的PlayerModel的Transform中的Position属性设置为（0, 0, 0），因为在层次视图中Player和PlayerModel是父子关系，需要确保其在场景视图中显示的坐标位置一致。另外，如果需将模型移动到舞台特定位置，则不要在Scene视图中直接用鼠标点击操作，而要先选择层次视图中的父Player，再通过点击坐标轴进行移动。 一定要将放置在场景视图中的模型或者游戏对象的Transform Position属性设置为(0, 0, 0)后再开始工作。另外，空游戏对象下端的子游戏对象或者子3D模型Transform Position属性也要设置为原点(0, 0, 0)。 生成脚本 函数名 函数属性 Awake 执行脚本时只调用一次，主要用于初始化游戏的状态值或初始化变量，调用Start函数前首先调用，禁用脚本时也可以执行，不可用于例程 Start 调用Update函数前仅调用一次，激活脚本后才能执行，其他脚本的所有Awake函数均执行后才能执行 Update 每个游戏帧都要调用，是制作游戏的核心逻辑，激活脚本后才能执行 LateUpdate 所有Update函数均调用后调用一次，用于按顺序执行的逻辑，主要用于摄像机移动逻辑，激活脚本后才能执行 FixedUpdate 主要用于使用物理引擎时，每间隔一定时间即被调用，每次调用的间隔时间一致 OnEnable 激活游戏对象或脚本时调用，事件发生时使用，不可用于例程 OnDisable 禁用游戏对象或脚本时调用，事件结束时使用，不可用于例程 OnGUI 处理GUI事件时调用 下载键盘输入值外部输入的资源有键盘、鼠标、移动设备的触摸、游戏杆等很多种类，Input类管理这些来自外部的输入值。下面利用Input类接收键盘输入值。 Unity定义了游戏中常用的组合键，这些组合键可以在输入管理器中进行管理。选择菜单Editor-&gt;Project Settings-&gt;Input打开输入管理器，如下图所示。组合键常以Vertical、Horizontal、Fire1、Jump、Mouse X等命名，可以修改其明细或添加新的组合键。 脚本中，可以通过Input.GetAxis(“组合键名”)函数获取事先设置的组合键的值。 1234567891011121314151617181920using UnityEngine;using System.Collections;public class PlayerCtrl : MonoBehaviour&#123; private float h = 0.0f; private float v = 0.0f; void Start() &#123; &#125; void Update() &#123; h = Input.GetAxis("Horizontal"); v = Input.GetAxis("Vertical"); Debug.Log("H=" + h.ToString()); Debug.Log("V=" + v.ToString()), &#125;&#125; Input.GetAxis(“Horizontal”)函数是InputManager的Horizontal项事先设置的值，玩家按键盘的A、D键或光标键Left、Right时，该函数返回-1&#126;1的值。 同时，Input.GetAxis(“Vertical”)函数也可以在玩家按健盘W、S、UP、Down键时返回-1&#126;1的值 Debug.Log()函数的参数是字符串类型，所以要利用ToString()方法将浮点类型变量h和v转换为字符串类型。 Input.GetAxis(“Horizontal”)返回-1.0f&#126;1.0f的值，通常在游戏对象做出平滑动作时使用。如果对键盘控制的即时性要求较高，请使用Input.GetAxisRaw(“Horizontal”)函数，该函数仅返回-1、0、1这3个枚举值。 角色移动 PlayerCtrl：添加移动逻辑 12345678910111213141516171819202122232425262728293031using UnityEngine;using System.Collections;public class PlayerCtrl : MonoBehaviour&#123; private float h = 0.0f; private float v = 0.0f; // 必须先分配变量，之后才能使用需要访问的组件。 private Transform tr; // 移动速度变量 public float moveSpeed = 10.0f; void Start() &#123; // 向脚本初始部分分配Transform组件。 tr = GetComponent&lt;Transform&gt;(); &#125; void Update() &#123; h = Input.GetAxis("Horizontal"); v = Input.GetAxis("Vertical"); Debug.Log("H = " + h.ToString()); Debug.Log("V = " + v.ToString()); // Translate(移动方向 * 速度 * 位移值 * Time.deltaTime, 基础坐标) tr.Translate(Vector3.forward * moveSpeed * v * Time.deltaTime, Space.Self); &#125;&#125; 如果变量被public修饰，则其在Inspector视图中设置的值要比脚本中指定的值优先级更高。 Inspector视图默认不显示访问权限修饰词为private的变量。实际开发中，有时会需要查看private变量的值，此时可以通过鼠标右击Inspector视图选项卡，在上下文菜单中选择Debug以显示声明为private的变量。 处理组件缓存每帧都会调用一次Update函数，因此，需要时刻注意该函数的优化。比如，运行游戏的设备为30帧（FPS，frame per seconds）时，Update函数每秒将会被调用30次。需要注意，不要使用Update函数编写占用资源过高的代码，更不要有错误的逻辑。特别在游戏对象移动时，其Transform组件的Position属性是一直在变的，所以Unity不提倡每帧都访问Transform组件。 建议各位可以先在Awake函数或Start函数创建要在Update函数中使用的组件，然后再用于Update函数。 GetComponent函数获取Transform组件并赋值于tr变量，其依赖于各类游戏对象拥有的特定组件。 GetComponent函数的使用方法如下，可以用多种语法表示。 1234tr = GetComponent&lt;Transform&gt;();tr = gameObject.GetComponent&lt;Transform&gt;();tr = (Transform)GetComponent("Transform");tr = (Transform)GetComponent(typeof(Transform)); 以上使用方法的效果相同，第一种方法用于通用类型的Transform组件，无需额外的类型转换。使用这种通用类型的Transform组件可以有效简化代码，所以会一直使用该类型。 Start函数中，为tr变量赋值的语法可概述为： 1tr = this.gameObject.GetComponent&lt;Transform&gt;(); 从该脚本包含的游戏对象拥有的各组件中抽取Transform组件，并保存至tr变量。 this关键字代表当前脚本，此处为PlayCtrl脚本。this.gameObject表示该脚本中添加的游戏对象，此处this.gameObject可以省略不写。 Unity 5删除的获取组件方法的缩略写法（getter） Unity 4.x及更早版本提供了常用的获取组件方法的缩写形式，但从Unity 5开始只保留获取transform组件的缩写形式，其余的都删除了。因此，下表中的任一缩写形式都不能再使用了。 Unity 4.x Unity 5.x rigidbody GetComponent audio GetComgonent collider GetComponent() renderer GetComponent() 游戏对象的移动Unity中移动某种游戏对象有以下两种方式： 更改Transform组件的Position属性； 利用物理引擎（PhysX，Box2D）移动游戏对象。 首先学习如何通过调整Transform组件的position属性实现游戏对象的移动。下列示例在每帧中将Z轴的值增加1，使游戏对象前进。Unity使用了左手坐标系，所以+Z轴方向是前进，-Z轴方向就是后退。 1234void Update()&#123; transform.position += new Vector3(0, 0, 1); &#125; 但是，如果所有游戏对象的移动逻辑都像上面那样编码，则会很繁项，而且容易降低代码可读性。幸好Unity中提供了更加简便的方法。 Vector3数据类型 Vector3(x, y, z)是Unity提供的用于保存三维坐标值和向量数据的结构体。 Translate函数Translate函数用于处理游戏对象移动，函数原型如下。 1void Translate(Vector3 direction, [Space relativeTo]); 用Translate方法重写上文中每帧加Z值的脚本，可以编写如下简洁并具有相当可读性的代码。 1234void Update()&#123; tr.Translate(Vector3.forward); &#125; Vector3.forward是预定义的单位向量缩写形式，与Vector3(0, 0, 1)含义一样。在代码中利用此单位向量乘以速度（moveSpeed），游戏对象就会按照moveSpeed变量指定的速度移动。 1tr.Translate(Vector3.forward * moveSpeed * v * Time.deltaTime, Space.Self); 该函数原型如下。 1tr.Translate(将移动的方向 * 速度 * 前进/后退方向 * Time.deltaTime, 基准坐标系); Time.deltaTime表示前一帧到当前帧花费的时间，需要注意的是，Update函数内，使用Transform组件使游戏对象移动的逻辑必须乘以deltaTime，使游戏对象的移动速度不受帧率（FrameRate）影响，而根据某个固定的速度移动。也就是说，上述脚本中如果没有乘以Time.deltaTime，游戏对象将每帧以10单位速度前进；如果乘以Time.deltaTime，游戏对象将每秒以10单位速度前进。因此，在帧率不同的机器上也可以相同速度移动。 1234// 每帧移动10单位transform.Translate(Vector3.forward * 10);// 每秒移动10单位transform.Translate(Vector3.forward * Time.deltaTime * 10); Translate函数的第二个参数决定游戏对象以全局坐标（Space.World）还是局部坐标（Space.Self）为基准移动。如果省略基准坐标参数，游戏对象将默认以局部坐标为基准移动。 坐标系：局部坐标系和全局坐标系 Unity的场景视图是无限的三维空间，此三维空间中一直不变的基准坐标是全局坐标；反之，局部坐标指各游戏对象自己的坐标。 因此，如果Translate函数的基准坐标指定为Space.Self，那么游戏对象将以局部坐标为基准进行移动；若指定为Space.World，则将以全局坐标为基准进行移动。（类比一下地球和个人。地球的上北下南左西右东是不变的，但是个人往前走，肯定是根据自己的前往前走，不是地球的前往前走。） 单位向量向量是具有大小和方向的数据类型，Unity中，每个方向轴上大小为1的向量称为单位向量（正规化向量，Normalized Vector）此处可以将之理解为只表示方向的向量。Vector3结构体是Unity提供的在开发过程中用以表示三维空间坐标和方向的数据类型。Unity提供了如下表所示的各种单位向量的简写形式，可以轻松调用。 单位向量的简写形式 简写形式 含义 Vector3.forward Vector3(0, 0, 1) Vector3.back Vector3(0, 0, -1) Vector3.left Vector3(-1, 0, 0) Vector3.right Vector3(1, 0, 0) Vector3.up Vector3(0, 1, 0) Vector3.down Vector3(0, -1, 0) Vector3.one Vector3(1, 1, 1) Vector3.zero Vector3(0, 0, 0) Unity使用左手坐标系，左手拇指表示X轴、食指表示Y轴、中指表示Z轴，Z轴代表了游戏对象前进的方向，Vector3.forward与Vector3(0, 0, 1)一样，Vetor3.forward乘以速度就是具有Z轴方向的向量。 与大部分3D工具一样，X、Y、Z轴对应的颜色分别为红（R）、绿（G）、蓝（B）。 现在运行之前编写的游戏脚本，通过键盘上下方向键查看游戏主人公能否前进或后退。如果游戏模型的动作正确，那么可以继续向Player添加左右移动的动作，PlayerCtrl脚本修改如下所示。 PlayerCtrl脚本：前后左右移动逻辑 123456789101112131415161718192021222324252627282930313233using UnityEngine;using System.Collections;public class PlayerCtrl : MonoBehaviour&#123; private float h = 0.0f; private float v = 0.0f; // 必须先分配变量，之后才能使用需要访问的组件。 private Transform tr; // 移动速度变量（声明为public并显示到检视视图。） public float moveSpeed = 10.0f; void Start() &#123; // 向脚本初始部分分配Transform组件。 tr = GetComponent&lt;Transform&gt;(); &#125; void Update() &#123; h = Input.GetAxis("Horizontal"); v = Input.GetAxis("Vertical"); Debug.Log("H = " + h.ToString()); Debug.Log("V = " + v.ToString()); // 计算前后左右移动方向向量。 Vector3 moveDir = (Vector3.forward * v) + (Vector3.right * h); // Translate（移动方向.Tune.deltaTime.位移值·速度,基础坐标） tr.Translate(moveDir * Time.deltaTime * moveSpeed, Space.Self); &#125;&#125; 将前进/后退向量和左右向量按照如下公式计算，利用加法运算得到一个方向向量，用其乘以速度即可使游戏对象前后左右移动。 1234// 计算前后左右移动方向向量。Vector3 moveDir = (Vector3.forward * v) + (Vector3.right * h);// Translate(移动方向 * Time.deltaTime * 位移值 * 速度, 基础坐标)tr.Translate(moveDir * Time.deltaTime * moveSpeed, Space.Self); 运行后，使用前后左右方向箭头或W、A、S、D键可以移动Player游戏模型。 moveDir变量属于Vector3类型，通过键盘输入值进行向量运算。对前进方向和左右方向的向量做加法运算，就会得到对角线方向的向量，如下图所示。根据“勾股定理”可以算出向量长度约为1.414，这个值为小数，所以需要将其转换为长度为1的单位向量。而且只能使用这个向量的方向，忽略其数值部分。 为了只获取向量的方向，需将其转换为单位向量。此处可以利用Vector3.normalized属性获取单位向量值，请如下修改PlayCtrl脚本。 12Vector3 moveDir = (Vector3.forvard * v) + (Vector3.right * b);tr.Translate(moveDir.normalized * Time.deltaTime * moveSpeed, Space.Self); 向量的大小和正规化 可以通过Vector3.Magnitude函数获取向量大小（Magnitude）。 12345678910void Start()&#123; float vec1 = Vector3 Magnitude(Vector3.forward); float vec2 = Vector3.Magnitude(Vector3.forward + Vector3.right); float vec3 = Vector3.Magnitude(Vector3.forward + Vector3.right).normalized; Debua.Log(vec1); Debug.Log(vec2); Debug.Log(vec3);&#125; 上述代码运行结果如下图所示。 角色旋转：Rotate要想旋转游戏对象，可以使用Rotate函数及如下各种参数 void Rotate(Vector3 eulerAngles, [Space relativeTo]); void Rotate(float xAngle, float yAngle, float zAngle, [Space relativeTo]); void Rotate(Vector3 axis, float angle, [Space relativeTo]); 以下示例中，Rotate函数使用的参数各有不同，但结果一样，都使游戏对象以Y轴为基准进行旋转。 123transform.Rotate(Vector3.up * Time.deltaTime);transform.Rotate(0, Time.deltaTime, 0);transform.Rotate(Vector3.up, Time.deltaTime); 要添加到PlayerCtrl的旋转逻辑如下所示。Rotate函数与Time.deltaTime相乘后，即可不受帧率影响进行旋转。 Rotate(旋转基准坐标轴 * Time.deltaTime * 旋转速度 * 输入的位移值) 之前的前进和后退是通过键盘输入值实现的，下面用鼠标的左右移动操控游戏对象旋转。在InputManager中使用定义为Mouse X的Axis，用于在脚本中获取旋转的位移值。另外，可以在此修改鼠标灵敏度（即旋转角色的灵敏度），通过调整Mouse X中的Sensitivity值（或在脚本中调整速度）实现。 12345678910111213141516171819202122232425262728293031323334353637383940using UnityEngine;using System.Collections;public class PlayerCtrl: MonoBehaviour&#123; private float h = 0.0f; private float v = 0.0f; // 必须先分配变量，之后才能使用常用组件。 private Transform tr; // 移动速度变量（声明为public，并显示到检视视图。） public float moveSpeed = 10.0f; // 旋转速度变量 public float rotSpeed = 100.0f; void Start() &#123; // 向脚本初始部分分配Transform组件。 tr = GetComponent&lt;Transform&gt;(); &#125; void Update() &#123; h = Input.GetAxis("Horizontal"); v = Input.GetAxis("Vertical"); Debug.Log("H = " + h.ToString()); Debug.Log("V = " + v.ToString()); // 计算前后左右移动方向向量 Vector3 moveDir = (Vector3.forward * v) + (Vector3.right * h); // Translate（移动方向 * Time.deltaTime * 位移值 * 速度,基础坐标） tr.Translate(moveDir.normalized * Time.deltaTime * moveSpeed, Space.Self); // 以Vector3.up轴为基准，以rotSpeed速度施转。 tr.Rotate(Vector3.up * Time.deltaTime * rotSpeed * Input.GetAxis("Mouse X")); &#125;&#125; 运行脚本后，左右移动鼠标即可看到游戏角色旅转。 摄像机追踪：Follow CamUnity中，要想使摄像机始终跟随主人公角色移动，最简单的方法就是直接将主摄像机拖曳到Player游戏对象下。但如果想要在实际游戏中实现平滑移动和震动效果，则需要添加追踪主人公角色模型的脚本。 新建脚本，重命名为FollowCam，代码如下。 12345678910111213141516171819202122232425262728293031using UnityEngine;using System.Collections;public class FollowCam : MonoBehaviour &#123; public Transform targetTr; // 要追踪的游戏对象的Transform变量 public float dist = 10.0f; // 与摄像机之间的距离 public float height = 3.0f; // 设置摄像机高度 public float dampTrace = 20.0f; // 实现平滑追踪的变量 // 摄像机本身的Transform变量 private Transform tr; void Start() &#123; // 将摄像机本身的Transform组件分配至tr tr = GetComponent&lt;Transform&gt;(); &#125; // 使用LateUpdate函数，调用所有Update函数后才会调用该函数。 // 要追踪的目标游戏对象停止移动后，调用LateUpdate函数。 void LateUpdate() &#123; // 将摄像机放置在被追踪目标后方的dist距离的位置。 // 将摄像机向上抬高height。 tr.position = Vector3.Lerp(tr.position, targetTr.position - (targetTr.forward * dist) + (Vector3.up * height), Time.deltaTime * dampTrace); // 使摄像机朝向游戏对象。 tr.LookAt(targetTr.position); &#125;&#125; 以上追踪脚本首先将摄像机从要追踪目标的位置向后移动距离dist，然后再将其抬高height，并使摄像机与被追踪目标旋转角度相同。为了达到平滑柔和的追踪效果，此处使用了Vector3.Lerp函数。该函数将2个向量进行线性内插（Linear Interpolation），实时计算摄像机当前应该处于的位置。 1Vector3.Lerp(Vector3起始位置, Vector3结束位置, 浮点格式时间); 时间变量为起始值0.0f时，返回摄像机起始位置值；取值为1.0f时，返回终止位置值。因此，调整dampTrace变量即可调整追踪动画的视觉效果。 1Vector3.Lerp(tr.position, targetTr.position - (targetTr.forward * dist) + (Vector3.up * height), Time.deltaTime * dampTrace); 如果在Update函数中实现计算摄像机位置的逻辑，即在Player移动完成之前就移动摄像机，则可能出现画面抖动现象。因此，必须在Player的移动及旋转都结束后再计算摄像机位置，所以这一步需要在LateUpdate函数中执行。 场景中所有脚本的Update函数完成后才会调用LateUpdate函数。 将FollowCam脚本添加到主摄像机下，将摄像机要追踪的目标--Player游戏对象拖曳到FollowCam组件的targetTr变量。 实际运行游戏时，用鼠标移动或旋转主人公角色后，会看到摄像机平滑柔和地跟随主人公移动或旋转。也可以适当修改摄像机的Dist和Height等属性值，获得想要的摄像机角度。 Legacy动画系统下面设置适合Player移动的动画系统。 Unity支持Legacy动画系统和Mecanim动画系统的动画。 Legacy动画系统：在3D Animation Tool中制作的动画。 Mecanim动画系统：新的动画系统，可利用动作复制功能重复利用现有动画。 可惜的是，AngryBot中的Player模型不适合Mecanim动画系统所需的骨骼结构，所以其不能使用Mecanim动画系统制作动画。 选择Project视图的Player 3D模型（AngryBot Player原版模型），Inspector视图中显示FBX Import Settings。FBX Import Settings中可以设置从外部导入的3D模型的属性。 选择Rig选项卡，查看Animation Type选项是否为Legacy。Animation Type中有4个选项，关于各选项的说明如下表所示。 Rig选项卡Animation Type选项 Animation Type 说明 None 不使用动画 Legacy 旧版动画 Generic Mecanim动画系统，适用于四肢行走的3D模型或未使用动作复制功能的动画制作 Humanoid Mecanim动画系统，适用于像人一样的直立行走模型 对于AngryBot Player模型，也可将Animation Type选项设置为Generic，以使用Mecanim动画系统，但其骨骼结构导致不可以对其进行动作复制。 根据3D模型FBX Import Settings中设置的动画类型，Unity会自动添加以下组件。 Legacy动画系统：Animation组件。 Mecanim动画系统：Animator组件。 Animation组件和Animator组件都与动画制作有关，但运行方式完全不同。因此，只需查看组件类型即可区分相应模型使用的动画类型。 动画片段首先定义动画和动画片段（Animation Clip）。Unity中，走路、奔跑、跳跃、射击等动作通常称为“动画片段”，这些动画片段统称为“动画文件”或“动画”。 3D模型工具中制作的动画片段可以通过以下两种方式生成为动画文件。 第一种方法是，将所有动画片段放入一个动画文件中，各动画片段均有开始帧和结束帧。下图将一个动画文件里的所有动画片段分离展示。 将一个动画文件分离展示为分散的动画片段 第二种方法是，将拥有各动画片段的3D模型按照动作进行拆分，这种方式生成的动画片段的文件名使用“模型名@动画片段名”的命名规则。如下图所示，动画片段ShockTrooper&#64;idle、ShockTooper&#64;runLoop、ShockTrooper&#64;Reload使用命名规则。 如果动画片段数量很多或动画的修改操作很频繁，那么使用第二种方式会便利很多，但也会导致文件个数变多而不易管理的情况。 以动画片段类型区分的3D模型 下面以第一种方式制作要使用的AngryBot Player 3D模型动画，名为Take001的动画文件下有5个动画片段。 请在Inspector视图中选择Animation选项卡，然后选择下方的Clips项目中的Take001动画文件，之后界面会展开如下图所示的一些属性，同时IDE也会打开底端预览窗口。 开始时，预览窗口中没有任何内容，会出现没有可用模型的提示信息：”No model is available for preview. Please drag a model into the Preview Window.”将项目视图的Player 3D模型拖曳到预览窗口，在预览窗口查看该模型的动画。 Animation预览窗口中的Player模型 点击预览窗口工具栏中的播放按钮，即可依次看到Take001动画文件包含的动作。预览窗口支持用鼠标滚轮的扩大/缩小动画功能。另外，点击鼠标右键并拖曳就会改变视角（Orbit），可以将其按照想要的角度进行设置。 动画片段的分离如下图所示，执行步骤如下：1.点击Clips区域的+按钮，Unity会添加名为Take0010的新动画片段；2.将添加的动画片段重命名为idle，并按Enter键确认；3.选择idle动画片段后，在底端Start和End中输入开始和结束帧的值；4.因为idle动画片段是需要一直重复的动作，所以将Wrap Mode更改为循环Loop。 动画片段的分离和设置帧 其余4种动画片段如下表所示，可以按照与上文类似的方法创建。 动画片段名称 开始帧 结束帧 是否反复（Wrap Mode） idle Loop runForward Loop runBackward Loop runRight Loop runLeft Loop 将所需的5种动画片段全部分离后，点击下方Apply按钮，在Project视图中查看Player模型下列出的分离的动画片段。 分离到Player模型下的动画片段 在Hierarchy视图中选择Player游戏对象下的PlayerModel，可以在Inspector视图中看到，之前分离的动画片段都在Animation组件的Animation属性中。 自动添加到动画目录的动画片段 Animation组件是Unity将动画类型设置为Legacy动画系统时自动添加的组件。Animation组件保存了相应游戏模型包含的动画片段列表，不存在于该列表的动画将不会运行。 最后需要设置默认动画片段。现在的默认动画片段为Take001，将Project视图Player模型下的idle动画片段拖曳到Animation组件的Animation属性，即可将默认动画片段变更为idle。 将默认动画片段更改为idle 运行示例游戏，可以看到Player执行idle动画。Animation组件的Play Automatically属性是设置是否自动执行默认动画片段的选项，撤销选择该选项后，将在脚本中控制是否自动执行默认动画片段。 动画控件将PlayerCtrl脚本拖曳到Player游戏对象下，在脚本中声明属于PlayerModel的Animation组件的变量和可以访问动画片段的数组。 如果实际开发中的动画片段个数较少，则可以依次为每个动画片段声明变量。但如果动画片段个数较多，那么为这些片段单独定义类即可进行更为高效的管理。要想在Inspector视图中显示某个类的对象，则需要为该类声明属性[System.Serializable]，使之可序列化。 PlayerCtrl:分配要保存动画片段的类及Animation组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using UnityEngine;using System.Collections;// 此类需要声明属性System.Serializable，表示可序列化// 显示到Inspector视图[System.Serializable]public class Anim&#123; public AnimationClip idle; public AnimationClip runForward ; public AnimationClip runBackward; public AnimationClip runRight; public AnimationClip runLeft;&#125;public class PlayerCtrl : MonoBehaviour&#123; private float h = 0.0f; private float v = 0.0f; // 必须先分配变量，之后才能使用常用组件 private Transform tr; // 移动速度变量（声明为public并显示到Inspector视图） public float moveSpeed = 10.0f; // 旋转速度变量 public float rotSpeed = 100.0f; // 要显示到Inspector视图的动画类变量 public Anim anim; // 要访问下列3D模型Animation组件对象的变量 public Animation _animation; void Start() &#123; // 向脚本初始部分分配Transform组件。 tr = GetComponent&lt;Transform&gt;(); // 查找位于自身下级的Animation组件并分配到变量。 _animation = GetComponentInChildren&lt;Animation&gt;(); // 保存并运行Animation组件的动画片段。 _animation.clip = anim.idle; _animation.Play(); &#125; void Update() &#123; h = Input.GetAxis("Horizontal"); v = Input.GetAxis("Vertical"); Debug.Log("H = " + h.Tostring()); Debug.Log("V = " + v.Tostring()); // 计算前后左右移动方向向量。 Vector3 moveDir = (Vector3.forward * v) + (Vector3.right * h); // Translate(移动方向 * Time.deltaTime * 位移值 * 速度, 基础坐标) tr.Tranalate(moveDir * Time.deltaTime * moveSpeed, Space.Self); // 以Vector3.up轴为基准，以rotSpeed速度旋转。 tr.Rotate(Vector3.up * Time.deltaTime * rotSpeed * Input.GetAxis("Mouse X")); &#125;&#125; 上述脚本中声明为Anim类的anim变量会在Inspector视图中分级展示动画片段列表，如下图所示。接下来，需要在Project视图中连接这些动画片段。 连接要保存动画片段的类变量 控制动画的Animation组件位于Player游戏对象的子PlayerModel下，为了使用该组件，可以直接将_animation变量从Hierarchy视图拖曳到Inspector视图；也可以在脚本中使用GetComponentInChildren函数为Player分配该组件。实际开发中可能会用到其他种类的组件，所以需要通过其他方式调用。 12// 查找位于自身下级的Animation组件并分配到变量。_animation = GetComponentInChildren&lt;Animation&gt;(); 运行脚本时，选择Player游戏对象即可在Inspector视图中看到_animation变量保存的Animation组件，效果如下图所示。 执行脚本后自动连接的Animation组件 下列脚本直接为Animation组件指定并运行某个动画片段，也可以用其他方法指定动画片段并运行，如_animation.Play(anim.idle.name)或_animation.Play(“idle”)。不过，如果像_animation.Play(“动画名称”)这样直接在代码中标明动画片段名称，那么以后其名称发生变化时就必须修改源代码，否则会出现错误。 123// 保存并运行Animation组件的动画片段。_animation.clip = anim.idle;_animation.Play(); 动画合成Unity提供了可以使两个相邻动画片段平滑过渡的效果，该功能称为动画合成（Animation Blending）。比如，Player执行idle动画后执行runForward动画时，如果突然变更动画片段，那么模型的动作看上去会很不自然。因此，Unity提供了可以让动画片段之间平滑过渡的CrossFade合成函数。如下脚本可以使Player从idle状态平滑过渡到runForward动画，请如下修改PlayerCtrl脚本的Update函数。 PlayerCtrl：修改Update函数 123456789101112131415161718192021222324252627282930313233343536373839void Update()&#123; h = Input.GetAxis("Horizontal"); v = Input.GetAxis("Vertical"); Debug.Log("H = " + h.Tostring()); Debug.Log("V = " + v.Tostring()); // 计算前后左右移动方向向量。 Vector3 moveDir = (Vector3.forward * v) + (Vector3.right * h); // Translate(移动方向 * Time.deltaTime * 位移值 * 速度, 基础坐标) tr.Tranalate(moveDir * Time.deltaTime * moveSpeed, Space.Self); // 以Vector3.up轴为基准，以rotSpeed速度旋转。 tr.Rotate(Vector3.up * Time.deltaTime * rotSpeed * Input.GetAxis("Mouse X")); // 以键盘输入值为基准，执行要操作的动画。 if (v &gt;= 0.1f) &#123; // 前进动画 _animation.CrossFade (anim.runForward.name, 0.3f); &#125; else if (v &lt;= -0.1f)&#123; // 后退动画 _animation.CrossFade (anim.runBackward.name, 0.3f); &#125; else if (h &gt;= 0.1f) &#123; // 向右移动动画 _animation.CrossFade (anim.runRight.name, 0.3f); &#125; else if (h &lt;= -0.1f)&#123; // 向左移动动画 _animation.CrossFade (anim.runLeft.name, 0.3f); &#125; else &#123; // 暂停时执行idle动画 _animation.CrossFade (anim.idle.name, 0.3f); &#125;&#125; 通过键盘上的Up、Down键输入的变量v返回-1 ~ 1的值。因此，如果v值大于0.1f则表示前进，此时执行runForward动画片段；小于-0.1f则表示后退，此时执行runBackward动画片段。对于左/右方向键输入的值v，也使用相同方法处理。如果值为0，则程序执行暂停状态idle动画片段。 CrossFade函数需要两个参数：第一个参数是要处理的动画片段名称，第二个参数是渐变为下一个动画片段的时间。也就是说，从idle动画片段到runForward动画片段需要0.3f秒。 123456// 以键盘输入值为基准，执行要操作的动画。if (v &gt;= 0.1f)&#123; // 前进动画 animation.CrossFade(anim.runForward.name, 0.3f);&#125; 运行游戏后，通过键盘移动Player，查看此时动画转换是否平滑。 实时阴影Unity支持3种光源的实时阴影，即平行光、点光源、聚光灯。 Unity 3.x版本不支持iOS和Android等移动设备上的实时阴影，Unity 4.0版本开始仅支持平行光的实时阴影。从Unity 5开始，点光源和聚光灯也支持实时阴影。实时阴影的处理负荷很大，所以需要根据移动设备的处理速度决定是否使用。 下列脚本根据不同iPhone版本分别设置实时阴影。 123456789101112131415161718192021222324252627282930313233using UnityEngine;using UnityEngine.iOS;using System.Collections;public class PerformanceMgr : MonoBehaviour &#123; private LightShadows shadowType = LightShadows.None; void Awake() &#123; if (Application.platform == RuntimePlatform.iPhonePlayer) &#123; switch (Device.generation)&#123; case DeviceGeneration.iPhone5s: shadowType = LightShadows.Hard; break; case DeviceGeneration.iphone6: shadowType = LightShadows.Soft; break; case DeviceGeneration.iPhone6Plus: shadowType = LightShadows.Soft. break; default: shadowType = LightShadows.None; break; &#125; GameObject.Find("Directional Light").GetComponent&lt;Light&gt;().shadows = shadowType; &#125; &#125;&#125; 随着移动设备性能的提高，各种实时阴影均在Unity中获得支持。Unity IDE中，可通过Inspector视图Directional Light属性Shadow Type选项设置实时阴影。Shadow Type有No Shadow、Hard Shadows、Soft Shadows这3种，如果设置为Hard Shadows和Soft Shadows，则可使用Unity提供的实时阴影功能，如下图所示。 No Shadows：默认设置值，不使用实时阴影。 Hard Shadows：使用实时阴影，但阴影边缘处理不自然。 Soft Shadows：虽然可以表现较为自然的实时阴影，但计算负荷很大。 实时阴影的视觉效果虽然很棒，但它会为引擎带来很高的负荷。因此，实际开发游戏时，必须将不需要实时阴影效果的3D模型的实时阴影属性设定为No Shadows。 3D模型默认具有Mesh Renderer组件或Skined Mesh Renderer组件，这两个组件均有与实时阴影有关的属性，即Cast Shadows和Receive Shadows。 Cast Shadows：决定有光照时是否需要投射自身阴影。 属性 含义 Off 不产生阴影 On 产生阴影 Two sided 忽略Back face curling，双面制作阴影 Shadows Only 生成阴影，但不需要自己渲染，可用于仅处理阴影的3D模型 Receive Shadows：当前模型能否显示其他模型投射到自己身上的阴影。 即使3D模型不使用实时阴影，也不会对画面产生太大影响。需要取消这两个选项的勾选，以免游戏消耗过多计算资源。 关于Cast Shadows属性的Two Sided选项 游戏模型为Plane或Quad时，Unity将只渲染Single-Side。此时如果将其Cast Shadows属性设为On，那么即使光从后面照过来也不会生成阴影（下图）；如果设置为Two Sided选项，则可生成阴影。 Scene视图中，用鼠标点击3D模型手中的枪，则会选中Hierarchy视图PlayerModel下的main.weapon001，如下图所示，将Mesh Renderer组件的Cast Shadows属性设为Off，并去掉Receive Shadows选项的勾选。 运用投影器制作阴影下面学习如何用Unity提供的投影器（Projector）制作Player的阴影。先将平行光的阴影属性改为No Shadow。 Unity提供的投影器可以简单理解为投射灯在屏幕中照射图像，主要用于构建Decal，以表现阴影、枪弹痕迹、血迹等。 Unity提供的投影器为Unity资源包形式。在项目视图中右击鼠标，并在上下文菜单中选择ImportPackage-&gt;Projectors，或在菜单中选择Assets-&gt;Import Package -&gt;Effects，出现导入资源包窗口。此处只选择导入投影器相关资源。在Importing Package窗口底端按钮中点击None按钮，取消全选，只选择所需投影器文件夹，最后点击Import按钮。 导入投影器资源包后，Project视图中会自动生成Standard Assets文件夹。 Standard Assets 包内含3个投影器预设。将Blob Shadow Projector拖曳到层次视图Player游戏对象下，然后将投影器以X轴为轴心向下旋转90°。再选择Z轴，向上方移动，使其边框包含Player游戏对象。此时，地面上生成模糊阴影。 Player游戏模型本身也被覆盖了阴影，所以需要将投影器的Near Clip Plane属性值修改为6.0左右。如下图所示，可以通过修改此值指定阴影范围。实际开发时的需求可能不同，需要自行调节Near Clip Plane数值。 投影器中，3D模型离Near Clip Plane越近，则阴影纹理越深；离Far Clip Plane越近，则阴影纹理越淡。因此，Player跳离地面时，地面上的影子会根据Player高度的增高而逐渐变淡。 除了通过调节投影器的Near Clip Plane和Far Clip Plane属性设置阴影范围外，还可以通过IgnoreLayers属性设置阴影范围，下面学习如何利用其修改阴影。 首先需要新建图层，创建方法与添加标签的方法类似。 在菜单中选择Edit-&gt;Project Settings-&gt;Tags and Layers或点击Inspector视图顶端的Layer，在弹出菜单中选择Add Layer…此时，Inspector视图显示Tags &amp; Layer项目，可以在此设置Tags、 Sorting Layers、Layers等。序号为1-7的层是Unity默认分配的层，可以从8号开始使用，直接在8号层后面输入名称PLAYER即可新建图层，如下图所示。 添加PLAYER图层后，选择PlayerModel，将Inspector视图的Layer属性设置为PLAYER图层。保存图层时，如果模型在Hierarchy视图中有子对象，IDE会询问是否适用于全部模型。此时选择Yes，Unity会将此设置应用于其下全部模型。 指定图层后，将Blob Shadow Projector投影器的Ignore Layers属性设置为PLAYER图层。之后，PlayerModel本身不会被投射阴影，如下图所示，仅能看到投影器在地面上生成的阴影。 设置Ignore Layers后，即使将Near Clip Plane值重新修改为原来的0.1，Player上也不会有阴影。 Layer，Sorting Layers 与Photoshop的图层不同，Unity中使用的图层没有2-order。换言之， Unity不是以物理层次分离游戏对象的，而是将特定的游戏对象编组，以决定是否受某个特定效果的影响。其具有代表性的功能有：光源发射的光可以选择性地只影响特定图层、从摄像机的可视视角中排除特定图层。 Sorting Layers用于处理2D游戏背景的远景与近景，可以为之指定z-order。 运用平面网格制作阴影用投影器制作阴影比较便利，还可以用平面网格（Plane Mesh）制作阴影，这也是移动设备游戏中常用的方式。 先删除或禁用前面添加的Blob Shadow Projetor投影器，然后进行下列操作。 在菜单中选择GameObject-&gt;3D Objeet-&gt;Quad，生成Quad模型，将其拖曳到Hierarchy视图Player游戏对象下，设置Transform属性。 删除Quad模型中默认添加的Mesh Collider组件，该组件用于处理碰撞效果。 下面为该模型附上阴影纹理。在Project视图Models/AngryBotPlayer/Materials文件夹中新建材质,重命名为shadow，然后将Models/AngryBotPlayer/Texture文件夹中的shadow纹理拖曳到Inspector视图Albedo插槽，并将Rendering Mode属性设置为Fade。 将Quad模型Mesh Renderer组件效果如下图所示。 ials属性设置为附上纹理的阴影材质shadow，完成阴影制 以上讲解了3种阴影制作方法，最后的平面网格方式计算负荷最小。但如果游戏场景中有弯曲或倾斜的路面，角色阴影会淹没在其他网格中，可能最终导致阴影无法显示。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 制作游戏场景]]></title>
    <url>%2F2019%2F03%2F23%2F%E7%AC%AC3%E7%AB%A0%20%E5%88%B6%E4%BD%9C%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 制作游戏场景时，最先要制作的是什么？ 用作纹理的图片分辨率遵守什么规则时压缩效率最高？如何调整分辨率？ 如何设置纹理平铺？ 渲染模式分为几种？ 高度图和放射是什么？ 遮挡贴图是干嘛用的？ 六面天空盒需要几次渲染调用？立方图天空盒和程序天空盒呢？ 点击下载文件 提取码: uaa4 3D模型制作游戏场景时，最先要制作的就是地面（Floor）。如果没有适合的3D模型，可以使用Unity 自带的原始模型（Primitive Mesh）中的Plane或者Cube。在此将使用Quad模型。Quad模型是由2个三角形（Triangle）和4个顶点（Vertex）构成的简单3D模型。 Unity提供的Quad原始模型 Quad是为了制作2D模型而添加的模型，已经以X轴为基准旋转了90°。 选定Quad后，设置Transform组件的Position、Rotation、Scale属性。 Transform属性 X Y Z Position 0 0 0 Rotation 90 0 0 Scale 50 50 1 将存放在Scene视图的所有游戏对象的名称均替换为直观的名称。例如，刚才制作的对象是地面，所以将其重命名为Floor。 设置游戏对象的Transform Position X、Y、Z原点 在Scene视图中创建游戏对象后，首先将其Transform组件的Position属性值设为（0, 0, 0），然后再放到合适的位置。游戏中，将Floor的Y轴坐标设置为0会对计算坐标很有帮助。假设某个模型的Y坐标大于0，则可直接导出以地面为基准时该模型的地上位置。 纹理纹理（Texture）是3D模型表面的图像文件，为3D模型附上纹理就像给人体模型穿上各种衣服一样。Unity支持PSD、PNG、JPEG、TIFF、GIF、BMP、TGA等各种格式图像文件，对于Photoshop的格式PSD，Unity会另外自动展平（Flatten）PSD文件的各种图层。（不建议使用psd格式） Unity还支持在保存纹理原文件的情况下，对其进行压缩后再使用，这样可以减少资源消耗。 用作纹理的图像文件的分辨率长宽均为2n（…，16×16，32×32，64×64，128×128，256×256，…）时，Unity对其压缩的速度最快。特别是对于移动平台，要想提高速度，就必须使用分辨率长宽均为2n（power of two，POT）的纹理文件。 导入图片，在Project视图中选择diffuse，可以查询Inspector视图的纹理的详细信息，或为其设置属性。 纹理的详细信息 上图中，Inspector视图下方的预览区域会显示纹理的图像和分辨率、使用的压缩算法以及纹理文件大小。该图中所选的diffuse纹理分辨率为1024×1024，文件大小为1.3MB。因此，如果使用其制作移动平台的版本，必须适当减小分辨率。将该纹理的Max Size设置为256，然后点击Apply按钮，可以看到纹理的文件大小变为85.4KB。 调节分辨率以适应移动平台 材质将纹理用作3D模型表面的图像文件后，还需要一种媒介联系3D模型与纹理--材质（Material）。材质用于设置3D模型的纹理的各种属性，即设置“是何种纹理、纹理间隙多少、模型表面的材质特性如何表现”等。 材质的作用 应用纹理Unity中应用纹理的方法有两种。第一种，导入纹理文件后，将Project视图中的纹理直接施放到Scene视图中的目标模型，则相应纹理文件夹中会自动生成材质文件，新生成的材质名称与纹理的文件名相同。 这虽然是应用纹理的最简单的方法，但并不建议各位使用。因为如果纹理和材质分散在各个文件夹，那么项目逐渐庞大后就很难管理。因此，建议各位使用方法二--创建材质并为其设置属性。 在Project视图创建文件夹Materials。创建新材质，将该材质重命名为Floor。 下面为Floor材质指定纹理。选定该材质，在Inspector视图中查看其属性。如下图所示，选定Floor之后，将纹理图像文件夹中的diffuse纹理拖曳到Inspector视图中的Albedo插槽、将Normal纹理拖曳到Normal Map插槽即可。设置完成后，可以通过底部预览区域查看Sphere模型附上纹理之后的效果。 除了从Project视图中拖曳纹理之外，也可以点击Inspector视图中各贴图插槽旁边的圆形图标，直接浏览并选择纹理。点击圆形图标后，IDE会打开Select Texture窗口，显示现阶段导入Project视图的所有纹理。 纹理插槽中对应的纹理预览放大功能 Inspector视图中的着色器（shader）选择的是标准（Standard）着色器时，因为各插槽当前选定的纹理预览区域很小，所以肉眼很难确认。此时可以按住Ctrl键，鼠标左键单击纹理插槽，即可放大显示对应纹理。 设定纹理后，将材质应用于游戏对象。将Floor材质直接拖曳到Scene视图的Floor游戏对象上即可。 材质可以将纹理像浴室瓷砖一样反复复制，此处将Floor材质的Tiling属性的X，Y值设定为（10,10）即可。也就是说，将一张纹理向X轴复制10次，向Y轴复制10次。 材质的预览功能 Inspector视图中，可以在材质属性等信息底部预览窗口中预览材质，并点击该窗口顶部实现最大化/最小化。此外，鼠标右击预览窗口顶部，则预览窗口从Inspector视图分离，另外打开新窗口以供预览。 点击Preview视图右上角的工具按钮，可以将已经附上纹理的球形（Sphere）模型转换为立方体（Cube ）、圆柱体（Cylinder）或圆环（Donut）模型。可以自行选择与纹理匹配的模型种类。 着色器以及基于物理的着色着色器用于渲染材质上的纹理，决定着材质的观感。着色器编程根据开发库的不同（DirectX、OpenGL等）而使用不同语言，要想涉及该领域就需要具备非常专业的知识，还要了解很多3D图像的基础理论。下面介绍如何使用着色器。 Unity环境下，即使没有关于着色器编程的知识或经验，也可以轻松使用其内置着色器。特别是Unity 5首次提供了基于物理的着色（Physically-Based Shading，PBS），该着色方式以物体具备的固有特征为基础表现材质，将现实中存在的石头、树木、玻璃、塑料、金属等材质感用一个着色器表现出来。 Unity 5重新设计了着色器，代替其历史版本中使用的多种着色器。当然，为了向下兼容，Unity4.x版本的着色器在Unity 5中被重命名为Legacy Shaders。 Unity 5的基础着色器--标准着色器为基于物理的着色提供了多种可详细设置的选项，其中比较重要的属性如下所示。 渲染模式渲染模式（Rendering Mode）可以设置为Opaque（不透明），Cutout（镂空效果），Fade（渐变效果）和Transparent（透明）等4种值，展现各种材质感。 渲染模式选项 选项 含义 Opaque 默认值，显示为不透明纹理，运用于没有任何透明部分的Solid对象 Cutout 同时显示不透明部分和透明部分，适用于草、镂空等效果 Transparent 显示透明的塑料或玻璃等材质 Fade 将具有透明属性值的模型渐隐，设为该值时可以处理渐隐/渐显的动画。因为可以渐隐不透明对象，故可用于构建全息效果 反照率反照率（Albedo）指反射光的程度，也可以称为反射率，是为了呈现Unity 5新引入的基于物理的着色而添加的纹理。其原理为“现实中所有物体的光照反射率均不相同”。 反照率纹理插槽 金属金属（Metallic）是表现物体表面金属材质感的纹理，此纹理插槽旁边的Slide值越接近1，该纹理的表现就越接近金属材质。 法线贴图法线贴图（Normal Map）是显示模型表面曲线的一种特殊纹理，无需使用多个多边形（Polygon）即可显示精细的曲面效果。法线贴图纹理插槽右边的属性值越大，阴影效果就越粗糙。 法线贴图纹理插槽和阴影属性 高度图高度图（Height Map）是使用纹理表现模型高低的一种方式，以便在游戏中表现地形（Terrain）。为其设置纹理文件后即可生效，并可以为其设置突出的高度。 遮挡贴图遮挡贴图（Occlusion）使用黑白纹理，利用间接光照产生的明暗度增强物体的立体感和深度。用于遮挡的贴图纹理一般从3D模型工具或第三方工具获取。 放射放射（Emission）指对应的纹理可以自己作为发射光源，更改其后的属性值，界面就会显示可以设置光源强度和光源颜色的选项。另外，该插槽下面会出现设置全局光照的选项。 细节遮蔽细节遮蔽（Detail Mask）用于设置二次贴图，一般用于只表现特定部分细节的纹理。 表现地面阴影--使用法线贴图下面修改先前用于地面模型的标准着色器的具体选项设置，以表现地面上的曲线。首先在Project视图中选择地面材质，并在法线贴图插槽中设置纹理文件为Images/Metal textures pack/pattern 10/normal。 在地面模型中使用法线贴图后，可以清楚地看到阴影，如下图所示。 预设预设（Prefab）的本意为活动房屋，或表示提前做好零部件并在工地直接组装的建筑方式。也就是说，将常用物体做成零部件，以便将来重复使用。 Unity中的预设指可以复制的原件，复制件（Clone）的属性与原件属性一致。因此，如果修改原件，其复制件也会自动修改。 如下图所示，复制3个做好的游戏对象，并放置到游戏场景各处。以后如果需要修改模型或属性，则需要对这3个游戏对象逐一进行修改。 但是，如下图所示，如果将游戏对象制作为预设，并将预设原件复制3个后分配到游戏场景各处，那么以后万一需要更改，则只需更改预设原件，3个复制件将自动更改。 不仅可以使用预设以高效管理游戏，也可以将其保存为资源包，轻松应用于其他项目。 用预设制作墙体下面介绍如何利用预设制作分布在游戏场景4面的墙体模型。首先，制作一个预设原件并复制该预设。选择菜单GameObject-&gt;3D Object-&gt;Cube，在Scene视图中生成正方体模型，然后重命名为墙（Wall），再如下表所示设置Transform属性。 Transform X Y Z Position 0 2 0 Rotation 0 0 0 Scale 50 4 1 放置正方体模型并为其设置Transform属性 在Project视图的Materials文件夹下新建材质，并重命名为Wall。然后分别将文件夹Images/Metal texture pack/pattern 08内的diffuse和normal纹理设置到标准着色器的反照率和法线贴图纹理插槽，并将纹理Tiling属性X、Y设置为(10,1)。 指定墙体材料的纹理 向Scene视图中的3D模型上直接拖曳材质后，模型会自动附上纹理。这就相当于为该3D模型的网格渲染器（Mesh Renderer）组件设置材质属性。 选择墙体游戏对象，Inspector视图中网格渲染器组件的材质属性中可以设置材质。在Hierarchy视图中选择墙体游戏对象，然后将事先做好的墙体材料设置到网格渲染器组件的材质属性，如下图所示。 墙体使用纹理 网格过滤器（Mesh Filter）、网格渲染器组件 Unity中的3D模型包含两种组件：网格过滤器和网格渲染器。网格过滤器组件拥有该模型的网格信息，以此网格信息为基础渲染画面的组件便是网格渲染器。 下面用Hierarchy视图的Wall制作预设。将Hierarchy视图中的Wall拖曳到Project视图，Project视图中就会生成同名对象，该对象即为预设。当然，也可以在Project视图中的右键菜单中事先新建一个预设，然后连接到Hierarchy视图中的Wall，但使用拖曳的方式更方便。 为了层次清晰、方便管理，请将新生成的预设移到Prefabs文件夹。各位以后制作的预设都可存放到该文件夹。 通过拖曳生成预设 使用颜色区分Hierarchy视图的游戏对象 如果将Unity IDE的皮肤设定为个人版，则Hierarchy视图中罗列的游戏对象默认字体颜色为黑色。字体颜色为蓝色则说明该游戏对象是预设或3D模型。选择相应的游戏对象，Inspector视图中会以纹理形式表现是否为预设或3D模型。 若删除预设原件，则Hierarchy视图中的预设名称会被标为红色；如果存在预设原件，则可将预设原件拖曳到Hierarchy视图中变红的游戏对象上，名称会变回蓝色，设置重新生效。但假若预设的原件被删除，就需要重新创建预设，或者将变为红色的游戏对象制作为预设。 红色表示删除原件的预设 Unity中所有的资源都可以复制，也就是说，不仅是游戏对象、预设、各种资源，连场景也可复制。选择Hierarchy视图的墙体，按快捷键（Windows:Ctrl+ D）即可复制墙体预设。此处将墙体复制3份，然后将这4个墙体放置到地面模型的各个角落。从Unity 5开始，系统会自动为在Hierarchy视图中复制的游戏对象名称后面赋予序号。因此，复制出的墙体预设分别命名为Wall、Wall(1)、Wall(2)、Wall(3)。 复制墙体预设并安放到地面模型的角落 如下图所示，如果想将墙体放到地面模型的角落，则无论使用鼠标拖动Transform轴还是直接改变Inspector视图的Transform属性值，都很难准确操作。 如果使用Unity提供的捕捉（Snapping）功能中的顶点捕捉（Vertex Snapping）则可轻松设置画面。选择需要移动的墙体后，按住键盘V键，拖动鼠标到特定顶点附近，墙体便会自动移动到Transform轴设置的相应顶点。 按住V键并拖动鼠标以准确捕捉到网格的角落 光照游戏开发中，是否能够有效使用光照（Light）是决定游戏氛围和完成度的重要因素之一。在游戏画面各处设置越多光照，视觉效果就越强，当然引擎负荷也会增大。因此，需要时刻注意使用最少光照达到视觉效果和游戏运行速度之间的平衡。 Unity提供的光照贴图（Lightmapping）和动态灯光探测器（Light Probe）功能可以在不明显降低游戏运行速度的前提下实现实时光照。 Unity提供以下4种光照，均可通过菜单GameObject-&gt;Light新建。Unity 5中，新建场景默认提供平行光（Directional Light）。 平行光平行光可以使整个画面呈现均匀光照，就像太阳光一样，不受位置影响。平行光照射的角度不同，影子的方向和长短则不同。 平行光的位置 场景视图中，平行光处于哪个位置都没有关系，但平行光源的Y轴坐标值要设置为大于0的数字。为了在场景视图中操作时不妨碍其他模型，我通常将平行光源的Y轴位置设置为100。 点光源点光源（Point Light）就像白炽灯，以点光源中点为中心，向四周发散照明。与平行光不同，我们可以设置Range属性以设置点光源的照射范围。 点光源的照射范围--Range属性 聚光灯聚光灯（Spot Light）光源会像手电筒一样发出圆锥形状的光，是实时光照中最消耗系统资源的光照方式。Unity提供可以调整照射角度的聚光角度（Spot Angle）属性。 区域光区域光（Area Light）通常是四边形，其中一面发光，只有在光照贴图中经过烘焙后才能呈现到画面。区域光不是实时的，主要在需要间接光照时使用。 地面上表现的区域光效果 Unity 5在后台处理烘焙的实时光照贴图，因此，虽然区域光也需要计算时间，但可以直接查看效果。 关闭实时光照贴图功能 即使是性能很高的PC机，实时的全局光照以及光照贴图的运算处理都会降低Unity IDE速度。如果速度慢到会妨碍工作或者发生中断，我建议各位关闭实时运算功能，只在需要烘焙时重新开启。选择菜单Window-&gt;Lighting打开光照视图，去掉底部Auto选项后， Unity将不再处理实时运算。 天空的表现方法天空的代表性表现方式有天空盒（Skybox）和天空穹（Skydome）。首先，天空盒将摄像机可以看到的天空分为6个面（front、back、left、right、up、down）的图像，并将其表现为立方体形式。而天空穹则在穹顶形态的网格上附上天空图像纹理呈现天空，如下图所示。 六面天空盒点击下载天空盒资源 首先学习如何使用默认六面天空盒（6 sided skybox）表现天空。新建材质并重命名为Skybox，将其着色器设置为Skybox/6 Sided即可指定天空盒的6个纹理。 大部分用于天空盒的图像文件名均为Front、Back、Left、Right、Up、Down，有时可能没有Down文件。 Exposure属性负责设置天空盒纹理曝光度，通过其可以调整天空亮度。Rotation属性可以Y轴为基准顺时针旋转天空。 选择菜单Window-&gt;Lighting，打开光照视图，在环境光照（Environment Lighting）功能的Skybox选项中设置天空盒材质。 1.先创建材质；2.选择着色器；3.添加天空盒图片；4.把材质赋给环境光照。 立方图天空盒立方图天空盒（CubeMap Skybox）方式是先建立立方图，然后用其表现天空。立方图天空盒与六面天空盒一样，需要6个纹理图像，主要用于实现物体反射远处天空环境的效果。为了使用立方图天空盒，Unity要求6个面的图像在一张纹理中，并且纹理类型（Texture Type）需要设置为立方图。 但是，将6个面的纹理合并为一个纹理图像时，需要以下表所示的3种方式进行。 合并类型 图像形态 6 Frame Layout （Cube Environment） 6个面的图像在同一平面布高 Latitude-Longitued （Cylindrical） 组合为圆柱形态的全景图像 Mirrored Ball （Spheremap） 组合为球面（Sphere）图像 程序天空盒Unity 5中，天空盒的构建方式增加到3种，除了上文介绍的六边形和立方体贴图，还有新增的程序天空盒（Procedural Skybox），程序天空盒的特点在于，可以自行设置天空颜色、大气浓度、亮度、太阳位置以及大小等。第一次打开Unity 5时，使用的默认天空盒就是程序天空盒，我们无法修改该默认值的各种属性值，所以需要另外制作。新建材质，重命名为SkyboxPC，并将其Shader选项修改为Skybox-&gt;Procedural. 属性 功能 Sun size 调整太阳大小 Atmoshpere Thickness 大气浓度-调整大气清晰或浑浊的程度 Sky Tint 调整天空颜色 Ground 调整大地颜色 Exposure 调整天空亮度 通过Sun size选项可以调整太阳图像的大小，也可以调整位置。选择菜单Window-&gt;Lighting开光照视图，将平行光设置到Sun属性，如下图所示。 现在，旋转场景视图中的平行光后，可以将太阳移动到想要的位置。 六面天空盒的渲染调用（DrawCall）消耗量 六面天空盒因使用6个纹理，故需要6次渲染调用，但立方图天空盒和程序天空盒只需要消耗一次渲染调用，所以使用后者可以降低渲染调用次数。另外，天空穹只使用一张纹理图像，所以也只消耗一次渲染调用，可以大大降低渲染调用次数。但是，不同游戏存在不同需求，需要限定最大可视范围时，使用天空穹就可能不太合适了。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1和第2章 简介与准备游戏开发]]></title>
    <url>%2F2019%2F03%2F22%2F%E7%AC%AC1%E5%92%8C%E7%AC%AC2%E7%AB%A0%20%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%87%86%E5%A4%87%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Preferences汉语是什么意思？ 如何在场景视图追踪移动的游戏对象？ Preferences基本保持原状就可以了。 To access the Preferences window, go to Edit -&gt; Preferences from the main menu in Unity. Unity provides a number of preferences that allow you to customize the behavior of the Unity Editor. Unity Preferences window A：The search box allows you to enter keywords so you can filter the list on the left by category and highlight keywords on the right. B：Preferences are grouped by category. The category list displays a list of available categories. When you click on a preference category, all preferences matching that category appear in the details pane. C：The details pane displays the list of preferences for each category. Package custom preferencesSome AssetStore or Unity packages add their own custom preferences to the Preferences window. Generally these use the package name as the preferences category. Package-specific preferences appear in the scope list For information about a specific package’s preferences, see the documentation for that package. This section contains documentation only for standard Unity preferences. General General scope on the Preferences window General preferences allow you to customize working in Unity overall. Property Function Auto Refresh Enable this option to update Assets automatically as they change.取消选中后脚本的改动不会生效。 Load Previous Project on Startup Enable this option to always load the previous Project at startup. Compress Assets on Import Enable this option to automatically compress Assets during import. Disable Editor Analytics (Pro only) Enable this option to stop the Editor automatically sending information back to Unity. Show Asset Store search hits Enable this option to show the number of free/paid Assets from the Asset Store in the Project Browser. Verify Saving Assets Enable this option if you wish to verify which Assets to save individually on quitting Unity.见图1. Script Changes While Playing Choose Unity’s behavior when scripts change while your game is running in the Editor.Recompile And Continue Playing:Recompile your scripts and keep running the Scene. This is the default behaviour, but you might want to change it if your scripts rely on any non-serializable data.Recompile After Finished Playing:Defer recompilation until you manually stop your Scene, avoiding any interruption.Stop Playing And Recompile:Immediately stop your Scene for recompilation, allowing you to quickly restart testing. Editor Skin Choose which skin to use in the Unity Editor. This is only available for Plus and Pro Unity subscriptions.Personal:Use the light grey background with black text.Professional:Use the dark grey background with white text. Enable Alpha Numeric Sorting Enable this option to display a button in the top-right corner of the Hierarchy window, which toggles between Transform sort (the default) and Alphanumeric sort. Device To Use Choose which of your computer’s graphics devices Unity should use. You can leave this on Automatic unless you want Unity to use a specific device. This setting overrides any device specified in command line options. 图1 Verify Saving Assets 2D 2D scope on the Preferences window Use the Max Sprite Atlas Cache Size (GB) preference to set the maximum size of the Sprite Atlas cache folder. Whenever possible, Unity keeps the size of this folder below this level. Grid Brush Grid Brush scope on the Preferences window Enable the Show Flood Fill Preview to preview the Tilemap you are painting in Flood Fill mode. This option is enabled by default, but you can disable it to improve performance for large fill areas. Flood Fill：用指定颜色填充一个密闭区域，相当于画图中的油漆桶。 Tile Palette Tile Palette scope on the Preferences window Choose a behavior from the Tile Palette Target Edit Mode drop-down menu to determine how to edit a Prefab instance in the Tile Palette when that instance is selected as the Active Target. Behavior Description Enable Dialog Always ask how to edit the instance (either in Prefab Mode or in the Scene). This is the default. Edit in Prefab Mode Edit the Paint target in Prefab mode. Edit in Scene Edit the Prefab instance directly in the Scene. Cache ServerAny time an Asset changes, Unity automatically re-imports it. Setting up a Cache Server drastically reduces the time it takes to import Assets. You can set up a Cache Server using remote hosting or stored on your local computer. Default Cache Server scope on the Preferences window By default, the Cache Server is disabled. To enable it, choose one of the other options from the Cache Server Mode drop-down menu: Property Function Local Use a local Cache Server on this computer. The preferences for Remote hosting appear. Remote Use a Cache Server hosted on a remote computer. The preferences for Local storage appear. Remote hosting Remote Cache Server preferences These preferences are only available when the Use Cache Server is set to Remote. Property Function IP Address Enter the IP address of the dedicated cache server that an administrator set up. Check Connection Click this button to attempt to connect to the remote Cache Server. Local storage Local Cache Server preferences These preferences are only available when the Use Cache Server is set to Local. Property Function Maximum Cache Size (GB) Specify the maximum size in gigabytes for the Cache Server on this computer’s storage. The minimum size is 1GB. The maximum size is 200GB. The default cache size is 10GB. Custom cache location Enable this option to specify a location where you want to store the cache. Cache Folder Location Click the Browse button to specify a location for the cache. Cache size is … Message displaying the current size of the cache. Before clicking the Check Cache Size button, this appears as Cache size is unknown. After clicking the button, the calculated cache size appears in the message. Check Cache Size Click this to find out how much storage the Local Cache Server is using. This operation can take some time to complete if you have a large project. Clean Cache Delete the contents of the cache. Colors Colors scope on the Preferences window The Colors preferences allow you to choose the colors that Unity uses when displaying various user interface elements. External Tools External Tools scope on the Preferences window The External Tools preferences allow you to set up external applications for scripting, working with images, and source control. Property Function External Script Editor Choose which application Unity should use to open script files. Unity automatically passes the correct arguments to script editors it has built-in support for. Unity has built-in support for Visual Studio (Express), Visual Studio Code, Xamarin Studio, MonoDevelop and JetBrains Rider. External Script Editor Args Set the arguments to pass to the external script editor.$(File) is replaced with a path to a file being opened.$(Line) is replaced with a line number that editor should jump to.$(ProjectPath) is replaced with the path to the open project.If not set on macOS, then the default mechanism for opening files is used. Otherwise, the external script editor is only launched with the arguments without trying to open the script file using the default mechanism.See below for examples of external script editor arguments. Add .unityproj’s to .sln Enable this option to add UnityScript (.unityproj) projects to the generated solution (.sln) file. This is enabled by default for MonoDevelop and Xamarin Studio, and disabled by default for Visual Studio (Express) and Visual Studio Code. Editor Attaching Enable this option to allow debugging of scripts in the Unity Editor. If this option is disabled, it is not possible to attach a script debugger to Unity to debug your scripts. Image application Choose which application you want Unity to use to open image files. Revision Control Diff/Merge Choose which application you want Unity to use to resolve file differences with the Asset serverLegacy - An asset and version control system with a graphical user interface integrated into Unity. Enables team members to work together on a Project on different computers. More info See in Glossary. Unity detects these tools in their default installation locations (and checks registry keys for TortoiseMerge, WinMerge, PlasticSCM Merge, and Beyond Compare 4 on Windows). Examples of script editor arguments Gvim/Vim: –remote-tab-silent +$(Line) “$File” Sublime Text 2: “$(File)”:$(Line) GI Cache GI Cache scope on the Preferences window The Global Illumination (GI) system uses a cache on each computer to store intermediate files used to pre-compute real-time Global Illumination. All projects on the computer share the cache. Property Function Maximum Cache Size (GB) Use the slider to set the maximum GI cache folder size. Unity keeps the GI cache folder size below this number whenever possible. Unity periodically deletes unused files to create more space (deleting the oldest files first). This is an automatic process, and doesn’t require you to do anything.Note: If the current Scene is using all the files in the GI cache, increase your cache size. Otherwise, resource-intensive recomputation occurs when baking. This can happen when the Scene is very large or the cache size is too small. Custom cache location Enable this option to allow a custom location for the GI cache folder. By default, the GI cache is stored in the Caches folder. All Projects share the cache folder.Tip: Storing the GI Cache on an SSD drive can speed up baking in cases where the baking process is I/O bound. Cache Folder Location Click the Browse button to specify a location for the cache. Cache compression Enable this option to allow Unity to compress files in the GI cache and reduce the size of the generated data. The files are LZ4-compressed by default, and the naming scheme is a hash and a file extension. The hashes are computed based on the inputs to the lighting system, so changing any of the following can lead to recomputation of lighting:- Materials (Textures, Albedo, Emission)- Lights- Geometry- Static flags- Light Probe groups- Reflection probes- Lightmap ParametersTip: If you need to access the raw Enlighten data, disable Cache Compression and clean the cache. Clean Cache Use this button to clear the cache directory.It is not safe to delete the GI Cache directory manually while the Editor is running. This is because the Editor creates the GiCache folder when it starts and maintains a set of references to those files. The Clean Cache button ensures that the Editor releases all references to the files on disk before they are deleted. Draw mode menu绘制模式（Draw Mode）又分为阴影模式（ShadingMode）、混合模式（Miscellaneous）、延时模式（Deferred）、全局照明（Global Illumination）模式。 阴影模式阴影模式中，根据子绘制模式的不同，Scene视图展示的画面将产生如下变化。 Shaded：默认选项，3D模型表面会附着纹理。 Wireframe：消除纹理，仅呈现3D模型的网格骨架（Mesh）。 Shaded Wireframe：同时呈现阴影和网格。 混合模式 Shadow Cascades：使用实时阴影时，设置生成的阴影贴图（Shadow Map）分辨率。距摄像机越远，阴影的分辨率越低。 阴影质量设置为4级（Four Cascades）时的场景视图 图片1 Render Paths：渲染方式不同，画面将呈现不同颜色。 不同颜色代表的渲染方式 Render Paths颜色 渲染方式 青色 延时阴影（Deferred shading） 绿色 延时光照（Deferred lighting） 黄色 正向渲染（Forward rendering） 红色 顶点光照（Vertex Lit） Alpha Channel：呈现已透明处理的黑白3D模型。 Overdraw：对于过度渲染的像素点，选择该项可使其颜色重叠，并呈现更深颜色。Overdraw意指摄像机可视范围外发生重复渲染的像素点，其产生的主要原因是硬件性能过低。 Mipmaps：降低距摄像机较远的纹理品质，从而减轻渲染负荷。此模式下，Unity会判断使用Mipmap处理的纹理大小是否合适。如果纹理过大，则视图画面呈现红色，反之则呈现蓝色。 Unity 5.x版本添加了新的延时模式，如果主摄像机的Rendering Path设置为Deferred，则该模式激活。该模式下，只能看到过滤后的Albedo、Specular、Smoothness以及Normal纹理。 如果想追踪移动的游戏对象，可以快速按两次快捷键F。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5权威讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在3D游戏中放置2D图形用户界面]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%9C%A83D%E6%B8%B8%E6%88%8F%E4%B8%AD%E6%94%BE%E7%BD%AE2D%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[本章涵盖： 比较旧GUI系统（Unity4.6之前）和新GUI系统 创建用于界面的画布 通过锚点定位UI元素 为UI添加交互（按钮、滑动条等） 从UI广播和侦听事件 本章中将构建一个在第一人称demo游戏虚拟场景上显示的2D界面。每个游戏除了进行游戏玩法的虚拟场景外，还需要一些抽象交互和一些信息显示。 这些抽象的交互显示被称为UI，更具体而言就是GUI。GUI指的是界面的可视化部分，例如文本和按钮（如下图所示）。 在游戏中，文本和按钮通常覆盖在游戏视图上，这是一种称为HUD的显示。 平视显示（HUD，heads-up display）使得图形叠加在世界视图上。这个概念源于军用飞机，目的是为了让飞行员不低头就能看到重要信息。类似的，GUI像HUD一样叠加在游戏视图上。 步骤：(1)规划界面(2)放置显示的UI元素(3)对UI元素编写交互(4)让GUI响应场景中的事件(5)让场景响应GUI上的动作 前期准备直接模式GUI还是高级2D界面Unity的第一个GUI系统是直接模式（immediate mode）GUI系统，该系统可以使在屏幕上放置按钮很简单。代码清单1展示了使用直接模式GUI系统的代码。 直接模式在每帧显式发出绘制命令，而对于另一种系统，只需要一次定义所有的视觉效果，之后系统就知道每帧需要绘制什么，而不必再重新声明。后一种方法称为保留模式（retained mode）。 代码清单1 使用直接模式GUI创建按钮的示例 1234567891011121314using UnityEngine;using System.Collections;public class BasicUI : MonoBehaviour&#123; // 函数在每帧渲染其他所有对象之后调用 void OnGUI() &#123; if (GUI.Button(new Rect(10, 10, 40, 20), "Test")) // 参数：位置X，Y，宽度，高度和文本标签 &#123; Debug.Log("Test button"); &#125; &#125;&#125; 上面代码清单中的核心代码是OnGUI()方法。非常类似于Start()和Update()，每个MonoBehaviour自动响应OnGUI()方法。这个方法会在每帧渲染完3D场景后执行，它提供了一个放置GUI绘制命令的入口。这段代码绘制了一个按钮；注意，用于绘制按钮的命令会在每帧执行（这就是直接模式）。按钮命令以条件判断的方式使用，这使得按钮被按下时可以进行响应。 新的UI系统基于保留模式工作，因此图形只需要布局一次就能在每帧被绘制而不需要重新定义。在这个系统中，用于UI的图形放置在编辑器中。相比于直接模式UI，这提供了两个优势： 1)可以在放置UI元素时看到当前UI的外观。2)这个系统可以让使用图像来定制UI变得更直接。 为了使用这个系统，需要导入图像并将对象拖动到场景中。接下来规划UI的外观。 规划布局接下来将在主游戏视图之上的屏幕角落中放置显示分数和设置按钮的UI（如下图所示）。设置按钮将打开一个弹出窗口，该窗口中包含一个文本域和一个滑动条。输入控件将用于设置玩家的姓名和移动速度。 导入UI图像UI需要一些用于显示类似按钮之类的图像。下面使用2D图像构建UI，因此需要遵循以下两个步骤： (1)导入图像（如果有必要，设置它们为Sprite）(2)将精灵拖动到场景中 首先将图像拖动到Project视图中，接着在Inspector中将它们的Texture Type设置改为Sprite(2D And UI)。 将图像导入到项目中。确保所有导入的资源都被设置为Sprite，你可能需要在导入之后调整设置中的Texture Type。 这些精灵构成了接下来将创建的按钮、分数显示和弹出窗口。现在图像已导入，下面将这些图形放置到屏幕上。 设置GUI显示美术资源和2D精灵是同一种资源，但这些资源在场景中以稍微不同的方式使用。Unity提供了一些特殊的工具，使图像成为HUD并显示在3D场景上，而不是显示作为场景一部分的图像。UI元素的定位通常有一些特殊技巧，因为显示可能需要根据不同的屏幕上进行变化。 为界面创建画布UI系统工作原理中最基础且最特殊的一面是所有图像必须附加到画布对象上。 画布（Canvas）是Unity用于为游戏渲染UI的一类特殊对象。 Hierarchy视图右键“UI-&gt;Canvas”创建Canvas。在场景中将会出现一个Canvas对象并重命名为HUD Canvas。该对象代表整个屏幕的范围，而且它的大小相对于3D场景，因为它将屏幕上的一个像素缩放为场景中的一个单位。 当创建Canvas对象时，也会自动创建EventSystem对象。对于UI交互，该对象是必需的，但你可以忽略它。 切换为2D视图模式（见下图）并双击Hierarchy中的画布，缩放视图使得完全可以看到它。 Scene视图面板顶部的按钮控制所显示的内容，因此查找Effects按钮，关闭天空盒。 画布中有一些可以调整的设置。首先是Render Mode选项，让它保持默认设置，但你应该知道如下三种设置的含义： Screen Space-Overlay：将UI渲染为摄像机视图顶部的2D图形（这是默认设置）。 Screen Space-Camera：也将UI渲染在摄像机视图顶部，但UI元素可以进行透视效果的旋转。 World Space：将画布对象放置在场景中，就好像UI是3D场景的一部分。 初始默认设置之外的另外两种模式有时对于实现特殊效果很有用，但也会稍微复杂一些。另外一个重要的设置是Pixel Perfet。这个设置导致渲染轻微调整图像的位置，以使图像完全清晰和锐利（相反，在像素之间定位时会模糊它们）。继续并选中复选框。现在HUD画布已经设置完毕，但它依然是空白的，此时需要一些精灵。 按钮、图像和文本标签画布对象定义了一个用于显示UI的区域，但它依然需要精灵来显示。因此，在GameObject菜单的UI部分只要为每个元素创建图像、文本或按钮即可。 为了正确显示UI元素，UI元素需要成为画布对象的子节点。Unity自动处理了这个操作，但记住，通常可以在Hierarchy视图（如下图所示）中拖动对象来创建父子关系。 画布中的对象可以因为定位的原因成为其他对象的父节点，就像场景中的任何对象一样。例如，你可能想把文本对象拖放到图像对象上，使文本随着图像的移动而移动。类似的，默认按钮对象有文本对象作为其子节点，这个按钮不需要文本标签，因此可以删除文本对象。 将UI元素粗略定位到角落。现在拖动对象，直到将它们放在比较协调的位置。单击并将图像对象拖放到画布的左上角，将按钮移到右上角。 在2D模式下使用Rect工具。把它描述为一个合并了三种变换（Move、Rotate和Scale）的工具。这些操作在3D模式中拆分为单独的工具，但在2D模式中需要合并起来，这是因为在2D模式中有一个维度不需要关心。 此时，图像是空白的。如果选择一个UI对象并观察它的Inspector，将会发现图像组件的顶部附近有一个Source Image槽。如下图所示，从Project视图中拖动精灵（记住不是贴图！），将其赋给对象的图像。将敌人精灵赋给图像对象，并且将齿轮精灵赋给按钮对象（在将精灵赋到对象后单击Set Native Size来修正图像对象的大小）。 首先关注敌人图像和齿轮按钮的外观。对于文本对象，在Inspector中有一些设置。首先，在大的Text框中输入一个数字；这个文本以后将被覆盖，但现在还是有用的，因为它看起来像是在编辑器中显示分数。由于该文本太小，因此增加Font Size为24并设置样式为Bold，你可能还想设置这个标签为水平左对齐（如下图所示）和垂直居中对齐。现在剩余的设置保留它们的默认值即可。 除了Text盒和对齐，最常见的调整的属性就是字体。可以将TrueType字体导入到Unity中，然后将该字体放置到Inspector中。 现在精灵已经被赋到UI图像，分数文本也已设置好，可以单击Play看看3D游戏顶部的HUD，如下图所示，显示在Unity的编辑器中的画布显示了屏幕的边界，可以在屏幕的这些位置上绘制UI元素。 很好，已经在3D游戏中使用2D图像显示了HUD！还有一个更复杂的可视化设置需要完成：相对于画布来定位UI元素。 控制UI元素的位置所有UI对象都有锚点（anchor），在编辑器中显示为target X（如下图所示）。锚点是一种在UI中灵活定位对象的方式。 对象的锚点是对象附加到画布或屏幕的点，它决定了计算对象的位置所依赖的点。 位置是类似“X轴偏移50像素”这样的值。但存在一个问题：这50像素是相对什么而言？这正是锚点存在的原因。锚点的作用是当对象相对于锚点放置时，锚点相对画布移动。锚点定义为类似“屏幕中心”，那么当屏幕改变大小时锚点依然会在中心。类似的，设置锚点为屏幕的右边会让对象不管屏幕是否改变大小都保留在右边。 理解所说的内容最简单的方式就是实践。选择图像对象并观察Inspector。锚点设置（如下图所示）将会出现在transform组件下的右侧。默认情况下，UI元素让它们的锚点设置为Center，但是可以将这个图像的锚点设置为Top Left；下图演示了如何使用Anchor Presets对锚点进行调整。 同样，下面修改齿轮按钮，设置这个对象的锚点为Top Right；单击右上角的Anchor Preset。现在尝试缩放窗口的左右：单击并拖动Scene视图的边。由于存在锚点，UI对象会在画布改变大小时一直保留在角落。如下图所示，这些UI元素会在屏幕移动时固定在位置上。 锚点能同时调整缩放和位置。图像上的每个角落都可以定位到屏幕的不同位置。下图中图像没有改变大小，但可以调整锚点使得当屏幕改变大小时图像进行缩放。 所有的可视化设置已经完成，现在是时候编写程序进行交互了。 编写UI中的交互在与UI交互之前，需要有鼠标光标。如果回想一下，就会记起该游戏是在RayShooter代码的Start()方法中调整Cursor设置。这些设置锁定并隐藏了鼠标光标，这种行为在FPS游戏的控件中可以正常工作，但是影响了UI的使用。从RayShooter.cs中移除这些设置光标的代码，这样就可以单击HUD。 只要打开了RayShooter.cs，就可以确保当与GUI交互时不能射击。代码清单2可以实现这一点。代码清单2 在RayShooter.cs中添加GUI检查的代码 12345678910using UnityEngine.EventSystems; // 包含UI系统代码框架// ...void Update() &#123; if(Input.GetMouseButtonDown(0) &amp;&amp; !EventSystem.current.IsPointerOverGameObject()) // 检查GUI未被使用 &#123; Vector3 point = new Vector3(camera.pixelwidth/2, camera.pixelHeight/2, 0); // ... &#125;&#125; 现在可以运行游戏并单击按钮，尽管该游戏还没有任何功能。可以看到，当鼠标移到按钮并单击时，它的颜色发生了变化。这个鼠标悬停和单击时表现为默认的染色，对于每个按钮都可以修改这个染色，但现在默认颜色看起来还可以。你可以加速默认的淡入淡出行为，Fade Duration是按钮组件中的设置，可以尝试将其减少为0.01并观察按钮如何变化。 有时，UI默认的交互控件会影响游戏。记住EventSystem对象会随着画布被自动创建。EventSystem对象控制UI交互控件，默认情况下，它使用方向按键来与GUI进行交互。你可能需要关闭EventSystem中的方向按键：在Event System设置中，不要选中Send Navigation Event复选框。 但当单击按钮时什么事情也没有发生，因为现在还没有关联按钮到任何代码。下面将编写代码。 编写不可见的UIController通常，所有UI元素的UI交互都一样，都以一系列标准步骤进行编写： (1)在场景中创建UI对象(前面部分创建的按钮)(2)编写当操作UI时调用的代码(3)将脚本附加到场景的对象上(4)通过脚本将UI元素（如按钮）关联到对象上 首先需要创建控制器对象来关联按钮。创建UIController脚本，并将该脚本拖动到场景中的控制器对象上。 对按钮编程的UIController脚本 12345678910111213141516171819using UnityEngine;using UnityEngine.UI; // 导入UI代码框架using System.Collections;public class UIController : MonoBehaviour &#123; [SerializeField] private Text scoreLabel; // 在场景中引用文本对象，设置文本属性 void Update() &#123; scoreLabel.text = Time.realtimeSinceStartup.ToString(); &#125; // 由设置按钮调用的方法 public void OnOpenSettings() &#123; Debug.Log("open settings"); &#125;&#125; 现在将对象拖动到组件槽，连接它们。将分数标签（我们之前创建的文本对象）拖动到UIController的文本槽。UIController中的代码设置了显示在该标签上的文本。当前代码显示了一个定时器，以测试文本显示；这将会在后面修改为分数。 接下来，将一个OnClick条目添加到按钮上并将控制器对象拖动到它上面。选中按钮观察它在Inspector中的设置。移动到底部，你将看到OnClick面板，初始时该面板为空，但如下图所示，可以单击+按钮在面板上添加一个条目，每个条目都定义了一个函数，当单击按钮时就会调用这个函数。这个列表中包含了一个对象槽和一个用于调用函数的菜单。将控制器对象拖动到对象槽上，并在菜单中查找UController，选择其中的OnOpenSettings()。 响应其他鼠标事件OnClick是按钮组件暴露给外部的唯一事件，但UI元素能响应各种不同的交互。为了使用默认交互以外的交互，可以使用EventTrigger组件。 将一个新组件添加给按钮对象，在组件的菜单中查找Event部分。从该菜单中选择EventTrigger。尽管按钮的OnClick只响应一次完整单击（按下鼠标按键并释放），接下来尝试响应鼠标按下且不松开的事件。执行之前和响应OnClick事件一样的操作，但仅响应另一个不同的事件。首先将另一个方法添加给UIController： 1234public void OnPointerDown()&#123; Debug.Log("pointer down");&#125; 现在单击Add New Event Type，给EventTrigger组件添加一个新类型。选择PointerDown作为事件。这个操作将创建空的事件面板，就像OnClick面板一样。单击+按钮，添加事件列表，将控制器对象拖动到这个新增事件上，并选择菜单中的OnPointerDown()。 运行游戏并单击按钮，在控制台中输出调试消息。同样，当前代码只是随机输出，以测试按钮的功能。我们希望打开一个弹出的设置窗口，因此接下来创建弹出窗口。 创建弹出窗口UI中包含一个用于打开弹出窗口的按钮，但目前还没有弹出窗口。弹出窗口是一个新的图像对象，在这个对象上附加有几个控件（例如，按钮和滑动条）。第一步是创建一个新图像，因此选择GameObject-&gt;UI-&gt;Image。和之前一样，新图像在Inspector中有称为Source Image的图像槽，将精灵拖动到那个槽上，设置这个图像，这次使用称为popup的精灵。 通常，精灵在整个图像对象上被缩放，这是score和gear图像工作的方式，单击Set Native Size按钮，重新设置图像对象的大小。这个行为是图像对象的默认设置，但弹出窗口将做一些不同的处理。 如下图所示，图像组件有Image Type设置。这个设置默认为Simple，这正是之前使用的正确图像类型，对于弹出窗口，将Image Type设置为Sliced。 切割图像（sliced image）是把图像切划为九份，以便能缩放为不同的图像。通过从中间缩放图像边缘，可以确保图像在保留边缘大小和形状时被缩放为任何你期望的尺寸。在其他开发工其中，此类图像通常在其名称中有个“九”字（例如，九切割、九片、缩放九）。表示图像有九部分。 在切换到切割图像之后，Unity可能会在组件设置中显示一个错误，表明图像没有边框。这是因为popup精灵还没有设置为九部分，为了设置该精灵，首先选择Project规图中的popup精灵。在Inspector中应该会看到Sprite Editor按钮（如下图所示），单击该按钮将出现Sprite Editor窗口。 在Sprite Editor中可以看到，绿色的线指示了图像是如何被切割的。初始时图像不会有任何边框（即，所有Border被设置为0）。增加4条边的边框宽度，将出现如下图所示的边框，因为所有4条边（左、右、底部、顶部）的边框被设置为12像素宽，所以边框线同时叠加为九部分，关闭编辑器窗口并应用修改。 现在精灵已被定义为九部分，切割的图像将正常工作（Image组件设置将显示FillCenter，请确保开启了这个设置），单击并拖动图像角落的蓝色指示器来缩放它（如果没看到任何缩放指示器，选择Rect工具），当中心部分缩放时，边框部分将保留它们的大小。 由于边框部分保留它们的大小，因此切割图像可以被缩放为任何大小并且保持清晰的边缘，这对于UI元素而言很完美--不同窗口可能大小不同，但看起来依然一样。对于弹出窗口，设置宽度为250，高度为200，让它看起来如下图所示（同时设置坐标为(0,0,0)让它居中）。 UI图像如何彼此堆放取决于它们在Hierarchy视图中的顺序。在Hierarchy列表中，将弹出对象拖动到其他UI对象上（当然，还是保持附加到画布上）。现在在Scene视图中移动弹出窗口；将看到图像和弹出窗口重叠。最后将弹出窗口拖动到画布底部，以使它显示在其他任何UI元素之上。 弹出对象现在已经设置好，因此可以为它编写代码。创建一个称为SettingsPopup的脚本，并将脚本拖动到弹出对象上。 12345678910111213141516using UnityEngine;using System.Collections;public class SettingsPopup : MonoBehaviour&#123; public void Open() &#123; gameObject.SetActive (true); // 开启对象，打开窗口 &#125; public void Close() &#123; gameObject.SetActive(false); // 使对象无效，关闭窗口 &#125;&#125; 接下来，打开UIController.cs做一些调整，代码如下所示。 123456789101112[SerializeField] private SettingsPopup settingsPopup;void Start()&#123; settingsPopup.Close(); // 游戏开始时，关闭弹出窗口&#125;public void OnopenSettings()&#123; settingsPopup.Open(); // 使用弹出窗口的方法替换调试文本&#125; 这段代码添加了一个弹出对象的对象槽，因此将弹出对象拖动到UIController上。现在当运行游戏时弹出对象将被关闭，当单击设置按钮时将打开。 此时还无法关闭弹出窗口，因此将关闭按钮添加到弹出窗口上。这一步和之前创建按钮的步骤类似：选择GameObject-&gt;UI-&gt;Button，将新按钮定位到弹出窗口的右上角，将close精灵拖动到这个UI元素的Source Image属性，接着单击Set Native Size正确设置图像的大小。与之前的按钮不同，这次我们需要文本标签，因此选择文本并在文本域中输入Close，并设置颜色为白色。在Hierarchy视图中，将按钮拖动到弹出对象上，使其成为弹出窗口的子节点。而且作为打磨，调整按钮的transition属性的Fade Duration值为0.01，让Normal Color更暗，设置为110, 110, 110, 255。 为了让按钮关闭弹出窗口，需要一个OnClick条目：单击OnClick面板的+按钮，将弹出窗口拖动到对象槽中，并从函数列表中选择Close()，现在运行游戏，这个按钮将关闭弹出窗口。 弹出窗口已被添加到HUD中。窗口当前还是空白的，因此接下来将一些控件添加到窗口中。 使用滑动条和输入域设置值将一些控件添加到弹出的设置窗口包括两个步骤，这与之前创建按钮的步骤一样。创建UI元素并将其附加到画布上，再将这些对象关联到脚本上。我们需要的输入控件是一个滑动条和一个文本域，还需要一个用于标识滑动条的静态文本标签。选择GameObject-&gt;UI-&gt;Text创建文本对象，选择GameObjet-&gt;UI-&gt;InputField创建文本域，而选择GameObject-&gt;UI-&gt;Slider创建滑动条对象（如下图所示）。 通过在Hierarchy视图中拖动这三个对象使其成为弹出窗口的子对象，并如下图所示定位它们，并将它们排列在弹出窗口的中心。设置文本为Speed，以便将它作为滑动条的标签。输入域用于输入文本，Text属性在玩家输入任何内容之前都显示在盒子中；这里设置Text的值为Name。可以让ContentType和LineType保留为默认值，如果需要，可以使用Content Type来限制输入类型，例如只输入字母或数字；另外，可以使用LineType将文本输入切换为单行或多行文本。 当文本标签覆盖在滑动条上时，将无法单击它，通过在Hierarchy中将文本对象放在滑动条之上，可以确保文本对象出现在滑动条的下方。 就其滑动条自身而言，组件Inspector底部有很多设置。Min Value默认设置为0，保持其默认设置。Max Value默认为1，但本示例中需要修改为2。类似的，Valu和WholeNumbers都可以保留其默认设置，Value控制滑动条的开始值，而Whole Numbers限制它为012而不是小数值（这个项目不受限）。 现在所有对象都已处理完毕。现在需要编写关联对象的代码。如代码清单6.6所示。将一些方法添加到SettingsPopup.cs中。代码清单6.6 SettingsPopup中用于弹出窗口的输入控件的方法 12345678public void OnSubmitName(string name) &#123; Debug.Log(name); // 当用户在输入域输入时触发该方法&#125;public void OnSpeedValue(float speed) &#123; Debug.Log("Speed: "+ speed); // 当用户调整滑动条时触发该方法 &#125; 很好，现在已经有了用于控件的方法，下面开始处理输入域。在输入域的设置中可以看到End Edit面板，其中列出的事件会在完成输入时触发，给这个面板添加一个条目，将弹出窗口拖动到对象情，并在函数列表中选择OnSubmitName()。 一定要在End Edit面板顶部的Dynamic String部分选择该函数，而不是在底部的StaticParameters部分选择，OnSubmitName()方法会出现在这两部分，但在Static Parameters中选择时将只会发送提前定义的单个字符串，而在Dynamic String中选择时发送的是输入域中输入的任何内容。 对于滑动条完成相同的步骤：查找组件设置底部的事件面板（本示例中需要查找的面板是OnValueChanged），单击+按钮添加一个条目，将弹出窗口拖动到对象槽上，并在列出的动态值函数中选择OnSpeedValue()。 现在所有输入控件已经关联到弹出脚本中的代码，运行游戏，移动滑动条或者在输入之后按下Enter键并观察控制台。 使用PlayerPrefs保存游戏过程的设置Unity中有一些不同的方法用于保存持久化的数据，最简单的方法称为PlaycrPrefs。Unity提供了一种抽象（也就是说不必关心细节）的可以工作在所有平台（使用它们不同的文件系统）的保存小量信息的方式。 PlayerPrets不适合保存大量数据，但它们用于保存游戏设置还是非常有用的。 PlayerPrefs提供了一些简单的命令用于获取和设置值（它的原理类似哈希表或字典）。 例如，在SettingsPopup脚本的OnSpeedValue()方法内，可以通过添加行PlayerPrefs.SetFloat(“speed”, speed);保存速度设置。OnSpeedValue方法将浮点数保存到一个speed值中。类似的，你可能会将滑动条初始化为所保存的值，将如下代码添加到SettingsPopup脚本中： 123456789using UnityEngine.UI;..[SerializedField]private slider speedSlider;void Start()&#123; speedSlider.value = PlayerPrefs.GetFloat("speed", 1);&#125;.. 注意，get命令获取值的同时也指定了默认值，以备之前没有保存speed值。 尽管控件生成调试输出，但它们依然不能真正影响游戏。让HUD影响游戏（反之亦然）是本章最后一节要讨论的话题。 通过响应事件更新游戏截至目前，HUD和主游戏之间互不相干，但它们之间应该是相互通信的。为此，可以通过我们为其他类型的对象通信所创建的脚本引用来完成，但这样做存在一些缺陷，特别是，这样做将把场景和HUD紧密耦合在一起，但你可能想要让它们相对独立，这样可以在编辑游戏时不必担心是否破坏HUD。 为了通知场景中UI的行为，接下去将使用消息广插系统。下图阐述了这个事件消息系统的工作原理：脚本可以注册为侦听事件，其他代码可以广插事件，接着侦听器将被通知有关广播的消息。接下来介绍消息系统以便完成它。 C#有一个内置的系统用于处理事件，所以你可能好奇为什么我们不使用内置的系统。内置的事件系统强制要求消息的目标，而我们需要的是广播消息系统，目标系统需要代码精确知道消息的来源而广播的来源可以是任意的。 集成事件系统为了通知场景中UI的行为，需要使用广播消息系统。尽管Unity没有这个内置特性，但线上已经存在用于这个功能的脚本。Unity的社区wiki，这是一个由其他开发者贡献的免费代码库。它们的消息系统为程序间的事件通信提供了一种解耦的方式。当一些代码广播消息时，代码不需要知道关于侦听器的任何消息，在切换或添加对象时，这提供了巨大的灵活性。 创建一个脚本，命名为Messenger，并将http://wiki.unity3d.com/index.php/CSharpMessenger_Extended页面的代码粘贴到脚本中。 接着需要创建一个名为GameEvent的脚本，如代码清单6.7所示。代码清单6.7 Messenger中使用的GameEvent脚本 12345public static class GameEvent &#123; public const string ENEMY_HIT = "ENEMY HIT"; public const string SPEED_CHANGED = "SPEED CHANGED";&#125; 代码清单中的脚本定义了一些事件消息的常量，消息通常以这种方式组织，你不必在每个地方都记住和输入消息字符串。 现在事件消息系统已经准备就绪，接下来开始使用它，首先将它用于场景和HUD的通信，接着用于其他方面。 从场景中广播和侦听事件截止到现在，分数显示依然把显示一个计时器作为文本显示的功能，但我们需要显示击中敌人的计数器，因此修改UIController中的代码，首先删除整个Update()方法，因为这是测试代码。当敌人死亡时，将会触发事件，因此代码清单6.8让UIController侦听该事件。 代码清单6.8 将事件侦听器添加到UIController 12345678910111213141516171819202122232425private int _score;void Awake()&#123; Messenger.AddListener(GameEvent.ENEMY_HIT, OnEnemyHit); // 声明响应事件ENEMY_HIT的方法&#125;void OnDestroy() // 当对象被销毁时，使用清除侦听器防止出错&#123; Messenger.RemoveListener(GameEvent.ENEMY_HIT, OnEnemyHit);&#125;void Start()&#123; _score = 0; // 将分数初始化为0 scoreLabel.text = _score.ToString (); settingsPopup.Close();&#125;private void OnEnemyHit()&#123; score += 1; scoreLabel.text = score.ToString(); // 响应事件时添加积分&#125; 首先注意Awake()和OnDestroy()方法。就像Start()和Update()方法一样，在对象唤醒或移除时每个MonoBehaviour都会自动响应这两个方法，在Awake()中添加侦听器并在OnDestroy()中移除它。这个侦听器是广播消息系统的一部分，而且当收到消息时，它会调用OnEnemyHit()。OnEnemyHit()将递增分数并把值放到分数显示中。 事件侦听器已经在UI代码中设置，因此现在不管敌人在何时被击中都需要广播。响应击中敌人的代码位于RayShooter.cs中，因此如下代码清单将触发消息。由RayShooter广播事件消息 12345678if (target != null)&#123; target.ReactToHit(); Messenger.Broadcast(GameEvent.ENEMY_HIT); &#125; else&#123; // 响应受击时添加的消息广播&#125; 在添加消息后运行游戏并观察当射击敌人时分数的显示，你将看到当每次击中敌人时分数都会增加。这个示例介绍了从3D游戏向2D界面发送消息,但我们还需要一个从2D界面向3D游戏发送消息的示例。 从HUD广播和侦听事件在上一节中，从场景广播事件并且被HUD接收。同样，UI控件可以广播玩家和敌人侦听的消息。通过这种方式，设置弹出窗口可能会影响游戏设置。打开WanderingAI.cs并添加代码。添加到WanderingAI的事件侦听器 12345678910111213141516public const float baseSpeed = 3.0f; // 由速度设置调整的基本速度vold Awake()&#123; Messenger&lt;float&gt;.AddListener(GameEvent.SPEED_CHANGED, OnSpeedChanged);&#125;void OnDestroy()&#123; Messenger&lt;float&gt;.RemoveListener(GameEvent.SPEED_CHANGED, OnSpeedChanged);&#125;private void OnSpeedChanged(float value) // 声明该方法，用于侦听事件SPEED_CHANGED&#123; speed = baseSpeed * value;&#125; 这里的Awake()和OnDestroy()方法也分别用于添加并移除事件侦听器，但在此它们都有值，用于设置wanderingAI的速度。 上一节中的代码使用的只是一般事件，但该消息系统可以传值和消息，支持侦听器中的值就像添加类型定义一样简单。注意&lt;float&gt;被添加到侦听器命令。 现在在FPSInput.cs中进行同样的修改来影响玩家的速度。代码大部分和之前代码一样，只是玩家的baseSpeed不同。 添加到FPSInput的事件侦听器 123456789101112131415public const float baseSpeed = 6.0f; // 这个值相对之前代码做了修改vold Awake()&#123; Messenger&lt;float&gt;.AddListener(GameEvent.SPEED_CHANGED, OnSpeedChanged);&#125;void OnDestroy()&#123; Messenger&lt;float&gt;.RemoveListener(GameEvent.SPEED_CHANGED, OnSpeedChanged);&#125;private void OnSpeedChanged(float value) &#123; speed = baseSpeed * value;&#125; 最后，从SettingsPopup中广播速度值，响应滑动条。从SettingsPopup中广播消息 1234public void OnSpeedValue(float speed)&#123; Messenger&lt;float&gt;.Broadcast(GameEvent.SPEED_CHANGED, speed); // 把滑动条的值作为&lt;float&gt;事件发送 &#125; 现在，当你调整滑动条时，玩家和敌人的速度都会改变。 练习：修改所生成的敌人的速度当前只会更新已存在于场景中的敌人的速度值，而不会影响新生成的敌人的速度值；新敌人并没有以正确的速度设置创建。将SPEED_CHANGED侦听器添加给SceneController，因为该脚本是生成敌人的代码。 小结 Unity有立即模式的GUI系统，也有基于2D精灵的新GUI系统。 将2D精灵用于GUI需要场景有一个画布对象。 UI元素能锚定在可调整画布的相对位置上。 设置Active属性来打开或关闭UI元素。 解耦的消息传送系统是在界面和场景之间广播事件的一种好方法。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5实战-使用C#和Unity开发多平台游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity灯光与渲染]]></title>
    <url>%2F2019%2F03%2F19%2FUnity%E7%81%AF%E5%85%89%E4%B8%8E%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[基于Unity 2017。 天空盒自己制作一个天空盒。网上下载这样的图片。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Siki</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天空盒的应用]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%A4%A9%E7%A9%BA%E7%9B%92%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[天空盒（Skyboxes）技术的思路十分简单，具体来说就是将整个场景放在一个由6幅正方形的纹理图无缝拼接组成的立方体中，将摄像机放置在这个立方体中，在视野里看来就像是位于真实的自然界中一样。因此，天空盒对于搭建真实的自然场景是必不可少的。 Unity的天空盒是一种特殊的渲染材质，在渲染设置中选择适当的天空盒材质即可。在Unity 5.0版本中去掉了其自带的强大的天空盒资源，因此需要从网上下载一些原有的天空盒资源包。 Unity天空盒资源Unity中的天空盒的使用有两种方法，一种是在依次单击“Window-&gt;Lighting-&gt;Settings”后打开的“Lighting”窗口下的“Scene”选项卡，如下图所示，这种方法是为整个场景添加天空盒，切换摄像机后天空盒不会改变。 另外一种方法是为摄像机添加天空盒，切换摄像机后天空盒会发生变化，如下图所示。 (1)直接把天空盒文件夹拖进Project视图，在导入完成后，在Project列表中会出现一个专门存放天空盒资源的文件夹。 (2)选中项目资源列表中的任意一个材质球时，在属性查看器中就会显示这个天空盒材质的具体属性材质，也可以更加详细地理解天空盒的组成。 (3)通过上图所示可以看到附加在天空盒上面的6幅纹理图。这6幅图就是特殊制作的纹理图，虽然看起来是6幅图，但实际上是一幅整图。在此可以添加对应的纹理图并改变每幅图对应的具体参数，即完成对天空盒的设置。 (4)下面介绍摄像机天空盒的添加方法。选中摄像机，依次单击“Add Component-&gt;Skybox”，然后将任意一个天空盒材质拖曳到Skybox右框当中，单击运行按钮运行场景。效果如下图所示。 开发实际需要的天空盒在实际开发过程中需要自己制作满足开发要求的天空盒，所以下面将介绍如何开发实际需要的天空盒（主要就是将游戏对象材质渲染模式修改为天空盒的渲染模式），制作过程如下。 (1)在Project属性列表中选中“Assets”，单击鼠标右键选择“Create-&gt;Material”，即可在项目中创建一个材质，重命名为“Skyboxtwo”。在项目资源列表中就会出现一个名为“Skyboxtwo”的材质。 (2)选中项目资源列表中的Skyboxtwo材质，在属性查看器中修改其渲染模式为Skybox模式，具体的修改步骤如下图所示。在修改完成后，属性查看器就会变得如图1所示。 (3)在开发环境中依次单击“Assets-&gt;Import New Asset”命令，选择需要导入的纹理图片。选中导入的图片资源将其Wrap Mode选项由Repeat修改为Clamp模式，这样能够防止天空盒出现黑色边缘线。单击“Apply”按钮应用。 (4)修好导入的纹理图片后，将每张图片拖入到Skyboxtwo材质的前后左右上下各面中，在拖入时需要注意的是每张纹理图的边沿搭配问题。到这一步，天空盒的搭建就完成了。 (5)制造好天空盒后，需要做的就是在Unity中对其进行相应的设置并将其显示出来。选中场景中的摄像机，依次单击“Add Component-&gt;Skybox”为其添加天空盒，并选择刚做好的天空盒到Skybox，效果图如下图所示。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D游戏实例]]></title>
    <url>%2F2019%2F03%2F18%2F3D%E6%B8%B8%E6%88%8F%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[本文主要通过实例《我是枪手》讲解如何使用Unity开发跨平台的3D第一人称视角射击游戏。支持平台包括PC以及Android。本章在动画播放方面使用旧动画系统Animation。 本章分为两大部分。 前期准备：需求分析、资源准备、知识准备、游戏设计。 游戏实现：UI实现、关卡实现、主角实现、敌人实现、音频功能、移动设备支持。 前期准备前期准备是游戏制作中非常重要的一个环节，所谓兵马未动，粮草先行，良好的准备可以使开发事半功倍。 需求分析我们需要实现一款单机的3D第一人称射击游戏，首先需要实现UI用户界面，然后实现玩家角色，通过检测输入并执行行走、奔跑、跳跃、射击、换枪、换弹匣、瞄准等行为。场景里有敌人，敌人会有巡逻、追逐、攻击、死亡等状态。 资源准备资源分为以下几个部分：UI资源、场景资源、模型资源、特效资源、音效资源。 UI资源：AssetStore里的免费插件InstantGui，负责基本的UI素材。使用PhotoShop绘制具体的射击、换枪、换弹匣等按钮的图标。 场景资源：AssetStore里的免费插件FPSControl中的场景。 模型资源：AssetStore里的免费插件FPSControl中的模型。 特效资源：使用PhotoShop绘制图片资源，用Unity的粒子系统实现。 音效资源：使用《反恐精英》中的音效资源，用Unity的音效系统实现。 先下载FPSControl，InstantGui和《反恐精英》作为准备。 知识准备有限状态机（Finite state machine，FSM）表示有限个状态以及在这些状态之间转移和执行状态行为的模型。游戏中的FSM一般分为3个部分：进入、执行和退出。此外，本例还会用到Nav Mesh等其他Unity的功能。 游戏设计游戏设计需要有良好的架构，使得游戏内容和脚本代码都具有良好的拓展性，以便之后加入新内容。 总体设计使用宏分别编写需要区分平台的代码片段，最后编译不同平台的安装包。Scene场景作为初始承载UI的场景，不同的关卡场景以“level”加关卡序号命名。 UI设计在本例中，UI实现使用了非常简单的结构，即在画布上添加UI管理脚本，并在画布下直接放置主界面、设置界面、游戏界面、暂停界面、游戏结束界面和读取界面等界面，并在各个界面的游戏上添加子界面的管理脚本，通过激活某子界面并不激活其余界面实现界面间的切换，最后根据屏幕预设分辨率与实际分辨率的比率实现UI适配。 游戏内容设计。本例中最重要的代码设计就是HumanBase类及其派生类（Player、Enemy）和StateBase类及其派生类（Player State Base、Enemy State Base）。其中HumanBase会处理播放动画，表现被射中后受伤死亡等内容。而在派生类中有各自的枚举去区分状态，没有公用的枚举，因为派生类Player主要处理由玩家输入决定的状态，而派生类Enemy主要处理根据AI人工智能设计的状态。 状态机分为3个基本部分：进入、执行和退出，而进入又分为条件判断和进入两个部分。例如Player的Fire状态，当检测到按下开火按钮后进入状态，播放开火状态动画结束后结束状态玩家。玩家和敌人的物理处理如表1所示。表1 玩家的状态和敌人的状态的物理对比 内容 玩家状态 敌人状态 移动 Rigidbody.Move NavMeshAgent.SetDestination后NavMesh系统处理 转向 Transform.localEulerAngles NavMeshAgent.SetDestination后NavMesh系统处理 跳跃 Rigidbody.AddForce 无 Player State Base的派生类有Idle、Walk、Run、Fire、FireAuto、Reload。Enemy State Base的派生类有Swap、Dead、Patrol、Chase、Shoot、Fall。 游戏实现创建一个新工程3DGame，然后将FPSControl和InstantGui导入工程，将《反恐精英》中的音效资源复制至工程下的Resources/Audio/Sound文件夹下。可新建文件夹Chapter18并整理资源，如下图所示。 UI实现新建一个场景，命名为Scene作为UI场景。最终结构如下图所示，各个界面位于其下。 1.UIManager新建画布并命名为UIManager，为其添加UI_Manager.cs脚本，如下代码所示。UIManager是一个简单的UI管理器。在脚本中使用枚举定义各个界面，并实现了UI界面的跳转和音效的播放。UIManager.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394using UnityEngine;using System.Collections;using System.Collections.Generic;using UnityEngine.UI;// UI状态枚举public enum UIState&#123; Main = 0, Settings = 1, Gaming = 2, Paused = 3, Gameover = 4, Loading = 5&#125;public class UI_Manager : MonoBehaviour &#123; // 指向实例对象的静态定量 public static UI_Manager Instance; // 所有子UI界面 public List&lt;GameObject&gt; pages; // 背景图 public GameObject bg; // 初始UI状态 private UIState initState = UIState.Main; // 当前状态 public UIState currentState&#123; get;set; &#125; // 是否锁定并隐藏光标 public bool lockMouse; // 摄像机 public Camera cam; // 点去按钮的音效 public string sound_click; void Start() &#123; Instance = this; for (int i=0; i&lt;pages.Count; i++) &#123; if(i == (int)initState) pages[i].SetActive(true); else pages[i].SetActive(false); &#125; currentState = initState; foreach (var item in pages) &#123; SetResolution.SetAResolution(item.transform); &#125; &#125; // 界面切换函数 public void PageTransition(UIState newState) &#123; if(newState == currentState) return; pages[(int)currentState].SetActive(false); pages[(int)newState].SetActive(true); currentState = newState; bg.SetActive( newState != UIState.Gaming &amp;&amp; newState != UIState.Paused &amp;&amp; newState != UIState.Gameover); &#125; // 清除函数 public void Clean() &#123; Destroy(gameObject); &#125; void Update() &#123; // 更新光标 if (lockMouse) &#123; if (currentState == UIState.Gaming) &#123; Cursor.lockState = CursorLockMode.Locked; Cursor.visible = false; &#125; else &#123; Cursor.lockState = CursorLockMode.None; Cursor.visible = true; &#125; &#125; &#125; // 点击按钮时播放音效 public void Sound_Click() &#123; AudioManager.PlayAudioUI(sound_click, 1, false, null, Vector3.zero, 0); &#125;&#125; 2.主界面主界面Main如下图所示，包含一个标题和两个按钮。 主界面对象上绑定的UI_Main.cs脚本如代码清单所示，两个按钮的OnClick事件与脚本中的方法对应。 123456789101112131415161718using UnityEngine;using System.Collections;public class UI_Main : MonoBehaviour &#123; // 点击开始游戏按钮 public void OnPress_Start() &#123; Debug.Log("OnPress_Start"); UI_Manager.Instance.PageTransition( UIState.Loading); &#125; // 点击设置选项按钮 public void OnPress_Settings() &#123; UI_Manager.Instance.Sound_Click(); Debug.Log("OnPress_Settings"); UI_Manager.Instance.PageTransition( UIState.Settings); &#125;&#125; 3.设置界面设置界面Settings可以设置音乐和音效的音量，通过右上角的关闭按钮回到主场景，如下图所示。UI_Settings.cs脚本结构与UIMain.cs类似，代码如下。 123456789101112131415using UnityEngine;using System.Collections;using UnityEngine.UI;public class UI_Settings : MonoBehaviour &#123; public Slider slider_music; public Slider slider_sound; public void OnPress_Close() &#123; UI_Manager.Instance.Sound_Click(); Debug.Log("OnPress_Close"); UI_Manager.Instance.PageTransition( UIState.Main); &#125;&#125; 4.读取界面读取界面Loading包含一个进度条和读取文字，如下图所示。进度条实际上是一个Slider元素，只是不勾选Interactable，使其不能被点击。通过SceneManager.LoadSceneAsync接口根据场景名异步读取场景并返回进度以设置进度条，进度从0至1，1的时候表示完成。UI_Loading.cs脚本如下。 12345678910111213141516171819202122232425262728293031using UnityEngine;using System.Collections;using UnityEngine.UI;public class UI_Loading : MonoBehaviour &#123; public string level2Load; public Slider slider; private AsyncOperation op; private float progress; private float speed = 0.5f; void Start() &#123; op = Application.LoadLevelAsync(level2Load); progress = 0; slider.value = progress; &#125; void Update() &#123; if(progress&lt;op.progress) &#123; progress += speed * Time.deltaTime; &#125; slider.value = progress; if(progress&gt;=1) &#123; UI_Manager.Instance.PageTransition( UIState.Gaming); &#125; &#125;&#125; 5.游戏界面游戏界面是本例中最重要的界面，玩家90%以上的时间会在这个界面之中。左下角是生命值显示，右下角是弹药情况显示，左上角是暂停按钮，中间是普通的绿色十字准心和瞄准镜。此外，还有受伤的效果图以及移动平台专用的控制按钮：虚拟操纵杆、开火按钮、换枪按钮、换弹匣按钮、瞄准按钮和跳跃按钮。结构如图1所示，画面如图3所示，游戏界面的UI_Gaming.cs脚本代码如下。在UI_Gaming.cs脚本中还使用了EventTriggerListener.cs脚本来检测按钮的按下与抬起，如代码所示。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity脚本程序开发-综合案例]]></title>
    <url>%2F2019%2F03%2F17%2FUnity%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[这是一个控制飞机飞行的案例。该案例的初衷就是运用基本的方法完成对飞机运动状态的控制，以及摄像机对目标物体的跟随。 本案例基本上包含了Start方法和Update方法的使用、向量的应用、标签功能的应用、对Android设备各个键的监听、整体场景的搭建，以及灯光的控制，正是通过这些应用的相互配合，才能使项目得以顺利运行。 效果如下：gif 案例策划及准备工作实现对飞机的飞行状态的控制（主要包含了飞机的前进、转向等功能），在项目开发前，首先要对项目开发所需要使用的资源进行收集和归类。需要的主要资源如下所示。图片资源列表| 图片名 | 大小/KB | 像素 | 用途 || :———— | :———— || plane_texture.jpg | 1024 | 2048X 2048 | 飞机机身贴图 || plane_glass.jpg | 7.59 | 64x64 | 飞机挡风玻璃贴图 | 模型资源列表| 图片名 | 大小/KB | 格式 | 用途 || :———— | :———— || airplane.FBX | 146 | FBX | 2D物理属性 | 创建项目及场景搭建(1)导入飞机模型包。执行”Assets-Import Package-Custom Package”命令,会立刻弹出Import package..对话框,如图3-3所示。在该对话框内浏览所要导入的包并选中,单击打开按钮,就会弹出图3-4所示的显示了资源包内的文件列表的对话框。勾选所需要导入的资源文件,单击Import按钮,开始导入资源。地形资源包的导入方法与飞机模型包的导入步骤相同。 (2)完成资源的导入后,在Project视窗中选中飞机模型 aipanl.FBX,如图3-5所示。将其拖曳到场景中,如图3-6所示。. (3)在Project视窗中分别选中纹理贴图plane texture.jpg和plane glass.jpg,如图3-7所示。将选中的纹理贴图拖曳到飞机模型身上即可为模型添加纹理,最终效果如图3-8所示。 (4)接下来为飞机模型添加刚体组件。首先选中模型,在Inspector视窗中,单击Add Component按钮,如图3-9所示,选择”Physcis-Rigibody”,添加完成后,设置刚体组件的参数,如图3-10所示,取消勾选USe Gravity选项,使物体不受重力影响. (5)在Project视窗中选中地形文件SeneTerrain-Town-Scene, preab, 图3-1所示,将其拖曳到场景中,并调整位置,如图3-12所示。 飞机控制脚本实现(1)首先创建一个名字为”AirControl.cs”的脚本,将此脚本挂载到飞机模型上. 1234567891011121314151617using UnityEngine;using System.Collections;public class AirControl : MonoBehaviour &#123; private transform m_transform; //保存Transform实例 public float speed = 600f; //飞机的飞行速度 private float rotationz = 0.0f; //绕2轴的旋转量 public float rotatespeed Axisz = 45f; // 烧2轴的旋转速度 public float rotatespeed AxisY = 20f; //绕丫轴的旋转速度 private Vector2 touchPosition; //触摸点坐标 private float screenWeight; //屏幕宽度 void Update() &#123; &#125;&#125; 口第1-2行为导入系统包。 口第4行为Mono维承自MonoBehaviour类,只有继承自MonoBehaviour的类才可以作为Unity脚本组件被使用。口第5行声明了一个Transform实例,用于后面存放Transform组件的调用。口第6行为飞机飞行的速度,该变量为public型,可在Unity中直接更改它的值.口第7行为飞机绕2轴的旋转量,用于保存飞机实时的姿态。口第8-9行为飞机绕2轴的旋转速度和绕y轴的旋转速度。口第10行为手指触摸到移动设备屏幕上的坐标。口第11行为移动设备屏幕的宽度。 (2)接下来重写Start函数。Start函数是在第一次调用Update或FixedUpdate函数之前被调用,这里一般用于编写在脚本开启后先执行且执行一次的代码,例如一些初始化操作。具体代码如下。 -2mguvoid start0) (m transtorm this.transformathis.gameabject. GetComponent () .useGravity- false; //关闭重力影响screenleight Screen.widthz //获取屏幕定度 口第2行用于保存this.transform的调用,避免了后面在Update方法中多次调用游戏对象身上的Transform组件。这样写可以减少外部代码的调用,提高运行效率。 口第3行用于关闭游戏对象的受重力的影响。使用GetComponent方法获取了游戏对象身上的Rigidbody组件后,为其useGiravity变量赋值”false”.口第4行用于获取设备屏幕的宽度。 (3)接下来让飞机开始动起来。首先是飞机可以向前飞行以及飞机的螺旋桨可以转动。此时需要重写Update方法,具体代码如下.145void Update () 0m transform.Translate (new Vector3(0, o, speed * Time.deltaTime) );//向前移动Gameobject.Find (“propeller”).transform.Rotate (new Vector3(0, 100of.Time, deltaTime, 0));//寻找到名称为”propeller”的对象并使其绕丫轴旋转 口第2行用于使飞机朝2轴方向移动, Vector3是一个三维向量,用于在Unity传递3D位置和方向, 3个参数分别代表x、y,z轴上的分量.Time.deltaTime为完成最后一帧的时间,在每帧中发生增减变化的数值就需要与”Time.deltalime”相乘。口第3行用于查找到propeller对象,并使其旋转。通过Find方法,查找飞机身上的名称为”propeller”的游戏对象。 propeller对象的位置如图3-13所示。通过Rotate方法使其发生旋转,这里仍是使用到了Vector3,因为螺旋桨是围绕y轴旋转的,所以第二个参数有值,为旋转的速度。 (4)接下来是控制飞机左右转向的代码。控制飞机转向是通过触摸屏幕来实现的,当玩家触摸屏幕的左半侧时飞机左转,触换屏幕的右半侧时飞机右转,当没有触摸事件发生时恢复平衡状态。具体代码如下。void Update ( 1mtransform.Translate (new Vector3(o, o, speed . Time.deltaTime) ) ://向前移动17寻找到名称为”propeller”的对象并使其绕y轴旋转GameCbject. Find (“propoller”) .transform. Rotate (new Vector3(0, 1000ETime.deltaTime, D))1/获取飞机对象绕2轴的旋转量rotationz - this.transform.eulerAngles.z;if (Input.touchCount &gt;0) //当離摸的数量大于。 for (int i-0; i &lt; Input.touchCount; i++) 1 Touch touch -Input.touches[1]: //实例化当前触搜点 1/手指在屏幕上没有移动或发生滑动时触发的事件 if (touch.phase TouchPhase. stationary Il touch.phaseTouchPhase.Moved) C //获取当前触摸点坐标 touchPosition touch.position; 1/触摸点在屏幕左半树 if (touchPosition.x &lt; screenWeight / 2) ( 11飞机左转 m transform. Rotate tnesVector3(0,-Time.deltaTime * 30, 0), Space.World) ;//触摸点在屏幕右半侧else if (touchPosition.x &gt;= screenweight / 2) (1/飞机右转m transform. Rotate (new Vector3 10, Time.deltaTime 30, O), Space. Morild) ;i (Input. touchcount-o) (BackToBlance ()://手指离开屏幕时触发的事件else if (touch.phase s TouchPhase. Ended) ( BackToBlance (); “//调用恢复平衡状态方法 // 表 手指触搜屏幕时 复平衡状态方法 口 第5-6行为获取飞机对象绕2轴的旋转量。口 第7-8行用于判断触摸事件是否发生了。口第9行用于实例化当前触摸点,用于后面判断触摸事件的类型和获取触摸点坐标。 口第11行用于判断触摸事件。通过phase的值来判断,当其等于TouchPhase.Stationary时代表手指在屏幕上但没有移动:当其等于TouchPhase. Moved时,手指在屏幕上并发生了滑动。口第14-18行用于判断飞机左转。如果触摸点在屏幕左半侧,就以一定的速度向左发生旋转。因为是左转,所以旋转的速度取负值。口第19-22行用于判断飞机右转,与左转类似,故不再赞述。 口第24-27行用于判断当手指离开屏暮时触发的事件,所调用的BackToBlance方法在后面介绍。口第28-30行为没有手指触摸屏幕时。触发的事件,同样是调用BackToBlance方法。(5)为了使飞机的转向更加真实,需要在飞机转向时让飞机的机身倾斜(例如,飞机左转时,机身应该同时向左稍微倾斜),所以需要改进上面的代码。将上面的第15-18行代码改为如if (touchPosition.x &lt; screenWeight / 2) 1 //触摸点在屏幕左半侧if ((rotationz &lt;- 45 11 rotationz 2 315)) (//飞机向左倾斜m transform.Rotate (rew Vector3 (0, o, (Time.deltaTine rotateSpeed Axis2), Space.Sel);//飞机左转m-transform. Rotate (new Vector3(0, -Time.deltaTime . 30, 0), Space.World);]第2行为判断飞机发生倾斜的阈值。0第3-4行用于使飞机发生向左倾斜,同样是使用了Rotate方法,此时是通过使飞机绕自:轴旋转,来实现倾斜的效果。因为是要绕自身坐标旋转,所以要使用Space.Self参数。……主意: 向右倾斜功能的代码与向左倾斜类似。读者可参照随书光盘中的源代码6)下面介绍上面所调用的BackToBlance方法。该方法用于在没有发生转向时,使飞机恢复]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏中的脚本]]></title>
    <url>%2F2019%2F03%2F17%2F%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是协程？怎么创建协程？ 协程在什么情况下会自动停止运行？如何手动关闭协程？ 大部分函数在完成工作后就立即返回怎么理解？ IEnumerator是什么？ 写一个让cube一直运行的协程 实例化一个对象意味着复制该对象是什么意思？使用什么函数？ 什么是特性？可以附加到什么上？ 特性可改变类的行为和类在编辑器中呈现的方式怎么理解？ RequireComponent怎么理解？如果没有该组件呢？ Header和Space是什么作用？ SerializeField和HideInInspector是为了解决什么问题？ ExecuteInEditMode是干嘛用的？ 本章涵盖： 1.协程 2.创建和销毁对象 3.特性 Unity提供了必要的基础功能，例如渲染图形、从玩家那里获取输入，以及播放音频。你需要做的就是添加自己的游戏所需要的功能。怎么做呢？编写脚本，并将其添加到游戏的对象中。 协程大部分函数在完成工作后就立即返回。然而，有些时候需要让一些工作用些时间逐渐完成。例如，如果想让一个对象从一个位置滑动到另一个位置，就需要让这种移动发生在多个帧中。 在多个帧中运行的函数称为协程。要创建协程，首先需要创建一个返回类型为IEnumerator的方法： 1234IEnumerator MoveObject()&#123; &#125; 接下来，使用yield return语句让协程临时停止运行，使游戏的其余部分能够继续执行。例如，要使一个对象在每一帧中向前移动一定距离，可以使用下面的代码： 123456789IEnumerator MoveObject()&#123; // 无限循环下去 while(true) &#123; transform.Translate(0, 1, 0); // 每一帧在y轴上移动一个单位 yield return null; // 等待进入下一帧 &#125;&#125; 如果包含一个无限循环（例如上例中的while(true)），那么在循环期间必须使用yield让出执行权。否则，循环将一直执行，其他代码将没有机会执行其他工作。由于游戏的代码运行在Unity内，如果进入无限循环，可能导致Unity不能响应。如果发生这种情况，需要强行关闭Unity，而这可能导致丢失未保存的工作。 从一个协程yield return时，将暂时停止执行该函数。Unity将在以后恢复执行该函数，具体何时恢复执行取决于使用什么值yield return。 例如： 123456789// 等到下一帧恢复执行yield return null// 等待3秒后恢复执行 yield return new WaitForSeconds(3)// 等待someVariable等于true时执行；在这里可以使用任何计算结果为true或false变量的表达式yield return new WaitUntil(()=&gt;this.someVariable == true) 要停止执行协程，需要使用yield break语句： 12// 立即停止此协程yield break; 当执行到方法末尾时，协程也会自动停止执行。 有了协程函数后，就可以启动该函数。要启动一个协程，不能单独进行调用，而要使用StartCoroutine函数进行调用： 1StartCoroutine(MoveObject()); 启动协程后，它将开始执行，直到遇到yield break语句，或者到达函数末尾。 除了刚刚提到的yield return示例，还可以yield return另一个协程。这意味着该协程将等待另一个协程结束。 在协程外部也可以停止一个协程。要使用这种方法，需要保留对StartCoroutine方法的返回值的一个引用，并将其传递给StopCoroutine方法： 123Coroutine myCoroutine = StartCoroutine(MyCoroutine());// ...后面...StopCoroutine(myCoroutine); 创建和销毁对象在游戏运行期间，有两种方法可创建对象。第一种方法是创建一个空的GameObject，然后使用代码给该GameObject附件组件；第二种方法可在一行代码中完成设置。 在Play Mode中创建新对象时，这些对象将在停止游戏后消失。如果想要这些对象保留下来，需要执行以下步骤。 (1)选择想要保存的对象。 (2)按Ctrl+C键复制这些对象。 (3)退出Play Mode。对象将从场景中消失。 (4)按Ctrl+V键，粘贴前面复制的对象。对象将重新出现，现在就可以在Edit Mode中操作这些对象了。 实例化在Unity中，实例化一个对象意味着复制该对象，以及该对象的所有组件、子对象以及子对象的组件。当实例化的对象是一个预设（prefab）时，这一点尤为强大。预设是作为资源保存的预构建对象。这意味着你可以创建对象的一个模板，然后在许多不同的场景中实例化该模板的多个副本。 要实例化一个对象，需要使用Instantiate方法： 123456789public GameObject myPrefab;void Start()&#123; // 创建myPrefab的一个新副本，将其置于与此对象相同的位置 var newObject = (GameObject)Instantiate(myPrefab); newObject.transform.position = this.transform.position;&#125; Instantiate方法的返回类型是Object，而不是GameObject。需要执行转换来将其作为GameObject处理。 从头创建对象创建对象的另外一种方法是通过代码自己创建。为此，需要使用new关键字构造一个新的GameObject，然后调用该GameObject的AddComponent方法来添加新组件： 123456789// 创建一个新的游戏对象// 在Hierarchy中，新游戏对象将显示为My New GameObjectvar newObject = new GameObject("My New GameObject");// 向游戏对象添加一个新的SpriteRenderervar render = newObject.AddComponent&lt;SpriteRender&gt;();// 告诉新的SpriteRender显示一个精灵renderer.sprite = myAwesomeSprite; AddComponent方法接受一个泛型参数，即想要添加的组件类型。在这里可以指定Component类的任意子类，该组件将被添加到GameObject中。 销毁对象Destroy方法从场景中移除对象。注意，这里的用词是“对象”（object），而不是“游戏对象”（game object）。Destroy方法既可以移除游戏对象，又可以移除组件。 要从场景中移除游戏对象，需要对该对象调用Destroy方法： 12// 销毁此脚本关联到的游戏对象Destroy(this.gameObject); Destroy方法可操作组件和游戏对象。如果在调用Destroy方法时传入this（代表当前的脚本组件），并不会移除游戏对象；相反，脚本将从所附的游戏对象上移除。游戏对象仍将存在，但是不再附有你的脚本。 特性特性（attribute）是可以附加到类、变量或方法上的一条信息。Unity定义了几种有用的特性，可改变类的行为或者类在编辑器中呈现的方式。 1.RequireComponent 当附加到类时，RequireComponent特性允许告知Unity，此脚本要求另外一种类型的组件必须存在。当脚本只有附加了该类型的组件才有意义时，这个特性会很有用。例如，如果脚本只是做一件事，比如修改Animator的设置，那么类要求必须存在一个Animator是很合理的。为了指定某个组件要求必须存在的组件类型，只需要提供该组件类型作为参数，例如： 12345[RequireComponent(typeof(Animator))]class ClassThatRequireAnimator : MonoBehaviour&#123; // 此类要求GameObject上关联一个Animator&#125; 如果添加的脚本要求GameObject有特定的组件，但是GameObject还没有该组件，那么Unity将自动把该组件添加到GameObject中。 2.Header和Space 把Header特性添加到一个字段时，Unity会在Inspector中在该字段的上方绘制一个标签。Space的工作方式与此类似，只不过是添加一个空行。二者对于组织Inspector的内容都很有用。 1234567891011public class Spaceship : MonoBehaviour&#123; [Header("Spaceship Info")] public string name; public Color color; [Space] public int missileCount;&#125; 显示标签和空行的Inspector 3.SerializeField和HideInInspector 正常情况下，只有公共字段才会显示在Inspector中。但是，将变量声明为public，意味着其他对象能够直接访问它们；这样一来，对象就很难完全控制自己的数据。然而，如果将变量声明为private，Unity就不会在Inspector显示该变量。 为了处理这个问题，当想要在Inspector中显示一个私有变量的时候，可以向该变量添加SerializeField特性。 如果想要获得相反的行为（即，变量是public变量，但是不显示在Inspector中），那么可以使用HideInInspector特性： 1234567891011121314151617181920class Monster : MonoBehaviour&#123; // 由于是公有的，所以会显示在Inspector中 // 可在其他脚本中访问 public int hitPoints; // 由于是私有的，所以不会显示在Inspector中 // 在其他脚本中无法访问 private bool isAlive; // 由于设置了SerializeField，所以会显示在Inspector中 // 在其他脚本中无法访问 [SerializeField] private int magicPoints; // 由于设置了HideInInspector，所以不会显示在Inspector中 // 可在其他脚本中访问 [HideInInspector] public bool isHostileToPlayer;&#125; 4.ExecuteInEditMode 默认情况下，脚本只在Play Mode中运行自己的代码。也就是说，只有当游戏实际运行的时候，Update方法才会运行。 但是，有时候让代码一直运行会很方便。这种情况下，可以向类添加ExecuteInEditMode特性。 组件的生命周期在Edit Mode下和在Play Mode下有所不同。在Edit Mode下，Unity只在必要的时候重绘，通常是为了响应用户输入事件（如鼠标单击）。这意味着Update方法只是间或运行，而不是连续运行。另外，协程的行为会与你的预期不同。 另外，在Edit Mode下不能调用Destroy，因为Unity的行为是推迟到下一帧才实际移除对象。在Edit Mode下，应该调用DestroyImmediate，该方法将立即移除对象。 例如，下面的脚本使一个对象始终面向其目标，即使当前不再Play Mode下： 12345678910111213141516[ExecuteInEditMode]class LookAtTarget : MonoBehaviour&#123; public Transform target; void Update() &#123; // 如果没有目标，就不继续执行 if (target != null) &#123; return; &#125; //转动以面对目标 transform.LookAt(target); &#125;&#125; 如果将这个脚本附加到一个对象，并将其target变量设为另外一个对象，那么不管是在Play Mode还是Edit Mode下，第一个对象将转动自身来面向其目标。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity移动游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碰撞器]]></title>
    <url>%2F2019%2F03%2F17%2F%E7%A2%B0%E6%92%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Unity中内置的碰撞器包括6种,具体情况如下所述。 (1)盒子碰撞器(Box Collider),盒子碰撞器是一种基本的方形碰撞器原型,可以调整成不,同大小的长方体,能够很好地应用于门、墙、平台和木箱等,同时也能够用于角色的躯干或者交通工具的外壳。一般情况下,盒子碰撞器应用于比较规则的物体上,能够恰到好处地将作用对象的主要部分包裹起来。因此,适当地使用该碰撞器可以在一定程度上减少物理计算,提高性能。 (2)球体碰撞器(Sphere Collider )。球体碰撞器是一种基本的球形碰撞器原型,在三维上可以均等调节大小,但是不能只改变某一维。该碰撞器适用于石头、篮球、弹珠等。 (3)胶囊碰撞器(Capsule Collider),胶囊碰撞器是一种胶囊状碰撞器原型,由一个圆柱体上下表面个连接一个半球体组成。胶囊碰撞器的半径和高度均可以单独调节。该碰撞器可以应用于角色控制器上或者与其他碰撞器结合应用于形状不规则的物体上。 (4)网格碰撞器(Mesh Collider),网格碰撞器是一种在物体的网格资源上构建的碰撞器。对于复杂的网状模型上的碰撞检测,该碰撞器要比上述几个原型碰撞器精确很多。该碰撞器的大小和位置与挂载物体对象上的Transform属性相同 (5)车轮碰撞器(Wheel Collider)。车轮碰撞器是一种特殊的车辆碰撞器。该碰撞器自带碰撞检测、车轮物理引擎和基于滑动的轮胎摩擦模型,专门为车辆的轮胎设计,同时也可应用于其他对象。车轮碰撞器的碰撞检测是通过车轮中心向外发射一条Y轴方向的射线来实现。车轮碰撞器将在后面的交通工具章节中更加详细的介绍,在这里不再赞述。 (6)地形碰撞器(Terran Collider),地形碰撞器是一种主要作用于地形上的碰撞器,用于检测地形和地形上物体对象的碰撞检测,防止地形上加有刚体属性的对象无限制的下落。说明在实际的开发中,经常会将多种碰撞器组合使用,以保证碰撞的真实性。 碰撞器的添加在Unity开发平台下,开发者想要对游戏对象进行碰撞处理是一件很简单的事情,对于某-个游戏对象,只需要对其附加上碰撞器即可实现。在Unity中,碰撞器作为游戏对象的一种组件,可以随意地添加或者删除。接下来将对碰撞器的添加方式进行介绍。 1,碰撞器的基本添加方法在这里仅仅对基本碰撞器的使用方法进行介绍。对于某个物体,如果仅要求其起到简单的碰撞效果,那么只需对其附加碰撞器即可。具体步骤如下。 (1)首先创建一个立方体对象(Cube),按照GameObject-3D Object-Cube顺序完成创建,如图6-5所示。 (2)在游戏对象列表(Hierarchy)中,找到步骤1步创建的立方体对象,选中此对象后可以在属性查看器(Inspector)中看到此游戏对象的所有属性。其中名为”Box Collider”的组件就是碰撞器,如图6-6所示。 (3)在“BoxCollider”处单击鼠标右键或者单击该组件的设置按钮,在弹出的列表中选择”Remove Component”选项,可以移除已经附加在游戏对象上的碰撞器组件。如图6-7所示。 (4)在立方体对象被选中的状态下,按照Component-Physics-BoxCollider顺序可以为当前立方体对象添加碰撞器组件。如图6-8所示, 说明同一个对象可以指定多个相同种类的碰撞器,在数量上不作限制。 2.碰撞器的组合使用在项目的开发过程中,单个碰撞器的使用方法是很简单的,前面已经进行了详细的介绍。但是在某些情况下,由于Unity内置的碰撞器都是规则的形状类型,并不能满足非规则形状物体的碰撞事件处理。针对这种情况,下面将介绍一种适合的解决方案,具体步骤如下。(1)执行”GameObiject-3D Object-Plane”命令,创建一个平面作为地板,并为其指定纹理(将纹理图片直接拖曳到地板对象上即可)。如图6-9所示。 (2)按步骤GameObject-3D Object-Capsule创建一个胶囊(Capsule),为其指定纹理后将其放置到步骤1中创建好的地板的上方、摄像机的正前方,调整好位置后将此对象自带的胶囊碰撞器移除。该胶囊作为碰撞器组合体的主体,如图6-10所示。 (3)在胶囊对象被选中的状态下分别按步骤Component-Physics-BoxCollider和Component-Physics-SphereCollider对胶囊对象添加一个盒子碰撞器和球体碰撞器。调整两个碰撞器与胶囊 对象的相对位置和各自的大小,直至球体碰撞器将胶囊的上半球完全遮盖和盒子碰撞器将胶囊的圆柱体和下半球完全遮盖。如图6-11、图6-12、图6-13所示。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 3D的物理引擎]]></title>
    <url>%2F2019%2F03%2F15%2FUnity-3D%E7%9A%84%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[Unity 3D游戏引擎内置了由NVIDIA出品的PhysX物理仿真引擎。该引擎是世界三大引擎之一，具有高效低耗的特点，且仿真程度极高。物理引擎通过为刚性物体赋予真实的物理属性的方式来计算它们的运动、旋转和碰撞反应。在开发过程中只需要简单地操作就可以使物体按照物理运动规律进行运动。 刚体刚体特性刚体（Rigidbody）是在使用物理引擎的过程中经常用到的一个组件。任何一个非角色对象，如果希望能够受作用力及扭矩进行仿真运动，都需要挂载一个刚体组件。（关键字：非角色，运动）刚体设置了许多属性、变量和相关方法，下面将分别进行介绍。 刚体属性为了便于开发人员控制物理系统，Unity 3D提供了多个属性接口（Inspector面板），开发人员可以通过更改这些参数来实现对物体物理状态的控制。在实际的开发过程中，这些参数都被详细地罗列在属性面板中，开发人员可以很方便地对这些属性进行修改。接下来将对这些属性进行详细讲解。 如下图所示。在实际开发过程中，除了可以在代码中对这些属性进行修改，还可以在属性面板中直接对其进行修改，以提高开发效率。 (1)质量（Mass） 质量属性表示刚体的质量，其数据类型是float，默认值为1。一般来说，大部分的物体的Mass属性值应该设置为接近0.1且不超过10.0才符合日常生活中的感官感受。刚体的质量并没有单位，在开发过程中读者要通过保持物体与物体之间的质量之比来提高其物理仿真度。 (2)阻力（Drag） 这里的阻力指的是物体的移动阻力，物体进行任意方向的移动都会受到Drag的影响。该属性的数据类型是float，默认值为0。Drag的方向与物体运动的方向相反，对物体的移动起阻碍作用。通过对Drag设置不同的值，可以分别模拟出羽毛和石头掉落的情景。 (3)旋转阻力（Angular Drag） Angular Drag与Drag类似，也是阻碍物体运动的一个力。该属性的数据类型是float，默认值是0.05，如果读者将该属性设置为0，则物体在因受瞬时力而旋转后，将不会停止旋转运动，此属性值越高，物体的角速度衰减就会越严重。 (4)使用重力（Use Gravity） Use Gravity这个属性是以布尔值的形式存在的，其初始值为true，这一属性设为false时，物体将不受重力的作用，但其他非重力则正常进行计算，可以模拟出物体在外太空等特殊场合的无重力状态，对于某些特殊的场景的物理模拟是非常有用的。 (5)是否遵循运动学（Is Kinematic） 这个属性表示的是该游戏对象是否遵循牛顿运动学物理定律，其数据类型是bool，初始值为false。值得注意的是，该属性值为true时表示该对象的运动只受脚本和动画的影响，作用力、关节和碰撞都不会对其产生任何作用。只有将该属性值设置为false时，才能正常调用物理计算。 另外，虽然当该属性值为true时物体不受物理定律的约束，但是该物体还是会影响其他物体，改变其他物体的运动状态，在游戏开发中此属性经常会被使用到。想像一下，在第一人称射击类游戏中，敌人被击杀后会倒地不动（不再受其他作用力的影响），就是因为这个敌人对象中Rigidbody组件上的Is Kinematic属性被赋为true。 (6)插值方式（Interpolate） 该属性表示的是该物体运动的插值模式。默认情况下，Interpolate属性值是空（None），此时物体的物理计算不进行插值，所需的值取最近计算的值。开发人员可以选择内插值（Interpolate）或外插值（Extrapolate）两种模式进行插值。 由于在Unity 3D中物理模拟和画面渲染并不同步，如果不进行插值处理，所计算得到的物理数据会是上一个物理模拟时间点的数据，而插值是获取近似当前渲染时间点数据的一种手段，然而，插值得到的值并非真实值，会产生轻微抖动的现象，建议在开发过程中只对主要游戏对象进行插值处理。&lt; (7)碰撞检测模式（Collision Detection） 假设一个高速运动的物体，其两个相邻物理模拟时间点所进行的位移大于被碰撞物体的厚度，且本身厚度足够小，则该物体将有可能直接穿过被碰撞物体，这种现象称为碰撞检测的穿透。为防止这种现象的出现，Unity 3D提供了三种不同的碰撞检测模式，用于应对不同情况下的碰撞检测。 本属性默认使用占用资源较少的离散模式（Discrete），对于静止或运动速度较慢的物体建议使用该模式；而对于高速运动或体积较小的物体建议使用连续模式（Continuous）；被使用了连续检测模式的物体所撞击的物体，则应该使用动态连续模式（Continuous Dynamic）。 (8)约束条件（Constraints） 该属性表示的是该物体的位移或旋转是否受到物理定律的约束。默认状态下，物体的任意方向的位移和任意轴的旋转都是受物理定律的约束的（人只能顺着Y轴旋转），开发人员通过设置指定方向的位移和指定轴的旋转，可以灵活地设置物体的状态，达到自己想要的效果。 刚体变量为了获取和更改物体的运动状态，Unity 3D还预留了多个变量接口，这些接口简化了对物体运动的处理，使得开发人员能够轻易地对物体的运动状态进行干预。接下来将具体地介绍这些变量。 (1)角速度（angularVelocity） 此变量表示刚体的角速度向量，其数据类型为Vector3；该向量的方向即为刚体旋转轴的方向，旋转方向遵循左手定则；该角速度的大小为向量的模，单位为rad/s。非必要情况下，不建议对此变量进行过多的干预，直接修改该值会造成一定的模拟失真。下面的代码可以实现一个静止物体的旋转，具体代码如下。 1234void Start()&#123; GetComponent&lt;Rigidbody&gt;().angularVelocity = Vector3.up; // 使物体以y轴为旋转轴进行旋转，一直在旋转&#125; (2)位移速度（velocity） 此变量表示物体的位移速度值，在Unity 3D中单位1表示现实生活中的1m。在开发过程中，直接修改此变量的值并不是一种明智的做法，因为Unity 3D中物体的运动要经过非常复杂的计算才能使得物体的运动自然平滑，如果有外加干预，会使得物体的运动模拟失真。下面的代码可以实现一个物体的速度骤增，以实现瞬移效果。具体代码如下。 1234void Start()&#123; GetComponent&lt;Rigidbody&gt;().velocity = Vector3.up; //给物体赋以向上的速度 &#125; (3)重心（centerOfMass） 通过调低物体的重心，可以使物体不易因其他物体的碰撞或作用力而倒下。若不对重心进行设置，Unity 3D会对重心位置自动进行计算，其计算基础为物体所挂载的碰撞器。值得注意的是，物体的重心的坐标以模型坐标系为准，而不是世界坐标系。下面的代码可以实现修改一个物体的重心，具体代码如下。 1234void Start()&#123; GetComponent&lt;Rigidbody&gt;().centerOfMass = Vector3.up; // 修改物体的重心位置&#125; (4)碰撞检测开关（detectCollisions） 这个变量是一个非常有用的变量，该变量默认是true，在必要的时候可以关闭。在实际开发过程中，有一些物体并不是时刻都需要进行碰撞检测的，此时，通过设置本属性而不是移除刚体组件进行实现，对提高程序的运行效率有明显的作用。 下面的代码演示了如何关闭物体碰撞检测，具体代码如下。 1234void Start()&#123; GetComponent&lt;Rigidbody&gt;().detectCollisions = false; // 关闭碰撞检测 &#125; (5)惯性张量（inertiaTensor） 该变量用来描述物体的转动惯量，其数据类型为Vector3。如果不对该值进行设置和干预，它将通过挂载在物体对象上的碰撞器组件自动进行计算。下面的代码可以实现给物体赋一个自定义的惯性张量，具体代码如下。 1234void Start()&#123; GetComponent&lt;Rigidbody&gt;().inertiaTensor = Vector3.one; // 修改惯性张量 &#125; (6)惯性张量旋转（inertiaTensorRotation） 该变量指物体惯性张量的旋转值，其数据类型为Quaternion，即四元数。如果不对该值进行设置和干预，它将通过挂载在物体对象上的碰撞器组件自动进行计算。下面的代码可以实现给物体赋一个原始惯性张量旋转值，具体代码如下： 1234void Start()&#123; GetComponent&lt;Rigidbody&gt;().inertiaTensorRotation = Quaternion.identity; // 修改惯性张量旋转 &#125; (7)最大角速度（maxAngularVelocity） 该变量用于设置物体的最大角速度，其数据类型为float，单位为rad/s，只能为非负数，且数值可无限大，默认为7。最大角速度用来限制物体的旋转速度，使物体的旋转速度不至于过大。当物体的旋转向量的模大于该值时，则使物体旋转速度等于该值。该值在一些指定的情况下会特别有用。下面的代码可以实现对物体最大角速度的修改，具体代码如下： 1234void Start()&#123; GetComponent&lt;Rigidbody&gt;().maxAngularVelocity = 1.9f; // 修改最大角速度 &#125; (8)最大穿透速度（maxDepenetration Veloctiy） 当一个物体穿透其他碰撞器时，物体的速度会变得非常不稳定，此时通过设置本变量可以限制物体的速度，从而使得物体的运动变得平滑。该值的数据类型为float，只能为非负数，且数值可无限大，默认情况下为无限大。下面的代码可以实现对物体最大穿透速度的修改，具体代码如下。 1234void Start()&#123; GetComponent&lt;Rigidbody&gt;().maxDepenetrationVelocity = 1.9f; // 修改最大穿透速度 &#125; (9)坐标（position） 该变量表示的是刚体在世界坐标系中的坐标，数据类型为Vector3。该变量与transform.postion具有完全不同的意义（切不可混淆乱用），前者代表物理模拟中的坐标，而后者指绘制场景中的坐标。两者的数值会尽量保持一致，但在高速运动的过程中，这两个变量的数值会有细微的差别。下面的代码用于打印物体的刚体坐标位置值，具体代码如下。 1234void Start()&#123; Debug.Log(GetComponent&lt;Rigidbody&gt;().position); // 打印刚体位置 &#125; (10)旋转（rotation） 该变量表示的是刚体在世界坐标系中的旋转，数据类型为Quaterion。该变量与transform.rotation也具有完全不同的意义，前者代表物理模拟中的旋转值，而后者指绘制场景中的旋转值。两者的数值会尽量保持一致，但在高速旋转的过程中，这两个变量的数值会有细微的差别。下面的代码用于打印物体的刚体旋转值，具体代码如下。 1234void Start()&#123; Debug.Log(GetComponent&lt;Rigidbody&gt;().rotation); // 打印刚体旋转&#125; 刚体常用方法在讲解了刚体的属性与变量之后，有必要讲解一下Unity提供的相关方法。 (1)给刚体施加力（AddForce） 此方法的方法签名为“public void AddForce(Vector3 force, ForceMode mode)”。此方法被调用时，将会向刚体施加一个沿着force方向的力，该力的类型为mode。ForceMode的类型包括计算重力的连续力、忽略重力的连续加速力、计算重力的瞬时力、忽略重力的瞬时力四种。下面的代码实现了对物体施加竖直向上的力，具体代码如下。 1234void Start()&#123; GetComponent&lt;Rigidbody&gt;().AddForce(Vector3.up); // 缺省情况下，默认为Force&#125; (2)移动刚体（MovePosition） 此方法的方法签名为“public void MovePosition(Vector3 position)”。此方法被调用时，系统会根据指定的参数，将刚体移动到相对应的位置，其效果是物体的位置会因为刚体的移动而随之移动。该方法经常用于FixedUpdate方法中。下面的代码实现了对物体的匀速平移操作，具体代码如下。 1234void FixedUpdate()&#123; GetComponent&lt;Rigidbody&gt;().MovePosition (transform.position + Vector3.right * Time.deltaTime); // 平移刚体&#125; (3)旋转刚体(MoveRotation) 此方法的方法签名为“public void MoveRotation(Quaternion rot)”。此方法被调用时，系统会根据指定的参数，将刚体旋转到相对应的角度，其效果是物体的角度会因为刚体的旋转而随之变化。该方法经常用于FixedUpdate方法。下面的代码实现了对物体的匀速旋转操作，具体代码如下。 1234void FixedUpdate()&#123; GetComponent&lt;Rigidbody&gt;().MoveRotation(transform.rotation * Quaternion. Euler(new Vector3(0, 100, 0) * Time.deltaTime)); //旋转刚体&#125; (4)添加爆炸力(AddExplosionForce) 此方法的方法签名为“public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier, ForceMode mode)”。其将在“explosionPosition”处产生模式为“mode”，大小为“explosionForce”的爆炸力，半径为“explosionRadius”，并在物体下方upwardsModifier向上施力。下面的代码实现了产生一个爆炸力的操作，具体代码如下。 1234void Start()&#123; GetComponent&lt;Rigidbody&gt;().AddExplosionForce(19.0f, transform.position, 10, 1.5f, ForceMode.Force); // 添加爆炸力&#125; 如果将爆炸力的值设置为负数，则该方法可以模拟出引力的效果，使在半径之内的物体因爆炸力的作用，向中心点靠拢。 (5)在指定点施加力（AddForceAtPosition） 此方法的方法签名为“public void AddForceAtPosition(Vector3 force, Vector3 position, ForceMode mode)”。该方法被调用时，将在“position”处添加一个“mode”模式、“force”大小的力。这里的position是基于世界体系的坐标，读者应使position在物体之内，否则将会很难进行控制。下面的代码实现了向物体施加一个力的操作，具体代码如下。 1234void FixedUpdate()&#123; GetComponent&lt;Rigidbody&gt;().AddForceAtPosition(Vector3.up, transform.position, ForceMode.Force); // 施加作用力&#125; (6)施加相对力（AddRelativeForce） 此方法的方法签名为“public void AddRelativeForce(Vector3 force, ForceMode mode)”。调用此方法时，将向刚体施加一个沿着“force”方向的力，该力的模式为“mode”。在本方法中，force基于物体的模型坐标，与基于世界坐标的AddForce方法略有不同。下面的代码实现了向刚体施加一个相对力的操作，具体代码如下。 1234void Start()&#123; GetComponent&lt;Rigidbody&gt;().AddRelativeForce(Vector3.up, ForceMode.Force); //施加相对力&#125; (7)施加力矩（AddTorque） 此方法的方法签名为“public void AddTorque(Vector3 torque, ForceMode mode)”。该方法被调用时，将向刚体施加一个“torque”的力矩，其力模式为“mode”。通过此方法可以使物体受力矩的作用而进行运动。下面的代码实现了向刚体施加一个力矩的操作，具体代码如下。 1234void Start()&#123; GetComponent&lt;Rigidbody&gt;().AddTorque(Vector3.up, ForceMode.Force); // 施加力矩&#125; (8)施加相对力矩（AddRelativeTorque） 此方法的方法签名为“public void AddRelativeTorque(Vector3 torque, ForceMode mode)”。调用此方法时，将向刚体施加一个沿着“torque”方向的力矩，该力的模式为“mode”。在本方法中，torque基于物体的模型坐标，与基于世界坐标的AddTorque方法略有不同。下面的代码实现了向刚体施加一个相对力矩的操作，具体代码如下。 1234void Start()&#123; GetComponent&lt;Rigidbody&gt;().AddRelativeTorque(Vector3.up, ForceMode.Force); // 施加相对力矩&#125; (9)计算相对刚体的最近点（ClosestPointOnBounds） 此方法的方法签名为“public Vector3 ClosestPointOnBounds(Vector3 position)”。调用此方法可以计算出在刚体所包含的三维空间内，与“position”距离最短的点的坐标。通过计算与刚体的最近点，可以在一些特殊场合实现所需效果。下面的代码实现了打印相对刚体最近点的操作，具体代码如下。 1234void Update()&#123; Debug.Log(GetComponent&lt;Rigidbody&gt;().ClosestPointOnBounds(Vector3.zero)); // 打印最近点&#125; (10)获取基于点坐标系的速度（GetPointVelocity） 此方法的方法签名为“public Vector3 GetPointVelocity(Vector3 worldPoint)”。给定一个基于世界坐标的点“worldPoint”，调用此方法可以计算出刚体在以“worldPoint”为原点的坐标系中的速度。下面的代码实现了打印基于点坐标系的速度的操作，具体代码如下。 1234void Update()&#123; Debug.Log(GetComponent&lt;Rigidbody&gt;().GetPointVelocity(Vector3.up)); // 打印速度 &#125; (11)获取基于相对点坐标系的速度（GetRelativePointVelocity） 此方法的方法签名为“public Vector3 GetRelativePointVelocity(Vector3 relativePoint)”。给定一个基于刚体模型坐标系的点“relativePoint”，调用此方法可以计算出刚体在以“relativePoint”为原点的坐标系中的速度。下面的代码实现了打印基于相对点坐标系的速度的操作，具体代码如下。 12 (12)确定是否处理休眠(IsSleeping),此方法的方法签名为&quot;public bool IsSleeping()&quot;,调用此方法将返回一个bool类型的值,表示该刚体是否处于休眠状态。下面的代码实现了打印休眠状态的操作,具体代码如下。void Update () {Debug. Log (GetComponent ().Issleeping); //打印休眠状态N。 (13)设置密度(SetDensity),此方法的方法签名为”public void SetDensity(float density)”,调用此方法将给刚体设置一个密度值,该密度值基于碰撞器的体积,而不是物体的体积。下面的代码实现了设置刚体密度的操作,具体代码如下。 (14)强制休眠(Sleep)。 此方法的方法签名为”public void Sleep()”,调用此方法可将对应刚体强制进行休眠,不参与物理模拟计算。通过将不重要的物体进行强制休眠,可以节约大量的资源,以提高程序的运,行效率。下面的代码实现了将刚体进行强制休眠,具体代码如下。1 void Start () t2 GetComponent().sleep(); //将刚体强制休眠, (15)唤醒(WakeUp)。此方法的方法签名为”public void WakeUpO”,调用此方法可将处于休眠状态的刚体进行唤醒,使其重新加入物理模拟计算。下面的代码实现了使刚体不被休眠,具体代码如下。 (16)扫描检测(SweepTest)。此方法的方法签名为&quot;public bool SweepTest(Vector3 direction, outRaycastHit hitInfo, float maxDistance)&quot;,调用该方法时,将沿着direction的方向产生一条长度为maxDistance&quot;的射线&quot;hitInfo&quot;,若该射线碰撞到其他刚体,则返回true,否则返回false。第一个被检测到的刚体信息储存在&quot;hitInfo&quot;上。 下面的代码实现了扫描检测的功能,具体代码如下。23RaycastHit rh = new RaycastHit();void Update () { Debug. Log (GetComponent () . SweepTest (Vector3. forward, out rh, 10.0f) );//扫描结果 (17)扫描检测所有(SweepTestAll)。此方法的方法签名为”public RaycastHit] SweepTestAll致(Vector3 direction, float maxDistance)”,该方法与SweepTest类似,不同的是将会返回RaycastHit类型的数组,其中储存了”direction”方向所有检测到的刚体的信息。该数组的最大长度不超过128. 下面的代码实现了扫描所有刚体的功能,具体代码如下。 SweepTest和SweepTestAll方法都只能扫描到简单类型的碰撞器(sphere、cube.capsule ),而网格碰撞器则不适用使用本方法。关闭碰撞器的知识将在后面进行详细讲解。6.1.2物理管理器: 前面简单介绍了刚体的属性、变量和方法,接下来这一部分将讲解一下物理管理器(PhysicsManager)的相关内容。Unity 3D作为一个优秀的游戏开发平台,其出色的管理模式是令人称赞的。在Unity 3D中不仅可以对单个分组进行属性设置,还可以对场景全局进行设置。这一部分的内容将会向读者详细讲解Unity 3D中场景的全局物理参数是如何设置的。 1,物理管理器预览 (1)打开Unity 3D开发平台,在菜单栏中选择”Edit”选项,会弹出图6-2所示的编辑列表。在编辑列表中,选择”Project Settings 选项,将弹出图6-3所示的全局设置列表。在全局设置列表中选择”Physics”,即可进入物理管理器界面。 (2)按照步骤1进行操作后,会在属性查看器中呈现出物理管理器的面板,如图6-4所示。读者可以在该面板中对当前项目的全局物理参数进行设置。 2、物理管理器参数 在前面的内容中,讲解了物理管理器的打开操作,读者应该能够熟练地调出物理管理器面板。接下来介绍的是物理管理器中的相关参数的含义和用法。 (1)重力(Gravity)。该属性表示的是当前项目中的重力加速度,该参数将被应用于所有刚体。该属性3个数值分别指在x、y、2方向上的重力加速度,一般重力加速度是竖直向下的,所以只有y轴上有一个负值。默认情况下, y轴上的值大小为-9.81, x轴和2轴方向的值为0。 (2)默认材质(Default Material)。该属性表示当物体没有被指定物理材质的时候,该物体的默认材质。默认状态下该属性是没有指定值的,也就是说在默认状态下创建的物体都是没有指定材质的,这是因为在Unity 3D中,每个物体的物理材质可能会有很大的不同,有时候指定默认材质并没有太大的意义。 (3)反弹阈值(Bounce Threshold),该属性表示的是项目中的反弹阈值,该参数被应用于所有刚体。如果两个相互碰撞的物体的相对速度低于反弹阈值,则将不会进行反弹计算。通过合理设计该属性可以有效减少物理模拟过程中的抖动。这里所有的相对速度是指以其中一个刚体为参照物,另外一个刚体的速度值。 (4)休眠阈值(Sleep Threshold )。该属性用来代替之前版本中的SleepVelocity.SleepAngularVelocity等值,实为刚体的能量值,其大小受刚体的平移速度和旋转速度所影响。设刚体能量为E,平移速度大小为v,角速度大小为A,则刚体的能量计算公式为E(V+VA) ×0.5.当刚体能量低于该阈值时,则进行休眠操作, (5)默认接触偏差(Default Contact Offset),当两个刚体的表面距离低于该值时,则认为两个刚体已经接触,并对其进行物理模拟计算。该属性只能为正数,不可为负数或0。在实际的物理模拟计算中,很难使两个刚体刚好无缝贴合,如果想对其进行碰撞检测,就必须有一个容差值, 使两个刚体能够进行物理模拟计算。 (6)求解迭代次数(Solver Iteration Count)。该属性表示的是项目中的关节和连接计算过程中的迭代次数。该属性值决定了关节和连接的计算精度。求解迭代次数越高,其计算精度越高,但是过高的迭代次数会浪费过多的资源,不利于项目的流畅运行,一般来说此属性值设置为7就可以适用于大多数情况。 (7)射线检测命中触发器(Raycasts Hit Triggers)。在Unity 3D中,有碰撞器和触发器之分,Unity 3D通过射线实现拾取。若一个物体上附加的是碰撞器,则碰撞拾取功能可一直正常使用;若一个物体上挂载的是触发器,则其碰撞拾取功能受本属性的限制,只有本属性值为true时,其拾取功能才能正常运行。 (8)允许自适应力(Enable Adaptive Force),自适应力是PhysX所使用的一项特殊技术,它主要用于修正PhysX在模拟动态状况时不可避免的数值偏差。Unity 3D在5.0版本之后采用了PhysXSDK3版本的物理引擎,其在经典PhysXSDK 2.x的基础上进行了重新设计。并将Physx的自适应力设置为可切换的,而且在默认状态下是关闭状态。 (9)层碰撞矩阵(Layer Collision Maxtrix),将碰撞检测进行分层是一个非常有用的功能。同一个物理层内的所有刚体可以相互进行碰撞检测,同时,开发人员可以指定不同的层与层之间进行碰撞检测,以适应不同的开发需求。而对于物理层的设置,则是通过层碰撞矩阵实现的。两个层交叉处便是设置这两个层是否可碰撞的标志位。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity游戏开发技术详解与典型案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android那些事]]></title>
    <url>%2F2019%2F03%2F14%2FAndroid%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[Unity的Android开发配置 所需组件配置Unity中的下载Unity需要认识Android，Android需要在我们的电脑中。在Unity中操作：（1）Android Build Support下载（2）Switch Platform JDK的安装与配置Android是利用Java来开发的，所以需要先安装Java。谷歌JDK，安装JDK8（此文版本：jdk-8u152-windows-x64）。JDK版本：1.8 必须大于等于7，不能是9。Unity requires the 64-bit version JDK 8 (1.8). 查看数字签名。exe上右键“属性-&gt;数字签名”，如下图所示。 点击jdk.exe安装JDK，目录D:\Install\java\jdk。安装完JDK后，会附赠安装JRE，不能和JDK一个目录，安装在D:\Install\java\jre。 安装完成后，此电脑，右键“属性-&gt;高级系统设置-&gt;高级-&gt;环境变量”。 系统变量，新建，JAVA_HOME变量，变量值选择或填写JDK的安装目录。 系统变量，找到Path变量，编辑，在变量值最后输入JDK安装目录下的bin目录（可以直接输入也可以写成%JAVA_HOME%\bin）与JRE安装目录下的bin目录。 系统变量，新建，CLASSPATH变量，变量值填写：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar 运行cmd，输入java -version与javac -version，若显示版本信息，则说明安装和配置成功 Android Studio的安装Android Studio下载（能打开哪个用哪个）https://developer.android.com/https://developer.android.google.cn/index.html （一般是这个）http://www.androiddevtools.cn/此文安装版本为3.3.2。安装Android Studio时会安装SDK。 我的电脑是AMD的CPU，所以装HAXM失败了。 只有Android Studio编译成功，Unity才可以成功。所以下面直接用Android Studio编译一个空工程。 没有遇到什么问题。然后Build一个APK。之前的版本可能会在Build时出现各种问题。但这个3.3.2版本没有。 当出现以下提示时，则Android Studio自己可编译成功了。 在Unity中设置AndroidSDK与JDK的目录Android Studio的配置工作Android SDK的规整工作发布相关知识三种BuildSystem的简介创建自己的密钥库用于签名使用Unity发布Android空工程之顺利的情况使用Unity发布Android空工程之不顺利的情况调试安装Google USB驱动及获取Unity RemoteUnityRemote原理介绍及移动端相关API概览UnityRemote的使用可以看见程序Debug打印的东西，还可以断点。 AVD的使用Android Virtual Device能看到Android里面的logcat，能看到Android系统里面的一些信息。AMD的CPU在创建模拟器时abi不要选x86，选armeabi就行了。 真机结合logcat调试与第三方模拟器调试移动端适配技术使用UGUI中的锚点功能进行自适应设置Canvas的自适应缩放通过代码设置视口的自适应Touch类的简单介绍Touch类的剩余成员讲解制作手指追踪的小Demo制作单指手势识别的小Demo与返回键的操控权其他常用手势识别的思路与双端通用的API介绍Unity标准资源中的虚拟摇杆简介与Android互相调用Unity与Android的联合开发模式简介互相调用模式之导出Jar包+扩展MainActivity+Java主导（上）互相调用模式之导出Jar包+扩展MainActivity+Java主导（中）互相调用模式之导出Jar包+扩展MainActivity+Java主导（下之Unity调用Android）互相调用模式之导出Jar包+扩展MainActivity+Java主导（下之Android调用Unity）互相调用模式之导出Aar包互相调用模式之提供扩展类互相调用模式之C#主导式调用入门各种模式的适用情况讲解Unity显示Toast之通过拓展MainActivity实现Unity显示Toast之通过C#调用实现AndroidJavaProxy的使用方式讲解获取讯飞语音听写的SDK创建供Unity使用的SDK库（上）创建供Unity使用的SDK库（下）完成语音识别SDK的接入Player SettingsPlayerSettings中一些参数的设置]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Siki</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物理引擎]]></title>
    <url>%2F2019%2F03%2F13%2F%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[Unity的物理引擎使用的是英伟达（Nvidia）公司的PhysX。它定义了物体的物理材质属性、物体受力后的运动以及物体碰撞后的运动。Unity有两个独立的物理引擎，分别是3D物理引擎和2D物理引擎。 3D物理引擎，相关组件在导航菜单栏-&gt;“Physics”栏中。 2D物理引擎，相关组件在导航菜单栏-&gt;“Physics 2D”栏中。 它们非常相似，只是使用不同的组件。例如刚体，3D使用的是Rigidbody，而2D使用的是Rigidbody 2D。 本章以3D为例介绍物理引擎的各个组件，这些组件可以通过导航菜单栏-&gt;“Physics”栏添加，如下图所示。 刚体刚体（Rigidbody）是激活物体物理属性的主要组件。当刚体被绑定在游戏对象上时，对象将立即受到重力影响。 因为刚体控制对象的移动，所以当添加刚体后，就不应该再用Transform来改变物体的位置旋转了，而是应该使用Rigidbody.AddForce来对对象施加力，并且让物理引擎来计算结果，如产生多少位移等。 也有一些情况，需要为游戏对象添加刚体但是又不想让其受物理作用。例如，需要为游戏对象添加刚体来触发碰撞，但同时又不想让其受物理作用。刚体有一个名为Is Kinematic的属性，当这个值为true时，力、碰撞、关节都不再影响刚体。此时刚体将只能通过Transform来操作。但游戏运行时尽量少切换Is Kinematic，因为比较影响效率。 当刚体的单位质量能量小于Rigidbody.sleepThreshold时，物体将停止移动，此时为Sleep状态。当能量重新超过这个值的时候才会离开Sleep状态。 场景中有左右两个立方体，左边的没有加刚体，右边的加了刚体。运行场景，左边的悬浮在空中，而右边的会下落，而且会穿过地面继续下落，如下图所示，这是因为还没有添加碰撞器组件的缘故。 碰撞器碰撞器（Collider）定义了游戏对象在发生物理碰撞时的形状。碰撞器是不可见的，不需要和对象的网格模型对应，一个简单近似形状的碰撞器是高效并且不会被察觉的。在Scene视图中碰撞器以绿色线框显示，原始（primitive）类别的碰撞器是最简单也是最高效的，包括盒子碰撞器（Box Collider）、球体碰撞器（Sphere Collider）和胶囊碰撞器（Capsule Collider）3种。可以对同一个游戏对象绑定多个碰撞器，这种组合出来的碰撞器形状可以很好地近似复杂的网格模型并且保持高效。子游戏对象也可以有碰撞器，但是不能再有刚体。 当然也可以使用与网格模型完全一致的网格碰撞器（Mesh Collider），它对处理器会有较多的性能占用，所以需要小心使用，在精准碰撞判定的同时也要保持良好的性能。特别需要注意的是，通常情况下，非原始碰撞器之间是不会产生任何碰撞的。例如两个网格碰撞器之间不会产生碰撞。标记为凸起的（Convex）的网格碰撞器才能够和其他网格碰撞器发生碰撞。原则是场景方面可以用网格碰撞器，而角色等移动的物体应使用原始碰撞器或原始碰撞器的组合。 碰撞器也可以不添加刚体单独使用，例如创建阶梯墙等场景中的静态物，我们称之为静态碰撞器（static collider）。通常，当我们标记一个碰撞器为静态时，就不要再通过Transform改变它的位置了，否则会严重影响物理引擎的效率。碰撞器与刚体同时绑定于游戏对象，我们称之为动态碰撞器（dynamic collider），当静态碰撞器与动态碰撞器碰撞时，动态碰撞器的对象会受到影响（如反弹等），但是静态不受影响。 下面通过表对碰撞器的参数进行说明。 参数 说明 Is Trigger 如激活，此碰撞器用于触发事件，并且被物理引擎忽略 Material 引用何种物理材质决定了它和其他对象如何作用 Convex 如激活，该网格碰撞器将会和其他网格碰撞器碰撞。凸起的网格碰撞器限制在255个三角形面内 Mesh网格 用于碰撞所引用的网格 在场景中，我们已经为立方体添加了Box Collider盒子碰撞体，并且与立方体的尺寸完成对应。运行场景，右边的立方体下落后不再穿过地面，而是在触碰到地面后摇摆进而逐渐静止。 物理材质物理材质即Physics Material。当碰撞器交互时，它们的表面需要模拟材质的属性。例如同样的一个球体，冰球和橡胶球在发生碰撞时的效果肯定是不一样的。虽然碰撞器的形状在碰撞时不会改变，但是它们的摩擦力和弹性可以用物理材质来设置。例如冰球的摩擦力和弹性近乎为0，而橡胶球的摩擦力和弹性都应该为很高的数值。 小时候我们都玩过弹珠，当弹珠掉到地板上，会有一个反复弹起来直到静止的过程，下面我们就来实现这个效果。 新建一个场景，然后在场景中新建一个立方体并调整成一个平面。接着创建一个球体并置于平台之上，然后添加刚体。点击运行会发现球体下落碰到平台就静止了。这是因为我们还没设置物理材质。 下面来创建物理材质。在Project窗口点击鼠标右键，在弹出的窗口中点击Create-&gt;Physic Material，接着命名为sphereMat，并在Inspector窗口中将Bounciness设置为1，如下图所示。 最后，在球体的球体碰撞器上将Material设置为刚创建的物理材质，如下图所示。 再次点击运行，这时弹珠落地的效果就实现了。 触发器触发器（Trigger）用来触发事件。在很多游戏引擎或工具（例如RPG Maker）中都有触发器，例如在角色扮演游戏里，玩家走到一个地方会发生出现BOSS的事件，这个就可以用触发器来做，当绑定着碰撞器的游戏对象进入触发器的区域时，会运行触发器对象上的MonoBehaviour中的OnTriggerEnter()函数。 新建一个场景，然后新建一个空的游戏对象并命名为Trigger，然后添加BoxCollider。勾选“Is Trigger”选项，将其设置为触发器，并设置尺寸为球体落下的区域，如下图所示。然后新建一个脚本TriggerDemo，脚本代码如下。 12345678910111213141516171819202122using UnityEngine;using System.Collections;public class TriggerDemo : MonoBehaviour &#123; void OnTriggerEnter(Collider other) &#123; Debug.Log(Time.time + ": 进入触发器的对象是" + other.gameObject.name); &#125; void OnTriggerStay(Collider other) &#123; Debug.Log(Time.time + ": 留在触发器的对象是" + other.gameObject.name); &#125; void OnTriggerExit(Collider other) &#123; Debug.Log(Time.time + ": 离开触发器的对象是" + other.gameObject.name); &#125;&#125; 将该脚本绑定至Trigger对象上，然后运行游戏，当球体每次落下进入触发器区域时，都会运行onTriggerEnter()函数。同理，每当离开时都运行OnTriggerExit()函数。当碰撞体在触发器区城里时，每帧都会运行OnTriggerStay()函数。 射线射线（Ray）是所有3D游戏里都会使用的一项技术，被广泛地运用在路径搜寻、AI逻辑和命中判断中。例如自动巡逻的敌人在视野前方发现玩家的时候会向玩家发起攻击，这时候就需要使用射线了。 新建一个场景，创建一个球体作为玩家，起名为Player，位置（-2, 0.6, 0），接着创建一个立方体作为障碍，位置为（2，0.6，0），新建名为“RayDemo”的脚本，并绑定至Player对象。 123456789101112131415161718192021222324252627282930313233343536using UnityEngine;using System.Collections;public class RayDemo : MonoBehaviour &#123; private Vector3 direction = new Vector3(1, 0, 0); // 前进及射线方向 private float distance = 1f; // 射线距离 void Update () &#123; transform.position += direction * Time.deltaTime; // 玩家向右移动 Ray ray = new Ray(transform.position, direction);// 新建射线 RaycastHit info; // 接受射线撞击信息的变量 // 发射射线方法1 /*if (Physics.Raycast(ray, out info, distance)) &#123; // 发现障碍 Debug.Log("前方有障碍" + info.collider.name); &#125;*/ Debug.DrawLine(ray.origin, ray.origin + direction * distance); // 用DrawLine显示射线 // 发射射线方法2 if (Physics.Raycast(transform.position, new Vector3(1, 0, 0), 1)) &#123; Debug.Log("前方有障碍！"); &#125; // 发射射线方法3 if (Physics.Raycast(transform.position, transform.right, 1)) &#123; Debug.Log("前方有障碍！"); &#125; &#125;&#125; 首先创建Vector3变量direction，代表前进及射线方向。接着创建float类型变量distance，代表射线终止的距离。Player对象即球体一直向右前进。然后创建一个Ray对象，构造函数的第一个参数是射线的起点，第二个参数是射线的方向。RaycastHit info用来接收射线撞击信息的变量，Raycast返回的是一个布尔值，True表示碰到东西了，False表示没有。至于射线碰到了什么物体、在什么位置等返回给第二个参数info。最后用Debug.DrawLine()函数将射线可视化显示。注意该函数需要勾选Game窗口的Gizmos选项才会显示。场景运行画面如下所示。 也可以不用创建Ray，例如Physics.Raycast(transform.position, transform.right, 1)，直接将射线的构成元素（起点、方向和检查碰撞的最大距离）传入。 关节关节（Joint）可以把刚体附着于另一个刚体或者固定点上。Unity一共提供了以下5种关节。 Hinge Joint：链条关节 Spring Joint：弹簧关节 Fixed Joint：固定关节 Character Joint：角色关节 Configurable Joint：可配置关节 常用的关节主要有两种：链条关节和弹簧关节。链条关节可以使刚体绕着固定点旋转，弹簧关节可以让两个刚体分开并保持固定距离。也可以设置一个数值，当作用的力超过这个数值的时候，关节关系会被打断。 链条关节链条关节将两个物体以链条的形式绑在一起，当力量大于链条的固定力矩时，两个物体就会产生相互的拉力。下面我们用链条关节来实现黑夜中垂吊的灯随风飘荡的效果。 新建一个场景，将摄像机Main Camera的Background背景颜色设置为夜晚的黑色(10, 10, 10, 255)，新建一个立方体并通过缩放调整为一个平台，接着新建一个方向光并把强度设置为0.2，最后新建两个立方体和两个胶囊体。如下图所示，缩放并摆放。新建一个聚光灯并置于下面扁平的灯罩下并面朝正下方。其中，1234分别表示吊顶、链条1、链条2和灯罩，分别为234添加Hinge Joint，其中4的Connected Body指向3，3的Connected Body指向2，这样就连接好了。点击运行，灯就会来回摆动。 弹簧关节弹簧关节和链条关节不同，链条关节两个刚体的锚点之间的距离是固定的，而弹簧关节连接的两个刚体的锚点之间的距离是会变化的，就像弹簧一样。 新建场景，然后新建两个胶囊体并命名为1、2，对2添加SpringJoint弹簧关节，将Connected Body设置为1，然后设置锚点，如下图所示。点击运行，发现下面的胶囊像有一根橡皮筋或者弹簧一样连着上面的胶囊。 习题1.简述刚体的作用。2.简述碰撞器与触发器的关系。3.做一个简单的保龄球游戏。4.做一个钟摆。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Layers]]></title>
    <url>%2F2019%2F03%2F12%2FLayers%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.Layer有几种用法？分别如何操作？2.位掩码如何使用？3.特殊的Layer有哪些？4.Layer数量有限制吗？最多有多少个？ ** Layers ** Layers are most commonly used by Cameras to render only a part of the scene, and by Lights to illuminate（照亮） only parts of the scene. But they can also be used by raycasting（光线投射） to selectively（有选择地） ignore（忽略） colliders（碰撞器） or to create collisions（碰撞）. ** Creating Layers ** The first step is to create a new layer, which we can then assign to（分配给） a GameObject. To create a new layer, open the Tags and Layers window (main menu: Edit &gt; Project Settings, then select the Tags and Layers category). We create a new layer in one of the empty User Layers. We choose layer 8. ** Assigning（分配） Layers ** Now that you have created a new layer, you have to（必须） assign the layer to one of the GameObjects. In the Tags and Layers window assigned the Player layer to be in layer 8. ** Drawing only a part of the scene with the camera’s culling mask ** Using the camera’s culling mask, you can selectively render objects which are in one particular layer. To do this, select the camera that should selectively render objects. Modify the culling mask by checking or unchecking layers in the culling mask property. Be aware that UI elements aren’t culled. Screen space canvas children do not respect the camera’s culling mask. ** Casting Rays Selectively ** Using layers you can cast（投射） rays（射线） and ignore colliders in specific layers. For example you might want to cast a ray only against the player layer and ignore all other colliders. The Physics.Raycast function takes a bitmask（位掩码）, where each bit determines if a layer will be ignored or not. If all bits in the layerMask are on, we will collide against（相撞） all colliders. If the layerMask = 0, we will never find any collisions with the ray. 12345int layerMask = 1 &lt;&lt; 8; // Does the ray intersect（相交） any objects which are in the player layer.if (Physics.Raycast(transform.position, Vector3.forward, Mathf.Infinity（无穷大）, layerMask)) Debug.Log("The ray hit the player"); In the real world you want to do the inverse（相反的） of that however. We want to cast a ray against all colliders except those in the Player layer. 12345678910111213141516171819202122void Update () &#123; // Bit shift（ [计算机] 使（数据）位移） the index of the layer (8) to get a bit mask int layerMask = 1 &lt;&lt; 8; // This would cast rays only against colliders in layer 8. // But instead we want to collide against everything except layer 8. The ~ operator does this, it inverts（使倒置，使反转） a bitmask. layerMask = ~layerMask; RaycastHit hit; // Does the ray intersect any objects excluding the player layer if (Physics.Raycast(transform.position, transform.TransformDirection (Vector3.forward), out hit, Mathf.Infinity, layerMask)) &#123; Debug.DrawRay(transform.position, transform.TransformDirection (Vector3.forward) * hit.distance, Color.yellow); Debug.Log("Did Hit"); &#125; else &#123; Debug.DrawRay(transform.position, transform.TransformDirection (Vector3.forward) *1000, Color.white); Debug.Log("Did not Hit"); &#125;&#125; When you don’t pass a layerMask to the Raycast function, it will only ignore colliders that use the IgnoreRaycast layer. This is the easiest way to ignore some colliders when casting a ray. Note: Layer 31 is used internally（内部的） by the Editor’s Preview window mechanics. To prevent clashes（冲突）, do not use this layer.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持久数据和游戏保存]]></title>
    <url>%2F2019%2F03%2F12%2F%E6%8C%81%E4%B9%85%E6%95%B0%E6%8D%AE%E5%92%8C%E6%B8%B8%E6%88%8F%E4%BF%9D%E5%AD%98%2F</url>
    <content type="text"><![CDATA[对于大多数游戏，玩家应可载入和保存游戏状态，对于持续时间较长的游戏尤其如此，例如冒险类游戏、实时战略游戏以及RPG游戏。其中，游戏应使文件在外部文件间存储和加载游戏数据。 该任务可通过XML或二进制文件并采用序列化机制予以实现，如图10-27所示。 序列化是指内存数据（例如GameObject中的组件状态）与数据流之间的转换过程，并可写入文件中。随后，可从该文件中加载数据，并重新在内存中创建组件，其状态与保存时相同。因此，游戏保存操作首先需要确定需保存、加载的数据（与特定游戏相关），后续处理过程并创建新类加载此类数据。示例代码ObjSerializer.cs可与任意GameObject进行绑定，在外部文件间序列化Transform组件（平移、旋转和缩放状态），并可通过XML或二进制文件格式予以实现。对此，XmlSerializer类用于将内存中的对象转换为XML文件；而BinaryFormatter类则将内存中的对象转换为二进制文件。其中，XML文件具有可读性，而二进制文件通常无法供人们阅读和理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159using UnityEngine;using System.Collections;using System.Collections.Generic;using System.Xml; using System.Xml.Serialization;using System.Runtime.Serialization.Formatters.Binary;using System.IO;public class ObjSerializer : MonoBehaviour&#123; //Data to save to file XML or Binary [System.Serializable] [XmlRoot("GameData")] public class MySaveData &#123; //Transform data to save/load to and from file //This represents a conversion of a transform object //into simpler values, like floats [System.Serializable] public struct DataTransform &#123; public float X; public float Y; public float Z; public float RotX; public float RotY; public float RotZ; public float ScaleX; public float ScaleY; public float ScaleZ; &#125; //Transform object to save public DataTransform MyTransform = new DataTransform(); &#125; //My Save Data Object declared here public MySaveData MyData = new MySaveData(); //Populate structure MyData with transform data //This is the data to be saved to a file private void GetTransform() &#123; //Get transform component on this object Transform ThisTransform = transform; //We got the transform component, now fill data structure MyData.MyTransform.X = ThisTransform.position.x; MyData.MyTransform.Y = ThisTransform.position.y; MyData.MyTransform.Z = ThisTransform.position.z; MyData.MyTransform.RotX = ThisTransform.localRotation.eulerAngles.x; MyData.MyTransform.RotY = ThisTransform.localRotation.eulerAngles.y; MyData.MyTransform.RotZ = ThisTransform.localRotation.eulerAngles.z; MyData.MyTransform.ScaleX = ThisTransform.localScale.x; MyData.MyTransform.ScaleY = ThisTransform.localScale.y; MyData.MyTransform.ScaleZ = ThisTransform.localScale.z; &#125; //Restore the transform component with loaded data //Call this function after loading data back from a file for restore private void SetTransform() &#123; //Get transform component on this object Transform ThisTransform = transform; //We got the transform component, now restore data ThisTransform.position = new Vector3(MyData.MyTransform.X, MyData.MyTransform.Y, MyData.MyTransform.Z); ThisTransform.rotation = Quaternion.Euler(MyData.MyTransform.RotX, MyData.MyTransform.RotY, MyData.MyTransform.RotZ); ThisTransform.localScale = new Vector3(MyData.MyTransform.ScaleX, MyData.MyTransform.ScaleY, MyData.MyTransform.ScaleZ); &#125; //Saves game data to XML file //Call this function to save data to an XML file //Call as Save(Application.persistentDataPath + "/Mydata.xml"); public void SaveXML(string FileName = "GameData.xml") &#123; //Get transform data GetTransform(); //Now save game data XmlSerializer Serializer = new XmlSerializer(typeof(MySaveData)); FileStream Stream = new FileStream(FileName, FileMode.Create); Serializer.Serialize(Stream, MyData); Stream.Close(); &#125; //Load game data from XML file //Call this function to load data from an XML file //Call as Save(Application.persistentDataPath + "/Mydata.xml"); public void LoadXML(string FileName = "GameData.xml") &#123; //If file doesn't exist, then exit if(!File.Exists(FileName)) return; XmlSerializer Serializer = new XmlSerializer(typeof(MySaveData)); FileStream Stream = new FileStream(FileName, FileMode.Open); MyData = Serializer.Deserialize(Stream) as MySaveData; Stream.Close(); //Set transform - load back from a file SetTransform(); &#125; public void SaveBinary(string FileName = "GameData.sav") &#123; //Get transform data GetTransform(); BinaryFormatter bf = new BinaryFormatter(); FileStream Stream = File.Create(FileName); bf.Serialize(Stream, MyData); Stream.Close(); &#125; public void LoadBinary(string FileName = "GameData.sav") &#123; //If file doesn't exist, then exit if(!File.Exists(FileName)) return; BinaryFormatter bf = new BinaryFormatter(); FileStream Stream = File.Open(FileName, FileMode.Open); MyData = bf.Deserialize(Stream) as MySaveData; Stream.Close(); //Set transform - load back from a file SetTransform(); &#125; void Update() &#123; //If 1 key is pressed,then data saved to XML file if(Input.GetKeyDown(KeyCode.Alpha1)) &#123; SaveXML(Application.persistentDataPath + "/Mydata.xml"); Debug.Log ("Saved to: " + Application.persistentDataPath + "/Mydata.xml"); &#125; //If 2 key is pressed,then data loaded from XML file if(Input.GetKeyDown(KeyCode.Alpha2)) &#123; LoadXML(Application.persistentDataPath + "/Mydata.xml"); Debug.Log ("Loaded from: " + Application.persistentDataPath + "/Mydata.xml"); &#125; //If 3 key is pressed,then data saved to binary file if(Input.GetKeyDown(KeyCode.Alpha3)) &#123; SaveBinary(Application.persistentDataPath + "/Mydata.sav"); Debug.Log ("Saved to: " + Application.persistentDataPath + "/Mydata.sav"); &#125; //If 4 key is pressed,then data loaded from binary file if(Input.GetKeyDown(KeyCode.Alpha4)) &#123; LoadBinary(Application.persistentDataPath + "/Mydata.sav"); Debug.Log ("Loaded from: " + Application.persistentDataPath + "/Mydata.sav"); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D拾取技术]]></title>
    <url>%2F2019%2F03%2F12%2F3D%E6%8B%BE%E5%8F%96%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[在3D开发过程中，需要允许用户通过触摸屏幕对虚拟3D世界中的物体进行操作控制，这时就需要使用3D拾取技术，因此3D拾取技术是必知必会的技术之一。 3D拾取技术的基本思想十分简单，即通过摄像机和屏幕上的触控点间确定一条射线，由此射线射向3D世界，最先和此射线碰撞的物体就是被选中的物体，然后对该物体编写与之对应的控制代码。Unity底层对3D拾取技术进行了完美的封装，在应用时只需几句代码。具体的代码片段如下。 123456789foreach (Touch touch in Input.touches) // 对当前触控进行循环&#123; Ray ray = Camera.main.ScreenPointToRay(touch.position); // 声明由触控点和摄像机组成的射线 RaycastHit hit; // 声明一个RaycastHit型变量hit if (Physics.Raycast(ray, out hit)) // 判断此物理事件 &#123; touchname = hit.transform.name; // 获得射线碰触到物体的名称 &#125;&#125; 第1-4行判断是否为触摸事件并且对事件进行循环判断，而且将由摄像机和触发点组成的射线射向3D世界中的物体。 第5-8行判断物理事件，获得射线碰触到物体的名称，并对该事件进行相应的处理。 在Scene中放入几个不同的物体，并且赋予不同的纹理图；然后通过3D拾取技术，使物体分别实现变换位置、变换纹理、物体爆炸等效果。制作过程如下。 (1)创建一个新Scene，保存命名为“3Dshiqu”，创建Plane作为地板，调整其大小和位置。再在项目中创建一个Cube游戏对象。 (2)创建一个Sphere游戏对象。在Transform中调整它的位置，使其位于Cube的旁边。 (3)创建一个Cylinder游戏对象。在Transform中调整它的位置，使其和其他两个游戏对象成为一行。 (4)使用纹理图为3D物体赋纹理。选择不同却适当的纹理图分别拖曳到3D游戏对象上，为Plane、Cube、Sphere以及Cylinder对象贴上纹理图，使其具有较好的视觉效果。 (5)调整摄像机的属性，使摄像机的视野中完美显示刚刚创建的游戏对象。 (6)Assets下新建Scripts文件夹，创建一个C#脚本Shiqu.cs。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071using UnityEngine;using System.Collections;public class Shiqu : MonoBehaviour&#123; public string touchname = null; // 声明射线触碰到的物体名字变量 private GameObject gb; // 声明游戏组成对象变量 private GameObject gbe; private GameObject obj; public GameObject objj; private bool cubeflag = false; // 声明一个标志位用来判断事件的发生 private bool sphereflag = false; private bool cylinderflag = false; public Texture2D texture; // 声明一个Texture2D变量 void Update() &#123; foreach (Touch touch in Input.touches) // 对当前触控进行循环 &#123; if (touch.phase == TouchPhase.Began) // 判断事件是否有触摸触发 &#123; Ray ray = Camera.main.ScreenPointToRay(touch.position); // 声明由触控点和摄像机连射线 RaycastHit hit; // 声明一个RayCastHit型变量hit if(Physics.Raycast(ray, out hit)) // 判断此物理事件 &#123; touchname = hit.transform.name; // 获得射线碰触到物体的名称 SetText(touchname) ; // 处理碰触触发事件 &#125; &#125; &#125; if (sphereflag) // 如果sphereflag为真 &#123; gb.transform.Rotate(Time.deltaTime * 100, 0, 0); // 开始旋转物体 gb.transform.position = new Vector3(-2.82f, -1.45f, 3.48f); // 使物体位置发生移动 &#125; if (cubeflag) // 如果cubeflag为真 &#123; gbe.GetComponent&lt;Renderer&gt;().material.mainTexture = texture;//改变物体的纹理图 &#125; if (cylinderflag) // 如果cylinderflag为真 &#123; GameObject.Destroy(obj);// 销毁该游戏对象 objj.SetActive(true); // 显示另外一个游戏对象 &#125; &#125; void SetText(string cubename) // 处理碰触触发事件 &#123; switch (cubename) &#123; case "Cube": // 如果碰触到的是Cube gbe = GameObject.Find("Cube"); // 找到Scene中的cube物体 cubeflag = true; // 切换标志位 break; case "Sphere": // 如果碰触到的是Sphere gb = GameObject.Find("Sphere"); // 找到Scene中的Sphere物体 sphereflag = true; // 切换标志位 break; case "Cylinder": // 如果碰触到的是Cylinder obj = GameObject.Find("Cylinder"); // 找到Scene中的Cylinder物体 cylinderflag = true; // 切换标志位 break; &#125; &#125;&#125; 第6-10行主要声明了几个在脚本中需要用到的游戏组成对象变量名称，以及由摄像机和屏幕出发点组成的射线碰触到的物体名字变量。 第11-14行声明了几个在脚本中会利用到的判断事件发生的标志位以及一个Texture2D变量，用来对3D世界中的物体进行纹理图切换。 第16-22行判断是否为触摸事件并且对事件进行循环判断，而且将由摄像机和触发点组成的射线射向3D世界中的物体。 第23-27行获取射线在3D世界中碰触到的物体名称，并且对事件进行处理。 第32-47行分别对触发事件进行处理。第一种是对物体进行旋转并且使其的位置发生变化。第二种是改变物体的纹理图。第三种是实现物体的爆炸效果。 SetText函数是判断射线所触发的物体并且对事件发生标志位进行置反，以使得Update方法中的触发事件得以发生。 (7)因为在这个项目中会有单击一个游戏对象时发生爆炸的游戏效果，所以在这里就会用到粒子系统。Unity开发环境中已经封装好部分粒子系统的效果，只需导入即可。依次单击“Assets-&gt;Import Package-&gt;Particle Systems”导入粒子系统。 (8)在游戏资源列表中依次单击“Standard Assets-&gt;Particle Systems-&gt;Prefabs”，将“Explosion”拖曳到场景中，调整其位置使其正好与Cylinder重合，然后在属性列表中勾掉Explosion前面的选项，使其变为不可见。 (9)将脚本代码编写完成后，单击保存按钮保存脚本。在游戏组成对象列表中选中Main Camera游戏对象，将脚本拖曳到摄像机上，拖一个图片到Shiqu脚本中的Texture选项，把Explosion游戏对象拖曳到Objj选项中。 (10)将程序导入Android设备，将纹理图片压缩格式设置为DXT（Tegra），依次单击“File-&gt;Build Setting”，选择Android平台，在Other Settings中修改参数，随意修改即可，只要不是原来的就可以发布成Android设备上的APK。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SmoothDamp方法：模拟阻尼运动]]></title>
    <url>%2F2019%2F03%2F12%2FSmoothDamp%E6%96%B9%E6%B3%95%EF%BC%9A%E6%A8%A1%E6%8B%9F%E9%98%BB%E5%B0%BC%E8%BF%90%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.SmoothDamp是干嘛用的？2.如何使用？ ** 基本语法 ** (1) public static float SmoothDamp(float current, float target, ref float currentVelocity, float smoothTime);(2) public static float SmoothDamp(float current, float target, ref float currentVelocity, float smoothTime, float maxSpeed);(3) public static float SmoothDamp(float current, float target, ref float currentVelocity, float smoothTime, float maxSpeed, float deltaTime); 对以上重载方法中涉及的参数进行说明：参数current为起始值；参数target为目标值；参数currentVelocity为当前帧速度，ref类型；参数smoothTime为预计平滑时间；参数maxSpeed为当前帧最大速度值，默认值为Mathf.Infinity（无穷）；参数deltaTime为平滑时间，值越大返回值也相对越大，一般用Time.deltaTime计算。 ** 功能说明 ** 此方法的功能是模拟平滑阻尼运动，并返回模拟插值。smoothTime:float，预计平滑时间，物体越靠近目标，加速度的绝对值越小。实际到达目标的时间往往要比预计时间大很多，建议smoothTime的取值范围为(0.0f, 1.0f)，若想控制物体到达目标的时间可以通过控制maxSpeed来达到目的。maxSpeed:float = Mathf.Infinity，每帧返回值的最大值，默认值为Mathf.Infinity。 ** 提示 ** 可以观察实例演示中maxSpeed取默认值和取较小值时当前速度随时间变化的示意图。 实例演示 下面通过实例演示方法SmoothDamp的使用。 1234567891011121314151617181920212223using UnityEngine;using System.Collections;public class SmoothDamp_ts: MonoBehaviour&#123; float targets = 110.0f; // 目标值 float cv1 = 0.0f, cv2 = 0.0f; // 输出值 float maxSpeeds = 50.0f; // 每帧最大值 float f1 = 10.0f, f2 = 10.0f; // 起始值 void FixedUpdate() &#123; // maxspeed取默认值 f1 = Mathf.SmoothDamp(f1, targets, ref cv1, 0.5f); Debug.Log("f1:" + f1): Debug.Log("cv1:" + cv1); // maxSpeed取有限值50.0f f2 = Mathf.SmoothDamp(f2, targets, ref cv2, 0.5f, maxSpeeds); Debug.Log("f2:" + f2); Debug.Log("cv2:"+ cv2); &#125;&#125; 在这段代码的FixedUpdate方法中调用了两次SmoothDamp方法，第一次调用时取maxSpeed值为默认值，即无穷大，第二次调用时取maxSpeed值为有限值，然后分别打印出它们每帧的输出值。下图分别是对输出值cv1和lcv2随时间变化的可视化显示，可以发现，起始时输出速度提升很快，结束时速度下降却很平缓，在移动距离相同的情况下，有最大速度限制的花费时间也更多。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity API解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在游戏中添加交互设施和物件]]></title>
    <url>%2F2019%2F03%2F12%2F%E5%9C%A8%E6%B8%B8%E6%88%8F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BA%A4%E4%BA%92%E8%AE%BE%E6%96%BD%E5%92%8C%E7%89%A9%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本章涵盖 编写程序，让玩家可以打开门（通过一个按键或者碰撞来触发） 使用物理模拟使堆叠的箱子分散 创建可收集的物件以供玩家存储在仓库中 使用代码来管理游戏状态，比如仓库数据 装备及使用仓库里的物件 在本章，你将会学到：1、如何创建像门这种具有功能的物件。2、如何收集物件，其中包括如何在当前关卡中和对象交互以及跟踪游戏状态。3、游戏通常需要跟踪一些状态，诸如玩家的当前状态、对象进展等。玩家的仓库就是这种状态的一个示例，所以你需要创建一个能用来跟踪玩家收集的物品的代码架构。 我们将从探索玩家单击按键来操作的设施（如门）开始，之后，将编写代码来检测玩家在关卡中何时碰撞对象，并做出像是推动附近的对象或者是收集可存储物件的这种互动功能。然后需要创建一个具有鲁棒性的MVC格式代码框架来管理收集的仓库数据。最终，你将为游戏玩法编写接口以便使用仓库，例如一个可以用来打开门的钥匙。 创建门和其他设施虽然游戏中的关卡大部分是由静态的墙壁和风景组成的，但它们也通常包括了很多具有功能的设施。现在讨论的对象是用户可以与之交互和操作的设施，例如可以打开的灯或者启动旋转的风扇。设施之间是可以有很大差别的，但是几乎都要使用相同类型的代码来让用户激活设施。 由按键控制开/关的门我们创建的第一种设施将是一个可以打开和关闭的门，通过单击按键来操作门。 在这个场景中，墙和墙的间隔之间有一些斑点，所以需要布置一个新的对象来挡住这个间隔。作者创建了一个立方体对象，然后设置它的位置为（2.5, 1.5, 17），大小为（5, 3.5）。在下图中可以看到所创建的这个门。 创建一个C#脚本，命名为DoorOpenDevice，然后将这个脚本放到门对象中。这段代码将会使对象表现出门的操作。 123456789101112131415161718192021222324252627// 根据命令打开和关闭门的脚本using UnityEngine;using System.Collections;public class DoorOpenDevice : MonoBehaviour&#123; [SerializeField] private Vector3 dPos; // 当打开门时要位移的位置 private bool _open; // 布尔参数追踪门的状态 public void Operate() &#123; if (_open) // 根据门的状态决定打开或关闭门 &#123; Vector3 pos = transform.position - dPos; transform.position = pos; // 新位置 &#125; else &#123; Vector3 pos = transform.position + dPos; transform.position = pos; &#125; _open = !_open; &#125;&#125; 其中第一个变量dPos定义的是当门打开时它的位移，当门打开时，它的值也会变化，而当门关上时这个值会减小。第二个变量open是一个私有的布尔变量，用于追踪判断门是打开或是关闭状态。在Operate()方法中，对象的变换设置为一个新位置，增加或者减少偏移则是取决于门是否已经打开了，然后_open对应地在打开或者关闭中切换。 和其他一系列变量一样，dPos也出现在Inspector中。但是这次它影响的是Vector3的值，所以和以前只有一个输入框相比，这里将会有三个，都在同一个变量的名下，输入当门打开时的相对位置，我决定让这个门下滑打开，所以这里的位移会是0, -2.9, 0（因为门对象的高度是3，下滑2.9就可以稍微在地板上留下门缝）。 这个变换会被立刻应用，但是当门打开时最好是能够看到运动，可以利用tween来使对象随着时间平滑移动。在游戏编程中，它指的是导致对象移动的代码；iTween就是一个很好的Unity缓动系统。 现在，其他的代码需要引用Operate()来让门开或者关（该函数就可以控制这两个操作）。我们目前还没有其他作用于玩家的脚本，下一步将编写这样的脚本。 在开门之前检查距离和朝向创建一个新脚本并命名为DeviceOperator。如下代码则会完成一个控制键，用来操作附近的设施。 123456789101112131415161718192021// 玩家的设施控制键using UnityEngine;using System.Collections;public class DeviceOperator : MonoBehaviour&#123; public float radius = 1.5f; // 玩家激活设施的距离 void Update() &#123; if(Input.GetButtonDown("Fire3")) // 响应Unity输入设置中定义的输入按钮 &#123; // OverlapSphere()返回一个附近对象的列表 Collider[] hitColliders = Physics.OverlapSphere(transform.position, radius); foreach(Collider hitCollider in hitColliders) &#123; // SendMessage()尝试调用指定的函数，不管目标对象的类型 hitCollider.SendMessage("Operate", SendMessageOptions.DontRequireReceiver); &#125; &#125; &#125;&#125; 这段代码中的大部分看起来都非常相似，但是代码中心有一个非常关键的新方法，首先，确定一个值，即距离多远可以操作设施。然后，在Update()方法中，检查键盘输入，因为Jump键已经在RelativeMovement脚本中使用过，这次我们将对Fire3做出响应（Fire3在项目的输入设置中作为保留命令按键）。 现在我们分析这个关键的新方法：OverlapSphere()。该方法返回在给定位置的给定距离中所有对象的数组。通过传入玩家的位置以及radius变量，可以检测出玩家附近的所有对象。实际所做的可能会和代码清单中的代码不同（比如你刚刚引爆了一个炸弹，然后需要去引用一个爆破力值），但在当前情况下，我们试图对周围所有对象都调用Operate()方法。 这种方法通过SendMessage()而不是通过传统的点记法被调用，在之前的章节中，在UI按钮中你也看到过这种方法。和之前一样，使用SendMessage())是因为我们不知道这个目标对象的确切类型，而这个类型信息会影响到所有的GameObjects的效果。这次我们将DontRequireReceiver选项传给这个方法，这是因为通过OverlapSphere()传回的对象大部分是没有Operate()方法的。通常，当对象中没有存在接受消息的组件时SendMessage()会打印错误消息，但是在这里，这个错误消息不需要被关注，因为我们已经知道大部分的对象会忽略这个消息。 一旦这段代码编写完成，就可以将这个脚本附加到玩家对象上，现在你可以站在门的附近，然后按下键来开门或者关门了。 这里有一个我们可以修复的小细节。目前而言，玩家的朝向并不影响门的开关，只要玩家站得离门足够近，但是我们还是可以调整脚本，使其只操作玩家正面对的设施，现在完成这个操作，回想第7章的内容知道，可以通过点积法来判断玩家的朝向，这是一个在两个向量上完成的数学运算，它将会返回一个在-1和1之间的值，其中1表示它们朝着完全相同的方向，而-1则表示它们的方向刚好相反。如下代码会给出在DeviceOperator脚本中的新代码。 12345678910// 调整DeviceOperator来使玩家只操作面向的设施foreach (Collider hitCollider in hitColliders)&#123; Vector3 direction = hitCollider.tranaform.position - transform.position; if (Vector3.Dot(transform.forward, direction) &gt; 0.5f) &#123; // 当面向正确的方向时才发送消息 hitCollider.SendMessage("Operate", SendMessageOptions.DontRequireReceiver); &#125;&#125; 在使用点积法之前，我们需要判断一下方向。通过在玩家位置和目标位置间做一个减法，就可以得到一个方向向量，该方向是由玩家指向目标对象的，然后在该方向向量和玩家目前的正朝向之间调用Vector3.Dot()，当其点积值非常接近1时（尤其是当代码检查到这个值大于0.5时），这意味着这两个向量所指向的方向非常接近。 通过这个调整，门不会在玩家朝向其他方向时被打开或者关闭了，即使玩家离门非常近。同样的，这个方法可以被应用到对其他不同设施的操作上面，为了证明其灵活性，下而创建另一个示例设施。 创建一个变色监控器我们已经创建了一个可以被打开或者关上的门，同样的设施操作逻辑也可以被运用在其他种类的设施上。接下来将创建另一种设施，它也是采用同样的方法来操作。这次，我们将创建一个展示在墙上的变色监控器。 建立一个新的立方体并放置它，使得它会在墙上超出一小部分。例如，选择位置(10, 91.5, -5)然后创建一个新脚本，命名为ColorChangeDevice；之后将这段脚本附加到墙上的显示器上。现在跑到墙壁的监控器处，单击和用于门一样的operate按键，将看到显示器颜色的改变。 12345using UnityEngine:using System.Collections;public class ColorchangeDevice : MonoBehaviour ipublic void Operate( 1 数字是介于0和1Color random - neu color (Random.Range (of,1t). 2间的RCB值 Random.Range (0f, 1f), Random, Range (0f,1f));GetComponent&lt;Renderer&gt;().material.color-random; 设置对案上的 材质的颜色定又一个和门脚本同名的方法 首先,声明一个与在门脚本DoorOpenDevice中使用的同名函数Operate, Operate是设施操作脚本中使用的函数名,所以为了触发显示器设施,需要使用Operate这个函数名。在这个函数中,代码会给对象材质分配一个随机的颜色(要记住,颜色并不是对象本身的个属性,而是对象所拥有的材质,然后材质才会有颜色). 注意: 即使颜色在大部分计算机图影中已经有了通过红、蓝,绿三种颜色的标准定义,在Unity的Color对象中颜色的值是在0和1之间,而不是在大部分情况下都通用的0到255(包括Unity的颜色拾取器UI).. 至此,我们已经讲解了一种在游戏中和设施交互的方法,并且为了演示实现了几种不同设备,另一种和对象交互的方法是和对象碰撞,接下来将讲解这个方法.8.2通过碰撞与对象交互 在上一节中,设施的操作是通过玩家敲击键盐来进行的,但这并不是玩家唯一能和当前关卡中的物件交互的方式。另一个非常直接的方法就是对玩家和对象的碰撞直接反应。Unity通过将碰撞检测和物理设置内置于游戏引案中,能够替你完成大部分的工作。虽然Unity会替你检测碰撞,但你还是需要创建一个对象来响应碰撞.我们将讲解三种在游戏中常见的碰撞响应:推开井且倒下触发关卡中的设施接触后消失(运用于捡起设施时)8.2.1 和具有物理功能的障碍物碰撞 首先,将创建一堆箱子,然后在玩家跑进这堆箱子时使其分散开。尽管这一过程涉及的物理计算非常复杂,但Unity内置了所有的运算并且会替我们将箱子以非常逼真的方式分敞开。 Unity默认情况下并不会使用其物理模拟来移动对象。这个功能的实现需要向对象添加一个Rigidbody组件,这个概念最先在第3章中讨论过,因为敌人的火球同样也需要一个Rigidbody组件。同第3章所述, Unity的物理系统仅仅会在拥有Rigidbody组件的对象上发挥作用。单击Add Component,然后在Physics菜单下找到Rigidbody. 创建一个新的立方体对象,然后给它添加一个Rigidbody组件,创建若干个这样的对象,然后把它们的位置摆成一堆,在下面的示例中,创建了五个箱子,然后将它们堆成两(如图8-3所示). 这些箱子现在已经准备好要响应物理上的外力,让玩家施加一个力作用在箱子上,向玩家的RelativeMovement脚本中添加一小段代码,如代码清单8.5所示(这段代码就是在之前章节中的脚本)。代码清单8.5为RelativeMovement脚本添加物理上的外力： 123456publis cloat pushEorce- 3.0f /要应用的力量值：.void OnControllerColliderHit (ControllerColliderHit hit)_contact -hiti 检查碰撞对象是否有 Rigidbody. 以便接受Rigidbody body-hit.collider.attachedRigidbody: 物理上的外力,if body != null ss !body.iskinematic) ( body.velocity-hit.moveDirection . pushForce; 将速度应用到 物理对象上关于这段代码并没有太多的解释:无论玩家碰撞到什么对象,都检查对象是否有Rigidbody组件,如果有,给这个Rigidbody施加一个速度、 运行游戏,然后让玩家角色冲进一堆箱子中,你应该会看到它们逼真地分散到周围。这就是你在场景中需要对一堆箱子激活的物理仿真! Unity有一个内置的物理仿真,所以我们不需要编写太多代码,这个模拟可以让对象响应碰撞进行位移,另一个需要的响应则是激活触发事件,下面用这些触发事件来控制门。8.22用一个压力板来触发门 鉴于之前通过按键来操控门,现在,门的开和关都将通过响应角色和场景中另一个对象的碰撞来完成,创建另一个门,然后将它放在另一面墙的空缺中(直接复制了之前的那个门,然后粘贴到(-2.5 1.5 -17)的位置上),现在,创建一个新的立方体用于这个触发对象,选中碰撞器的Is Trigger复选框(这一步在第3章中创建火球时解释过),另外,在监控器的右上角有一个Layer菜单,设置对象的层为Ignore Raycast.最后,需要关掉这个对象的投射阴影(请记佳,这个设定在你选择对象时,出现在Mesh Renderer的下面).警告: 这些细櫃但是很重要的步骤很容易被遺漏:將对象用作触发器时一定要打开Is Trigger.在Inspector中,检查一下Collider组件里的箱子,同样的,将层转变到Ignore Raycast,这样触发对象不会在光线投射中出现, 注意: 当我们在第3章首次介绍触发对象时,需要给这些对象添加一个Rigidbody纽件,但此时, Rigidbody对于触发对象而言不是必需的,因为它会对玩家做出触发响应(相较于早些时和墙壁的碰撞),为了让触发器工作,无论触发或者对象进入触发时,都需要有一个 Unity物理系统,一个Rigidhbody组件满足这一要求,但是玩家的CharacterController同样也满足这个条件。 调整触发对象的位置和大小,使其既覆盖到门同时也覆盖到门附近的区域,选择位置为(-2.5 1.5-17 门7也是这个位置),大小为(7.5 3.6),另外,你可能需要将一个半透明的材质t能给这个对象,然后就可以直观地从实体对象中区分出触发器。使用Assets菜单创建个新的材质,然后在Project视图中选择这个新建的材质。查看Inspector,顶部的设置为Rendering Mode(当前设置的默认值是Opaque),在这个菜单中选择Transparent. 现在,单击其色板弹出Color Picker窗口,在该窗口的主要部外选择绿色,然后使用底部的滑块降低alpha.从Project中将该材质拖动到对象上,图8-4显示了选择这种材质 定义：触发器通常被定义成体积而不是对象,这样是为了能从概念上把实体对象和可穿透对象区分开来. 运行游戏,现在你可以自由地穿过触发器, Unity依然记录着对象的碰撞,但是这些碰撞不再会影响到玩家的移动。我们需要编写一些代码来响应这些碰撞。具体来说,我们希望这个触发器可以控制门,创建一段新脚本,命名为DeviceTrigger(代码清单8.6所示).代码清单8.6控制一个设施的触发器的代码 1234567891011using UnityEngine:using System.collections;public class Devicerriqger: MonoBehaviour t[SerializeField] private GameObject[1 targets;魅发器要激活的目标对象列表void OnTriggerEnter (Collider other) tforeach (Gameobject target in targets)target.SendMessaqe ("hctivate").当另一个对象进入触发空间时, OnTrigerEntert)将被调用void OnTriggerExit (Collider other) &#123;4而当一个对象离开触发空间时, OnTriggerExit)将被i用foreach (Gameobject target in targeta) ttarget. SendMessage ("Deactivate"); 这段代码为触发器定义了一个目标对象数组,尽管当前该列表中只有一个元素,但它为单一触发器控制多个设施提供了可能。可以通过目标数组循环向所有目标发送消息,这个循环发生在OnTrigger Enter)和OnTriggerExit)方法中。当另一个对象首次进入和离开触发器时,会调用这些函数(而不是在对象处于触发空间内时不断地去调用这些函数). 注意,和以前发送的信息不同的是,现在我们需要给门定义Activate)和Deactivate))函数。现在,给门脚本添加代码清单8.7所示的代码.代码清单8.7将激活和不激活函数添加到DoorOpenDevice脚本 ：. 123456789publle void hetivate() tif (!_open) (vector3 pos -transfors.position + dPosi 当门没有打开transform.position . pos:,-open - trues 时,才打开,public void Deactivateo 1 同样,当门没有if (_open) i 关闭时才关闭 vector3 pos - transform.position -dPos; tranaform.position -posa open-falsen 新的Activate()和 Deactivate()方法的代码和之前的Operate0代码几乎相同,除了现在.开门和关门是独立分开的函数,而在过去是用一个函数来完成这两个操作. 在所有需要的代码都到位之后,现在就可以使用触发空间来开关门了.将Device trigger脚本添加到触发空间,然后将门和脚本中的target属性关联起来,在Inspector中,首先.设置数组的大小,然后将对象从Hierarchy视图中拖到目标数组槽里,因为我们只有一个门是用这个触发器控制的,所以在数组的Size中输入1,然后将门拖动到这个目标槽里。在完成这些之后,运行游戏,观察当玩家走向门和离开门时会发生什么。可以看到,当玩家走进和离开触发空间时,门会自动地打开和关闭. 这是另一个在游戏关卡中加入互动的好方法!这个触发空间方法不仅仅可以用于类似门这种设施上,也可以用这种方法来收集对象.]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5实战-使用C#和Unity开发多平台游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建第三人称3D游戏：玩家移动和动画]]></title>
    <url>%2F2019%2F03%2F12%2F%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B03D%E6%B8%B8%E6%88%8F%EF%BC%9A%E7%8E%A9%E5%AE%B6%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[本章涵盖 给场景添加实时阴影 使摄像机环绕它的目标 使用线性插值（Lerp）算法平滑修改旋转 为跳跃、悬崖、斜坡处理地面检测 为逼真的角色应用和控制动画 在第一人称视角中，玩家通过他们角色的眼睛来观察周围，而在第三人称视角中摄像机被放置在角色的外部。 3D模型这个词和网格对象一样，它是由顶点和多边形（即网格几何）定义的静态形状。对于一个人物角色。这个网格几何体被塑造成头、胳膊、腿等。 1将角色模型导入到场景2实现摄像机控制,以观察角色3编写脚本,让玩家能够在地面上跑4添加能够跳跃、移动的脚本5基于移动来播放模型的动画 7.1 调整摄像机视图为第三人称视角在编写代码让玩家到处移动之前,需要先将一个角色导入场景,并设置摄像机来观察角色。我们将导入一个无脸的人形模型作为玩家角色,然后在上方放置摄像机并以一个角度向下倾观察玩家。 7.1.1 导入一个用于观察的角色文件中包括了模型和贴图。 FBX是模型而TGA是贴图。将FBX文件导入到项目中,将该文件拖动到Project视图,或者右击项目视图并选择Import New Asset,然后查看Inspector来调整模型的导入设置。在本章后面,你将调整导入的动画,但是现在只需要在Model选项卡上做一些调整。首先,修改Scale Factor的值为10(为了部分抵消文件缩放的0.01),使得模型大小合适。在Scale Factor设置稍微往下,可以发现Normals选项(见图7-4)。这个设置控制了光线、阴影在模型上的显示,使用了通常所知的称为法线的3D数学概念 定义：法线(Normals)是垂直于多边形的方向向量,它将多边形的朝向告诉计算机。这个朝向方向用于光照计算。 Normals的默认设置是Import,它将使用定义在导入网格几何体的法线。但是个别模型无法正确定义法线并将以奇怪的方式对灯光做出反应。相反,修改设置为Calculate,以便Unity为每个多边形计算朝向的方向向量。 当修改完这两个设置后,单击Inspector上的Apply按钮。接着将TGA文件导入到项目,并将这张图片赋予材质的贴图。在Materials文件夹中选择player材质。将贴图图像拖到Inspector上的空的贴图槽。应用贴图之后,不会看到模型颜色发生了巨大的变化(贴图图像大多是白色)。但绘制在贴图的阴影,将改善模型的外观。 应用贴图后,把玩家模型从Project视图拖到场景中,设置角色位置为(0, 1.1.0),以便玩家位于房间的中心并且举起站在地板上。很好,现在场景中有一个第三人称的角色。注意:这个导入的角色有双臂,垂直两侧,而不是更自然的双臂向下姿态。这是因为还没有应用动画,这样的姿态被称为T形姿态,在动画角色播放动画前,它们的标准默认姿态是,T形姿态. 7.1.2将阴影添加到场景我们在真实世界里理当有阴影,但在虚拟的游戏世界中却不一定。很幸运Unity能处理这个细节,阴影通过场景中默认的灯光来打开。选择在场景中的平行光,然后在Inspector中找Shadow Type选项。作为默认的灯光,设置已经开启Soft Shadows(如图7-5所示)。但注意菜单中也有一个No Shadows选项。 你所需要做的是在这个项目中创建阴影,但还有很多关于游戏阴影方面的知识你应该知道。计算场景阴影是计算机图形学中特别耗时的一部分。所以游戏往往以不同的方式偷工减料,以达到所需的视觉外观要求。这种角色投影被称为实时阴影,因为阴影的计算是在游戏运行时和跟随移动对象移动时完成的。一个很真实的灯光设置会让所有的对象在实时接收和投射光线,但为了使得阴影计算运行得足够快,实时阴影限制了阴影看起来的外观或者哪个灯光可以投射阴影。注意,在这个场景中只有平行光投射阴影。 在游戏中处理阴影的另一种常见方式是使用一种称为光照贴图(lightmapping)的技术。 定义:Lightmaps是应用到平面几何体的贴图,这个几何体的阴影被烘焙到贴图图像中。定义:把阴影绘制到模型贴图上,这种技术被称为烘焙阴影. 因为这些图像是预先生成的(而不是在游戏运行时生成),所以它们可以非常复杂和真实。缺点是,因为阴影提前生成,所以它们不能运动。因此,光照贴图被广泛用于静态平面几何体,而不用于类似角色等动态对象上。光照贴图自动生成而不用手工绘制。计算机计算场景中的灯光如何照亮关卡,而角落边上则是隐约的黑暗。在Unity中,渲染光照贴图的系统称作Enlighten,你可以在Unity的手册中查找该关键字。 使用实时阴影或光照贴图,并不是一个非此即彼的选择。你可以设置灯光的CullingMask属性,使得实时阴影只用于确定的对象,同时允许你在场景中将高质量的光照贴图用于其他对象。同样,虽然你几乎总是让主角投射阴影,但有时可能不想让这个角色接收阴影,所有网格对象都有投射和接收阴影的设置(见图7-6). 定义:Culing这个术语通常是指移除不必要的东西,这个词在计算机图形学的许多不同情况下多次出现。但在此culling mask是指你想从阴影授射移除的一系列的对象。你现在明白了有关如何在场景中应用阴影的基础知识。场景中的灯光和阴影本身是一个很大的话题(关于关卡编辑的书往往在光照贴图上就占用了很多章节)。在这里限制在一盏灯上打开实时阴影。 7.1.3摄像机环绕玩家角色在第一人称示例中,在Hierarchy视图中,摄像机和玩家关联在一起,所以它们会一起旋转。然而,在第三人称的移动示例中,玩家将独立于摄像机朝向不同的方向。因此这次,在Hierarchy视图上你不会把摄像机拖到角色上。相反,摄像机的代码将跟随玩家角色移动其位置,但独立于摄像机做旋转。 首先,把摄像机放置在相对于玩家的位置,为了把摄像机放在玩家的后上方,把位置设置为(0, 3.5,-3.75(如果有必要,把旋转重置为0,0,0),然后创建OrbirCamera脚本(参见代码清单7.1),将这个脚本组件添加到摄像机上,然后把玩家角色拖到这个脚本的Target字段的空槽上。现在可以运行场景,看到在运行的摄像机代码效果。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5实战-使用C#和Unity开发多平台游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity脚本程序开发（1）]]></title>
    <url>%2F2019%2F03%2F12%2FUnity%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Unity中的脚本程序如果要起作用，主要途径为将脚本附加到特定的游戏对象上。这样，脚本中不同的方法在特定的情况下会被回调，实现特定的功能。下面给出几个最常用的回调方法。 Start：在游戏场景加载时被调用，在该方法内可以写一些游戏场景初始化之类的代码。 Update：会在每一帧渲染之前被调用，大部分游戏代码在这里执行，除了物理部分的代码。 FixedUpdate：会在固定的物理时间步调调用一次。这里也是基本物理行为代码执行的地方。 同时，还有一种可以称为方法外部代码的源代码，其在物理加载时运行，还可以用于初始化脚本状态，有点类似于C#里面的成员变量声明。 开发人员还可以重写一些处理特定事件的回调方法，这类方法一般以On前缀开头，如OnCollisionEnter方法（此方法在系统检测到碰撞开始时被回调）等。 其实上述的方法与代码在开发中一般都是位于MonoBehaviour类的子类中的，也就是说开发脚本代码时，主要是继承MonoBehaviour类并重写其中特定的方法。 继承自MonoBehaviour类Unity中所有挂载到游戏对象上的脚本中的类必须继承MonoBehaviour类（直接的或间接的）。MonoBehaviour类中定义了各种回调方法，如Start，Update和FixedUpdate等回调方法。 类名字必须匹配文件名C#脚本中类名需要手动编写，而且类名还必须和文件名相同，否则当脚本挂载到游戏对象时，在控制台会报错。 使用Awake或Start方法初始化用于初始化脚本的代码必须置于Awake或Start方法中。两者的不同之处在于，Awake方法是在加载场景时运行；Start方法是在第一次调用Update或FixedUpdate方法之前被调用；Awake方法运行在所有Start方法之前。 Unity脚本中协同程序有不同的语法规则Unity脚本中协同程序（Coroutines）必须是IEnumerator返回类型，并且yield被yield return替代，具体操作时可以使用如下的C#代码片段来实现。 12345678910using UnityEngine; //导入系统包using System.Collections;public class NewBehaviourScript : MonoBehaviour // 声明类&#123; IEnumerator SomeCoroutine&#123; // C#协同程序 yield return 0; // 等待1帧 yield return new WaitForSeconds(2); // 等待2s &#125;&#125; 只有满足特定情况变量才能显示在属性查看器中只有序列化的成员变量才能显示在属性查看器中，而private和protected类型的成员变量只能在专家模式中显示，而且，其属性不被序列化或显示在属性查看器中。如果属性想在属性查看器中显示，其必须是public类型的。 尽量避免使用构造函数不要在构造函数中初始化任何变量，要用Awake或Start方法来实现。即便是在编辑模式，Unity仍会自动调用构造函数，这通常是在一个脚本编译之后，因为需要调用脚本的构造函数来取回脚本的默认值。无法预计何时调用构造函数，它或许会被预制件或未激活的游戏对象所调用。而在单一模式下使用构造函数可能会导致严重后果，会带来类似随机的空引用异常。因此，如果想实现单一模式就不要用构造函数，要用Awake或Start方法。事实上，没必要在继承自MonoBehaviour类的构造函数中写任何代码。 断点Unity中通过Debug.Break()设置断点，如果想查看特定情况发生时对象属性的变化时，用断点可以快速地完成。 常用操作Unity中很多对游戏对象的操作都是通过在脚本中修改对象的Transform（变换属性）与Rigidbody（刚体属性）参数来实现的，上述属性的参数可以非常方便地通过脚本编程实现修改。例如，让物体绕x轴顺时针旋转20°，则可以使用如下的C#代码片段来实现。 12345678910using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; void Update() &#123; this.transform.Rotate(20, 0, 0); &#125;&#125; 脚本开发完成后，将这个脚本挂载到需要旋转的游戏对象上，在项目运行时即可实现所需功能。如果希望游戏对象沿z轴正方向移动，则可以使用如下的C#代码片段来实现。该代码运行时可以实现游戏对象GameObject每帧向前移动1个单位。 12345678910using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; void Update() &#123; this.transform.Translate(0, 0, 1); &#125;&#125; 一般情况下，在Unity中，x轴为红色的轴表示左右，y轴为绿色的轴表示上下，z轴为蓝色的轴表示前后。 用于旋转的Rotate方法和用于移动的Translate方法都有4个参数的重载形式。第四个参数为Space枚举类型，如果设置为“Space.Self”，变换被应用相对于自身轴；如果设置为“Space. World”，变换被应用相对于世界坐标系统。如果不设置第四个参数，则默认设置为“Space.Self”。 记录时间在Unity中记录时间需要用到Time类。Time类中比较重要的变量为deltaTime（只读），它指的是从最近一次调用Update或者FixedUpdate方法到现在的时间，如果想均匀地旋转一个物体，不考虑帧速率的情况下，可以乘以Time.deltaTime，具体操作时可以使用如下的C#代码片段来实现。 12345678910using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; void Update() &#123; this.transform.Rotate(10 * Time.deltaTime, 0, 0); &#125;&#125; 如果想每秒增加或者减少一个值，需要乘以Time.delaTime，同时也要明确在游戏中是需要每秒1个单位还是每帧1个单位的效果。如果是乘以Time.deltaTime，那么，游戏对象就会按固定的节奏运动而不是依赖游戏的帧速率，因此，游戏对象的运动变得更容易控制。 例如，想让游戏对象沿y轴正方向每秒上升5个单位，具体操作时可以使用如下的C#代码片段来实现。 1234567891011121314using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; public GameObject gameObject; // 声明游戏对象 void Update() &#123; Vector3 te = gameObject.transform.position; // 获取游戏对象的位置坐标 te.y += 5 * Time.deltaTime; // 沿y轴每秒上升5个单位 gameObject.transform.position = te; // 设置游戏对象的位置坐标 &#125; &#125; 如果涉及刚体时，可以写在FixedUpdate方法里面。在FixedUpdate方法里面，如果想每秒增加或者减少一个值，需要乘以TimefixedDeltaTime。例如，想让刚体沿y轴正方向每秒上升5个单位，具体操作时可以使用如下的C#代码片段来实现。 1234567891011121314using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; public GameObject gameObject; // 声明游戏对象 void FixedUpdate() &#123; Vector3 te = gameObject.GetComponent&lt;Rigidbody&gt;().transform.position; // 获取刚体的位置坐标 te.y += 5 * Time.fixedDeltaTime; // 刚体沿y轴每秒上升5个单位 gameObject.GetComponent&lt;Rigidbody&gt;().transform.position = te; // 设置刚体的位置坐标 &#125; &#125; FixedUpdate方法是按固定的物理时间被系统回调执行的，其中代码的执行和游戏的帧速率无关。 访问游戏对象组件组件属于游戏对象，比如把一个Renderer（渲染器）组件附加到游戏对象上，可以使游戏对象显示到游戏场景中；把Camera（摄像机）组件附加到游戏对象上可以使该对象具有摄像机的所有属性。由于所有的脚本都是组件，因此一般的脚本都可以附加到游戏对象上。 常用的组件可以通过简单的成员变量取得。下面介绍了一些常见的成员变量，如下表所示。| 组件名称 | 变量名称 || :———— | :———— || Transform | transform || Rigidbody | rigidbody || Renderer | renderer || Camera | camera（只在摄像机对象有效） || Light | light（只在光源对象有效） || Animation | animation || Collider | collider | 这里的组件体现在属性查看器上，而变量是在脚本中体现的。一个游戏对象的所有组件及其所带的属性参数都能够在属性查看器中查看。如果想通过挂载在游戏对象上的脚本代码来实现获得该游戏对象上的对应组件及其属性，可以通过变量名来获得。 如果想查看所有的预定义成员变量，可以查看关于Component、Behaviour和MonoBehaviour类的文档。如果游戏对象中没有想要取得的值，那么上面的变量将为null。在Unity中，附加到游戏对象上的组件可以通过GetComponent方法获得，具体操作时可以使用如下的C#代码片段来实现。代码中第4行和第5行代码功能是一样的，都是使游戏对象沿x轴正方向移动，而第5行代码通过获取Transform组件来使游戏对象移动。 1234567891011using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; void Update() &#123; transform.Translate(1, 0, 0); // 沿x轴移动一个单位 GetComponent&lt;Transform&gt;().Translate(1, 0, 0); // 沿x轴移动一个单位 &#125; &#125; 同样地，也可以通过GetComponent方法获取其他的脚本。比如有一个HelloWorld的脚本，里面有一个sayHello方法。HelloWorld脚本要与调用它的脚本附加在同一游戏对象上，具体操作时可以使用如下的C#代码片段来实现。 1234567891011using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; void Update() &#123; HelloWorld helloWorld = GetComponent&lt;HelloWorld&gt;(); // 获取"HelloWorld"脚本组件 helloWorld.sayHello(); &#125; &#125; 在C#代码中只有public类型的变量和方法才能在所有其他类中使用，private类型的变量和方法只能在自身类中使用，protected类型的变量和方法只能在子类和同命名空间下的类中使用，而不写类型的变量和方法只能在同命名空间下的类中使用。 访问其他游戏对象大部分脚本不单单控制其附加到的游戏对象。Unity脚本中有很多方法访问其他的游戏对象和游戏组件，可以通过属性查看器指定参数的方法来获取游戏对象，也可以通过Find()方法来获取游戏对象。下面将对这几种方法进行详细介绍。 通过属性查看器指定参数代码中声明public类型的游戏对象引用，在属性查看器中就会显示这个游戏对象参数，然后就可以将需要获取的游戏对象拖曳到属性查看器的相关参数位置，具体操作时可以使用如下的C#代码片段来实现。代码获取游戏对象上的{“Test”脚本组件，然后执行doSomething方法。 12345678910111213using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; public GameObject otherObject; void Update() &#123; Test test = otherObject.GetComponent&lt;Test&gt;(); // 获取“Test”脚本组件 test.doSomething(); // 执行doSomething方法 &#125; &#125; 确定对象的层次关系游戏对象在游戏组成对象列表中存在父子关系，在代码中可以通过获取Transform组件来找到子对象或者父对象。具体操作时可以使用如下的C#代码片段来获取游戏对象的子对象和父对象。 1234567891011using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; void Update() &#123; transform.Find("hand").Translate(0, 0, 1); // 其沿z轴每帧移动1个单位 transform.parent.Translate(0, 0, 1); // 每帧移动1个单位 &#125; &#125; 一旦读者成功获取到“hand”子对象，就可以通过GetComponent方法获取“hand”对象的其他组件。例如，有一个Test脚本挂载在子对象“hand”上，具体操作时可以使用如下的C#代码来实现。 123456789101112using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; void Update() &#123; transform.Find("hand").GetComponent&lt;Test&gt;().a = 2; // 找到子对象“hand”，同时设置“Test”脚本中的变量a为2 transform.Find("hand").GetComponent&lt;Test&gt;().doSomething(); // 执行doSomething方法 transform.Find("hand").GetComponent&lt;Rigidbody&gt;().AddForce(0, 0, 2); // 为“hand”子对象的刚体属性上加一个沿z轴的大小为2的力 &#125; &#125; 也可以使用脚本来循环获取到所有的子对象，然后对子对象做某种操作，如平移、旋转等。具体操作时可以使用如下的C#代码片段来实现。 12345678910111213using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; void Update() &#123; foreach(Transform child in transform) // 循环获取所有的子对象 &#123; child.Translate(0, 5, 0); // 沿y轴每帧移动5个单位 &#125; &#125; &#125; 通过名字或标签获取游戏对象Unity脚本中可以使用FindWithTag方法和Find方法来获取游戏对象，FindWithTag方法获取指定标签的游戏对象，Find方法获取指定名字的游戏对象。具体操作时可以使用如下的C#代码片段。 12345678910111213141516using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; void Start() &#123; GameObject name = GameObject.Find("somename"); // 获取名称为“somename”的游戏对象 name.GetComponent&lt;Test&gt;().doSomething(); name.transform.Translate(0, 0, 1); // 沿z轴平移 GameObject tag = GameObject.FindWithTag("sometag"); // 获取标签为“sometag”的游戏对象 tag.transform.Translate(0, 0, 1); // 沿z轴平移 tag.GetComponent&lt;Test&gt;().doSomething(); &#125;&#125; 这样，通过GetComponent方法就能得到指定游戏对象上的任意脚本或组件。 通过传递参数来获取游戏对象一些事件回调方法的参数中包含了特殊的游戏对象或组件信息，例如触发碰撞事件的Collider组件。在OnTiggerStay方法的参数中有一个碰撞体参数，通过这个参数能得到碰撞的刚体。具体代码如下。 12345678910111213141516171819using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; void OnTriggerStay(Collider other) // 重写OnTriggerStay方法 &#123; if (other.GetComponent&lt;Rigidbody&gt;()) // 如果该游戏对象上有刚体组件 &#123; other.GetComponent&lt;Rigidbody&gt;().AddForce(0, 0, 2); // 给刚体施加一个力 &#125; if (other.GetComponent&lt;Test&gt;()) // 如果该游戏对象上有“Test”脚本组件 &#123; other.GetComponent&lt;Test&gt;().doSomething(); &#125; &#125;&#125; 通过组件名称获取游戏对象Unity脚本中可以通过FindObjectsOfType方法和FindObjectOfType方法来找到挂载特定类型组件的游戏对象。FindObjectsOfType方法可以获取所有挂载指定类型组件的游戏对象，而FindObjectOfType方法获取挂载指定类型组件的第一个游戏对象。具体操作时可以使用如下的C#代码来实现。 1234567891011121314151617using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; void Start() // 重写Start方法 &#123; Test test = FindObjectOfType&lt;Test&gt;(); // 获取第一个找到的“Test”组件 Debug.Log(test.gameObject.name); // 打印挂载“Test”组件的第一个游戏对象的名称 Test[] tests = FindObjectsOfType&lt;Test&gt;(); // 获取所有的“Test”组件 foreach( Test te in tests) &#123; Debug.Log(te.gameObject.name); // 打印挂载“Test”组件所有的游戏对象的名称 &#125; &#125;&#125; 向量3D游戏开发中经常需要用到向量和向量的运算，Unity中提供了完整的向量以及向量操纵方法,分别为表示二维向量的Vector2类和表示三维向量的Vector3类,因为二维向量和三维向量的使用方法相同,下面将以三维向量为例详细介绍Unity中向量的使用方法。 Vector3类可以在实例化时进行赋值，也可以实例化后给x、y、z分别进行赋值。具体操作时可以使用如下的C#代码片段来实现。 123456789101112131415using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; public Vector3 position1 = new Vector3(); // 实例化Vector3 public Vector3 position2 = new Vector3(1, 2, 2); // 实例化Vector3并赋值 void Start() // 重写Start方法 &#123; position1.x = 1; position1.y = 2; position1.z = 2; &#125;&#125; Vector3类中也定义了一些常量，例如Vector.up等同于Vector(0, 1, 0)，这样可以简化代码。这些常量对应的值如下表所示。 常量 值 Vector3.zero Vector(0,0,0) Vector3.one Vector(1,1,1) Vector3.forward Vector(0,0,1) Vector3.up Vector(0,1,0) Vector3.right Vector(1,0,0) Vector3类中有很多对向量进行操纵的方法，例如想要获得两点之间的距离时，可以使用Distance方法来完成。这些方法的具体作用如下表所示。| 方法 | 作用 || :———— | :———— || Lerp | 两个向量之间的线性插值 || Slerp | 在两个向量之间进行球形插值 || OrthoNormalize | 使向量规范化并且彼此相互垂直 || MoveTowards | 从当前的位置移向目标 || RotateTowards | 当前的向量转向目标 || SmoothDamp | 随着时间的推移，逐渐改变一个向量朝向预期的目标 || Scale | 两个矢量组件对应相乘 || Cross | 两个向量的交叉乘积 || Reflect | 沿着法线反射向量 || Dot | 两个向量的点乘积 || Project | 投影一个向量到另一个向量 || Angle | 返回两个向量的夹角 || Distance | 返回两点之间的距离 || ClampMagnitude | 返回向量的长度，最大不超过maxLength所指示的长度 || Min | 返回两个向量中长度较小的向量 || Max | 返回两个向量中长度较大的向量 || operator + | 两个向量相加 || operaton - | 两个向量相减 || operatos * | 两个向量相乘 || operator / | 两个向量相除 || operator == | 两个向量是否相等 || operastor != | 两个向量是否不相等 | 成员变量和静态成员变量一般情况下，定义在方法体外的变量是成员变量，如果这个变量为public类型的，就可以在属性查看器看到，若在属性查看器对它的值进行修改，它的值就会随着项目一起自动保存。C#脚本如下。 1public int a = 1; 可以在属性查看器中看到这个变量，名字为“a”，它默认显示的值为“1”，读者可以随时在属性查看器中修改它的值。 如果声明的是一个组件类型的变量（类似GameObject、Transform、Rigidbody等），需要在属性查看器中拖曳游戏对象到变量处并确定它的值。具体操作时可以使用如下的C#代码片段来实现。 123456789101112131415using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; public Transform ren; // 声明一个Transform组件 void Update() &#123; if (Vector3.Distance(ren.position, transform.position) &lt; 10) // 如果ren和transform的距离小于10 &#123; Debug.Log(ren.position); &#125; &#125;&#125; 可以通过private关键字创建私有变量，此时在属性查看器中就不会显示该变量，避免其被错误地修改，具体操作时可以使用如下的C#代码片段来实现。 1234567891011using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; private Collider collider; // 声明私有的collider组件 void OnCollisionEnter(Collision, collisionInfo) // 重写OnCollisionEnter方法 &#123; collider = collisionInfo.collider; // 获取Collider组件 &#125;&#125; 在C#脚本中可以通过static关键字来创建全局变量，这样就可以在不同脚本间调用这个变量。具体操作时可以使用如下的C#代码片段来实现。 1public static int test; 如果想从另外一个脚本中调用变量“Test”，读者可以通过“脚本名.变量名”的方法来调用。具体操作时可以使用如下的C#代码片段来实现。 12345678910using UnityEngine;using System.Collections;public class HelloWorld : MonoBehaviour&#123; void Start() &#123; Test.test = 1; // 为“Test”脚本中的“test”变量赋值 &#125;&#125; 实例化游戏对象Unity中如果想创建游戏对象，可以通过创建游戏对象菜单在场景中创建游戏对象（这些游戏对象在场景加载的时候被创建出来），也可以在脚本中动态地创建游戏对象。在游戏运行的过程中，根据需要在脚本中实例化游戏对象的这些方法更加灵活。 Unity中如果想创建很多相同的物体（如射击出去的子弹、保龄球瓶等）时，可以通过实例化（Instantiate）快速实现，而且实例化出来的游戏对象包含了这个对象所有的属性，就能保证原封不动地创建所需的对象。实例化在Unity中有很多用途，充分地使用它非常必要。 例如，创建一个脚本“Hit.cs”，该脚本的功能为当一个碰撞体撞击到一个物体时，销毁这个物体，并在原来的位置实例化一个损坏的物体。该脚本的代码如下所示。 12345678910111213using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; public GameObject explosion; // 声明游戏对象引用 void OnCollisionEnter() // 重写OnCollisionEnter方法 &#123; Destroy(gameObject, 1); // 撞击发生1s后销毁对象 GameObject theClonedExplosion = Instantiate(explosion, transform.position, transform.rotation) as GameObject; // 在物体原来的位置实例化一个损坏的物体 &#125;&#125; Destroy(gameObject,n)方法是在ns后销毁物体。如果想立刻销毁物体可以使用DestroyImmediate(gameObject.boolean)，如果参数的布尔值为true，就会立刻销毁物体。 协同程序和中断协同程序，即在主程序运行时同时开启另一段逻辑处理，来协同当前程序的执行，但它与多线程程序不同，所有的协同程序都是在主线程中运行的，它还是一个单线程程序。在Unity中可以通过StartCoroutine方法来启动一个协同程序。 StartCoroutine方法为MonoBehaviour类中的一个方法，也就是说该方法必须在MonoBehaviour或维承于MonoBehaviour的类中调用。StartCoroutine方法可以使用返回值作为IEnumerator类型方法的参数。 12345678910111213141516using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; void Start() &#123; StartCoroutine(doThing()); // 开启协同程序 &#125; IEnumerator doThing() // 声明doThing方法 &#123; Debug.Log("dothing"); yield return null; &#125;&#125; 协同程序中可以使用yield关键字来中断协同程序，也可以使用WaitForSeconds类的实例化对象让协同程序休眠。 1yield return new WaitForSeconds(2); 可以将多个协同程序进行连接，创建一个脚本，该脚本功能为在Start方法开启doThing1协同程序，在doThing1协同程序中开启并等待执行doThing2协同程序，doThing2协同程序休眠2s然后打印“doThing2”提示信息，doThing2协同程序执行完后返回doThing1协同程序然后打印“doThing1”提示信息，具体代码如下。 1234567891011121314151617181920212223using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; void Start() &#123; StartCoroutine(doThing1()); // 开启doThing1协同程序 &#125; IEnumerator doThing1() // 声明doThing1方法 &#123; yield return StartCoroutine(doThing2); // 开启doThing2协同程序 Debug.Log("dothing1"); &#125; IEnumerator doThing2() // 声明doThing2方法 &#123; yield return new WaitForSeconds(2); // 协同程序休眠2s Debug.Log("dothing2"); &#125;&#125; 一些重要的类MonoBehaviour类MonoBehaviour类是每个脚本的基类，其继承自Behaviour类。在C#脚本中，必须直接或间接地继承MonoBehaviour类，MonoBehaviour类中的一些方法可以重写，这些方法会被系统在固定的时间回调，常用的可以重写的方法如下表所示。| 方法 | 说明 || :———— | :———— || Update | 当脚本启用后，该方法在每一帧被调用 || FixedUpdate | 当脚本启用后，这个方法会在固定的物理时间步调调用一次 || Awake | 当一个脚本实例被载入时该方法被调用 || Start | 该方法仅在Update方法第一次被调用前调用 || OnCollisionEnter | 当刚体撞击碰撞体或碰撞体撞击刚体时该方法被调用 || OnEnable | 当对象变为可用或激活状态时该方法被调用 || OnDisable | 当对象变为不可用或非激活状态时该方法被调用 || OnDestroy | 当对象被销毁时该方法被调用 || OnGUI | 渲染和处理GUI事件时调用 | MonoBehaviour类中有许多可以被子类继承的成员变量，这些成员变量可以在脚本中直接使用，常用的可继承的成员变量如下表所示。| 成员变量 | 说明 || :———— | :———— || enabled | 启用行为被更新，禁用行为不更新 || transform | 附加到游戏物体的Transform组件（如无附加则为空） || rigidbody | 附加到游戏物体的Rigidbody组件（如无謝加则为空） || camera | 附加到游戏物体的Camera组件（如无附加则为空） || light | 附加到游戏物体的Light组件（如无附加则为空) || animation | 附加到游戏物体的Animation组件（如无附加则为空） || constantForce | 附加到游戏物体的ConstantForce组件（如无附加则为空） || renderer | 附加到游戏物体的Renderer组件（如无附加则为空） || audio Source | 附加到游戏物体的AndioSource组件（如无附加则为空） || guiText | 附加到游戏物体的GUIText组件（如无附加则为空） || collider | 附加到游戏物体的Collider组件（如无附加则为空） || particleEmitter | 附加到游戏物体的ParticleEmitter组件（如无附加则为空） || gameObject | 组件附加的游戏物体，一个组件总是被附加到一个游戏物体 || tag | 游戏物体的标签 | MonoBehaviour类中有许多可以被子类继承的成员方法，这些成员方法可以直接在子类中使用。常用的可继承的成员方法如下表所示。 成员方法 说明 GetComnonent 返阿游戏物体上指定名称的组作 GetComponentInChildren 返回游戏对象及其子对象上指定类型的第一个找到的组件 GetComponents 返回游戏物体上指定名称的全部组件 SendMessage 在游戏物体每一个脚本上调用指定名称的方法 Instantiate 实例化游戏对象 Destroy 删除一个游戏物体、组件或资源 DestroyImmediate 立即销效物体 FindObjectsOfType 返回指定类型的所有激活的加载的物体列表 FindObjectOType 返同指定类型第一个激活的加载的物体 Transform类场景中的每一个物体都有一个“Transform”组件，它就是Transform类实例化的对象，用于储存并操控物体的位置、旋转和缩放，每一个Transform可以有一个父级，允许分层次应用位置、旋转和缩放。可以在“Hierarchy”面板查看层次关系。Transform类中包含了很多的成员变量，常用的成员变量如下表所示。| 成员方法 | 说明 || :———— | :———— || position | 在世界空间坐标中游戏对象的位置 || localPosition | 相对于父级的变换的位置 || eulerAngles | 物体旋转的欧拉角 || localEulerAngles | 相对于父级旋转的欧拉角 || right | 在世界空间坐标变换的红色轴。也就是x轴 || up | 在世界空间坐标变换的绿色轴。也就是y轴 || forward | 在世界空间坐标变换的蓝色轴。也就是z轴 || rotation | 在世界空间坐标物体变换的旋转角度 || localRotation | 物体变换的旋转角度相对于父级的物体变换的旋转角度 || localScale | 相对于父级物体变换的缩放 || parent | 物体变换的父级 || worldToLocalMatrix | 从世界坐标转为自身坐标的矩阵变换（只读） || localToWorldMatrix | 从自身坐标转为世界坐标的矩阵变换（只读） || childCount | 变换的子物体数量 || lossyScale | 物体的全局缩放（只读） | Transform类中也包含了很多的成员方法。常用的成员方法如下表所示。| 成员方法 | 说明 || :———— | :———— || Translate | 移动游戏对象的方向和距离 || Rotate | 应用一个欧拉角的旋转角度 || RotateAround | 按照指定角度通过在世界坐标轴旋转物体 || LookAt | 旋转物体，这样指向目标的当前位置 || TransformDirection | 从自身坐标到世界坐标变换方向 || InverseTransformDirection | 变换方向从世界坐标到自身坐标 || TransformPoint | 变换位置从自身坐标到世界坐标 || InverseTransformPoint | 变换位置从世界坐标到自身坐标 || DetachChildren | 所有子物体解除父子关系 || IsChildOf | 这个变换是否是父级的子物体 | Rigidbody类“Rigidbody”组件可以模拟物体在物理效果下的状态，它就是Rigidbody类实例化的对象，它可以让物体接受力和扭矩，让物体相对真实地移动，如果一个物体想被重力所约束，其必须含有Rigidbody组件。Rigidbody类中包含了很多的成员变量，常用的成员变量如下表所示。 成员变量 说明 velocity 刚体的速度向量 angularVelocity 刚体的角速度向量 drag 物体的阻力 angularDrag 物体的角阻力 mass 刚体的质量 useGravity 控制重力是否影响整个刚体 isKinematic 控制物理是否影响这个刚体 freezeRotation 控制物理是否改变物体的旋转 collisionDetectionMode 刚体的碰撞检测模式 centerOfMass 相对于变换原点的重心 worldCenterOfMass 在世界坐标空间的刚体的重心（只读） inertiaTensorRotation 惯性张量的旋转 inertiaTensor 相对于重心的质量的惯性张量对角线 detectCollisions 碰撞检测应否启用（默认总是启用的） useConeFriction 用于该刚体的锥形摩擦力 position 该刚体的位置 rotation 该刚体的旋转 interpolation 插值允许你以固定的帧率平滑物理运行效果 solverIterationCount 允许覆盖每个刚体的求解迭代次数 sleepVelocity 线性速度，低于该值的物体将开始休眠 sleepAngularVelocity 角速度，低于该值的物体将开始休眠 MaxAngularVelocity 刚体的最大角速度 Rigidbody类中也包含了很多的成员方法，常用的成员方法如下表所示。 成员方法 说明 SetDensity 基于附加的碰撞器假设一个固定的密度设置质量 AddForce 施加一个力到刚体 AddRelativeForce 施加一个力到刚体，相对于自身的系统坐标 AddTorque 施加一个力矩到刚体 AddRelativeTorque 施加一个力矩到刚体，相对于自身的系统坐标 AddForceAtPosition 在指定位置施加一个力 AddExplosionForce 施加一个力到刚体来模拟爆炸效果，爆炸力将随着到刚体的距离线性衰减 ClosestPointOnBounds 到附加的碰撞器包围盒上的最近点 GetRelativePointVelocity 相对于刚体在指定点的速度 GetPointVelocity 刚体在世界坐标空间中指定点的速度 MovePosition 移动刚体到指定位置 MoveRotation 旋转刚体到指定角度 Sleep 强制一个刚体休眠至少一帧 IsSleeping 判断刚体是否在休眠 WakeUp 强制唤解在休眠状态中的刚体 CharacterController类角色控制器是CharacterController类的实例化对象，用于第三人称或第一人称游戏角色控制。它可以根据碰撞检测判断是否能够移动，而不必添加刚体和碰撞器。而且角色控制器不会受到力的影响。 CharacterController 类包含了很多的成员变量，常用的成员变量如下表所示。 成员变量 说明 isGrounded 角色控制器是否触碰地面 velocity 角色控制器当前的相对速度 collisionFlags 在最近一次角色控制器移动方法调用时，角色控制器的哪个部分与周围环境相碰撞 radius 角色控制器的半径 height 角色控制器的高度 center 角色控制器的中心位置 slopeLimit 角色控制器的坡度度数限制 stepOffset 角色控制器的台阶偏移量（台阶高度） detectCollisions 其他的刚体和角色控制器是否能够与本角色控制器相碰撞 CharacterController类中也包含了很多的成员方法，常用的成员方法如下表所示。| 成员方法 | 说明 || :———— | :———— || SimpleMove | 以一定的速度移动角色 || Move | 一个更加复杂的移动函数，每次都绝对移动 | 性能优化Unity本身已经针对各个平台在功能上进行了大量的优化，保证了程序的顺利运行，但在使用Unity开发软件的过程中，培养良好的开发习惯，积累编程技巧，对开发人员是至关重要的。良好的开发习惯不仅能帮助开发人员编写健康的程序，还能达到事半功倍的效果。下面将介绍一些针对Unity开发的优化措施。1.缓存组件查询当通过GetComponent获取一个组件时，Unity必须从游戏物体里查找目标组件，如果是在Update方法中进行查找，就会影响运行速度。可以设置一个私有变量去储存这个组件，这样，Unity无需在每一帧中去查询组件。实现方法可以参考如下代码片段。 1234567891011121314151617using UnityEngine;using System.Collections;public class NewBehaviourScript : MonoBehaviour&#123; private Transform m_transform; void Start() &#123; m_transform = this.transform; &#125; void Update() &#123; m_transform.Translate(new Vector3(0, 0, 1)); &#125;&#125; 2.使用内建数组虽然ArrayList和Array用起来容易并且方便，但是相比较内建数组而言，前者和后者的速度还是有很大的差异。内建数组直接嵌入struct数据类型存入第一缓冲区里，不需要其他类型信息或者其他资源，因此用作缓存遍历更加快捷。实现代码如下。 脚本编译 作为一名Unity开发者，熟悉Unity脚本的编译步骤是很有必要的。这样可以让我们更加高效地编写自己的代码，如果代码出现了问题，还能有效地改正错误。由于脚本的编译顺序会涉及特殊文件夹，所以脚本的放置位置就非常重要了。根据官方的解释，脚本的具体编译需要以下4步。 (1)所有在Standard Assets. Pro Standard Assets和Plugins中的脚本将被首先编译。在这些文件夹之内的脚本不能直接访问这些文件夹以外的脚本,不能直接引用类或它的变量,但是可以使用GameObject.SendMessage与它们通信。 (2)所有在Standard Assets/Editor, Pro Standard Assets/Editor和Plugins/Editor中的脚本接着被编译。如果想要使用UnityEditor命名空间,必须将你的脚本放置到这些文件夹。 (3)然后所有在Assets/Editor外面的,并且不在(1)、 (2)中的脚本文件被编译。 (4)所有在Assets/Editor中的脚本,最后被编译。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity游戏开发技术详解与典型案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SceneManager.LoadScene]]></title>
    <url>%2F2019%2F03%2F11%2FSceneManager-LoadScene%2F</url>
    <content type="text"><![CDATA[public static void LoadScene(int sceneBuildIndex, SceneManagement.LoadSceneMode mode = LoadSceneMode.Single); public static void LoadScene(string sceneName, SceneManagement.LoadSceneMode mode = LoadSceneMode.Single); Parameters： sceneName Name or path of the Scene to load.sceneBuildIndex Index of the Scene in the Build Settings to load. mode Allows you to specify whether or not to load the Scene additively. See LoadSceneMode for more information about the options. Description： Loads the Scene by its name or index in Build Settings. Note: In most cases, to avoid pauses or performance hiccups while loading, you should use the asynchronous version of this command which is: LoadSceneAsync. When using SceneManager.LoadScene, the loading does not happen immediately, it completes in the next frame. This semi-asynchronous behavior can cause frame stuttering and can be confusing because load does not complete immediately. Since loading is set to complete in the next rendered frame, calling SceneManager.LoadScene forces all previous AsynOperations to complete, even if AsyncOperation.allowSceneActivation is set to false. This can be avoided by using LoadSceneAsync instead. The given sceneName can either be the Scene name only, without the .unity extension, or the path as shown in the BuildSettings window still without the .unity extension. If only the Scene name is given this will load the first Scene in the list that matches. If you have multiple Scenes with same name but different paths, you should use the full path. Note that sceneName is case insensitive, except when you load the Scene from an AssetBundle. For opening Scenes in the Editor see EditorSceneManager.OpenScene. SceneA can additively load SceneB multiple times. The regular name is used for each loaded scene. If SceneA loads SceneB ten times each SceneB with have the same name. Finding a particular added scene is not possible. 1234567891011121314using UnityEngine;using UnityEngine.SceneManagement;public class ExampleClass : MonoBehaviour&#123; void Start() &#123; // Only specifying the sceneName or sceneBuildIndex will load the Scene with the Single mode SceneManager.LoadScene("OtherSceneName", LoadSceneMode.Additive); &#125;&#125;// Load an assetbundle which contains Scenes.// When the user clicks a button the first Scene in the assetbundle is// loaded and replaces the current Scene. 123456789101112131415161718192021222324using UnityEngine;using UnityEngine.SceneManagement;public class LoadScene : MonoBehaviour&#123; private AssetBundle myLoadedAssetBundle; private string[] scenePaths; // Use this for initialization void Start() &#123; myLoadedAssetBundle = AssetBundle.LoadFromFile("Assets/AssetBundles/scenes"); scenePaths = myLoadedAssetBundle.GetAllScenePaths(); &#125; void OnGUI() &#123; if (GUI.Button(new Rect(10, 10, 100, 30), "Change Scene")) &#123; Debug.Log("Scene2 loading: " + scenePaths[0]); SceneManager.LoadScene(scenePaths[0], LoadSceneMode.Single); &#125; &#125;&#125; The following two script examples show how LoadScene can load Scenes from Build Settings. LoadSceneA uses the name of the Scene to load. LoadSceneB uses the number of the Scene to load. The scripts work together. LoadSceneA file. 1234567891011121314151617181920// SceneA.// SceneA is given the sceneName which will// load SceneB from the Build Settingsusing UnityEngine;using UnityEngine.SceneManagement;public class LoadScenesA : MonoBehaviour&#123; void Start() &#123; Debug.Log("LoadSceneA"); &#125; public void LoadA(string scenename) &#123; Debug.Log("sceneName to load: " + scenename); SceneManager.LoadScene(scenename); &#125;&#125; LoadSceneB file. 1234567891011121314151617181920// SceneB.// SceneB is given the sceneBuildIndex of 0 which will// load SceneA from the Build Settingsusing UnityEngine;using UnityEngine.SceneManagement;public class LoadScenesB : MonoBehaviour&#123; void Start() &#123; Debug.Log("LoadSceneB"); &#125; public void LoadB(int sceneANumber) &#123; Debug.Log("sceneBuildIndex to load: " + sceneANumber); SceneManager.LoadScene(sceneANumber); &#125;&#125; public static SceneManagement.Scene LoadScene(int sceneBuildIndex, SceneManagement.LoadSceneParameters parameters);public static SceneManagement.Scene LoadScene(string sceneName, SceneManagement.LoadSceneParameters parameters);ParameterssceneName Name or path of the Scene to load.sceneBuildIndex Index of the Scene in the Build Settings to load.parameters Various parameters used to load the Scene.ReturnsScene A handle to the Scene being loaded. DescriptionLoads the Scene by its name or index in Build Settings. An example using two scenes called Scene1 and Scene2. ExampleScript1.cs is for scene1 and ExampleScript2.cs is for scene2. 12345678910111213141516171819202122using UnityEngine;using UnityEngine.SceneManagement;// This is scene1. It loads 3 copies of scene2.// Each copy has the same name.public class ExampleScript1 : MonoBehaviour&#123; private Scene scene; private void Start() &#123; var parameters = new LoadSceneParameters(LoadSceneMode.Additive); scene = SceneManager.LoadScene("scene2", parameters); Debug.Log("Load 1 of scene2: " + scene.name); scene = SceneManager.LoadScene("scene2", parameters); Debug.Log("Load 2 of scene2: " + scene.name); scene = SceneManager.LoadScene("scene2", parameters); Debug.Log("Load 3 of scene2: " + scene.name); &#125;&#125; Scene2: 123456789101112using UnityEngine;// create a randomly placed cubepublic class ExampleScript2 : MonoBehaviour&#123; private void Start() &#123; GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube); cube.transform.position = new Vector3(Random.Range(-5.0f, 5.0f), 0.0f, Random.Range(-5.0f, 5.0f)); &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object.DontDestroyOnLoad]]></title>
    <url>%2F2019%2F03%2F11%2FObject.DontDestroyOnLoad%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：这个函数是什么意思？为什么要使用这个函数？如何使用？ public static void DontDestroyOnLoad(Object target); ** Parameters： ** target： An Object not destroyed on Scene change. ** Description： ** Do not destroy the target Object when loading a new Scene. The load of a new Scene destroys all current Scene objects. Call Object.DontDestroyOnLoad to preserve an Object during level loading. If the target Object is a component or GameObject, Unity will also preserve all of the Transform’s children. Object.DontDestroyOnLoad does not return a value. Change the argument type using the typeof operator. The following example script uses Object.DontDestroyOnLoad. The example has scene1 which starts playing background music from an AudioSource. The music continues when scene2 loads. Switch between scenes using a button. To implement this example, create two new Scenes, named scene1 and scene2. Open scene1 and add the SceneSwap.cs script to an empty GameObject and name it Menu. Next, add DontDestroy.cs to a new GameObject and name it BackgroundMusic. Add an AudioSource to BackgroundMusic - Add Component-&gt;Audio-&gt;Audio Source - and import an AudioClip into your Project. Assign the AudioClip to the AudioSource’s AudioClip field. Create a tag, call it music, and add it to BackgroundMusic. Switch to scene2. Again add SceneSwap.cs to a new GameObject and name it Menu. Save the Project. Return to scene1 and run the Project from the Editor. SceneSwap.cs script: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using UnityEngine;using UnityEngine.SceneManagement;// Object.DontDestroyOnLoad example.//// Two scenes call each other. This happens when OnGUI button is clicked.// scene1 will load scene2; scene2 will load scene1. Both scenes have// the Menu GameObject with the SceneSwap.cs script attached.//// AudioSource plays an AudioClip as the game runs. This is on the// BackgroundMusic GameObject which has a music tag. The audio// starts in AudioSource.playOnAwake. The DontDestroy.cs script// is attached to BackgroundMusic.public class SceneSwap : MonoBehaviour&#123; private void OnGUI() &#123; int xCenter = (Screen.width / 2); int yCenter = (Screen.height / 2); int width = 400; int height = 120; GUIStyle fontSize = new GUIStyle(GUI.skin.GetStyle("button")); fontSize.fontSize = 32; Scene scene = SceneManager.GetActiveScene(); if (scene.name == "scene1") &#123; // Show a button to allow scene2 to be switched to. if (GUI.Button(new Rect(xCenter - width / 2, yCenter - height / 2, width, height), "Load second scene", fontSize)) &#123; SceneManager.LoadScene("scene2"); &#125; &#125; else &#123; // Show a button to allow scene1 to be returned to. if (GUI.Button(new Rect(xCenter - width / 2, yCenter - height / 2, width, height), "Return to first scene", fontSize)) &#123; SceneManager.LoadScene("scene1"); &#125; &#125; &#125;&#125; DontDestroy.cs script: 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;// Object.DontDestroyOnLoad example.//// This script example manages the playing audio. The GameObject with the// "music" tag is the BackgroundMusic GameObject. The AudioSource has the// audio attached to the AudioClip.public class DontDestroy : MonoBehaviour&#123; void Awake() &#123; GameObject[] objs = GameObject.FindGameObjectsWithTag("music"); if (objs.Length &gt; 1) &#123; Destroy(this.gameObject); &#125; DontDestroyOnLoad(this.gameObject); &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>官方文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个人的世界很孤独：Unity网络编程]]></title>
    <url>%2F2019%2F03%2F10%2F%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E4%B8%96%E7%95%8C%E5%BE%88%E5%AD%A4%E7%8B%AC%EF%BC%9AUnity%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在游戏开发中，网络模块是不可或缺的一部分。哪怕是一款单机游戏，也离不开网络。授权验证、收集玩家信息、实现玩家社交互动和玩家对战等等，都需要使用网络来实现。 目前在Unity中实现网络功能主要有三种方式，第一种是使用Unity新提供的网络引擎UNET，第二种是使用第三方的插件Photon，最后一种则是由开发者自行从底层开始设计和实现网络功能。 在本章的内容中，我们主要介绍前两种实现网络功能的方式，特别是第二种方式，它也是目前Unity项目中实现网络功能的主流解决方案。 UNET简介Unity 5.1版本提供了全新的网络工具–UNET（Unity Networking）。Unity根据开发者的实际需求将该工具的用户分为两类： 1) 对网络相关的知识不太了解，需要借助网络快速实现相关功能的开发者。这类开发者应该使用High Level API(HLAPI)或者NetworkManager。 2) 准备构建大型网络游戏，需要强大且足够灵活的网络工具。这类开发者应该使用NetworkTransport API(LLAPI)。 开发者应当在项目构建初期就计划好网络需求，即需要使用哪些工具来实现哪些功能。有了具体规划后，再来了解相应的组件和概念，就可以节省大量的开发时间。 UNET基于多人在线游戏的概念构建，并提供了相关功能，本节将会重点介绍以下内容：1) 授权服务器和非授权服务器2) High Level API(HLAPI)3) Transport Layer API4) WebGL Support5) Internet Services6) NetWork View UNET中的服务器UNET中存在两个重要的概念，授权服务器和非授权服务器，以下分别进行介绍。 授权服务器在讲解授权服务器之前，有必要先了解客户端的概念。 玩家从网上下载到的网络游戏即客户端，客户端本身不执行计算操作。它的作用是告诉服务器玩家将要做什么，比如释放一个技能、购买某件物品。游戏的判断逻辑和规则不在客户端执行，比如玩家释放技能的流程是这样的：玩家按下某个键，客户端将这个信息传输给服务器，服务器对该技能的伤害值进行判断，之后再将计算后的信息反馈给玩家。 整个游戏的所有规则、数据和逻辑都由授权服务器处理。玩家在客户端上执行的任何操作，都会传输到授权服务器进行判定。比如在FPS游戏中，客户端只能告诉服务器“我射出了一发子弹”，而更具体的信息如子弹射中了谁、造成了多少伤害、还剩多少发子弹，这些都由授权服务器来判定。 从根本上来说，授权服务器将玩家操作与操作的结果隔离。可以把这个过程理解为：客户端将玩家当前的信息和操作发送到服务器-&gt;服务器处理接收到的信息-&gt;服务器将新的数据发送到各个客户端。 这个机制的优点在于玩家无法在本地客户端上作弊，因为所有操作和数据的判定均由授权服务器来处理。 非授权服务器非授权服务器和授权服务器之间的不同在于，非授权服务器并不控制客户端上各个用户的操作。玩家的输入输出和游戏逻辑均由本地客户端处理，然后本地客户端将处理结果发送给非授权服务器，非授权服务器再将这些状态同步到游戏世界中。在整个过程中，非授权服务器扮演的角色类似于中转站，并不对信息进行判定，唯一职责就是将收到的信息同步到整个游戏世界中。而在授权服务器中，判断和同步都由授权服务器来处理。 完成这种网络通信的方式有两种：远程过程调用和状态同步。 远程过程调用（Remote Procedure Calls，RPC）用来调用远程计算机上的某个方法。一方面可以从客户端调用服务器上的某个方法，另一方面则是从服务器上调用所有客户端或者指定客户端上的方法。 状态同步用于同步各个客户端中不断改变的数据。例如在MMORPG中，玩家可以看到身边别的玩家移动或者释放技能等。状态同步就是不断地将玩家的数据分发出去，这样每个客户端上的玩家都能同时知道别的玩家的所有状态。状态同步需要消耗大量带宽，所以开发人员应该尽量优化带宽数量。 High Level APIHigh Level API(HLAPI)是在Unity中创建多人游戏的一个功能，构建于较低级别的实时通信层之上，用来处理许多多人游戏常用的任务。它可以同时作为客户端和服务器的一部分，所以不需要专门的服务器进程。 HLAPI使用了新的命名空间：UnityEngine.Networking。它是Unity中的一个全新网络系统，简单易用，并为多人游戏提供了大量实用的功能，例如： 消息处理 通用高性能的序列化 分布式的对象管理 状态同步 网络类：Server、Client、Connection等 了解HLAPI之前，首先需要了解一下网络系统的基本概念。 (1)服务器（Server）和主机（Host） 在Unity中，一个游戏的网络系统通常是由一个服务器端和多个客户端组成的。如果没有专门的服务器端时，服务器端的角色将由某个客户端来扮演，通常称这个客户端为“Host”（主机），如下图所示。 Host下有一个客户端和服务器端，host使用的客户端被称为Local Client，除此之外的客户端被称为Remote Client。Local Client和服务器通过直接的方法调用和消息队列进行通信，因为二者在同一个进程、同一个场景中。而Remote Client和服务器则是通过普通的网络连接进行通信。 (2)实例化（Instantiate）和生成（Spawn） GameObject.Instantiate方法可以创建新的游戏对象，但在网络系统中，对象必须还要被“生成”(spawned)。这个操作必须在服务器上进行，然后其他客户端上也会创建出该对象。对象一旦生成，生成系统（Spawning System）会使用分布式对象生命周期管理和同步状 态原则来管理这些对象。 (3)玩家（Players）和本地玩家（Local Players） 网络系统中的每一个玩家对象都是专有的，一个玩家不能控制另外一个玩家对象，因此就有了MyPlayer的概念。在添加一个玩家对象时，这个Player对象就成为该玩家客户端上的LocalPlayer。如下图所示。 HLAPI中封装好了网络相关的Serve API，开发者可以直接使用，而不需要了解底层相关的细节。HLAPI的 主要功能如下： 通过Network Manager来控制游戏的网络状态。 发送和接收网络消息。 将客户端上的网络命令发送到服务器。 从服务器上对客户端进行远程过程调用。 将服务器上的网络事件发送至客户端。 Transport Layer API在某些项目的开发中，如果HLAPI提供的功能不足以满足网络需求，开发者还可以使用Unity提供的较低级别的传输层API（Transport Layer API），它允许开发者构建自己的网络系统。 传输层API可以发送和接收消息，并以字节数组来表示，还提供了许多“服务端质量”选项以适应不同的使用场景。它侧重于灵活性和高性能，API暴露在UnityEngine.Networking.NetworkTransport中。 传输层API支持基础的网络通信服务，包括： 建立连接。 使用多种服务水平的通信。 流量控制。 统计数据。 通过中继服务器或者本地发现的服务器进行通信。 传输层API使用两种协议：通用通信UDP和用于WebGL的WebSockets。使用传输层API的常见工作流程如下。 初始化网络传输层。 配置网络拓扑。 创建服务端主机。 开始通信（处理连接、发送/接收消息）。 Unity中的第三方网络插件：Photon虽然Unity提供了官方的UNET，但因为种种原因，当前版本的UNET并没有得到广泛的应用。在实际项目开发中，开发者要么选择自己从零构建网络系统，要么采用最为流行的第三方网络插件–Photon。 我们将使用Photon For Unity(PUN)实现游戏的网络功能。PUN是根据“房间”的概念构建的服务器系统。每一个房间可以容纳最多10位玩家。玩家可以根据房间名或者随机加入某房间。 Photon的主要功能特性Photon插件的功能不仅仅是替代UNET，它还提供了一系列围绕网络服务的插件，具体包括： 1) Photon Realtime：Photon Realtime是Exit Games架设在全世界各地区的服务器。通过Photon Realtime，即便是不同设备的玩家也可以同台竞技。 2) Photon Unity Networking(PUN)：针对于Unity平台的插件，支持Photon Realtime所提供的所有功能，并且支持Unity所支持的所有平台，与Unity完美整合。 3) Photon TrueSync：通过TrueSync，客户端只需要处理用户输入，TrueSync会在服务端模拟物理效果，能够有效提升用户延迟高时的用户体验。 4) Photon Bolt：用于构建游戏中的P2P模式，使用Photon Bolt能够快速开发出类似于英雄联盟、王者荣耀等游戏的匹配机制。 5) Photon Chat：基于PUN的游戏内文字聊天系统。 6) Photon Voice：基于PUN的游戏内语音聊天系统。 以上功能如Photon Chat和Photon Voice都是基于PUN的功能。在使用PUN之前，让 我们先了解一下PUN的一些基本概念。 (1) AppId&amp;Game VersionPUN通过AppID区分不同的应用，只有AppID相同的客户端之间才能成功连接。除了AppID，还需要通过Game Version来区分游戏的不同版本，版本相同的客户端之间才可以互相连接，开发者可以手动设置游戏的Game Version。 (2) Lobby 当玩家成功登录游戏时，首先会进入游戏大厅（Lobby），在大厅中玩家可以获取游戏的房间列表，之后玩家可以选择加入哪个房间。如果没有勾选设置中的Auto-Join Lobby选项，则不会自动进入大厅，需要玩家手动进入。 (3) RoomsPUN是根据“房间”的概念构建的服务器系统。每一个房间最多10位玩家。玩家可以根据房间名或者随机加入某房间。 Photon Cloud与Photon ServerPhoton本身提供了架设与全球各地区的服务器（Photon Cloud），如果开发者希望使用自己架设的服务器，则需要使用到Photon Server。 Photon Server是一个本地部署（On-Premises，即On-Prem）的服务端应用，开发者可自行架设，同时开发者享有完全自定义服务器的权利。 而Photon Cloud是Saas（Software as a Service，软件即服务）的服务，开发者只需要专注于使用这些服务即可，其他所有细节都由Exit Games（开发Photon的公司）完成。 Photon Cloud运行于Photon Server之上，Photon Realtime、Photon Chat是运行于Photon Cloud之上的应用。 PUN、PUN+与UNET首先要说明一下，PUN是Photon Unity Networking的缩写。Unity提供了内置的网络系统–UNET，那么为什么此处笔者选择PUN呢？PUN相对于UNET的优势在何处呢？ (1)房间模式 UNET是基于Server-client的，服务器是运行于某一个客户端之上的。PUN也是基于Server-client的联网服务，但是有特定的服务器，不会因为某个客户端玩家离线而影响游戏体验。 (2)连接 由于UNET中，服务器托管于某一客户端之上，所以当客户端玩家网络出现问题时，与该客户端连接的所有玩家都会出现卡顿甚至掉线。而PUN是使用特定的服务器，所以只要玩家的网络没有问题，PUN就能充分保证网络连接的畅通性。 (3)功能性 前一节中已经提到，PUN提供了大量功能性插件，并且使用都非常简单，这是UNET完全不具备的。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity AR/VR开发--从新手到专家</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有了光就有了一切：Enlighten]]></title>
    <url>%2F2019%2F03%2F10%2F%E6%9C%89%E4%BA%86%E5%85%89%E5%B0%B1%E6%9C%89%E4%BA%86%E4%B8%80%E5%88%87%EF%BC%9AEnlighten%2F</url>
    <content type="text"><![CDATA[本章涵盖： Unity光照系统介绍 全局光照 实战：给BattleStar游戏场景添加光照 Unity光照系统介绍Unity引擎中提供的光照系统叫做Enlighten，它作为引擎渲染功能的一部分，负责构建场景中的灯光。 Light组件简介Unity中的灯光系统并不复杂，各个不同类型的灯光组件实现不同类型的光效。Unity的灯光组件大致分为两个类别：光源组件和烘焙组件，光源组件应该非常容易理解，只有能自己发出光的物体，才能被称作光源。这一概念放到Unity中，也就是如下几种灯光：Directional Light、Point Light、Spot Light。 常见的光源类型Directional LightDirectional Light也即平行光，它是场景中的主要灯光。几乎每一个场景中都会使用到这个光源对象，它常用于模仿太阳光的效果。它与Point Light和Spot Light最大的不同在于：Directional Light并没有真正的“源”。在游戏中，Directional Light从同一个角度照射场景，也就是说Directional Light在整个场景中的任何一个角落的光照强度都是相同的。 在Unity中创建新场景时，场景中默认会有一个Directional Light和一个Main Camera。 各个光源对象在Scene视图中的图标都不同，如Directional Light的图标是一个太阳，比较便于理解。读者可以自行尝试调整Directional Light的位置，来观察它对于场景的影响。 事实上Directional Light的光照效果完全不受位置的影响，最直观影响Directional Light灯光效果的因素是角度。在场景中调整Directional Light的角度为朝正上方，可以很明显地看到整个场景变成了黑色，不再有光照的效果。 在Directional Light的Inspector视图中，同样显示了灯光的类型。左上角各个不同的灯光类型也有各自的图标。在Type选项中可以直接切换灯光的类型，如下图所示。 Point LightPoint Light顾名思义就是点光源，点光源从中心呈球形向四周扩散，如火把、室内灯具等通常都使用Point Light实现。 Point Light的效果受到范围（Range）和强度（Intensity）的影响。和Directional Light不同，点光源的效果是会受到位置影响的。 Spot LightSpot Light即聚光灯，从中心呈扇形向某一个方向发出，受扇形角度（Angle）和范围（Range）的影响。Spot Light可用于模拟手电筒和车灯等的效果。 除以上三种基本的光源组件外，Unity还提供了一种特殊的光源：Area Light，也就是区域光。 Area Light区域光和以上三种灯光最大不同在于，它只能在烘焙的情况下使用，而Directiona Light、Point Light、Spot Light能够在实时（Realtime）和烘焙（Bake）两种情况下使用。Area Light用于一些较特殊的情况，如某个场景的主要场景在室内，以上三种灯光都无法较好地实现灯光效果时就可以使用Area Light来实现这一效果。 Light inspector中的参数简介灯光效果的把控非常依赖于开发者的个人审美和感觉，所以开发者应该了解灯光组件中各个参数的用处，这样才能调试出最理想的灯光。 1) 在Unity中新建一个项目，将其命名为MyLights。保存默认的场景，将其命名为MainScene。在Hierarchy视图中右键单击，并添加一些简单的几何体对象。 2) 在Hierarchy视图中选择Directional Light，在Inspector视图中确认Directional Light组件下的Shadow Type设置为Soft Shadow。关于阴影的其他参数保持默认即可。Soft Shadow所呈现的阴影比较柔和，更接近真实，但性能开销也更大。Hard Shadow所呈现的阴影更硬朗，锯齿感也更强。 3) 接下来可以调整Directional Light的角度，可以很直观地看到，整个场景的色调、阴影的效果都发生了改变。 读者也可以自行调整Inspector视图中的Color（色彩）和Intensity（强度），来进一步改变Directional Light的效果。 4) 接下来在场景的中心位置添加一个Point Light组件，并调整Color为更显眼的颜色，比如热情洋溢的红色。选中Hierarchy视图中的Point Light组件，可在Scene视图中看到Point Light的范围，在Inspector视图中调整Range（范围）的中心较明显的红色区域也会越来越大。这缘于Point Light的范围特性，并不是说范围内所有区域的灯光强度都是相同的，而是呈从中心向边缘递减的效果。如果读者不太理解，可以继续调整Range的值，并观察场景中红色区域的范围。 Point Light同样支持Hard Shadow和Soft Shadow。但默认情况下，Point Light的阴影效果并不会呈现出来。因为实时的Spot Light和Point Light并不支持阴影，只有在烘焙后才能看到它们的阴影效果。 此外灯光组件还有两个较常用的属性：Cookie和Flare。Flare即光晕，而Cookie则用于显示一些特殊的阴影，如下图所示。 如上图中，聚光灯穿透纸面，在幕布上投射出特殊的阴影。Cookie的作用类似于纸面，开发者在图片编辑器（如PhotoShop等）中调整好材质后，设置Spot Light或其他灯光组件的Cookie属性即可。 全局光照在前面的章节中介绍光源时，只是介绍各个灯光单独作用的场景。但在实际开发中，大多数情况下灯光都是相互作用的，如灯光照射到物体A上，物体A反射的光会照射到物体B。这种关联关系是通过全局光照（Global Illumination，GI）系统来进行处理的。 全局光照简介下图显示了全局光照的作用效果。在一个封闭空间内，两个玻璃球体互相反射。全局光照极大提升了场景中光照的真实性，但这种程度的实时计算是非常消耗资源的。 但从另外一个方面来说，我们只需要对场景中的动态物体进行实时计算，保证光照效果。而那些固定的物体，或许不应该在它们身上浪费太多资源。先想象一下，如果一个场景中所有物体全部是静止的状态，那么实时计算光照效果显然是白白浪费资源的，我们只需要执行一次计算即可。这种技术在Unity中称为烘焙（Bake）。当对场景进行灯光烘焙后，场景中的光照信息就会存储在Lightmap中。当场景运行时，Unity直接读取Lightmap中的数据即可，而无需再进行一次计算，这种工作流程很好地避免了不必要的性能消耗。 全局光照的作用效果 烘焙稍等片刻烘焙结束后，可以看到场景中的火在Scene视图中，之前勾选为Lightmap Static的对象无法被移动。修改Directional Light的角度会发现，对象的阴影并不会改变。修改Point light的颜色、范围等，同样场景不会有任何改变。 这是因为Directional Light、Point Light和场景中所有对象的光照信息都已经烘焙到Lightmap中了，现在场景中的光照数据来自Lightmap，而不是根据灯光变化实时计算。 如果场景中的灯光发生了变化，开发者需要手动再次进行烘焙，场景中的光效才会发生改变。 Lightmap的使用读者现在已经知道，在进行灯光烘焙后，场景中的光照信息全部储存到了Lightmap中。由Lighting视图切换到Global maps中，如下图所示。 灯光烘焙的数据可以直接在Assets视图中查看，存储在与场景同级的文件夹中，文件夹名称和场景名称一致。双击上图标记的左侧烘焙数据，即可通过图片浏览器打开该文件，如下图所示。 上图中就是完成烘焙后的阴影、灯光信息。我们通常不会对这些数据进行更改，但开发者有必要知道它们存放的路径，当需要移动场景文件的路径时，也需要移动这些文件，或者重新进行烘焙。 Light Probe和Reflection Probe的使用当场景中的灯光烘焙后，光照信息和阴影都变成“静止”的了。如果场景中有动态的物体，比如可以自由行走的玩家，那玩家岂不是没有阴影了？这个问题我们该怎么解决呢？这个时候就需要用到Light Probe和Reflection Probe了。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity AR/VR开发--从新手到专家</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真实世界的法则：物理引擎]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E6%B3%95%E5%88%99%EF%BC%9A%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[在游戏世界中，无论画面多么精美，人物多么鲜活，但如果玩家在其中感受不到类似真实世界的物理法则，那么就很难产生足够的代入感，物理引擎正是为了解决此类问题而生的。 Unity中的物理引擎系统Unity中使用了两个不同的物理引擎：Nvidia PhysX用于3D物理、Box2D用于2D物理。 物理系统概述游戏中的物理引擎用于在游戏中模拟出真实世界的物理效果，例如物体之间的碰撞、布料等。Unity为开发者提供了几个组件用于模拟物理效果，只需要这些组件就可以实现逼真的物理特效了。 RigidBody组件要想实现游戏对象的物理行为，Rigidbody（刚体）组件是必不可少的。当游戏对象挂载了Rigidbody后，对象会立即受到重力等物理因素的影响。如果该对象上还挂载着Collider组件，那么该对象就会受到碰撞的影响，例如被游戏中的车撞飞。 在Unity中，如果希望两个对象发生碰撞，需满足两个条件：两个对象上都有Collider组件，并且其中一个对象上必须有Rigidbody组件。 当一个对象上挂载着Rigidbody组件时，应该使用“力”（forces）来移动物体，由物理引擎来计算移动过程中的物体效果，而不是修改对象的Transform组件中的Position。在日常开发中，我们也会遇到不该用力移动对象，但仍然希望物体进行物理计算的情况。例如玩家的移动，这种移动方式成为动力学（Kinematic）运动。此时，可以勾选出Rigidbody组件下的Is Kinematic属性来实现以上的效果。 给游戏对象添加Rigidbody组件创建新的Unity项目，名为PhysicsTest。在场景中添加一个Cube对象，在Hierarchy视图中选中该对象，在Inspector视图中点击Add Component，选择Physics-&gt;Rigidbody，为Cube对象添加一个Rigidbody组件，如下图所示。 其中Mass代表质量（并不是重量），默认 单位为干克；Drag为阻力；Use Gravity选项用于确认物体是否受重力影响；若勾选Is Kinematic选项，该对象就不会受物理引擎的影响而移动，只能使用Transform组件移动。 现在运行场景，会发现Cube会匀速向下坠落，这就是物理引擎的作用。如果取消Use Gravity选项的勾选，或者勾选Is Kinematic选项，都能实现让物体不会下坠的效果。 读者可能会疑惑Use Gravity和Is Kinematic的具体区别，以及在实际应用中我们如何使用这两个属性。简单来说，Use Gravity选项表示物体是否受地心引力的影响，如果不勾选此项，物体就不会再下坠，但是仍然会受其他物理效果的影响。但是勾选Is Kinematic属性时，物体不会受任何物理效果的影响，即使我们通过脚本为该对象施加一个非常大的力，它也不会被移动。 通过Rigidbody组件底部Constraints中的参数，我们也可以实现物体不被移动的效果。 给物体施加力我们可以通过脚本来为物体施加力。在施加力时，需要指定力的方向和力的大小。创建一个新脚本，将其命名为AddForce。 123456789101112131415161718using System.Collections; using UnityEngine;public class AddForce : MonoBehaviour&#123; private Rigidbody myRigidbody； void Start() &#123; myRigidbody = GetComponent&lt;Rigidbody&gt;(); myRigidbody.AddForce(new Vector3(0, 10, 0), ForceMode.Impulse); &#125; void Update() &#123; &#125;&#125; 在该脚本中，首先通过GetComponent&lt;&gt;()方法获取Rigidbody组件，然后再通过Rigidbody组件的AddForce添加一个向上的力，大小为10。在参数中，我们使用Vector3来表示这个力，也可以使用浮点数来表示这个力，如AddForce(0f, 10f, 0f, ForceMode.Impulse)，也可以使用AddForce(Vector3.Up * 10, ForceMode.Impulse)，这3种表达方式完全一致。 接下来需要指定ForceMode。ForceMode有4个属性: 1)Force：给Rigidbody添加一个可持续的力，受Mass影响； 2)Acceleration：给Rigidbody添加一个可持续的加速度，忽略Mass影响； 3)Impluse：立即给Rigidbody添加一个冲力，受Mass影响； 4)VelocityChange：立即给Rigidbody添加速度，忽略Mass影响。 由于目前是在Start()方法中执行AddForce方法，该方法只会执行一次，所以这里只能将ForceMode设置为Impluse或者VelocityChange。 在Hierarchy视图中选中Cube物体，在Inspector视图中点击Add Component，选择Scripts-&gt;Add Force。点击运行，可以看到Cube物体先是向上运动一小段距离，然后就在重力的作用下向下运动。 接下来我们尝试在FixedUpdate()方法中施加向上的力，首先要清楚此处为什么使用FixedUpdate()而不是Update()，FixedUpdate()的调用次数是固定的，不会受帧率的影响，而Update()会在每帧调用一次，会受到帧率的影响。所以Unity中所有关于Rigidbody的方法都应该放在FixedUpdate()方法中执行，如果在Update()方法中执行，物理效果会受帧率影响。 在AddForce脚本中将Start()方法中的AddForce方法移动到FixedUpdate方法中，并将Start方法中的相关代码注释。 1234void FixedUpdate()&#123; myRigidbody.AddForce(Vector3.up * 10, ForceMode.Impulse);&#125; 此时运行场景，可以看到Cube直接向上飞出去了。这是因为我们将ForceMode设置为Impulse，每次调用FixedUpdate()方法都会给Rigidbody添加一次力。如果将ForceModel修改为Force或者Acceleration，再次运行可以看到，Cube将会在下落一小段后，开始匀速向上移动。这就是Impulse/VelocityChange和Force/Acceleration的主要区别，在FixedUpdate()方法中，Impulse和VelocityChange模式会不断添加力，而Force和Acceleration模式会维持力。 在指定位置施加力我们已经能够对某个游戏对象整体施加指定方向的力了，在某些情况下，还需要在指定的位置施加力以实现一些特殊效果。 Unity为我们提供了AddForceAtPosition(Vector3 Force, Vector3 Position, ForceMode)方法，该方法第一个参数是力，和AddForce中一样，第二个参数为力的位置，第三个参数为力的模式。 在上一节中，我们使用AddForce(Vector3.up * 10)时，给对象添加了一个向上的力，力度为10，对整个对象施加这个力。如果希望将这个力在对象左侧施加，只需要指定一个位置即可，代码如下： 1myRigidbody.AddForceAtPosition(Vector3.up * 10, Vector3.left, ForceMode.Force); 注释掉FixedUpdate()方法中的原有代码，添加以上代码并运行场景，可以看到Cube一直旋转并且缓慢上升。在以上代码中，我们在(-1, 0, 0)位置施加了一个向上的持续力，力度为10。 模仿手雷爆炸的效果如果想要实现类似手雷爆炸的效果，只需要修改力的方向即可。目前我们使用的都是单方向的力，并不能很好地模拟出手雷爆炸时向周围施加力的效果。在施加力时，只需要将AddForce或AddForceAtPosition修改一下即可，例如： 1myRigidbody.AddForceAtPosition(new Vector3(10, 10, 10), Vector3.zero, ForceMode.Force); 手雷爆炸时，力是从手雷中心发出的，所以需要把力的位置设置为Vector3.zero，代表从中心施加一个力。手雷爆炸力并不是持续力，所以还需要将ForceMode设置为Impluse，代码如下： 1myRigidbody.AddForceAtPosition(new Vector3(10, 10, 10), Vector3.zero, ForceMode.Impluse); 此外，因为爆炸是瞬间发生而非持续发生，所以还需要将这行代码从FixedUpdate()中删除，并移动到Start()方法的最后一行： 1234void Start()&#123; myRigidbody = GetComponent&lt;Rigidbody&gt;(); myRigidbody.AddForceAtPosition(new Vector3(10, 10, 10), Vector3.zero, ForceMode.Impulse); 为了更直观地看到效果，我们在Cube附近再添加几个Cube，如下图所示。 此时运行场景会发现，周围的Cube并没有被炸开，只有中间的Cube被炸飞了。也就是说此时并没有成功模拟出爆炸力。 使用爆炸力正确实现爆炸力的效果需要使用到AddExplosionForce方法，只需要指定力的大小、力的位置以及爆炸半径即可： 1myRigidbody.AddExplosionForce(20, Vector3.zero, 5, 0, ForceMode.Impulse); 在以上代码中，我们设置爆炸力为20，爆炸位置为原点，爆炸半径为5，ForceMode为Impluse，AddExplosionForce方法会在球体范围内施加一个爆炸力。运行场景会发现，实际情况并不如预期那么理想。这是因为我们只对中心Cube施加了力，但这个爆炸力并没有作用到周围的4个Cube之上。 那么如何对某个范围内的对象都施加力呢？如果场景中只有4个对象，我们当然可以手动施加力，如果场景中有40个对象呢？在下一节中，笔者将使用Collider组件解决这一问题，实现真正的爆炸效果。 Collider组件Collider组件顾名思义，就是碰撞组件。上一节中提到过，如果希望两个对象发生碰撞，那么这两个对象上都必须挂载着Collider，其中一个对象上必须挂载着Rigidbody。那么何为Collider组件呢？ Unity提供了4种不同的Collider组件，分别为： 1) Box Collide：立方体状的Collider，Cube对象默认挂载该Collider； 2) Capsule Collider：胶囊状的Collider，Capsule对象默认挂载该Collider； 3) Sphere Collider：球体状的Collider，Sphere对象默认挂载该Collider； 4) Mesh Collider：根据Mesh确定形状的Collider，Plane对象默认挂载该Collider。 以Box Collider组件为例，点击Edit Collider按钮就可以开始编辑Collider的形状，在Scene视图中点击需要修改的那一面，按住鼠标并拖动即可。Is Trigger属性表示该Collider是否为Trigger，具体用法随后进行讲解。Material参数用于指定Physic Material，开发者可以在Asset面板创建新的Physic Material，并指定弹性等参数。最后Center和Size属性下的参数用于决定Collider的位置和尺寸，Box Collider组件如图所示。 我们先创建一个有弹性的Physic Material。在Asset面板中右键，选择Physic Material即可完成创建，将其重命名为CubeMaterial，选中该对象时Inspector面板中就会显示出相关参数，如下图所示。 其中Dynamic Friction和Static Friction分别为动态摩擦力和静态摩擦力，不做修改。Bounciness参数就是弹性，在这里我们指定为1（默认为0）。这样我们就成功创建了一个富有弹性的物理材质。 选中场景中心的Cube对象，将Box Collider组件中的Physic Material参数指定为CubeMaterial。 为了测试Cube是否真的有弹性了，我们在上一节的场景中添加一个Sphere对象，设置Position为(0, 3, 0)（也就是Cube的正上方），为Sphere对象添加Rigidbody组件。最后还需要勾选Cube对象Rigidbody组件中的Is Kinematic选项。从运行场景可以看到，Sphere对象落到Cube之上后被轻轻弹开。如果移除Cube对象的Box Collider组件的Material，Sphere落到Cube之上后并不会产生弹性效果。 如果此时勾选了Cube对象Box Collider组件的Is Trigger选项会发生什么呢？此时Sphere对象会直接穿过Cube，并没有发生碰撞和弹性。让我们回头检查Cube和Sphere对象，二者都有Rigidbody组件和Collider组件，看起来没什么问题，只是Cube对象的Collider勾选了Is Trigger而已。 在勾选Is Trigger选项后，Collider就不再与其他Collider发生碰撞。读者此时可能会想，那我要这个Collider有何用？其实Trigger和Collider都有不同的应用场景。 如果读者有过单机游戏经验，肯定知道自动存档功能， 自动存档功能的触发机制就是通过Trigger。当玩家触发某个关卡中用于存档的Trigger时就会自动存档。与之类似的还有游戏中地面上的血包等，都是通过Trigger来实现的。 如果要在代码中获取Collider的碰撞信息，就要通过OnCollisionEnter/Stay/Exit方法。而获取Trigger的碰撞信息则是通过OnTriggerEnter/Stay/Exit方法。也就是说，二者的原理和机制都是一致的，唯一区别在于，Trigger并不会触发物理效果。 了解完Collider组件后，就可以利用Collider的相关方法来实现真正的手雷爆炸效果。大致思路如下： 1) 检查“手雷”对象周围一定范围内的所有对象； 2) 如果范围内有对象，则一一获取他们的Rigidbody组件； 3) 通过每个对象Rigidbody组件施加爆炸力，力的位置为“手雷的位置”。 首先，删除场景中用于测试弹性的Sphere对象。 其次，为了方便查看区别，还需要将场景中心的Cube替换为Sphere对象，并为新的Sphere对象添加Rigidbody组件。 最后，还需要在场景中添加一个Plane对象，设置Position为(0, -0.5, 0)以防止场景中的对象下坠，此时场景如下图所示。 选中Sphere对象，在Inspector视图中点击Add Component添加新的组件，选择Scripts-&gt;AddForce命令，将上一节中使用的AddForce脚本添加到Sphere对象上。在编写脚本前，我们还需要为每一个Cube对象都添加Rigidbody组件。接下来就可以按前面讲过的思路来一步步实现手雷功能了。完整代码如下： 1234567891011121314151617181920212223242526272829303132using System.Collections; using System.Collections.Generic; using UnityEngine; public class AddForce : MonoBehaviour&#123; private float radius = 5.0f; private float force = 1000.0f; void Update() &#123; if (Input.GetKeyDown(KeyCode.A)) &#123; Explode(); &#125; &#125; private void Explode() &#123; // 1.检查“手雷”对象周围一定范围内的所有对象 Collider[] colliders = Physics.OverlapSphere(transform.position, radius); // 2.如果范围内有对象，则一一获取他们的Rigidbody组件 foreach (Collider obj in colliders) &#123; // 3.通过每个对象Rigidbody组件施加爆炸力，力的位置为“手雷的位置” if (obj.GetComponent&lt;Rigidbody&gt;() != null) &#123; obj.GetComponent&lt;Rigidbody&gt;().AddExplosionForce(force, transform.position, radius); &#125; &#125; &#125;&#125; 在Explode方法中，首先使用Physics.OverlapSphere()方法检测球体范围内的所有挂载着Collider的对象，球体中心位置为Sphere对象的位置，通过transform.position获取，球体半径我们指定为5。随后再通过foreach方法遍历colliders数组中的所有对象，检测每一 个对象是否有Rigidbody组件，如果有Rigidbody组件，就给它施加一个爆炸力，力度为1000f，爆炸中心为Sphere对象的位置。 此时运行场景，按下键盘上的A键即可看到效果，Sphere对象向上飞去，4个Cube都被炸飞。如果希望Cube朝上方被炸开，而不是向四周炸开，可以在AddExplosionForce()方法中添加一个可选参数upwardsModifier，例如： 1obj.GetComponent&lt;Rigidbody&gt;().AddExplosionForce (force, transform.position, radius, 100.0f); 笔者在radius参数后添加了一个值为100f的参数。此时再次运行场景并按下A键可以看到，Cube被炸向空中了。 Raycast在上一节中，我们使用到了Physic Material组件的Bounciness参数来实现弹性，但Bounciness参数的弹性最大只能为1，如果希望弹性更大该怎么办呢？我们可以通过射线（Raycast）和AddForce()方法来实现这个效果。大致思路如下： 每一帧发射一个向下的射线，检测对象和地面的距离，如果距离小于等于0.1米，则给对象施加一个向上的力。 我们可以使用Physics.Raycast方法来发射一条射线，射线的长度、方向、起始位置等属性都由我们自由决定。当射线碰撞到Collider时就会返回碰撞信息。在编写脚本前，我们先搭建一个新的测试场景。在场景中添加一个Plane对象和Sphere对象，设置Sphere对象的坐标为(0, 5, 0)，并为Sphere对象添加Rigidbody组件，效果如下图所示。 此时运行场景能够看到，Sphere坠落到地面上之后并不会弹起。新建一个名为Raycast的脚本，将其拖动到Hierarchy视图中的Sphere对象上。其完整代码如下。 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;public class Raycast : MonoBehaviour&#123; public float bounce = 5.0f; private void FixedUpdate() &#123; // 用于接受射线结果的对象 RaycastHit hit; // 从Sphere对象中心向下方发射一条射线，射线长度为1 if (Physics.Raycast(transform.position, Vector3.down, out hit, 1.0)) &#123; // 如果射线碰撞到的对象小于0.6 if (hit.distance &lt;= 0.6f) &#123; // 给Sphere对象施加一个向上的力 GetComponent&lt;Rigidbody&gt;().AddForce(Vector3.up * bounce, ForceMode.Impulse); &#125; &#125; &#125;&#125; 如果我们想要获取射线的结果，那么就必须要先定义一个RaycastHit类型的变量hit。随后执行Physics.Raycast()方法。如果射线在指定方向和距离内检测到了有Collider的对象，该方法会返回true，所以通常把Physics.Raycast()方法放在if()语句中。 读者应该会疑惑hit.distance &lt;= 0.6f是什么意思，为什么是0.6？首先需要明确，在Physics.Raycast对象中，我们指定射线起点为transform.position，也就是Sphere对象的正中心。而Sphere对象的默认半径为0.5，如果执行hit.distance &lt;= 0.1f，我们将永远不会得到结果，因为距离Sphere对象中心0.1个单位的范围在Sphere对象Collider内部。所以这里0.6f其实是0.5f（Sphere对象的半径） + 0.1f（我们的理想距离）。如果读者愿意，将0.6修改为0.51f也是可行的。 此时点击运行，可以看到小球坠落到地面上后弹起。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity杂项]]></title>
    <url>%2F2019%2F03%2F10%2FUnity%E6%9D%82%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[记录一些学习过程中遇到的关于Unity的基础知识 1.什么是网格？2.将面数控制在多少数量之内？3.三角形面是什么？4.顶点和法线是什么关系？5.什么是漫反射？英文是什么？ 网格网格（Mesh）定义了构成某个3D结构的相互连接的顶点。 3D艺术往往都是由三大元素构成的：顶点（Vertex）、边（Edge）和面（Face）。顶点是指3D空间中的点。Cube有8个顶点（或者叫点）–每个顶角上各有一个。 边将这些点连在一起–在顶点之间形成线条。Cube有12条边：4条边位于上方，4条边位于下方，还有4条边位于每个顶角上，将顶部和底部连接起来。 面是由3个顶点（通常是3个）构成的平面。Cube有6个面。边定义了一个面的终止位置，以及另一个面的起始位置。 实际上，Cube上的每个面都有一条隐藏边，把四边面分割成两个三角面。所以严格来说，Cube是由6x2=12个三角面构成的。 而3D模型是由若干个三边面（有时候是四边或更多边）构成的表面体。有多条边的图形叫做多边形（Polygon）。“多边形数量”通常指的是构成3D模型的三角面的数量。多边形数量越少，计算机渲染或绘制模型所需的运算资源就越少。所以也会有低多边形风格（Low Poly）。在电影或电视里，一个镜头只需要在最终成片之前渲染一次即可，而像Unity这样的引擎则必须不断地实时更新画面。多边形越少，游戏的潜在运行速度就会越快。低面数模型看上去要比高面数模型更显粗糙。 如果面数过多影响到游戏性能怎么办？Unity能够处理的单场景的多边形的数量取决于你运行游戏的硬件。Unity游戏靠的是硬件加速–运行游戏的机器的运行速度越快，你就能放更多的多边形进去。最好的办法是让你的模型拥有尽可能少的面数，同时又不能太过简化（除非你是在做Minecraft，这种刻意追求的方块风格游戏除外）。确定一个最低系统需求，然后尽早并经常在那样性能的系统中测试，以保证游戏能够运行起来! 当然，这完全取决于你的游戏。但一般来讲，将每个网格的三角形面数控制在1500-4000之间是没问题的。 当你将3D模型从其他软件导入到Unity时，Unity会将模型原本的各种网格面统统转换成三角形面。了解过Unity的模型结构你就会知道，“三角形面”是最经常用到的术语。 低多边形“低多边形（Low-Poly）”一词最早产生于计算机游戏的三维实时渲染，指在电脑三维图形中具有相对较少的多边形面。其中三维图形是计算机通过运算多边形或曲线，在各种媒体如电影，电视，印刷，快速创建模拟三维物体或场景的视觉效果。而构成三维图形的基本单位就是“多边形（Polygon）”。 对于三维模型而言，越多的多边形面意味着能展示越多的细节，而相反的计算机的运算速度也会更加缓慢。计算机游戏采用的是即时渲染（RealTime Rendering），这意味着在每三十分之一秒的时间内（游戏帧速率最低为30帧每秒）电脑硬件和软件就要运算出一张完整的画面。一旦画面中的内容过于复杂，运算速度就会变慢，帧速就会变低，人们在观看时就会觉得不流畅甚至反感。 在同等引擎和硬件条件下，为了缩短渲染时间，场景中的多边形面必须减少，“低多边形”也就孕育而生了。这一点是游戏与所有其他数字影像艺术所不同的地方。如数字动画、电影，他们的播放速率是固定的，所以不需要实时渲染。此类作品通常利用渲染农场（Render Farm），每帧（Frame）花数小时来渲染出尽善尽美的效果。 影视渲染和游戏渲染的区别在哪？涉及到离线和即时的区别影视作品渲染非常考察硬件水准，一般使用工业级集群工作站，且耗时长，往往需要几小时至几个礼拜不等，渲染结束再给观众看没问题。影视作品画质高，2K、4K级别作品现在很多，放在IMAX上放映也不成问题，那都是硬件设备和不知道多久的渲染时长堆起来的。 渲染农场 而游戏渲染就不一样，当运行时玩家就坐在旁边，必须在几十毫秒内完成一帧。游戏渲染充其量在端游和手游居多，屏幕再大也比不上影院的荧幕，所以要求低了很多，一般也不会超过主流电视水平，所以我们描述一款高画质游戏往往会赞叹“闻到了显卡的香气”，手游和端游都一样，玩游戏其实就是在玩显卡（GPU）。 引擎技术的不同影视渲染追求真实，使用全局光源，对粒子效果、流体效果进行实时演算 粒子特效 游戏渲染一般使用预优化的模型和材质压缩技术，简单的局部光源。（游戏里画质极棒的剧情动画就另说，那是需要单独下载的，跟观看视频没有区别） 光照贴图和法线贴图light map。简单说就是把光源造成的阴影效果事先计算好并保存成一张贴图。之后贴到模型表面就可以呈现出光照效果了。因为它只是一张贴图而已，并不是实时运算出来的光影，所以自然比实时计算的光源要少很多运算量。 Normal map正常情况下表现出一个顶点受光源影响的效果需要对应一个法线点。法线是很重要的，因为3d模型如果没有光源影响它的透视效果会大打折扣。表示一个法线要x、y、z三个浮点数，相当于一个顶点坐标的量。但是实际上不一定需要顶点与法线点一一对应，它们是可以分开算的。Normal map技术简单说就是采用高模的法线套用到低模上面，使低面模型看起来有类似高模的光影效果，也就是看起来像是有更多的多边形构成。 阻尼阻尼含义阻尼（damping）是指任何振动系统在振动中，由于外界作用或系统本身固有的原因引起的振动幅度逐渐下降的特性，以及此一特性的量化表征。 阻尼的物理意义是力的衰减，或物体在运动中的能量耗散。通俗地讲，就是阻止物体继续运动。当物体受到外力作用而振动时，会产生一种使外力衰减的反力，称为阻尼力（或减震力）。 通常阻尼力的方向总是和运动的速度方向相反。因此，材料的阻尼系数越大，意味着其减震效果或阻尼效果越好。但是并不是阻尼越大越好，阻尼大到一定程度时两个物体之间变成了刚性连接，阻尼一般和弹簧一起使用，阻尼过大，将起不到缓冲的效果。 阻尼是指阻碍物体的相对运动、并把运动能量转化为热能或其他可以耗散能量的一种作用。 在实际振动中，由于摩擦力总是存在的，所以振动系统最初所获得的能量，在振动过程中因阻力不断对系统做负功，使得系统的能量不断减少，振动的强度逐渐减弱，振幅也就越来越小，以至于最后停止振动，像这样的因系统的力学能，由于摩擦及转化成内能逐渐减少，振幅随时间而减弱振动，称为阻尼振动。 一个有阻尼的弹簧振子振动示意图。 阻尼的运用阻尼抽屉可实现在无论多大的推力作用下，都可使抽屉缓慢关闭，不会发生抽屉与固定框的碰撞。 阻尼铰链阻尼铰链是一种利用液体的缓冲性能，缓冲效果理想的一种液压缓冲铰链，门在60°开始自行缓慢关闭，减低冲击力，形成关闭时的阻尼铰链舒适效果。即使用力来关门也会轻柔关闭。 阻尼器阻尼器，是以提供运动的阻力，耗减运动能量的装置。利用阻尼来吸能减震不是什么新技术，各行业中早已应用各种各样的阻尼器（或减震器）来减振消能。 大家知道，使自由振动衰减的各种摩擦和其他阻碍作用，我们称之为阻尼。而安置在结构系统上的“特殊”构件可以提供运动的阻力，耗减运动能量的装置，我们称为阻尼器。 在力学中，对于使自由振动衰减的各种摩擦和其他阻碍作用，称为阻尼。 阻尼器又称阻尼装置。为了当受到冲击而产生的振动很快衰减所制成的增加阻尼的装置。 刚体物理学上指受到外力作用后不发生体积和形状变化的物体。 一种理想固体,它的尺寸和形状完全是固定的,当施加外力时,仍保持不变 在任何力的作用下，体积和形状都不发生改变的物体叫做“刚体”(Rigid body)。它是力学中的一个科学抽象概念，即理想模型。事实上任何物体受到外力，不可能不改变形状。实际物体都不是真正的刚体。若物体本身的变化不影响整个运动过程，为使被研究的问题简化，可将该物体当作刚体来处理而忽略物体的体积和形状，这样所得结果仍与实际情况相当符合。 刚体是指在运动中和受力作用后，形状和大小不变，而且内部各点的相对位置不变的物体。简单的说，刚体就是受力不变形对应的就是弹簧，受力就变形 刚体指的是在力的作用下，任意两点间的距离保持不变的物体。 简单来讲，就是不考虑其自身变形的物体 在外力作用下,物体的形状和大小(尺寸)保持不变,而且内部各部分相对位置保持恒定(没有形变),这种理想物理模型称之为刚体. 特点：固体，尺寸值有限，形变可以忽略外文名：Rigidbody性质：理想模型中文名：刚体 阿尔法通道(Alpha Channel)是指一张图片的透明和半透明度。 漫射漫反射（简称漫射，英语diffuse reflection）是光线照射在物体粗糙的表面会无序地向四周反射的现象。 漫反射，是投射在粗糙表面上的光向各个方向反射的现象。当一束平行的入射光线射到粗糙的表面时，表面会把光线向着四面八方反射，所以入射线虽然互相平行，由于各点的法线方向不一致，造成反射光线向不同的方向无规则地反射，这种反射称之为“漫反射”或“漫射”。这种反射的光称为漫射光。很多物体，如植物、墙壁、衣服等，其表面粗看起来似乎是平滑，但用放大镜仔细观察，就会看到其表面是凹凸不平的，所以本来是平行的太阳光被这些表面反射后，弥漫地射向不同方向。 漫射光就是由漫反射产生的光，什么是漫反射呢？就是光线照在一个物体上，反射向各个方向。而不是像镜子那样只向一个方向反射。我们能看到物体就是由于漫反射的功劳。 例程例程的作用类似于函数，但含义更为丰富一些。例程是某个系统对外提供的功能接口或服务的集合。比如操作系统的API、服务等就是例程； 我们编写一个DLL的时候，里面的输出函数就是这个DLL的例程。 但如果我们把这些函数编写为DLL动态库的输出函数的话，此时虽然对于编写这个DLL的程序员来讲，仍然可以用函数的概念来理解这些DLL提供的功能，但对于以后调用这个DLL的程序来说，DLL里面提供的输出函数（或者说服务）就是例程了。 回调NugetUnity不支持nuget包管理器，因此通过VS添加包不起作用。您必须从nuget.org下载软件包（及其依赖项）。从*.nupkg重命名为*.zip并打开它，将.dll从lib / net46复制到项目的资产文件夹。不要忘记依赖项。在这种情况下，它是Elasticsearch.NET包。 NuGet是什么？如果你了解python，那么它类似pip。如果你了解nodejs，那么它类似npm。它就是一个包（package）管理平台。 Z-orderZ-order，也有人称为Zorder，指的是对象之间的层次关系。通常GUI程序设计都会用到Z-order的概念。 Z-order(Z轴次序)的属性。它来源于三维空间的概念，X和Y分别代表屏幕所在平面上的水平坐标和垂直坐标，而Z轴则是垂直于屏幕的。 窗口的Z次序表明了重叠窗口堆中窗口的位置，这个窗口堆是按一个假想的轴定位的，这个轴就是从屏幕向外伸展的Z轴。Z次序最上面的窗口覆盖所有其它的窗口，Z-次序最底层的窗口被所有其他的窗口覆盖。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与Mono协同工作]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%B8%8EMono%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[C#通常不会提供创建游戏所需的全部内容。就C#语言而言，其自身并不会加载、解析XML语言以支持游戏数据的存储；另外，该语言也无法创建窗口对象和GUI微件，以对复杂数据集执行高级的搜索和查找行为。当实现某些附加操作时，用户通常需要向外部库寻求帮助。其中，某些库可直接从Unity的Asset Store下载，这一类库往往用于实现特定的功能。相应地，Unity发布了Mono Framework，该框架具有免费、跨平台特征，并可见为Microsoft NET框架（编程库）的开源实现，其中包含了大多数类。对应类可用于处理字符串、文件输入和输出、搜索和排序数据、记录动态表、解析XML等。这也说明，作为可扩展的工具箱，Mono可高效地管理应用程序中的数据。本章将考察Unity应用程序中Mono的多种部署方式，即考察表、栈、Linq、正则表达式以及枚举结构等内容。 表和集合存储数据表是游戏编程中较为常见的任务，而此类数据的本质特征也存在多种变化方式，其中包括积分榜、玩家状态，库存物品，武器装备量，关卡表等。出于速度和效率考虑，应尽量采用静态数组存储数据。简而言之，静态数组于先期创建，其最大尺寸从一开始便固定，在运行期内，数据项可被添加和删除，但全部尺寸不会发生变化。当然，如果数据量未达到数组的最大尺寸，则对应空间将被浪费。顾名思义，静态数组适用于存储数据表（其内容通常较少变化），例如游戏中的关卡，采集的全部武器装备等。 然而，用户常会使用到动态数组，其尺寸可增长或收缩，并与处于变化状态下的真实数据相适应。例如生成或销毁敌方角色、库存物品的变化、武器装备的获取或丢弃等。 Mono Framework提供了多个类可维护数据表，其中包括3个主要类，即List、Stack和Dictionary，各个类用于实现不同的功能。 List类如果需要使用单一数据类型的无序数据项序列表，并可增长或收缩以匹配于存储数据的实际尺寸，则List是一个较为理想的选择。List可用于添加和删除数据，并按照顺序遍历全部存储项。除此之外，List对象还可在Unity的Object Inspector中进行编辑。 1234567891011121314151617181920212223242526272829303132333435363738using UnityEngine;using System.Collections;using Systen.Collections.Generic;// Sample enemy class for holding enemy data[System.Serializable]public class Enemy&#123; public int Health = 100; public int Damage = 10; public int Defense = 5; public int Mana = 20; // 法力 public int ID = 0;&#125;public class Using_List: MonoBehaviour&#123; // List of active enemies in the scene public List&lt;Enemy&gt; Enemies = new List&lt;Enemy&gt;(); void Start() &#123; // Add 5 enemies to the list for (int i=0; i&lt;5; i++) &#123; Enemies.Add(new Enemy()); // Add method inserts item to end of the list // Remove 1 enemy from start of list (index 0) Enemies.RemoveRange(0, 1); &#125; // Iterate through list foreach (Enemy E in Enemies) &#123; // Print enemy ID Debug.Log(E.ID); &#125; &#125;&#125; 当使用List类时，需要包含System.Collections.Generic命名空间。如果表数据类型声明为System.Serializable类，则该表可在Object Inspector中予以显示。在类的成员声明中，用户可通过一条语句声明并初始化新的表实例。通过Add方法，新对象可添加至表的尾部。数据项可通过多种方法被移除。其中，RemoveRange方法可从表中删除多个连续数据项，其他的移除方法还包括Remove、RemoveAll以及RemoveAt。用户可采用foreach循环遍历表中的全部数据项。总体而言，在循环遍历过程中，不可添加或移除数据项。 未运行时 点击play后，下图显示了 Object Inspector中的List类。自动生成了5项，有一项被删除了，所以剩4项。 List类支持多种方法，可逐项或整体移除数据项，并可于表循环外部进行操作。然而，在某些场合下，通过循环遍历操作则是一类相对简单、方便的处理方法。例如，用户需要在处理完毕后移除各个数据项。一类较为经典的操作是：删除场景中的全部引用类型对象，例如敌方角色，且同时移除对应的数组数据项，以避免产生null引用。然而，循环方式的数据项移除方式可能会产生问题。对于迭代器而言，这很容易在数组内丢失数据项的位置信息，其原因在于，全部数据项的数量在循环过程中发生变化。当在某一次处理过程中执行循环和移除操作时，应反向遍历数组（而非前向）。 12345678910111213//Remove all items from a loopvoid RemoveAllItems ()&#123; // Traverse list backwards for (int i= Enemies.Count-1; i&gt;=0; i--) &#123; //Call function on enemy before removal Enemies[i].MyFunc(); // Remove this enemy from list Enemies.RemoveAt(i); &#125;&#125; 前向删时删除为0的，则第二个默认又变成0了。 Dictionary类当用户根据某一键值对搜索并直接访问特定元素时，将是Dictionary类的用武之地。对于表中的各个数据项，用户需要存储对应的键或ID，并以此进行独立识别。随后，Dictionary类可根据唯一的键直接访问相应的数据项。对于拼词类游戏，如果用户希望查找特定单词的含义或分值时（在字典或单词库中），Dictionary类的功能类似于真正的字典。其中，单词自身定义为键，而单词的具体信息则表示为值。 当然，用户也可通过多个List对象复制此类行为，而非使用Dictionary类。但在计算性能方面，Dictionary类则具有明显的速度优势。用户可以较小的性能开销在字典中存储海量的数据，因而可实现基于键值对的快速数据查找行为。 123456789101112131415161718192021222324252627282930using UnityEngine;using System.Collections;using System.Collections.Generic;public class Using Dictionary : MonoBehaviour&#123; // Database of words. &lt;Word, Score&gt; key-value pair public Dictionary&lt;string, int&gt; WordDatabase = new Dictionary&lt;string, int&gt;(); void Start() &#123; // Create some words string[] words = new string[5]; Words [0] ="hello"; Words [1] ="today"; Words [2] ="car"; Words [3] = "vehicle"; Words [4] ="computers"; // add to dictionary with scores foreach (string Word in Words) &#123; WordDatabase.Add(Word, Word. Length); &#125; // Pick word from list using key value // Uses array syntax! Debug.Log("Score is:" + WordDatabase["computers"].ToString()); &#125;&#125; 类似于List类，此处应包含System.Collections.Generic命名空间。声明并创建字典。与List类不同，Dictionary并不会出现于Unity的Object Inspector中。Dictionary类通过Add方法添加数据。除了利用键数据确定各项数据元素（而非数组索引）之外，Dictionary类中的元素其访问方式类似于数组。 Stack类在纸牌游戏中，玩家需要抽取最上方的纸牌；另外，对于取消历史记录、路径搜索编码、复杂的法术召唤系统，以及汉诺塔游戏中，均会看到栈结构。根据后入先出（LIFO）规则，栈可定义为一种特殊的表。用户可将数据项置入表中，并在垂直方向上相互堆叠，且最近置入的数据项位于栈的最上方。随后，可从栈顶逐一弹出数据项（从数组中移除数据项）。相应地，弹出的顺序通常与置入的顺序相反。 因此，栈对于撤销或回绕操作十分有效。 1234567891011121314151617181920212223242526272829303132333435363738394041using UnityEngine;using System. Collections;using System. Collections. Generic;[System.Serializable]public class PlayingCard&#123; public string Name; public int Attack; public int Defense;&#125;public class Using_Stack: MonoBehaviour&#123; // Stack of cards public Stack&lt;PlayingCard&gt; CardStack = new Stack&lt;PlayingCard&gt;(); // Use this for initialization void Start() &#123; // Create card array PlayingCard[] Cards = new PlayingCard[5]; // Create cards with sample data for (int i=0; i &lt; 5: i++) &#123; Cards[i] = new PlayingCard(): Cards [i].Name = "Card-0" + i. ToString(); Cards[i].Attack = Cards[i].Defense =i*3 // Push card onto stack CardStack.Push(Cards[i); &#125; //Remove cards from stack while (CardStack.Count &gt; o) &#123; PlayingCard PickedCard = CardStack.Pop(); // Print name of selected card. Debug.Log(PickedCard. Name); &#125; &#125;&#125; Object Inspector什么都没有 IEnumerable和IEnumerator接口当与数据集协同工作时，例如List，Dictionary和Stack等，用户通常会根据特定的方案遍历表中的全部或部分数据项。如前所述，某些时候，用户需要前向遍历序列中的数据项，而在其他场合下，后向遍历则更加方便。对此，用户可采用标准的for循环。然而，该过程中可能会产生某些问题。对此，可通过IEnumerable和IEnumerator接口处理这一类问题。 123456789101112// Create a total variableint Total = 0;// Loop through List object,from left to rightfor (int i=0; i &lt; MyList.Count; i++)&#123; // Pick number from list int MyNumber = MyList[i]; // Increment total Total+= MyNumber;&#125; 当使用for循环时，问题主要体现在3个方面，此处暂且讨论前两个问题。首先，循环的语法内容并无特别之处，其中使用了整型迭代变量（i）访问数组数据元素。其次，迭代器自身并不具备“边界安全”这一特征。实际上，这可产生上溢或下溢问题，并导致越界错误。 在某种程度上，上述问题可通过相对整洁的foreach循环予以解决，进而保证边界安全，并采用更为简单的语法结构，代码如下所示。 123456789// Create a total variableint Total= 0;// Loop through List object, from left to rightforeach (int Number in MyList)&#123; // Increment total Total += Number;&#125; 不难发现，foreach循环更为简洁，且兼具良好的可读性，但实际问题远不止于此。foreach循坏仅适用于实现了IEnumerable接口的类。实现了IEnumerable的对象须返回基于IEnumerator接口的有效实例。因此，对于工作于foreach循环内的某一对象，该对象依赖于两个接口。对于简单的循环和遍历行为，当前操作显然过于复杂。对应的处理方法可描述为：IEnumerable和IEnumerator不仅可处理前两个问题（即基于foreach循环的简单语法和边界安全问题），还应可解决第三个问题。特别地，该方法应可遍历对象组（甚至是非数组类型）。也就是说，可遍历不同的对象类型，该功能十分强大, 下面将通过具体实例对此加以考祭。 例如，在中世纪风格的RPG游戏场景中，居住着不同的邪恶法师角色采用Wizard类进行编码，这一类角色以随机地点和随机时间间隔出现于关卡中,并通过召唤法术、执行某些破坏任务对玩冢进行干扰。相应的随机生成结果可描述为:默认状态下,玩豕无法知晓某一时刻场景中的法师数量。尽管如此,这里依然需要获取法师的全部数量;或许,法师角色可能处于禁用、隐身、暂停或被销毁状态;抑或需要知晓其全部数量以防止其数量超出一定范围。因此,若不考虑法师的生成过程及其随机性,最终依然需要根据要求访问关卡中的全部法师角色。 如前所述,第2章曾定义了一个可遍历的法师角色列表,如示例代码6-7所示。 12345678// Get all wizardsWizard[] WizardsInScene = Object.FindObjectsOfType&lt;Wizard&gt;();// Cycle through wizardsforeach (Wizard W in WizardsInScene )&#123;// Access each wizard through W&#125; 当频繁使用时，FindObjectsOfType函数的计算速度较慢，且性能较差。 对此，可通过IEnumerable和IEnumerator实现类似的行为，以消除性能问题。当采用上述两个接口时，可使用foreach循环高效地遍历场景中的全部法师角色，即使此类角色位于数组中，如示例代码6-8所示。 示例代码6-8]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity脚本设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件驱动程序设计]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 1.事件 2.事件管理 对于一段时间内按一定规律执行的代码，MonoBehaviour对象的Update事件提供了一个较为方便的环境，并可跨越多个帧以及多个场景。当创建某些持久行为时，例如针对敌方角色或连续运动的人工智能行为，除了编写Update函数之外似乎别无他法，其中包含了大量的if和switch语句，取决于对象的当前需求，以使代码分支于不同的方向。当通过该方式考察Update事件时，即作为默认函数实现某些复杂行为，对于大型、复杂场景，这将会产生性能问题。当对此经过深入分析后，不难发现其中所隐藏的原因。一般情况下，游戏中涵盖了大量的行为，场景中时刻会出现各种事件，仅在Update函数中对此予以实现往往不切实际。例如，考察某一敌方角色，此类角色需要了解玩家何时进入或离开其视线，何时生命值处于危险状态，何时武器失效，何时身处于危险的地形中，何时遭受攻击，何时应处于运动状态等。初看之下，由于敌方角色需要及时了解此类属性的变化时机（作为玩家输入结果），因而需对此予以持续关注，这也是Update函数的主要适用原因。但这里存在一类较好的替代方案，即事件驱动编程。当采用事件方式考察游戏和应用程序时，性能将得到极大的提升。本章主要讨论事件问题，以及如何在游戏中对其加以管理。 事件游戏场景世界可表示为一个确定性系统。在Unity中，场景定义为3D笛卡尔空间和时间轴，其中包含了某些GameObject。各种事件在游戏逻辑和代码的支配下产生于该空间内。例如，对象仅可在代码和特定条件允许时方可处于运动状态，如玩家按下某个键时。从中可以看出，行为并非是随机状态而是彼此间相互关联的–对象仅在产生键盘事件时处于运动状态。因此，动作间往往存在一个重要的连接，且动作间存在某种传递行为。这一类连接称作事件，各个独立的连接表示为独立的事件。事件往往表示为被动状态（非主动态），体现了某种时机而非自身动作，例如按下某个键、鼠标单击操作、对象进入碰撞器空间、玩家遭受攻击等，这均可视为事件的各种示例，但并未表明程序的执行内容，只是展现了所发生的某种情形。作为一类通用概念，事件驱动编程始于事件的识别，并将游戏中的各种情形视为事件的实例化结果。也就是说，事件与时间相关，理解游戏事件对于后续内容的学习十分有帮助，游戏中的全部动作均直接响应于特别的事件。特别地，事件连接于响应行为，即事件发生后将触发某一响应操作。进一步讲，该响应结果可再次形成某一事件，并触发后续响应行为等。换而言之，游戏场景表示为一个完整的、由事件和响应构成的集成系统。通过这一方式考察游戏场景时，随之而来的问题则是，如何通过Update函数提升性能，并使得各种行为在各帧中向前推进。对此，需要获取对应方式以降低事件的频度。该方案略显抽象，但却十分重要。为了进一步展示这一概念，下面对敌方角色进行考察。在于玩家战斗过程中，该角色将对玩家开火射击。 在游戏体验中，敌方角色需要跟踪多个属性。首先是生命值，当该值较小时，敌方角色会搜寻医药箱，在其辅助下，其生命值将得到迅速提升。其次是弹药量，若该值较小，该敌方角色将收集更多的弹药。另外，该角色还需判断何时向玩家射击。例如，仅当视线未被阻挡时，敌方角色即向玩家射击。通过上述方案，可在动作间确定某些连接，即事件。但在进一步讨论之前，还需查看基于Update函数的、此类行为的实现方式，如下代码所示。随后，还将进一步讨论事件对于该实现方案的改进方法。此代码绑定在敌方角色的对象上。 1234567891011121314151617181920212223242526272829void Update()&#123; // 检查血量 if (Health &lt; 0) &#123; Die(); return; &#125; // 血量低就寻找医药箱 if (Health &lt; 20) &#123; RunAndFindHealthRestore(); return; &#125; // 子弹没有了就寻找 if (Ammo &lt;= 0) &#123; SearchMore(); return; &#125; // 看见游戏玩家就射击 if (HaveLineOfSight) &#123; FireAtPlayer(); &#125;&#125; 在上述代码中，Update函数包含了大量的条件检测和响应操作。实际上，Update函数希望将事件处理和响应行为合二为一，但实际结果则包含了某些冗余处理过程。当考察不同处理间的事件连接时（生命值和弹药量检测），将会发现代码可实现进一步的优化。例如，弹药量仅在两种情形下发生变化：敌方角色射击时，或者弹药被再次填充时。类似地，生命值的变化也包含两种情形：当敌方角色遭受玩家攻击时，或者该角色找到了第一个医药箱。对于前者，生命值将有所减少；而对于后者，生命值将增加。 鉴于属性发生变化（事件），因而对应值需要得到进一步确认。如下代码重构了敌方角色对象，其中包含了C#属性以及简化后的Update函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using UnityEngine;using System.Collections;public class EnemyObject : MonoBehaviour &#123; // C# accessors for private variable public int Health &#123; get&#123; return _health;&#125; set &#123; // Clamp(固定) health between 0-100 _health = Mathf.Clamp(value, 0, 100); // Check if dead if (_health &lt;= 0) &#123; OnDead(); return; &#125; // Check health and raise event if required if (_health &lt;= 20) &#123; OnHealthLow(); return; &#125; &#125; &#125; public int Ammo &#123; get &#123;return _ammo;&#125; set &#123; // Clamp ammo between 0-50 _ammo = Mathf.Clamp(value, 0, 50); // Check if ammo empty if(_ammo &lt;= 0) &#123; // Call expired event OnAmmoExpired(); return; &#125; &#125; &#125; // Internal variables for health and ammo private int _health = 100; private int _ammo = 50; void Update() &#123; &#125; void OnHealthLow() &#123; &#125; void OnDead() &#123; &#125; void OnAmmoExpired() &#123; &#125;&#125; 敌方角色类重新设计为事件驱动模式，Ammo和Health这一类属性不再设置于Update函数中，而是采用了赋值操作。自此，根据最新赋值结果将生成相关事件（函数触发写在了属性里）。当采用事件驱动设计时，性能将得到优化，同时代码将更为简洁。具体而言，在4-1代码中，Update函数的内容将大大减少，并消除了某些数值检测操作。相反，示例代码4-2中采用了特定的数值事件驱动代码，且仅在相关时刻对其进行调用。 事件管理事件驱动程序设计大大简化了操作过程，但问题也随之而来。特别地，在上面的代码中，基于生命值和弹药量的C#属性用于检测、验证相关变化，并于随后生成相关事件（例如OnDead事件）。该过程理论上工作良好，至少可将自身事件告知自身。然而，如果该角色需要了解另一个敌方角色的生命值，或者需要知晓其他角色何时被射杀，情况又当如何？当然，对于特定情况，可返回至上面代码中的敌方角色类并对其进行修正，随后可利用相关函数，例如SendMessage函数，针对其他角色（而非仅针对当前角色）调用OnDead事件，但这依然无法解决一般意义上的问题。理想状态下，各个对象应可随意监听各种事件类型并被告知，仿佛是自身事件一样。因而，当前问题则是如何对优化后的系统进行编码，并按照当前方式简化事件管理系统。简而言之，需要一个允许对象倾听特定事件的EventManager类（新的专门管理的类），该系统依赖于下列3个核心概念。 EventListener：监听器是指需要被告知所发生的事件，甚至是自身事件的对象。在实际操作过程中，几乎每个对象均可针对至少一个事件定义为监听器。例如，某一敌方角色需要了解其他角色的生命值和弹药量。此时，该对象应至少针对两个独立事件定义为一个监听器。因此，无论何时对象需要被告知所发生的事件时，该对象均可定义为一个监听器。 EventPoster：与监听器相比，当对象检测到所发生的事件后，应发送与其相关的消息，并告知全部监听器。在上面的代码中，敌方角色类通过相关属性检测Ammo和Health事件，并于随后在必要时调用内部事件。对此，对象需要在全局层次上生成相关事件。 EventManager：最后，还需定义一个单例持久对象EventManager，并提供全局访问行为。该对象可将监听器连接至消息传递者。另外，该对象接收传递者发送的事件消息，并于随后将其以事件形式传递至相应的监听器中。 基于接口的事件管理事件处理系统中的基本实体是监听器–可向其通知特定的事件。如果可能，任意对象和类均可定义为监听器，并简单地向其通知特定的事件。简单地讲，监听器需要通过EventManager并针对一个或多个特定事件注册为监听器。当产生相关事件时，可通过函数调用消息监听器。因此，从技术角度上讲，对于EventManager而言这将会产生类型问题。也就是说，如果监听器可表示为任意类型的对象，管理器如何在其上调用某一事件？当然，前述内容中曾提到，可利用SendMessage或BroadcastMessage函数解决这一问题。实际上，网络上的某些事件处理系统即采用了这种处理方式，例如NotificationCenter，然而，鉴于SendMessage或BroadcastMessage函数过度依赖于反射机制，本章将避免使用，而是采用了多态机制。特别地，本章将定义一个接口，且全部监听器对象均继承自该接口。 在C#语言中，接口类似于一个空的抽象基类。接口将方法和函数集整合至单一模板单元中，这一点与类十分相似。然而，与类结构不同，接口仅可定义函数原型，例如名称、返回类型以及函数的参数，且不可于其中定义函数体。其原因在于，接口仅定义了派生类应有的全部函数集。派生类在必要时须实现对应函数，接口的存在使得其他类可通过多态机制调用函数，且无须了解各个派生类的具体类型。据此，接口适用于创建Listener对象。通过定义Listener接口（全部对象均继承自该接口），各对象均可定义为事件监听器。示例代码显示了简单的Listener接口。 12345678910111213141516171819using UnityEngine;using System.Collections; //Enum defining all possible game events//More events should be added to the listpublic enum EVENT_TYPE&#123; GAME_INIT, GAME_END, AMMO_EMPTY, HEALTH_CHANGE, DEAD&#125;; ///Listener interface to be implemented on Listener classespublic interface IListener&#123; //Notification function invoked when events happen. void OnEvent(EVENT_TYPE Event_Type, Component Sender, Object Param = null);&#125; 示例代码中的部分解释内容如下所示。 第6到10行代码：枚举结构定义了可能发生的、完整的游戏事件列表。相应地，代码中仅列出了5种游戏事件，即GAME_INIT、GAME_END、AMMO_EMPTY、HEALTH_CHANGE以及DEAD，当然，用户还可定义多种事件。另外，也可仅采用整数对事件进行编码，此处采用枚举结构旨在提高代码的可读性。 第13到17行代码：监听器接口定义为IListener（C#接口），且仅支持一个事件，即OnEvent。该函数被全部派生类继承，针对注册的监听器，当产生某一事件时该函数将被管理器所调用。需注意的是，OnEvent仅表示为函数原型，而非函数体。 通过IListener接口，仅利用类继承机制即可根据任意对象创建监听器。也就是说，任意对象均可声明为监听器并接收事件。例如，MonoBehaviour组件可通过如下代码转化为监听器，并采用了多重继承机制，即继承自两个类。 12345678910111213141516using UnityEngine;using System.Collections; public class MyCustomListener : MonoBehaviour, IListener&#123; //Use this for initialization void Start() &#123;&#125; //Update is called once per frame void Update() &#123;&#125; //Implement OnEvent function to receive Events public void OnEvent(EVENT_TYPE Event_Type, Component Sender, Object Param= null) &#123; &#125;&#125; 定义EventManager如前所述，任意对象均可转化为监听器，但监听器自身仍需通过某种类型的管理器对象进行注册。因此，当产生相关事件时，管理器负责调用监听器上的事件。下面讨论管理器的具体实现细节。此处，管理器类称作EventManager，如示例代码所示。作为持久性单例对象，该类绑定至空场景对象GameObject上，并可通过静态实例属性被其他对象直接访问。代码中的注释内容列出了该类及其应用的更多信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128using UnityEngine;using System.Collections;using System.Collections.Generic;// Singleton EventManager to send events to listeners// Works with IListener implementationspublic class EventManager : MonoBehaviour&#123; #region C# properties // Public access to instance. public static EventManager Instance &#123; get &#123; return instance; &#125; set &#123; &#125; &#125; #endregion #region variables // Notifications Manager instance (singleton design pattern) private static EventManager instance = null; // Array of listeners (all obiects registered for events). private Dictionary&lt;EVENT_TYPE, List&lt;IListener&gt;&gt; Listeners = new Dictionary&lt;EVENT_TYPE, List&lt;IListener&gt;&gt;(); #endregion #region methods // Called at start-up to initialize. void Awake() &#123; // If no instance exists, then assign this instance if (instance == null) &#123; instance = this; DontDestroyOnLoad(gameObject); &#125; else DestroyImmediate(this); &#125; /// &lt;summary&gt; /// Function to add listener to array of listeners /// &lt;/summary&gt; /// &lt;param name = "Event_Type" &gt;Event to Listen for&lt;/param&gt; /// &lt;param name = "Listener"&gt;Object to listen for event&lt;/param&gt; public void AddListener(EVENT_TYPE Event_Type, IListener Listener) &#123; // List of listeners for this event List&lt;IListener&gt; ListenList = null; // Check existing event type key. If exists, add to list if (Listeners.TryGetValue(Event_Type, out ListenList)) &#123; // List exists, so add new item ListenList.Add(Listener); return; &#125; // Otherwise create new list as dictionary key ListenList = new List&lt;IListener&gt;(); ListenList.Add(Listener); Listeners.Add(Event_Type, ListenList); &#125; /// &lt;summary&gt; /// Function to post event to listeners /// &lt;/summary&gt; /// &lt;param name="Event_Type"&gt;Event to invoke&lt;/param&gt; /// &lt;param name-"Sender"&gt;Object invoking event&lt;/param&gt; /// &lt;param name="Param"&gt;Optional argument&lt;/param&gt; public void PostNotification(EVENT_TYPE Event_Type, Component Sender, Object Param = null) &#123; // Notify all listeners of an event // List of listeners for this event only. List&lt;IListener&gt; ListenList = null; // If no event exists, then exit if (!Listeners.TryGetValue(Event_Type, out ListenList)) return; // Entry exists. Now notify appropriate listeners for (int i=0; i &lt; ListenList.Count; i++) &#123; if (!ListenList[i].Equals(null)) ListenList[i].OnEvent(Event_Type, Sender, Param); &#125; &#125; // Remove event from dictionary, including all listeners public void RemoveEvent(EVENT_TYPE Event_Type) &#123; // Remove entry from dictionary Listeners.Remove(Event_Type); &#125; // Remove all redundant（多余的） entries from the Dictionary public void RemoveRedundancies() &#123; // Create new dictionary Dictionary&lt;EVENT_TYPE, List&lt;IListener&gt;&gt; TmpListeners = new Dictionary&lt;EVENT_TYPE, List&lt;IListener&gt;&gt;(); // Cycle through all dictionary entries foreach (KeyValuePair&lt;EVENT_TYPE, List&lt;IListener&gt;&gt; Item in Listeners) &#123; // Cycle all listeners, remove null objects for (int i = Item.Value.Count - 1; i &gt;= 0; i--) &#123; // If null, then remove item if (Item.Value[i].Equals(null)) Item.Value.RemoveAt(i); &#125; // If items remain in list, then add to tmp dictionary if (Item.Value.Count &gt; 0) TmpListeners.Add(Item.Key, Item.Value); &#125; // Replace listeners object with new dictionary Listeners = TmpListeners; &#125; // Called on scene change. Clean up dictionary void OnLevelWasLoaded() &#123; RemoveRedundancies(); &#125; #endregion&#125; 示例代码4-5中的部分解释内容如下所示。 第3行：System.Collections.Generic命名空间可访问附加的Mono类，同时还包括Dictionary类。该类贯穿于整个EventManager类。简单地讲，Dictionary表示为2D数组，并根据键值对存储数值的数据库。 第3行：EventManager类继承自MonoBehaviour，且应与场景中的空GameObject绑定，并作为持久性单例对象存在。 第3行：private成员变量Listeners采用Dictionary类声明，该结构用于维护键中值对的哈希表数组，并可像数据库那样执行查找和搜索行为。EventManager类的键值对接收形如EVENT_TYPE和List的参数。这意味着，可存储事件类型列表（例如HEALTH_CHANGE），且针对各个类型，可存在0个、1个或多个监听组件，并在产生相关事件时被通知。实际上，Listener成员表示为主数据结构，EventManager以此维护监听目标。 第3行：Awake函数负责实现单例功能，即EventManager表示为单例对象，并在场景中持久存在。 第3行：针对各个监听事件，EventManager的AddListener方法通过Listener对象调用，该方法接收两个参数，即监听的事件（Event_Type）和监听器对象的引用（继承自IListener），并在产生事件时被通知。AddListener函数负责访问Listener字典，生成新的键值对，并存储事件和监听器之间的连接。 第3行：当检测到某一事件时，PostNotification函数可通过任意对象（无论是否为监听器）加以调用。随后，EventManager遍历字典中的全部匹配项，搜索与当前事件连接的所有监听器，通过IListener接口调用OnEvent方法，进而对其予以通知。 第3行：EventManager类中的最后一个方法维护Listener结构的数据完整性（场景产生变化，且EventManager类具有持久性特征）。虽然EventManager类在不同场景间具有持久性特征，但Listener变量中的监听器对象则并非如此。当场景变化时，此类对象将被销毁。对此，场景变化会使某些监听器处于失效状态，从而使得EventManager包含了无效项。因此，可调用RemoveRedundancies方法搜索并消除全部无效项。另外，当场景发生变化时，Unity将自动调用OnLevelWasLoaded事件。 字典的优势不仅体现于作为动态数组的快速访问能力，同时，用户还可通过对象类型和下标操作符与其协同工作。在常规数组中，各数据元素可采用整型索引予以访问，例如MyArray[0]和MyArray[1]。当采用字典时，情况则有所不同。特别地，用户可利用EVENT_TYPE对象访问数据元素，即键值对中的“键”，例如MyArray[EVENT_TYPE.HEALTH_CHANGE]。 代码折叠#region和#endregionregion和#endregion预处理器指令（与代码折叠特性结合使用）对于改善代码的可读性，以及源代码的浏览速度十分有效。在不影响源代码的有效性和执行结果准确性的前提下，可向源代码添加重组和结构化功能。其中，#region标记于代码块的上方，而#endregion则标注于结尾处。当某一区域按照这一方式标记后，该区域将呈现为折叠状态。在代码编辑器中，将显示为收缩状态。当收缩某一代码区域后，其内容将隐藏于视图中，用户可仅关注特定的代码区域。 使用EventManager下面考察如何从监听器和传送对象的角度将EventManager置于实际工作环境中。首先，事件监听器需要利用EventManager单例实例进行注册。一般情况下，该操作仅在前期执行一次，例如在Start函数中。此处不可使用Awake函数，该函数用于对象的内部初始化行为。示例代码采用了Instance静态属性获取指向处于活动状态的、EventManager单例对象的引用。 123456// Called at start-upvoid Start()&#123; // Add myself as listener for health change events EventManager.Instance.AddListener(EVENT_TYPE.HEALTH_CHANGE, this);&#125; 当对一个或多个事件注册了监听器后，若检测到事件，对象可向EventManager发送消息，如以下代码所示。 123456789101112public int Health&#123; get &#123;return _health;&#125; set &#123; // Clamp health between 0-100 _health = Mathf.clamp(value, 0, 100); // Post notification - health has been changed EventManager.Instance.PostNotification(EVENT_TYPE.HEALTH_CHANGE, this, _health); &#125;&#125; 最后，事件消息经传递后，与其关联的监听器通过EventManager自动更新。特别地，EventManager将调用各个监听器的OnEvent函数，解释事件数据并在对应处予以响应，如以下代码所示。 1234567891011// Called when events happenpublic void OnEvent(EVENT_TYPE EVENT_TYPE, Component Sender,object Param = null)&#123; // Detect event type switch (EVENT_TYPE) &#123; case EVENT_TYPE.HEALTH_CHANGE: OnHealthChange(Sender, (int)Param); break; &#125;&#125; 基于委托机制的替代方案接口可视为一类高效方案，并简化了事件处理系统的实现过程，但并非是唯一的处理方案。除此之外，还可利用C#语言中的委托机制。实际上，用户可定义一个函数，并在变量中存储指向该函数的引用。该变量可将函数视为引用类型的变量。也就是说，当采用委托机制时，用户可存储指向函数的引用，在后续操作中，可以此调用该函数。其他语言则通过函数指针提供了类似的功能，例如C++语言。当采用委托机制实现事件系统时，可不再使用接口。作为替代方案，示例代码通过委托实现了EventManager。其中，调整内容采用黑体表示，以彰显接口和委托实现之间的差别。除了与委托机制对应的变化内容之外，其他函数均保持不变。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141using UnityEngine;using System.Collections;using System.Collections.Generic;//Enum defining all possible game events//More events should be added to the listpublic enum EVENT_TYPE &#123;GAME_INIT, GAME_END, AMMO_CHANGE, HEALTH_CHANGE, DEAD&#125;;//Singleton EventManager to send events to listeners//Works with IListener implementationspublic class EventManager : MonoBehaviour&#123; #region C# properties //Public access to instance public static EventManager Instance &#123; get&#123;return instance;&#125; set&#123;&#125; &#125; #endregion #region variables //Internal reference to Notifications Manager instance (singleton design pattern) private static EventManager instance = null; // Declare a delegate type for events public delegate void OnEvent(EVENT_TYPE Event_Type, Component Sender, object Param = null); //Array of listener objects (all objects registered to listen for events) private Dictionary&lt;EVENT_TYPE, List&lt;OnEvent&gt;&gt; Listeners = new Dictionary&lt;EVENT_TYPE, List&lt;OnEvent&gt;&gt;(); #endregion #region methods //Called at start-up to initialize void Awake() &#123; //If no instance exists, then assign this instance if(instance == null) &#123; instance = this; DontDestroyOnLoad(gameObject); //Prevent object from being destroyed on scene exit &#125; else //Instance already exists, so destroy this one. This should be a singleton object DestroyImmediate(this); &#125; /// &lt;summary&gt; /// Function to add specified listener-object to array of listeners /// &lt;/summary&gt; /// &lt;param name="Event_Type"&gt;Event to Listen for&lt;/param&gt; /// &lt;param name="Listener"&gt;Object to listen for event&lt;/param&gt; public void AddListener(EVENT_TYPE Event_Type, OnEvent Listener) &#123; //List of listeners for this event List&lt;OnEvent&gt; ListenList = null; //New item to be added. Check for existing event type key. If one exists, add to list if(Listeners.TryGetValue(Event_Type, out ListenList)) &#123; //List exists, so add new item ListenList.Add(Listener); return; &#125; //Otherwise create new list as dictionary key ListenList = new List&lt;OnEvent&gt;(); ListenList.Add(Listener); Listeners.Add(Event_Type, ListenList); //Add to internal listeners list &#125; /// &lt;summary&gt; /// Function to post event to listeners /// &lt;/summary&gt; /// &lt;param name="Event_Type"&gt;Event to invoke&lt;/param&gt; /// &lt;param name="Sender"&gt;Object invoking event&lt;/param&gt; /// &lt;param name="Param"&gt;Optional argument&lt;/param&gt; public void PostNotification(EVENT_TYPE Event_Type, Component Sender, object Param = null) &#123; //Notify all listeners of an event //List of listeners for this event only List&lt;OnEvent&gt; ListenList = null; //If no event entry exists, then exit because there are no listeners to notify if(!Listeners.TryGetValue(Event_Type, out ListenList)) return; //Entry exists. Now notify appropriate listeners for(int i=0; i&lt;ListenList.Count; i++) &#123; if(!ListenList[i].Equals(null)) //If object is not null, then send message via interfaces ListenList[i](Event_Type, Sender, Param); &#125; &#125; //Remove event type entry from dictionary, including all listeners public void RemoveEvent(EVENT_TYPE Event_Type) &#123; //Remove entry from dictionary Listeners.Remove(Event_Type); &#125; //Remove all redundant entries from the Dictionary public void RemoveRedundancies() &#123; //Create new dictionary Dictionary&lt;EVENT_TYPE, List&lt;OnEvent&gt;&gt; TmpListeners = new Dictionary&lt;EVENT_TYPE, List&lt;OnEvent&gt;&gt;(); //Cycle through all dictionary entries foreach(KeyValuePair&lt;EVENT_TYPE, List&lt;OnEvent&gt;&gt; Item in Listeners) &#123; //Cycle through all listener objects in list, remove null objects for(int i = Item.Value.Count-1; i&gt;=0; i--) &#123; //If null, then remove item if(Item.Value[i].Equals(null)) Item.Value.RemoveAt(i); &#125; //If items remain in list for this notification, then add this to tmp dictionary if(Item.Value.Count &gt; 0) TmpListeners.Add (Item.Key, Item.Value); &#125; //Replace listeners object with new, optimized dictionary Listeners = TmpListeners; &#125; //Called on scene change. Clean up dictionary void OnLevelWasLoaded() &#123; RemoveRedundancies(); &#125; #endregion&#125; 示例代码中的部分解释内容如下所示。 第1行：事件类型枚举结构替换为源自原IListener类的EventManager文件。委托实现避免使用接口和IListener，因而枚举结构转换为管理器源文件。 第1行：public成员变量OnEvent声明为委托类型。需注意的是，声明采用了混合方式，并结合了变量声明和函数原型。这确定了函数原型，并可赋予委托变量中；基于该结构的任意函数可通过类或脚本文件进行赋值。因此，OnEvent函数演变为委托类型，并用于下一条语句中，进而创建内部字典。 第1行：声明了private字典；同时，针对各个事件类型，存储了一个委托数组（而非接口）；各个委托将引用一个函数，该函数在产生事件时被调用。 第1行：严格地讲，PostNotification函数在EventManager上被调用，当产生事件时将调用全部委托（监听器函数）。该行为出现于处，即“ListenListi;”语句。这将像调用函数一样调用委托。 MonoBehaviour事件下面讨论Unity中已经提供的使用事件驱动编程的事件。MonoBehaviour类定义了多种事件，并可在特定条件下自动被调用。这一类函数或事件始于前缀On，并包含了诸如OnGUI、OnMouseEnter、OnMouseDown、OnParticleCollision等事件。 鼠标事件鼠标输入和触摸输入事件集十分有用，其中包含了OnMouseDown、OnMouseEnter和OnMouseExit。在Unity的早期版本中，此类事件仅通过鼠标事件触发，且不包括触摸输入。近期，触摸输入也加入其中，这也意味着，默认条件下，触击行为注册为鼠标事件。具体而言，按下鼠标键时（同时鼠标指针悬停于某一对象上），OnMouseDown将被调用。然而，该事件并不会重复被调用，直至按键被释放。类似地，当鼠标指针悬停于某一对象上时，OnMouseEnter将被调用；而鼠标指针离开该对象时，OnMouseExit将被调用。这一类事件的成功与否取决于与对象绑定的碰撞器组件，并在鼠标事件检测过程中靠近其空间体。也就是说，如果对象未绑定碰撞器，则不会触发鼠标事件。 然而，某些场合下，MouseEvents并不会被触发，即使相关对象绑定了碰撞器。其原因在于，根据当前活动相机的视角，其他对象（包含碰撞器）遮挡了所单击的对象，即可单击对象位于背景中。当然，存在多种方式可处理这一类问题，例如，可简单地将前景对象赋予Ignore aycast层中，以使其免受物理光线操作的影响。 在将某一对象赋予Ignore Raycast层时，可选择该场景对象，单击Object Inspector中的Layer下拉列表，并将当前对象置于Ignore Raycast层中，如下图所示。 在某些情况下，上述措施同样也会失效。通常，这会涉及多部相机以及多个包含碰撞器的对象，并遮挡希望选取或调整的对象（根据鼠标输入事件）。对此，用户需要手动处理鼠标事件。示例代码根据输入内容，以手动方式调用特定的鼠标事件。实际上，代码使用了Raycast（射线）系统，并将手动检测到的输入事件重定向至MonoBehaviour鼠标事件。除此之外，代码还使用了系统程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using UnityEngine;using System.Collections;public class ManualMouse : MonoBehaviour&#123; //Get collider attached to this object private Collider Col = null; //Awake function - called at start up void Awake() &#123; //Get collider Col = GetComponent&lt;Collider&gt;(); &#125; //Start Coroutine void Start() &#123; StartCoroutine(UpdateMouse()); &#125; public IEnumerator UpdateMouse() &#123; //Are we being intersected bool bIntersected = false; //Is button down or up bool bButtonDown = false; //Loop forever while(true) &#123; //Get mouse screen position in terms of X and Y //You may need to use a different camera, if you have multiple Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; //Test ray for collision against this collider if (Col.Raycast(ray, out hit, Mathf.Infinity)) &#123; //Object was intersected - if not previous intersecting, then send on enter message if(!bIntersected) SendMessage("OnMouseEnter", SendMessageOptions.DontRequireReceiver); bIntersected = true; //Test for mouse events if(!bButtonDown &amp;&amp; Input.GetMouseButton(0))&#123;bButtonDown = true; SendMessage("OnMouseDown", SendMessageOptions.DontRequireReceiver);&#125; if(bButtonDown &amp;&amp; !Input.GetMouseButton(0))&#123;bButtonDown = false; SendMessage("OnMouseUp", SendMessageOptions.DontRequireReceiver);&#125; &#125; else &#123; //Was previously entered and now leaving if(bIntersected) SendMessage("OnMouseExit", SendMessageOptions.DontRequireReceiver); bIntersected = false; bButtonDown = false; &#125; //Wait until next frame yield return null; &#125; &#125;&#125; 协同程序表示为一种特定类型的函数，从某种程度上讲，其行为类似于线程，并相对于主游戏循环并行或异步运行。也就是说，一旦处于执行状态，协同程序仿佛在后台运行。执行过程并不会暂停或等待，直至该程序像常规函数那样执行完毕。因此，协同程序适用于创建具有异步外观的行为。 从技术角度上讲，全部协同程序需要返回IEnumerator类型，并在程序体中至少包含一条yield语句，并通过StartCoroutine函数进行发布。yield语句表示为一类特殊的语句，并可暂停协同程序的执行，直至其条件得到满足。yield语句返回WaitForSeconds（x），将暂停执行流程x秒，并在间隔后（下一行处）恢复执行。相比较而言，yield语句返回null将针对当前帧延缓执行，并在下一帧恢复执行流程（下一行处）。 应用程序焦点和暂停读者应注意3个额外的MonoBehaviour事件，其操作容易引起混淆并产生未知结果，即OnApplicationPause、OnApplicationFocus和OnApplicationQuit事件。 OnApplicationQuit将在游戏退出前发送至场景中的全部对象中，随后，场景及其全部内容将被销毁。如果游戏在编辑器中进行测试，则播放停止时将调用OnApplicationQuit事件。值得注意的是，OnApplicationQuit不会针对iOS设备被调用，此时应用程序处于暂停状态，同时用户可执行其他操作，最终返回至中断点并恢复执行。如果用户希望或需要接收包含暂停态的OnApplicationQuit，则需要在Player Settings窗口中启用相关选项。具体来说，可在应用菜单中选择Edit-&gt;Project Settings-&gt;Player命令，随后可在ObjectInspector中针对iOS版本打开Other Settings选项卡，并选中Exiton Suspend复选框。 当游戏失去焦点时，事件OnApplicationFocus将传递至全部场景对象中。通常在多任务系统中，游戏窗口将会处于非激活状态。这可视为一类较为重要的游戏事件，特别是在多玩家游戏中。其中，公共场景中的动作和事件将持续进行，即使玩家并未实际参与。在这一类情形中，用户需要暂停、恢复特定行为，或者淡入、淡出游戏音乐。 OnApplicationPause表示为一类模糊事件，其原因在于，Unity中的暂停概念并未加以清晰定义。相应地，存在两种暂停方式，即最终（ultimate）暂停和相对暂停。对于前者，游戏中的各项活动和事件均处于暂停状态。期间，时间处于停止状态，且全部事物均呈现为静止状态。相比较而言，相对暂停则更为常见。其中，游戏知晓自身处于暂停状态，并中止某些事件，例如场景中的事件，同时可使其他事件继续执行，例如GUI交互或用户输入，进而可解除游戏的暂停状态。OnApplicationPause事件表示为第一类暂停，（而非后者）。当满足多个条件时，该事件将被调用，稍后将对此予以介绍。 首先，如果Run In Background选项在选项卡中未被选中（位于Resolution分组内），如图4-5所示，则OnApplicationPause仅实现了桌面级调用。当禁用该选项后，且窗口失去焦点时，这将自动暂停桌面游戏。这也意味着，OnApplicationPause将随OnApplicationFocus事件被调用。 当实现自己的相对暂停功能时，应尽量避免使用OnApplicationPause事件。相应地，可使用Time.timeScale变量，或者对更为复杂的综合系统进行编码，进而可对暂停，元素有选择性地加以控制。 小结本章主要通过EventManager讨论事件驱动框架针对应用程序的各种优势。当实现此类管理器时，可采用接口或委托机制，二者均功能强大且兼具可扩展性。特别地，Update函数中可加入诸多功能项，但也会产生性能问题。较好的方法是分析各功能之间的连接，并将其重构为事件驱动框架。实际上，事件表示为事件驱动系统中的原始资料，体现了动作（起因和响应）间的必要连接。当对事件进行管理时，可创建EventManager类–将传递者链接至监听器的集成类或系统，从传递者处接收与事件相关的消息，并于随后将函数调用分发至基于该事件的全部监听器上。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity脚本设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GameObject、场景世界以及单例模式]]></title>
    <url>%2F2019%2F03%2F08%2FGameObject%E3%80%81%E5%9C%BA%E6%99%AF%E4%B8%96%E7%95%8C%E4%BB%A5%E5%8F%8A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Unity中的游戏和世界可通过场景表达，其中场景表示为位于笛卡儿3D坐标系（定义了X、Y、Z轴）内的游戏对象集合。这里，场景单位采用Unity单位进行测算，在实际操作过程中，对应单位表示为米。通过Unity进行脚本设计时，应理解场景和对象的含义，以及对象间的交互方式。也就是说，需要了解场景中的单一、独立对象间的彼此通信方式，以使进程按照希望的方向发展。本章主要讨论本地Unity方法，进而通过优化方式搜索、引用并访问场景对象。除此之外，本章还将对相关方法进行逐一考察，并在具体应用环境中以及性能和效率方面对其予以评估。 GameObject对象通常情况下，GameObject表示场景中的基本单元或实体，一般对应于常见场景中的某项“事物”。这里，具体的环境行为或者游戏中所需的实际对象并不重要，无论何种情形，用户仅需通过GameObject加以实现。GameObject对于游戏体验者而言不一定可见，例如声音、碰撞器以及管理类。另外，某些GameObject处于可见状态，其中包括网格、动画网格、精灵对象等。无论是否可见，GameObject通常在场景中作为相关组件集合予以实例化。实际上，组件表示为继承自MonoBehaviour的一个类，并可绑定在场景中的GameObject上，进而调整其行为。各个GameObject至少包含一个组件且不可移除，即Transform组件（对于GUI对象则是RectTransform组件）。该组件记录对象的位置、旋转以及缩放状态。例如，如果在场景中创建了一个空游戏对象（通过应用菜单中的GameObject-&gt;Create Empty命令），场景中的新对象仅包含一个Transform组件。相应地，即使GameObject非空，但依然包含了空GameObject对象的组件，Transform组件用于维护其在场景中的物理位置。 当然，GameObject可包含多个组件，对象的行为源自组件间的组合和交互结果。另外，用户还可通过Component菜单向对象添加更多的预置组件。通过将脚本拖曳至对象上，还可添加自定义组件。 因此，GameObject由组件构成。在较高层次上，场景则由单一场景空间内的GameObject集合构成。进一步讲，对象自身彼此间存在着较为重要的关系，并通过层次结构加以定义。同时，对象还可能为其他对象的子对象，反之则称作父对象（即transform.parent）。对于对象的运动和转换方式，这一关系十分重要。简而言之，对象Transform组件的对应值向下级联，并添加至其子对象的转换中。通过该方式，子GameObject相对于其父对象偏移和转换；而父对象位置则表示为子对象位置的原点。然而，如果某一对象未包含父对象，则会相对于世界原点(0, 0, 0)进行转换。 组件间的交互方式如前所述，GameObject表示为组件的集合，关于组件间的交互和通信方式，需要考察其中的组织方式。其中，各个组件可高效地定义为自包含的脚本文件，且独立于其他组件，并与其他组件进行交互。特别地，用户常会访问变量，并在同一GameObject上调用其他组件中的函数，甚至会在每一帧中执行此类操作。本节将讨论这一类交互组件间的通信方式。 一个对象绑定了10个CS文件。这10个文件间如何相互调用彼此的变量和方法？ SendMessage和BroadcastMessage一种调用其他组件函数的方法是使用SendMessage和BroadcastMessage，此类函数通常与类型无关。特别地，这一类方法可在脚本中的任意处调用，并通过与同一对象绑定的、其他组件中的名称调用相关方法，且无须考察具体的类型。也就是说，这一类函数并不关注组件的类型，因而便于使用。然而，该方案的问题也较为明显。 缺点： 首先，用户可能会通过其他组件上的名称调用某一函数，抑或根本不会采用这一方法。由于消息发送至全部组件中，因而用户无法对目标组件进行选取（SendMessage:Calls the method named methodName on every MonoBehaviour in this game object）。其次，SendMessage和BroadeastMessage方法在内部依赖于反射机制，因而频繁使用常会导致性能问题，例如在Update事件中调用此类函数，或者OnGUI事件（这将使情况变得更为糟糕）。因此，在实际操作过程中，应寻找相应的替代方案。 GetComponent函数如果用户需要直接访问某一对象上的特定单一组件，且已知其数据类型，则可尝试使用GetComponent函数，如示例代码所示。该函数可访问与GameObject绑定的、首个匹配类型的组件。一旦获取其引用，则可像常规对象那样访问该组件，设置、获取其public变量，并调用其中的相关方法。 12345678910111213141516171819202122using UnityEngine;using System.Collections; public class MyCustomComponent : MonoBehaviour &#123; // Reference to transform of object private Transform ThisTransform = null; void Start() &#123; // Get cached reference to transform ThisTransform = GetComponent&lt;Transform&gt;(); &#125; void Update() &#123; if (ThisTransform != null ) &#123; ThisTransform.localPosition += Time.deltaTime * 10.0f * ThisTransform.forward; &#125; &#125;&#125; 第7行和第12行代码：变量ThisTransform声明为private类型，该变量将赋予与GameObject绑定的、指向Transform组件的引用。该操作将通过函数GetComponent并在Start事件中完成。当访问Transform组件时，还需进一步使用到派生的转换属性，例如“ThisTransform=transform;”。 第20行代码：ThisTransform变量直接用于设置GameObject的localPosition。再次强调，对于Transform组件，还可采用transform.localPosition。然而，该方法（transform）将从内部调用额外的函数（属性其实就是一个方法）：成员transform定义为C#属性而非标准变量（如果是变量就直接返回了）。因此，在Start或Awake事件内采用GetComponet函数（获取指向private类变量（即第7行）的组件引用）通常被认为是访问外部组件的一种高效方法，当组件频繁被访问时尤其如此，例如Update函数。 Transform组件定义了两个主要的位置成员，即position和localPosition，并以特定方式调整对象的位置。相对于世界原点，位置成员一般定义了对象在世界空间内的位置。因此，在脚本中设置该变量并不会与实际数字对应（位于Object Inspector中的Transform组件）。若对象表示为另一个对象的子对象，且后者并未位于世界原点处，则Unity将相对于父对象偏移对象的局部位置,进而将其设置于世界空间中。相比较而言，localPosition成员则直接对应于Object Inspector中Transform组件的位置值。特别地，对象位置表示为相对于父对象位置的偏移值；如果该对象不包含父对象，则表示相对于世界原点的偏移量。此时，成员position和localPosition彼此相等。 获取多个组件有些情况下，用户需要获取列表中的多个组件，即全部组件列表或者仅与特定类型匹配的列表，用户可通过GetComponents函数实现这一操作，如示例代码所示。用户可在单次事件中调用该函数，例如Start和Awake事件，而非Update事件。 12345678910111213141516171819using UnityEngine;using System.Collections;public class MyCustomComponent : MonoBehaviour &#123; // Reference to all components as array private Component[] AllComponents = null; // Use this for initialization void Start() &#123; // Gets a list of all components attacted to this object AllComponents = GetComponents&lt;Component&gt;(); foreach(Component C in AllComponents) &#123; Debug.Log(C.ToString()); &#125; &#125;&#125; 关于GetComponent和GetComponents函数，Unity提供了相应的变化版本，并使用了对象间的通信机制，而非仅是同一对象中不同组件间的通信。这一类函数包括GetComponentsInChildren（获取子对象中全部组件的累计列表），以及GetComponentsInParent（获取父对象的全部组件）。 组件和消息GetComponent函数族工作良好，可满足组件间通信的大多数要求，若使用得当，则优于SendMessage或BroadcastMessage方法。尽管如此，当给定GameObject后，基于SendMessage调用某一方法时依然十分有效，用户无须事先了解组件的类型。 123456789101112131415using UnityEngine;using System.Collections; public class MyCustomComponent : MonoBehaviour&#123; // Reference to component on which function must be called public MonoBehaviour Handler = null; //Use this for initialization void Start() &#123; //Call function immediately Handler.Invoke("OnSave", 0.0f); &#125;&#125; 第7行代码：对应类中包含了public引用变量Handler。通过该字段，用户可通过Object Inspector将任意组件拖曳至Handler字段中，并以此表示消息发送的组件。需要注意的是，该类表示为MonoBehaviour类型或者继承自MonoBehaviour。这也意味着，用户无须事先了解具体的对象类型。 第14行代码：MonoBehaviour的Invoke方法被调用，进而运行名称匹配的对应方法。其中，第二个浮点参数定义了时间值（以秒计），此后，相关函数将被调用。相应地，0表示为即时调用。 GameObject和场景世界Unity中的另一项重要任务则是根据脚本搜索场景中的对象，尤其是运行期内实例化的对象，例如玩家对象。场景中的全部敌方对象，这对于相关操作十分重要，其中包括生成敌方角色、拾取能量棒、重定位玩家，以及检测对象间的碰撞。为了获取特定GameObject的引用，Unity提供了一系列与GameObject类相关的函数集。尽管有效，但函数开销较大，因而建议在单次事件中进行调用，例如Start和Awake函数。下面讨论与获取对象协同工作的其他技术和方法。 获取GameObject获取场景中的某一对象可通过GameObject.Find或GameObject.FindObjectWithTag函数实现。其中，出于性能考虑，这里建议使用GameObject.FindObjectWithTag函数。下面首先考察GameObject.Find函数。该函数利用匹配名称搜索首次出现的对象所处的场景。此处，搜索名称应与Hierarchy面板中所呈现的名称匹配。对此，函数执行字符串比较操作并以此确定匹配结果，因而其执行速度较慢且相对烦琐。另外，该函数仅对包含唯一名称的对象有效，而某些时候，情况并非如此。尽管如此，若函数包含了适当的名称，GameObject.Find函数依然十分有效，如下所示。 12//Find Object with the name of playerObjPlayer = Gameobject.Find("Player"); 关于GameObject，读者可能会注意到Find函数定义为静态函数，因而无须执行GameObject的实例化操作以调用该函数。用户可通过GameObject.Find在源文件中实现随意调用。本章稍后将对静态和全局作用域予以介绍。 GameObject.Find函数的执行速度较慢。对此，应在单次事件中使用该函数，例如Awake和Start事件。 依据标签进行搜索可视为一种相对高效的方法。场景中的各个对象均包含一个标签成员，默认条件下设置为Untagged。该成员定义为唯一的标识符，用以标记独立对象或多个对象（整体形成一个集合）。总体而言，当采用标签搜索对象时，首先需要将标签显式地赋予某一对象中。用户可在脚本中利用GameObject.tag这一public成员实现这一行为。然而，通常情况下，用户多会使用Unity Editor，即单击Object Inspector中的Tag下拉菜单并选取一个标签。除此之外，用户还可选择Add Tag选项，进而创建新的自定义标签。其中，通用标签包括Player、Enemy、Weapon、Bonus、Prop、Environment、Light、Sound以及GameController等内容。 当对一个或多个对象赋予了相应的标签后，用户可在代码中通过标签高效地搜索对象。对于包含匹配标签的对象，GameObject.FindGameObjectWithTag函数将搜索相应的场景，并返回首个对象（返回一个对象数组），如示例代码所示。需要注意的是，虽然GameObject.FindGameObjectWithTag函数使用字符串参数，但Unity在内部将该字符串转换为数值形式，进而提升标签的比较速度。 1234567891011121314151617using UnityEngine;using System.Collections; public class ObjectFinder : MonoBehaviour&#123; // Tag name of objects to find public string TagName = "Enemy"; // Array of found objects matching tag public Gameobject[] FoundObjects; //Use this for initialization void Start() &#123; // Find objects of matching tag FoundObjects = Gameobject.FindGameObjectsWithTag(TagName); &#125;&#125; 某些时候，用户可能将多个标签赋予单一对象。然而， Unity目前尚不支持此项功能。当然，用户可绕开这一限定条件，将空游戏对象作为主对象的父对象，并将所需的标签赋予各个子对象中。当按照标签搜索对象时，应注意获取指向父对象的索引，即所需的实际对象。 对象比较当针对特定对象搜索场景时，GameObject搜索函数较为有效，但在一些场合下，用户需要对已获取的两个对象进行比较。一般情况下，该操作涉及两个对象间的名称和标签的比较。对此，可通过CompareTag函数实现这一功能，如下所示。 12// Compares tag of this object with another Obj_Yboo bMatch = gameObject.CompareTag(Obj_Y.tag); 除此之外，用户还需要比较两个对象的相等性，进而确定是否为同一对象，而非简单地判断二者是否具有同一标签。当对决策行为进行编码时，该操作十分重要。例如，在战斗过程中，当判断敌方角色是否投入战斗抑或逃离时，可进一步确定其附近是否存在其他作战单位，并对该角色予以支援。如前所述，用户可通过标签搜索获取场景中的全部敌方对象。对应结果中包含了执行呼救且制订决策的当前角色，因而应将其排除在外。示例代码展示了GetInstanceID的应用方法，如下所示。 123456789// Find objects of matching tagFoundObjects = GameObject.FindGameObjectsWithTag(TagName);// Search through all objects and exclude ourselvesforeach(GameObject O in FoundObjects)&#123; // If two objects are the same if (O.GetInstanceID() == gameObiect.GetInstanceID()) continue; // Skip this iteration // [...] Do stuff here&#125; 获取最近对象当给定GameObject数组后（可能返回自搜索结果），如何获取场景中线性距离最近的对象？对此，示例代码显示了此类对象的获取方式，其中，使用了Vector3.Distance函数计算场景中两点间的最短距离（以米计）。 1234567891011121314151617181920212223242526// Returns the nearest game objectGameObject GetNearestGameObject(GameObject Source, GameObject[] DestObjects)&#123; //Assign first object GameObject Nearest = DestObjects[0]; //Shortest distance float ShortestDistance = Vector3.Distance(Source.transform.position, DestObjects[0].transform.position); // Loop through all objects foreach(GameObject Obj in DestObjects) &#123; // Calculate distance float Distance = Vector3.Distance(Source.transform.position, Obj.transform.position); // If this is shortest, then update if (Distance &lt; ShortestDistance) &#123; //Is shortest, now update Nearest = Obj; ShortestDistance = Distance; &#125; &#125; // Return nearest return Nearest;&#125; 获取特定类型的对象有时，用户需要使用到场景中特定类型组件的列表，而并不关心所绑定的游戏对象。这一类组件包括敌方角色、所有可收集的对象、转换组件、碰撞器等。基于脚本的实现过程虽然简单但开销较大，如示例代码所示。特别地，通过调用Object.FindObjectsOfType函数，用户可获得特定场景对象实例的完整列表，除非对象处于禁用状态。考虑到该方法的计算开销，应避免在帧事件中对其加以调用；相反，该方法仅可在Start和Awake这一类非频发函数中加以使用，如下所示。 12345void Start()&#123; //Get a list of all colliders in the scene Collider[] Cols = Object.FindObjectsOfType&lt;Collider&gt;();&#125; GameObject之间的路径当给定两个场景中的GameObject后，例如玩家和敌方角色，通常会测试二者间的路径。也就是说，测试是否存在一个碰撞器，并与两个对象间的虚拟直线相交，如下图所示。这在视见系统中十分有用，同时也用于对象剔除机制中，并以此实现相应的AI功能。 对此，存在多种方法可实现上述行为，方法之一是使用Physics.LineCast函数，如示例代码所示。 1234567891011121314151617181920212223242526272829using UnityEngine;using System.Collections;//sample class to determine if a clear line or path exists between two objectspublic class ObjectPath : MonoBehaviour &#123; //Reference to sample enemy object public GameObject Enemy = null; //Layer mask to limit line detection public LayerMask LM; //---------------------------------------------------- // Update is called once per frame void Update() &#123; //Check if clear path between objects if(!Physics.Linecast(transform.position, Enemy.transform.position, LM)) &#123; //There is clear path Debug.Log("Path clear"); &#125; &#125; //---------------------------------------------------- //Show helper debug line in viewport void OnDrawGizmos() &#123; Gizmos.DrawLine(transform.position, Enemy.transform.position); &#125; //----------------------------------------------------&#125; 第07行代码：示例类与Player绑定；否则，另一个源对象将接收一个public成员变量Enemy，并对其进行路径测试。 第10行代码：LayerMask变量定义了一个位掩码，以此表示碰撞测试所用的场景层。 第16行代码：Physics.Linecast函数用于确定两个场景对象间是否存在一条连续路径。需要注意的是，如果两个对象均包含碰撞器，例如BoxColliders，则会在碰撞检测过程中对其加以使用。换而言之，对象自身的碰撞器可对LineCast调用产生影响。因此，可使用LayerMask变量包含或排除特定层。 访问对象的层次结构Unity中的Hierarchy面板提供了父子关系的可视化视图，并应用于场景中的全部GameObject中。由于子对象继承了其父对象的转换，因而该关系十分重要。尽管如此，在编辑器中定义并编辑层次结构关系还远远不够，通常还需要在代码中构建对象间的父子关系，遍历特定对象的子节点，进而处理数据或调用其中的功能项。下面首先考察父对象，示例代码显示了如何通过Transform组件将对象X绑定至对象Y上（作为子对象）。 123456789101112131415161718192021using UnityEngine;using System.Collections;public class Parenter : MonoBehaviour &#123; // Reference to child object in scene private GameObject Child; // Reference to parent object in scene private GameObject Parent; // Use this for initialization void Start() &#123; // Get parent and child objects Child = GameObject.Find("Child"); Parent = GameObject.Find("Parent"); // Now parent them Child.transform.parent = Parent.transform; &#125;&#125; 下面讨论如何遍历与父对象绑定的全部子对象。再次强调，该过程通过Transform组件实现，如示例代码所示。 12345678910111213141516using UnityEngine;using System.Collections;public class CycleChildren : MonoBehaviour &#123; // Use this for initialization void Start() &#123; // Cycle though children of this object for(int i=0; i &lt; transform.childCount; i++) &#123; // Print name of child to console Debug.Log(transform.GetChild(i).name); &#125; &#125;&#125; 场景、时间和更新操作Unity中的场景体现了同一3D空间内的有限GameObjet集，并共享同一时间帧。由于动画通常意味着一段时间内的变化效果，因而游戏中需要建立统一的时间概念，进而实现同步动画和变化效果。在Unity中，Time类用于读取时间数据并负责在脚本中的传递操作。因此，对于游戏中可预测的、一致的运动行为，与该类协同工作则是一项十分重要的技能。 游戏中均体现了一定的帧速率，且定义为每秒的帧数（FPS），并可在Game选项卡的Stats面板中进行查看。FPS表示1秒内游戏代码的循环次数，并依据相机将相关内容绘制至屏幕上。其中，每次循环过程称作一帧，帧速率随时间以及不同的计算机设备动态变化，并会受到计算机功耗、运行中的其他处理操作，以及当前帧中的渲染内容等因素的影响。也就是说，随着时间的推移以及设备间的变化，用户难以获取一致的FPS。 关于帧这一概念的近似描述，Unity提供了MonoBehaviour类可实现的3个类事件，并执行随时间连续更新、变化的各项功能。 Update：针对场景中处于活动状态的各个GameObjet，Update事件将对其上的活动组件逐帧调用一次。如果对象通过MonoBehaviour.SetActive方法被禁用，则Update事件将不再被该对象调用，直至其再次处于激活状态。简而言之，Update最大程度上准确地描述了Unity中的帧这一概念，因此，对于一段时间内需更新或监视的重复性行为，这一概念十分有用，例如玩家输入事件、键盘事件以及鼠标单击事件。需要注意的是，对于各帧，此处无法保证Update事件在全部组件间的调用顺序。例如，在某一帧内，用户无法保证对象X上的Update函数是否先于对象Y被调用。 FixedUpdate：类似于Update事件，该事件通常在每帧内被调用多次，但调用模式具有一定的规律，即各次调用间采用了固定的时间间隔。FixedUpdate事件最为常见的应用则是与Unity物理内容协同工作。随着时间变化，如果用户希望更新速度或Rigidbody组件上的属性，则可使用FixedUpdate事件而非Update。 LateUpdate：类似于Update，该事件在每帧内被调用。然而，LateUpdate通常在Update和FixedUpdate之后被调用，这也表明，当调用LateUpdate时，可确保针对当前帧中的各个对象，Update和FixedUpdate已被调用完毕。因此，LateUpdate常用于更新相机运动，特别是第三人称相机，以使相机可于当前帧内的最新位置尾随对象。 当创建随时间变化的运动行为时，Update，FixedUpdate和LateUpdate的细节内容，以及时间和FPS等概念，对于游戏的编码方式有着重要的指导意义。 规则1–帧的重要性帧通常在每秒内出现多次，否则，游戏将处于不连续状态。在各帧内，Update事件将对场景中各个活动的MonoBehaviour调用一次。在很大程度上，各帧中场景的计算复杂度（以及性能）主要取决于Update事件中的内容。随着功能的增加，其处理时间和负载也将随之增长，对于CPU或GPU皆是如此。对于包含大量对象和组件的场景，如果在Update函数中对代码缺乏有效的规划，并有效地降低载荷量，将极易产生失控状态。因此，应对Update事件以及规则调用的帧事件加以精心设计。简而言之，仅在必要时，例如读取玩家输入或查看鼠标的运动行为，方可将对应代码置于其中。对此，事件驱动编程可有效地降低Update函数中的负载量。 规则2–相对于时间的运动鉴于帧频率无法得到有效保证（帧速率随着时间和不同的计算机设备发生变化），因而需要对运动和变化行为的代码予以精心设计，进而提供一致的游戏体验。下面考察场景中的立方体对象在一段时间内的平滑运动行为。示例代码显示了一种运动行为的构建方法（并非是最佳方案）。 123456789101112131415using UnityEngine;using System.Collections;public class Mover : MonoBehaviour &#123; // Amount to move cube per frame public float Speed = 1.0f; // Update is called once per frame void Update() &#123; // Move cube along x axis transform.localPosition += new Vector3(AmountToMove, 0, 0); &#125;&#125; 上述代码在一定范围内有效，并在各帧或者通过AmountToMove变量移动绑定对象，其问题在于，对应行为与帧速率相关。当前，鉴于帧随时间和计算机设备的不同而发生变化，因而各用户将得到不同的体验结果。特别地，立方体对象将以不同的速度运动。由于无法预测游戏针对特定用户的运行方式，因而情况变得不容乐观。对此，可将运动行为映射至时间上，而非帧。帧处于变化状态，但时间始终保持一致。因此，这里可使用Time类中的deltaTime变量，参见示例代码，即上面代码的修正版本。 123456789101112131415using UnityEngine;using System.Collections;public class Mover : MonoBehaviour &#123; //Speed of cube public float Speed = 1.0f; // Update is called once per frame void Update() &#123; //Move cube along forward direction by speed transform.localPosition += transform.forward * Speed * Time.deltaTime; &#125;&#125; deltaTime定义为浮点值，表示为自上一次Update函数调用后的时间量（以秒计）。例如，0.5表示自上一帧起时间经历了0.5秒。考虑到deltaTime可用于乘数，因而该值十分有用。在各帧中，当deltaTime与速度相乘时，即可知晓对象的运动距离，即距离=速度x时间。因此，针对对象的运动行为，deltaTime与帧速率无关。 永久对象默认状态下，Unity假设各个对象处于自闭合的时间和场景空间内。场景间的差别类似于各个独立的天体间的差别。最终结果可描述为，对象无法在所属的场景之外存在；同时，当活动场景变化时，对象也将不复存在。由于场景间彼此不同且相互独立，因而这体现了对象的一般行为方式。即使如此，某些对象依然需要被保留，并会在不同场景间被载入，例如玩家角色、积分榜系统或者GameManager类。这一类高优先级对象，其存在不应受到特定场景的限制，并可跨越多个场景。通过DontDestroyOnLoad函数，用户可生成持久性对象，其中包含了某些较为重要的结果。 1234567891011121314using UnityEngine;using System.Collections;// This object will survive scene changespublic class PersistentObj : MonoBehaviour &#123; // Use this for initialization void Start() &#123; // Make this object survive DontDestroyOnLoad(gameObject); &#125;&#125; 场景间的对象持久性十分重要，对象将持有这一特性并在不同场景间运动。这也意味着，子对象中也继承了这一类持久性对象，及其所采用的数据和资源，例如网格、纹理以及声音等。据此，持久性对象可采用轻量级方式构建，例如不包含子对象的空游戏对象，其中仅涉及了可保证正常工作的基本组件，以使场景变化过程中仅保留某些必要、重要的数据。 当改变Unity中的活动场景时，可使用SceneManager.LoadScene函数或SceneManager.LoadSceneAsync。 如前所述，DontDestroyOnLoad函数在活动场景中现有对象上被调用，并防止场景变化时对象被销毁。此时，将会产生与对象复制相关的问题。特别地，如果随后重新载入或者返回至持久对象所处的原场景时，将产生对象的持久特性复制。也就是说，源自上一个场景的原持久性特征，以及针对新创建场景实例的最新对象实例。当然，当每次重新进入场景时，问题还会被再次放大–每次均会产生新的复制，这并非是期望结果。通常情况下，用户仅需要一个对象实例：一名玩家、一个游戏管理器以及一个积分榜。对此，用户需要创建单例对象。 理解单例模式某些类的实例化方式与其他类有所不同，大多数类针对属性集和行为定义了模板，并可在场景中多次实例化为GameObject。例如，敌方角色类可用于实例化多个对象；能量棒类可创建多个对象，等等。然而，某些类则需要作为单一实体存在，例如GameManager、HighScoreManager、AudioManager以及SaveGameManager，并包含统一的行为集合。简单地讲，任何时候只可包含一个类实例。否则，这将混淆对象的含义，并使其有效性大打折扣。此类对象称作单例对象，通常作为持久对象存在于各场景中。单例的核心内容可描述为，任意时刻内存中仅包含一个类实例。下面将在GameManager类中创建单例对象。 在实际操作过程中，各游戏均包含GameManager或GameController类，且均为持久性单例对象。实际上，GameManager负责处理游戏中的全部高层功能项。例如，游戏是否处于暂停状态，是否满足胜利条件，以及任意时刻的决策方式。示例代码显示了GameManager类的部分内容。 123456789101112131415161718192021using UnityEngine;using System.Collections;// Sample Game Manager classpublic class GameManager : MonoBehaviour &#123; // High score public int HighScore = 0; // Is game paused public bool IsPaused = false; // Is player input allowed public bool InputAllowed = true; void Start() &#123; // Make game manager persistent DontDestroyOnLoad(gameObject); &#125;&#125; 此类对象在场景中持久存在，但如何依此创建单例对象？示例代码实现了这一功能，如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using UnityEngine;using System.Collections;// Sample Game Manager class - Singleton Objectpublic class GameManager : MonoBehaviour &#123; // C# Property to get access to singleton instance // Read only - only has get accessor public static GameManager Instance &#123; // return reference to private instance get &#123; return instance; &#125; &#125; private static GameManager instance = null; // High score public int HighScore = 0; // Is game paused public bool IsPaused = false; // Is player input allowed public bool InputAllowed = true; // Use this for initialization void Awake() &#123; // Check if any existing instance of the class exists in the scene // If so, then destroy this instance if(instance) &#123; DestroyImmediate(gameObject); return; &#125; // Make this active and only instance instance = this; // Make game manager persistent DontDestroyOnLoad(gameObject); &#125;&#125; 第9-18行代码：private成员被添加至Manager类中，并被声明为static。如果存在多个实例，该变量将在全部实例间被共享。当创建新实例后，可确定内存中是否存在现有的实例。另外，该变量还可通过Instance属性予以访问，且仅包含一个get成员并以此体现其只读特征。 第34-41行代码：在Awake事件中（在对象创建时被调用），将对实例变量进行检测，以查看内存中是否已存在现有的类实例。若存在，由于只可存在唯一的类实例，因而需要删除当前对象。这也表明，GameManager在场景变化过程中依然保持了持久性，且场景中仅包含唯一的原对象实例。 在示例代码中，GameManager类使用了Awake函数，而非Start函数。 Start和Awake函数之间的差别在于：Awake函数通常在Start函数之前被调用。Awake函数一般在对象创建时被调用。Start函数则在首帧被调用，其中，GameObject处于激活状态。如果GameObject某个场景下处于禁用状态，则Start函数不会被调用，直至该对象处于活动状态。对于默认条件下处于活动状态的对象，Start函数在场景开始处被调用，且位于Awake事件之后。 如果用户需要将组件引用缓存至类的局部变量中，例如ThisTransform中的Transform组件，则需要使用Awake事件而非Start事件。在Start事件中，可假设对象的全部引用均已处于有效状态。 GameManager的全局静态Instance属性的最大优势在于，可直接访问任何脚本文件，且无须使用到任何局部变量或对象引用。这意味着，各个类可直接访问全部GameManager属性，并调用较高层次的游戏功能。例如，可通过不同的类设置GameManager上的游戏积分变量，如示例代码所示。 123456789101112using UnityEngine;using System.Collections;public class ScoreSetter : MonoBehaviour &#123; // Use this for initialization void Start() &#123; //Set score on GameManager GameManager.Instance.HighScore = 100; &#125;&#125; 本章小结本章讨论了GameObject、场景、组件及其在场景中的应用方式。初看之下，此类问题较为简单，但理解其应用方法并对对象进行管理则颇具技巧，这一类技术常出现于Unity的游戏开发项目中。特别地，本章着重阐述了GameObject，即以交互方式生成同一行为的组件集。同时，Transform组件同样十分重要。除此之外，本章还介绍了场景内容，即GameObject所处的独立时间和空间。一般情况下，场景表示为一个自封闭的实体，并防止对象位于其外部空间。进一步讲，各场景均涉及时间概念，并以此生成变化和动画效果。其中，时间可采用deltaTime变量进行测算，并可表示为一个乘数因子，以实现与帧速率无关的运动行为。最后，本章还探讨了单例设计模式，通过静态成员定义类–在实际操作过程中，任意时刻内存中仅可包含一个活动实例。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity脚本设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人工智能]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%2F</url>
    <content type="text"><![CDATA[本文构建一个包含智能型敌方角色的迷宫场景。这一类角色能够搜索、追逐玩家，或者在查询到生命值恢复位置后即刻逃遁。会涉及某些AI概念，例如有限状态机（FSM）、导航网格、视线等内容。 游戏中的人工智能本文主要讨论迷宫环境中第一人称游戏的构建过程，其中，玩家可攻击敌方角色，而敌人也可进行反击。这里，敌方角色网格基于Unity中的动画构造角色，其中包含了行走、跑动以及跳跃动画。该构造角色可搜索环境、寻找玩家，并在适当时候进行追逐或发动攻击。在其受到攻击时，此类角色可逃离现场，并在生命值较小的情况下搜索能量棒。 开始项目首先，需要创建包含新场景的Unity空白项目，然后导入多个Unity资源包，即从Asset中选择Import Package命令，如图7-3所示。该资源包包含了Character Controller、Skyboxes以及Particles等内容。其中，Character Controller涵盖了构造网格和动画，以及第一人称控制器预制组件。 Skyboxes资源包添加了相机可查看到的天空背景，而Particles资源包则用于创建瞬移设备。 除此之外，向场景中添加第一人称控制器以及迷宫网格（该网格位于本章assets文件夹中的资源文件内），并创建光照效果以及光照贴图均会增加游戏的真实感。对应网格采用Blender这一类3D建模程序加以创建。就自身而言，上述资源数据并非是AI的核心内容，但却可生成一类具体的灰盒测试环境。 烘焙导航网格创建完毕的敌方角色需要以某种智能方式在关卡中行走，进而可搜寻和追逐玩家，或者寻找能量棒。具体而言，由于行进途中可能存在障碍物，例如墙壁或其他游戏角色，因而AI角色不可以简单的直线形式在路点间行进。相反，AI角色应避开这一类障碍物。对此，可采用导航网格。导航网格是Unity自动生成的不可见网格数据，并近似模拟关卡中可行走的水平平面。也就是说，此类表面通常可视为地面。导航网格可定义为一种数学模型，并包含了全部所需数据，以使AI角色计算、获取某一条路径，并在必要时避开障碍物的阻拦。当生成关卡的导航网格时，可从应用菜单的Window中选择Navigation命令，这将显示Navigation Mesh选项卡，并停驻于Object Inspector中。 关于导航网格的烘焙操作,读者应留意某些细节内容,如图7-5所示。 首先，需要调整Radius项的默认值。简而言之，该项定义了围绕角色脚部的、虚构的圆形，该圆形表示为行走主体对象的近似尺寸。如果半径值过大，导航网格将会处于断裂状态；若该值过小，则网格的生成时间会过长，另外，主体对象在行进过程中可能会穿越墙壁，因此，用户需要对该值反复设置，进而获得最佳效果。针对当前示例，建议使用0.2，如前所述，如果半径值过大，导航网格在狭窄区域将会断裂，进而导致主体对象无法穿越这一缝隙，如图7-6所示。 其次,生成后的导航网格可能会凸起(相对于网格地面) ,对此,可在Advanced分组中将Height Inaccuracy %降至1,如图7-7所示,可防止角色悬停于半空中。需要注意的是,待上述设置项调整完毕后,需要重新烘焙导航网格,以使变化内容生效。 迷宫场景包含了两个独立的区域(左、右区域) ,二者间不存在相应的连接路径。对此,智能主体对象可通过瞬移方式在两部分间自由穿行。 当在导航网格中构建连接,以使AI角色在表面间获取有效路径时,可使用分离网格链接。相应地,可向关卡中添加新的网格,当角色停驻于其上时,可以此作为瞬移设备。在当前示例中,可采用包含粒子系统的标准盒体网格,但这并非必需。随后,可将分离网格组件绑定至网格对象上,如图7-8所示。 对于目标瞬移设备,可重复上述操作。针对各个瞬移设备,可将对象转换赋予分离网格组件的Start设置项中,即所选的瞬移设备作为起始点。随后,在End设置项中,可将目标转换赋予其中。这将在两个瞬移设备间构建连接,并在二者间生成路径。待连接构建完毕后,当打开Navigation面板并在编辑器中处于激活状态时,可看到场景间绘制的连接箭头,如图7-9所示。除此之外,用户还可自动生成分离网格链接。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity脚本设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建一个让你置身3D空间的演示-1]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AE%A9%E4%BD%A0%E7%BD%AE%E8%BA%AB3D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%BC%94%E7%A4%BA-1%2F</url>
    <content type="text"><![CDATA[本章涵盖 了解3D坐标空间 在场景中放置一个玩家 编写移动对象的脚本 实现FPS控件 了解3D坐标空间不仅能写代码使用这些三个数字的坐标定位对象，也能使用它们定义沿着每个轴移动的距离。 开始项目：在场景中放置对象地板、外墙和内墙所有的墙都是一个空对象的子节点。因此Hierarchy列表看起来比较有组织性。 在连接任何子对象到父对象上之前，需要把空的根对象节点放到（0， 0， 0）的位置，这样可以避免以后出现坐标奇怪的现象。 所有场景对象都是类GameObject的实例，这和所有脚本组件从类MonoBehaviour继承很像。 灯光和摄像机通常，在3D场景中使用一个方向光点亮场景，然后再用一系列的点光点亮场景。 ** 光的类型 ** 你能创建一些类型的光源，这决定了它们如何并且往哪里投射光线。三种主要的光是点光、聚光和方向光。 点光是一种从一点向所有方向射出光线的光源，就像真实世界中的灯泡。越靠近光源则越亮，因为光线在靠近光源的地方比较集中。 聚光是一种从一点向一个有限的锥形发射光线的光源，这种灯通常用于关卡中的高亮部分。 方向光是一种所有光线都平行和均匀的光源，场景中所有对象都以相同的方式被照亮。这就像真实世界中的太阳。 方向光的位置不会影响它发射的光，只有光源面向的方向才会影响。把它放置到高过房间，这样它比较直观，看起来像太阳，而且在你操作场景其他东西时它不会遮挡你。可以在Inspectort中看到Intensity设置。这个设置控制灯光的亮度。如果这个是唯一的灯光，我们会让它更亮，但因为你会增加一些其他点光，所以这个方向光可以暗一点，如设置Intensity为0.6。 可以创建几个点光，并在房间的暗处放置它们，以确保所有墙都被照亮。不需要增加太多灯光（当游戏有很多灯光时性能将会降低），但每个角落都有一个灯光是比较合适的（建议把它们升到墙的顶部），增加一个灯光在场景的高度（例如Y轴改为18），让房间有一些灯光的变化。注意点光的Inspector增加了对Range（范围）的设置。这控制了灯光能到达的距离；鉴于方向光发射的光线能到达整个场景，而点光却是当一个对象越靠近它越亮，因此为了让在高处的点光能照到整个场景，该点光的范围应该大约在40。 Camera将大致定位在玩家顶部以便进入玩家的视野。 玩家的碰撞器和视口创建Capsule代表玩家。设定这个对象的Y轴为1.1（对象高度的一半，增加一点高度可以避免和地板重叠）。命名这个对象为Player。 移除Capsule Collider，Collider（碰撞器）是包围对象的绿色网格，所以当删除Capsule Collider时将看到绿色网格消失。 我们将给这个对象赋予一个Character Controller，从而替代Capsule Collider。顾名思义，这个组件将允许对象表现得像一个角色。 将Camera对象拖动到玩家胶囊上，以将摄像机附加到玩家身上。现在定位摄像机，让它看起来像是玩家的眼睛（建议位置是0, 0.5, 0）。 如果需要，重置摄像机的rotation为(0, 0, 0)（如果你旋转过胶囊体，重置前摄像机的rotation将不会是(0,0,0)）。 让东西移动：应用变换的脚本旋转一个对象意味着改变它的rotation。 图示说明如何通过编程实现旋转让一个对象实现动画（例如让它旋转）归结于随着帧反复播放，每帧让它动一点。由于应用变换是即时的，因此这明显和随着时间运动完全相反。通过一次次应用变换，让对象看起来像是在运动，就像一系列序列帧图像。 脚本组件有Update()方法，它会在每帧运行，为了旋转立方体。在Update()中添加代码，每次旋转一个小的角度。所添加的代码将会在每帧运行。 编写代码实现运动创建一个新的C#脚本，命名为Spin。 123456789101112using UnityEngine;using System.Collections;public class Spin : MonoBehaviour &#123; public float speed = 3.0f; // 声明一个公有变量，用于旋转速度 void Update () &#123; transform.Rotate(0, speed, 0); // 在此放置Rotate命令，以便它能在每帧运行 &#125;&#125; 单击Play按钮，会看到视角在旋转。 本地和全局坐标空间默认情况下，Rotate()方法基于本地坐标来操作。你能使用的其他类型的坐标还包括全局坐标。通过为可选的第四个参数输入Space.Self或Space.World可以告诉Rotate()方法使用本地或者全局坐标。例如: 1Rotate(0, speed, 0, Space.World); 每个单一的对象都有它自己的原点，一样有三个轴向，而且这个坐标系统会跟着对象移动。这样的坐标被称为本地坐标。 所有的3D场景也有它自己的原点和自己三个轴向，但这个坐标系统从不会移动。这样的坐标被称为全局坐标。因此，当你为Rotate()方法指定本地或全局时，是在告诉该方法应围绕哪个X，Y，Z来移动，如下图所示。 上图描绘了两种不同的轴。 首先，选择一个玩家对象，然后使他稍微倾斜（类似旋转X轴30°）。这将把本地坐标抛离地面，因此本地和全局旋转看起来是不同的。现在尝试运行Spin脚本，分别加上和不加上Space.World；如果你很难观察发生了什么，请尝试从玩家对象上移除Spin组件并旋转一个放在玩家前面的倾斜的立方体。当设置命令为本地或全局坐标时将看到对象围绕不同的轴旋转。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5实战-使用C#和Unity开发多平台游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity脚本-1]]></title>
    <url>%2F2019%2F02%2F28%2FUnity%E8%84%9A%E6%9C%AC-1%2F</url>
    <content type="text"><![CDATA[Unity的编程工作都是在脚本里编写的，脚本通过添加到游戏对象的方式运行。 MonoBehaviour所有创建的用于添加到游戏对象上的脚本都必须继承自MonoBehaviour（不添加到游戏对象上就无需继承MonoBehavior），继承自MonoBehaviour的脚本从唤醒到销毁有着完整的生命周期。 Awake()，脚本唤醒函数。当游戏对象被创建的时候，游戏对象绑定的脚本会在该帧（frame）内执行Awake()函数，无论脚本是否处于激活（enable）状态。 Start()，该函数在脚本被激活的时候执行，位于Awake()函数之后。该函数的执行同样也是在游戏对象被创建的帧里。不同的是，如果脚本处于不激活状态（MonoBehaviour.enable=false），Start()函数是不会被执行的。 Update()，只要处于激活状态下的脚本，都会在每一帧里调用Update()函数，该函数也是最为常用的一个函数，用来更新逻辑。 LateUpdate()，该函数是延迟更新函数，处于激活状态下的脚本在每一帧里都会在Update()函数执行后调用该函数，通常用来调整代码执行的顺序。比如玩家的角色需要一个摄像机来跟随，那么通常角色的移动逻辑会写在Update()里。而摄像机跟随在LateUpdate()里，这样可以确保在角色的位置计算完毕后，再根据角色位置确定摄像机的位置和视角。 FixedUpdate()，该函数用于固定更新。在游戏运行的过程中，每一帧的处理时间是不固定的，当我们需要固定间隔时间执行某些代码时，就会用到FixedUpdate()函数。在导航栏中，点击Edit-&gt;Project Settings-&gt;Time菜单项，之后在Inspector视图里出现时间管理器，其中Fixed Timestep选项用于设置FixeUpdate()的更新频率，更新频率默认是0.02秒，如下图所示。固定更新常用于移动物体等操作，因为固定更新每一帧调用的时间间隔是一样的，所以移动速度是均匀的。 OnGUI()，绘制界面函数。因为Unity使用最新的UGUI界面系统来创建页面，所以OnGUI()一般作为测试功能使用，如创建测试按钮等。 OnDestroy()，在当前脚本销毁时调用该函数，我们可以在函数里填写删除时需要处理的逻辑。 OnEnable()，激活函数，当脚本被激活时调用。 OnDisable()，当脚本被禁用时调用。 所有继承自MonoBehaviour的脚本都有一个名为enabled的bool值开关，enabled对应脚本名称左侧的勾。enabled决定生命周期的函数是否会被调用。当enabled为true时，生命周期各个阶段对应的函数将会被调用，否则不调用。当enabled变为true时脚本执行OnEnable()，当enabled变为false时脚本执行OnDisable()。 enabled只与生命周期的函数有关，与其他函数和所有变量都没有关系。如果脚本中不包含任何生命周期函数，enabled将没有任何意义，此时在Inspector窗口中，脚本名左侧将不再有勾选框，如下图所示。同理，不管是没有任何生命周期函数还是enabled为false，都不影响其他脚本调用此脚本的变量或者非生命周期函数。 设置脚本自定义图标。选中任意脚本，在Inspector窗口中点击下图所示的左上角图标，弹出设置脚本图标窗口。可以选择任意一种预制样式，或者点击“Other…”按钮选择图片作为图标。这里选择第一个灰色椭圆图标，效果如下图所示。 UnityGUI由于效率和可视化程度低等原因，一般用UnityGUI作为测试UI。 UnityGUI使用一个特殊的OnGUI()函数，在该函数中加入实现UI的脚本。 它一共有两种类型的接口：GUI.xxx()和GUILayout.xxx()。第一种需要自己手动填写处于屏幕上的位置。第二种Unity会为我们自动排版，我们只需要关心内容即可。本文所有的测试UI只用到以下3个函数。 GUILayout.Label(string str)：标签，用于显示文本。输入的参数为需要显示的文本。 GUILayout.Button(string str)：按钮，用于触发事件。输入的参数为在按钮上显示的文字。它返回一个bool值，表示是否按下了按钮。 GUILayout.TextField(string str)：文本区域，用于输入文本。输入的参数为显示的文本，返回经过用户输入改动后的文本。一般来说，用参数变量接收返回值即可。如 12string str="";str = GUILayout.TextField(str); 新建一个场景，将场景里的对象全部删除。再新建一个空的游戏对象，重命名对象为Manager。然后新建一个脚本GUIDemo.cs。 1234567891011121314151617181920212223242526using UnityEngine;using System.Collections;public class GUIDemo : MonoBehaviour &#123; string text = ""; string myName = ""; void OnGUI() &#123; // 用标签显示文本 GUILayout.Label("请输入你的名字："); // 用文本区域输入名字 text = GUILayout.TextField(text); if(GUILayout.Button("提交")) &#123; myName = text; &#125; // 当myName不为空的时候，说明我们已经提交了名字，则显示名字 if( !string.IsNullOrEmpty(myName)) &#123; GUILayout.Label("提交成功，名字：" + myName); &#125; &#125;&#125; 调试我们可以在脚本里输出调试信息，并在控制台中显示，主要是在脚本中使用以下几个接口。 Debug.Log：向控制台输出普通信息（白色）。 Debug.LogWarning：向控制台输出警告信息（黄色）。 Debug.LogError：向控制台输出错误信息（红色）。 需要注意的是，Unity本身在运行场景时会向控制台输出警告信息和错误信息，但不会输出普通信息，所以一般情况下我们输出普通信息即可。 123456789101112using UnityEngine;using System.Collections;public class LogDemo : MonoBehaviour &#123; void Start () &#123; Debug.Log ("普通信息"); Debug.LogWarning("警告信息"); Debug.LogError("错误信息"); &#125;&#125; 运行场景后，在控制台窗口中可以看到输出的信息，如下图所示。 游戏对象的操作Unity中的所有实体都属于游戏对象，比如Unity自带的立方体、球体以及场景中使用的模型等，而对游戏对象的操作以及游戏对象之间的一切交互都需要使用脚本来完成。 创建游戏对象创建游戏对象的方式有以下两种： 第一种为将导入工程后的模型放入Hierarchy视图或者Scene视图中，好处是完全可视化的操作。 第二种则是在代码里动态地创建和删除游戏对象，这种处理方式灵活性比较高。 本例在游戏视图中添加了两个按钮：“创建立方体”和“创建球体”。点击其中一个按钮，将在游戏中动态添加立方体对象或者球体对象。为了让创建的立方体对象与球体对象具有物理属性，比如质量、重力和碰撞等，我们需要为其添加刚体组件（Rigidbody）。 1234567891011121314151617181920212223242526272829303132333435using UnityEngine;using System.Collections;public class ObjDemo : MonoBehaviour&#123; void OnGUI() &#123; if (GUILayout.Button("创建立方体", GUILayout.Height(50))) &#123; // 设置该模型默认为立方体 GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube); // 为对象添加一个刚体，赋予物理属性 obj.AddComponent&lt;Rigidbody&gt;(); // 赋予对象的材质红色 obj.GetComponent&lt;Renderer&gt;().material.color = Color.red; // 设置对象的名称 obj.name = "Cube"; // 设置此模型的位置坐标 obj.transform.position = new Vector3(0, 5f, 0); &#125; if(GUILayout.Button("创建球体", GUILayout.Height(50))) &#123; // 设置该模型默认为球体 GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Sphere); // 为对象添加一个刚体，赋予物理属性 obj.AddComponent&lt;Rigidbody&gt;(); // 赋予对象的材质绿色 obj.GetComponent&lt;Renderer&gt;().material.color = Color.green; // 设置对象的名称 obj.name = "Sphere"; // 设置此模型的位置坐标 obj.transform.position = new Vector3(0, 5f, 0); &#125; &#125;&#125; 运行游戏后点击按钮，立方体或球体将被创建。物体由于被添加了刚体具有物理属性，将受到重力的作用自由落体。 GameObject.CreatePrimitive()函数：创建一个游戏对象并指定一个Unity自带的模型，如立方体、球体以及圆柱体等。 AddComponent()函数：用于给该游戏对象添加一个组件，也就是所添加的脚本必须继承自Component类。值得注意的是，有些组件是依赖于其他组件的，当添加组件时，其依赖的组件会被自动添加，例如关节HingeJoint依赖刚体Rigidbody，当添加HingeJoint时，如果游戏对象没有Rigidbody，将会自动添加Rigidbody到游戏对象上。 renderer.material.color：设置渲染材质的颜色。 transform.position：设置该游戏对象的位置，这个属性设置的是位于世界坐标系下的位置。如果需要设置物体坐标系下的位置，即相对于父节点下的位置，则用到的是transform.localPosition。 获取游戏对象在脚本中获取游戏对象的方式一共有两种： 第一种为在代码里声明对象，在Inspector属性栏里指定游戏对象； 第二种是通过对象名称获取对象。 通过指定主要是通过在代码里声明一个公开的游戏对象，然后在Inspector属性栏里指定游戏对象。这种方法获取的游戏对象一般是预制体或者是场景中已经存在的对象。 12345678using UnityEngine;using System.Collections;public class GetObjDemo : MonoBehaviour &#123; // 声明名为obj的游戏对象 public GameObject obj;&#125; 通过对象名称获取对象在代码中使用CameObject.Find(string name)即可找到对应名称的游戏对象。只需要名字即可，不需要知道游戏对象的路径信息，使用方法如代码所示。 12345678910111213using UnityEngine;using System.Collections;public class GetObjByName : MonoBehaviour &#123; private GameObject obj; void Start() &#123; // 寻找整个场景中名为Cube的游戏对象并赋予obj变量 obj = GameObject.Find("Cube"); &#125;&#125; 添加组件与修改组件新创建的游戏对象本身不具备任何属性，自然没有功能作用。为了让它具备一些功能，就必须给它添加游戏组件。常用的组件有物理类、网格类、粒子类等。 添加游戏组件时，需要使用AddComponent()方法。而删除组件的时候需要使用Object.Destroy()方法，参数为需要删除的游戏对象或游戏组件。如果删除的是某一游戏对象，对象中所有的组件都会被一并删除。 本例中，我们首先在Scene视图中创建一个空的立方体对象，然后为其添加渲染组件。运行游戏后，在Game视图中点击“添加颜色”按钮或者“添加贴图”按钮将为该立方体对象添加颜色或贴图。 12345678910111213141516171819202122232425262728293031using UnityEngine;using System.Collections;public class AddComponentDemo : MonoBehaviour &#123; public Texture texture; // 需要在Inspector指定贴图 private GameObject obj; private Renderer render; void Start() &#123; // 获取游戏对象 obj = GameObject.Find("Cube"); // 获取该对象的渲染器 render = obj.GetComponent&lt;Renderer&gt;(); &#125; void OnGUI() &#123; if (GUILayout.Button("添加颜色",GUILayout.width(100), GUILayout.Height(50))) &#123; // 修改渲染颜色为红色 render.material.color = Color.red; &#125; if(GUILayout.Button("添加贴图", GUILayout.Width(100), GUILayout.Height(50))) &#123; // 添加组件贴图 render.material.mainTexture = texture; &#125; &#125;&#125; 在上述代码中,render.material引用为当前脚本绑定对象的材质，直接为其赋值即可修改对象材质。render.material.color为材质的颜色，render.material.mainTexture为材质的主要贴图。运行效果如图所示。 发送广播与消息在游戏对象之间使用广播传递消息是游戏对象之间互动的一种快捷的方式。 主要是通过GameObject.SendMessage(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver)函数发送的。方法是向该游戏对象上的所有MonoBehaviour脚本发送消息。第一个参数是消息的名称，所有MonoBehaviour脚本里与该名称同名的方法将被调用；第二个参数是向该方法传递的参数；第三个参数是是否必须有接收方法的选项，一般选不要求接收方法即可。 新建一个场景，然后新建一个游戏对象并命名为Sender，添加脚本。新建一个游戏对象，命名为Receiver并添加脚本，最后将Sender脚本的receiver指定为Receiver对象。 12345678910111213using UnityEngine;using System.Collections;public class SendDemo : MonoBehaviour&#123; public GameObject receiver; void Start () &#123; // 向本脚本所属的游戏对象发送ShowNumber消息并传递参数100 receiver.SendMessage("ShowNumber", 100, SendMessageOptions.DontRequireReceiver); &#125;&#125; 1234567891011using UnityEngine;using System.Collections;public class ReceiveDemo : MonoBehaviour &#123; // 消息发送后，ShowNumber函数被自动调用 void ShowNumber(int number) &#123; Debug.Log("收到的数字是" + number); &#125;&#125; 运行场景，Sender成功向Receiver发送消息并输出至控制台。 克隆游戏对象克隆游戏对象与创建游戏对象不同，创建游戏对象是创建一个全新的游戏对象，需要另外添加组件来赋予功能。而克隆游戏对象通常是克隆具有一定功能的现成的对象。如果这个现成对象已经保存为文件的话，则称之为预制体。一般来说，克隆的执行效率较高。比如游戏中发射的子弹，每颗子弹对象是一样的，所以每次发射子弹直接克隆一个子弹，然后赋予新的位置速度等信息即可。在代码中，需要使用Instantiate()函数克隆游戏对象。 首先创建一个Cube立方体，然后添加Rigidbody组件。下一步，将Cube立方体从Hierarchy视图拖曳至Project视图。一个预制体就创建好了。对着预制体点击鼠标右键“Show in Explorer”，会在文件夹中显示该文件，名称是“Cube.prefab”。prefab就是Unity中所有预制体的后缀名。我们已经创建好了预制体，接着选中Scene场景视图中的Cube对象，右键“Delete”将其删除。 接着在游戏中通过代码动态克隆这个预制体，如代码所示。 123456789101112131415using UnityEngine;using System.Collections;public class CloneDemo : MonoBehaviour&#123; public GameObject prefab; void Start() &#123; // 克隆预制体 GameObject obj = Instantiate(prefab) as GameObject; // 设置游戏对象obj的位置 obj.transform.position = new Vector3(0, 3, 0); &#125;&#125; 创建一个新的空游戏对象，命名为“Manager”，添加该脚本。 添加后，在Inspector窗口里CloneDemo栏目下可以看到Prefab指定条，将之前创建好的Cube预制体拖曳上去。 运行游戏，在屏幕中间出现我们通过代码克隆出的Cube游戏对象。Cube对象因为添加了刚体而向下自由落体。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[法线贴图]]></title>
    <url>%2F2019%2F02%2F27%2F%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 法线贴图是干嘛用的？怎么使用的？ 如何使用代码动态更换贴图？使用哪个组件？如何使用？ 法线贴图（Normal mapping）在三维计算机图形学中，是凹凸贴图（Bump mapping）技术的一种应用，有时也称为“Dot3（仿立体）凹凸纹理贴图”。与纹理贴图通常是在现有的模型法线上添加扰动不同，法线贴图要完全更新法线。 与凹凸贴图类似的是，法线贴图也是用来在不增加多边形的情况下于浓淡效果中添加细节。但是凹凸贴图通常根据一个单独的灰度图像通道进行计算，而法线贴图的数据源图像通常是从更加细致版本的物体（精模）得到的多通道图像，即红、绿、蓝通道都是被作为一个单独的数据通道对待。 在Unity中使用法线贴图法线贴图的使用在如今的游戏开发中越来越频繁，这种又能节省资源又能得到良好的视觉效果的方法得到了越来越多的认可，而Unity也对法线贴图做出了支持。 (1)使用到的模型和图片如下表所示。 资源名 用途 Dinosaur.fbx 恐龙模型 GRANDEB2.jpg 恐龙的法线贴图 GRABDECO.jpg 恐龙的漫反射贴图 (2)导入上述的资源后，开始搭建场景。新建一个场景，然后将Dinosaur.fbx拖到场景中，将其位置摆放到摄像机前方，在Game视口中就可以看到恐龙的模型。 (3)下面对导入的法线图片进行设置。在Project面板中选中GRANDEB2.jpg，在Inspector面板中将其Texture勾选为“Normal map”。下面的Bumpiness滑块控制凹凸的程度，可以根据需要进行设置，设置完毕后单击Apply按钮应用设置。 (4)接下来创建材质。在Project面板中单击鼠标右键选择“Create-&gt;Material”创建两个材质，分别命名为“DDiffuse”和“DNormal”。 (5)下面为其指定对应的着色器。 DDiffuse材质的着色器为“Legacy Shaders/Diffuse”，对应的贴图为“GRABDECO.jpg”，DNormal材质的着色器为“Legacy Shaders/Bumped Diffuse”，Base对应贴图“GRABDECO.jpg”，Normalmap对应贴图“GRANDEB2.jpg”。如下图所示。 (6)准备工作做好后，接下来进行脚本的开发。脚本的主要功能是生成两个单选按钮，然后根据用户的选择切换恐龙的材质，显示使用普通漫反射贴图的恐龙或者使用法线贴图的恐龙。 UseNormalMap.cs 1234567891011121314151617181920212223242526272829303132using UnityEngine;using System.Collections;public class UseNormalMap : MonoBehaviour &#123; int selectindex = 1; // 选中按钮的索引 string[] selectstring = new string[]("法线", "默认" ); // 按钮显示的字样, public Material normalmap; // 使用法线贴图的材质 public Material diffusemap; // 使用漫反射贴图的材质 publie GameObject model; // 恐龙游戏对象 void OnGUI() &#123; int lastchange = selectindex; // 记录上次选择的结果, selectindex = GUI.SelectionGrid(new Rect(Screen.width.1/ 2- Screen.width 1/6, 0, Screen.width*1/3, Screen.height*1/ 15), selectindex, selectstring, 2);// 创建单选按钮组 if (lastchange != selectindex) &#123; //选择结果发生变化 if (selectindex = s) &#123; ChangeMaterial (normalmap); // 调用方法使用法线材质 if (selectindex) // 玩家选择显示漫反射图 ChangeMaterial (diffusemap); // 调用方法使用漫反射材质 &#125; // 玩家选择显示法线图 &#125; &#125; void ChangeMaterial(Material m) &#123; // 切换模型的材质 model.GetComponent&lt;MeshRenderer&gt;().materials = new Material[2]&#123;m, m&#125;; &#125;&#125; 第1-8行为命名空间的引用以及变量的声明。在变量声明的地方需要声明一个int类型的数字以记录用户选择的单选按钮的索引，selecstring数组用于控制单选按钮上显示的字样，然后声明3个public的变量，分别是之前创建的两个材质以及恐龙游戏对象。 第9-18行是对OnGUI方法的重写。首先记录下上次选择按钮的索引，然后绘制两个单选按钮，并记录下当前选中的按钮索引。若是和上次选择的索引不一样，就调用ChangeMateral方法按照用户的选择为模型赋上对应的材质。 第19-21行是一个自定义方法，需要传入一个Material类型的参数代表需要切换的材质。首先获取模型的MeshRenderer组件，然后更换其materials参数的材质列表即可。 (7)至此，案例的开发结束。运行效果分别如下图所示。明显可以看出，法线贴图在模型精度很低的情况下依旧可以呈现出很多凹凸的细节，这在当前游戏的开发中非常重要，使用较少面数的低模配合法线图可以搭建出非常真实的场景。需要注意的是，由于法线图改变了顶点的法线，所以产生的凹凸感还可以响应光影效果。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity游戏开发技术详解与典型案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据存储与读取]]></title>
    <url>%2F2019%2F02%2F27%2F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AF%BB%E5%8F%96%2F</url>
    <content type="text"><![CDATA[游戏中通常需要实现“保存进度”“读取进度”之类的功能，那么在开发中，就需要对数据进行存储和读取等工作。可以用PlayerPrefs实现对简单数据的处理以及用JSON实现对对象结构的数据的处理。 PlayerPrefsPlayerPrefs是Unity自带的数据结构，位于UnityEngine命名空间下。它可以对整数、浮点数、字符串3种类型的数据进行存取。它是持久存储于设备上的，例如安卓，只要用户没有删除应用或者手动去清除应用数据，PlayerPrefs的数据就会一直保留。 整数的存取一般脚本都会使用UnityEngine命名空间，所以可以在脚本里直接使用PlayerPrefs。PlayerPrefs使用“键/值”配对的规则，如下： 12int num = 10; // 定义一个整型变量numPlayerPrefs.SetInt("Number", num); // 存储该变量 第一行代码定义了一个整型变量num，第二行代码存储该变量。第一个参数Number传递了键，第二个参数num传递了这个键所要存储的值。 下面是如何读取这个整数： 1int num = PlayerPrefs.GetInt("Number"); 浮点数的存取浮点数的存取和整数类似，如下： 123float PI = 3.14f; // 定义一个浮点数PlayerPrefs.SetFloat("PI", PI); // 存储该浮点数PI = PlayerPrefs.GetFloat("PI"); // 读取该浮点数 字符串的存取字符串的存取也是一样的处理方法： 123string str = "Hello World!"; // 定义一个字符串PlayerPrefs.SetString("HW", str); // 存储该字符串str = PlayerPrefs.GetString("HW"); // 读取该字符串 其他PlayerPrefs接口PlayerPrefs还有一些其他的接口，如下所示： 12345PlayerPrefs.Save(); // 保存PlayerPrefs数据PlayerPrefs.Haskey("HW"); // 是否存在该键PlayerPrefs.DeleteKey("HW"); // 删除键PlayerPrefs.DeleteAll(); // 删除所有PlayerPrefs数据 需要注意的是，3种数据结构的键是公用的，比如有一个键“Somekey”，先用它来存整数10，再用它来存字符串“Hello”，最后读取整数。那么结果是0，因为之前存的10被覆盖了。 属性访问器get和set属性的访问器包含与获取（读取或计算）或设置（写）属性有关的可执行语句。访问器声明可以包含get或set访问器，或者两者均包含。简而言之，就是把一个变量拆成get读取部分和set写入部分，格式如下： 123456789101112private string name;public string Name&#123; get &#123; return name; &#125; set &#123; name = value; &#125;&#125; 上面代码中的get部分返回一个字符串，而set部分把value赋给name，用起来就跟普通的变量一样，例如： 12Name = "Hi";Debug.Log(Name); 任何类型的变量都可以使用属性访问器。 属性访问器与PlayerPrefs思考一下就会发现，PlayerPrefs包含读写两部分，刚好跟get和set对应。用get和set包装一下，PlayerPrefs不就可以当作普通变量使用了吗？确实是这样。两者配合后可以很方便地使用： 12345678910111213public string Name&#123; get &#123; return PlayerPrefs.GetString("Name"); &#125; set &#123; PlayerPrefs.SetString("Name", value); PlayerPrefs.Save(); &#125;&#125; 一个自动保存的变量就这么创建出来了，是不是很方便呢? JSONJSON是一种轻量级的数据交换和存储格式，可以用于对数据的设备（如手机的本地存储）和向Web服务器上传，并且符合面向对象编程的思想。JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言，易于人阅读和编写，同时也易于机器解析和生成。下面用JSON这个轻量级的数据格式来实现跨平台的存取数据功能。 JSON数据格式JSON基本数据书写格式是：名称/值，如”name”:”李四”。JSON基本结构主要有以下两种。 对象用{}包裹，用名称/值来表示对象中的一个属性，如下所示： 123456789101112131415public class Person&#123; public string name; public int age; public Person() &#123; &#125; public Person(string _name, int _age) &#123; name = _name; age = _age; &#125;&#125; 对象Person john = new Person(“John”, 19);用JSON表示就是:{“name”:”John”, “age”:”19”} 数组用[]包裹，用“,”表示并列关系，如： 1&#123;"people":[&#123;"name":"John", "age":"19"&#125;, &#123;"name":"Tom", "age":"18"&#125;]&#125; 前面我们知道对象john用JSON的表达，那么下面就来实现这个转换。这里用到了JsonFx，这是一个类对象和SON数据相互转换的动态链接库，网上有很多这样的库。在代码Person.cs中定义了Person类，在以下代码中创建了对象john，再将john转成JSON字符串，最后将JSON字符串转换回Person对象。 12345678910public class Person&#123; public string name; public int age; public Person(string _name, int _age) &#123; name = _name; age = _age; &#125;&#125; 12345678910111213141516using UnityEngine;using System.Collections;using JsonFx.Json;public class JsonDemo : MonoBehaviour &#123; void Start() &#123; Person john = new Person("John", 19); // 将对象序列化成JSON字符串 string Json_Text = JsonWriter.Serialize(john); Debug.Log(Json_Text); // 将JSON字符串反序列化成对象 john = JsonReader.Deserialize(Json_Text) as Person; &#125;&#125; 数据存储Unity及其使用的Mono是跨平台的，符合NET框架，我们完全可以使用System.IO下的File.ReadAllText()和File.WriteAllTtext()这两个函数来实现数据的存取。我们已经有了JSON字符串，下一步是得到存取的路径，如下代码所示： 123456789101112131415161718public static string GetDataPath()&#123; if (Application.platform == RuntimePlatform.IPhonePlayer) &#123; // iPhone路径 string path = Application.dataPath.Substring(0, Application.dataPath.Length - 5); path = path.Substring(0, path.LastIndexOf('/')); return path + "/Documents"; &#125; else if (Application.platform == RuntimePlatform.Android) &#123; // 安卓路径 return Application.persistentDataPath + "/"; &#125; else &#123; // 其他路径 return Application.dataPath; &#125; &#125; 最后一步，将JSON数据写到该路径： 1File.WriteAllText(GetDataPath() + '/' + "FileName", Json_Text); 至此，对数据存储功能实现的每一步都进行了讲解，数据存储功能的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using UnityEngine;using System.Collections;using JsonFx.Json;using System.IO;public class DataDemo : MonoBehaviour &#123; string path = "data.txt"; void OnGUI() &#123; if(GUILayout.Button("保存")) &#123; Write(); &#125; if(GUILayout.Button("读取")) &#123; Read(); &#125; &#125; void Write() &#123; Person john = new Person("John", 19); string Json_Text = JsonWriter.Serialize(john); File.WriteAllText(GetDataPath() + path, Json_Text); &#125; void Read() &#123; string Json_Text = File.ReadAllText(GetDataPath() + path); Person john = JsonReader.Deserialize&lt;Person&gt;(Json_Text); Debug.Log(john.name + "'s age is " + john.age); &#125; public static string GetDataPath() &#123; if (Application.platform == RuntimePlatform.IPhonePlayer) &#123; // iPhone路径 string path = Application.dataPath.Substring(0, Application.dataPath.Length - 5); path = path.Substring(0, path.LastIndexOf('/')); return path + "/Documents"; &#125; else if (Application.platform == RuntimePlatform.Android) &#123; // 安卓路径 return Application.persistentDataPath + "/"; &#125; else &#123; // 其他路径 return Application.dataPath; &#125; &#125;&#125; 运行一下，先点击保存按钮，然后刷新（Ctrl+R），发现在文件夹下多了刚才保存的data.txt文件，并且可以看到里面的内容。点击读取，在控制台里可以看到输出“John’s age is 19”。 数据加密但是打开data.txt文件是可以直接看到文本内容的，十分不安全，需要对文本内容进行加密，加密算法有很多种，如RC2、RC4等。这里使用的是Rijndael算法。Rijndael是.NET里包含的一个对称加密接口，在加密和解密时都使用相同的秘钥。位于System.Security.Crytography命名空间下。Rijndael算法符合AES堆成密码标准，秘钥长度为128、192、256位之一。加密步骤如下：(1)设置字符串秘钥并转化为byte数组。这里使用32的字符串转化为长度为32的byte数组，也就是256位的秘钥。 12static string key = "12348578902223367877723456789012";byte[] keyArray = UTF8Encoding.UTF8.GetBytes(key); (2)创建RijndaelManaged对象并设置参数。 12345RijndaelManaged rDel = new RijndaelManaged();rDel.Key = keyArray;rDel.Mode = CipherMode.ECB;rDel.Padding = PaddingMode.PKCS7;ICryptoTransform cTransform = rDel.CreateEncryptor(); (3)加密。 1234567// 将原始字符串转化成byte数姐byte[] toEnCryptArray = UTF8Encoding.UTF8.GetBytes("content");// 加密byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);// 转换回字符串并返回return Convert.ToBase64String(resultArray, 0, resultArray.Length); 解密步骤如下：(1)和加密共用同样的秘钥。(2)创建RijndaelManaged对象并设置参数，和加密的第(2)步一致。(3)解密。 123456// 将加密后的字符串转化成byte数组byte[] toEncryptArray = Convert.FromBase64string(toD);// 解密byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length); // 转换回字符串并返回return UTF8Encoding.UTF8.GetString(resultArray); 整个字符串加密与解密的完整代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445using UnityEngine;using System;using System.Text;using System.Collections;using System.Security.Cryptography;public class Encrypt_Decrypt&#123; static string key = "12348578902223367877723456789012"; /// &lt;summary&gt; /// 字符串加密 /// &lt;/summary&gt; private static string Encrypt (string toE) &#123; byte[] keyArray = UTF8Encoding.UTF8.GetBytes (key); RijndaelManaged rDel = new RijndaelManaged (); rDel.Key = keyArray; rDel.Mode = CipherMode.ECB; rDel.Padding = PaddingMode.PKCS7; ICryptoTransform cTransform = rDel.CreateEncryptor (); byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes (toE); byte[] resultArray = cTransform.TransformFinalBlock (toEncryptArray, 0, toEncryptArray.Length); return Convert.ToBase64String (resultArray, 0, resultArray.Length); &#125; /// &lt;summary&gt; /// 字符串解密 /// &lt;/summary&gt; private static string Decrypt (string toD) &#123; byte[] keyArray = UTF8Encoding.UTF8.GetBytes (key); RijndaelManaged rDel = new RijndaelManaged (); rDel.Key = keyArray; rDel.Mode = CipherMode.ECB; rDel.Padding = PaddingMode.PKCS7; ICryptoTransform cTransform = rDel.CreateDecryptor (); byte[] toEncryptArray = Convert.FromBase64String (toD); byte[] resultArray = cTransform.TransformFinalBlock (toEncryptArray, 0, toEncryptArray.Length); return UTF8Encoding.UTF8.GetString (resultArray); &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[粒子系统]]></title>
    <url>%2F2019%2F02%2F27%2F%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[粒子系统（Particle System）在各个游戏引擎中都是非常重要的功能，而且具有相同的原理和相似的用法，下面就先讲述粒子系统的原理。 粒子系统介绍在3D游戏里，角色及场景元素通常都是网格模型。但要在场景中模拟火焰、烟雾和云彩等难以用网格模型来表现的效果时，则需要用到粒子系统。粒子系统还有一个别名：Shuriken，即手里剑。 粒子系统发射大量的简单粒子单元，它们以特定的规律运动。这些粒子共同模拟复杂的自然现象或效果，粒子本质是简单微小的图片或者网格。 以云雾为例，每个粒子都是细小的一小片云贴图，大量粒子组成了流动的体积云，可以说粒子系统的核心是一组粒子以一定的规律运动。 粒子系统各个模块新建场景并命名为ParticleDemo。点击菜单栏-&gt;GameObject-&gt;Effects-&gt;Particle System，创建粒子系统，默认的粒子系统效果是一些从中心点向上飘飞的“雪花”。 Particle System模块选择粒子系统游戏对象，在Inspector窗口中可以看到粒子系统有众多模块。第一个模块–Particle System基本模块，该模块不能删除或禁用，参数说明如下表所示。 参数 说明 Duration 持续时间，粒子系统发射粒子持续的时间 Looping 是否循环 Prewarm 预热，只有循环的粒子系统可以设置预热，即在发射粒子时就已经发射了一个周期 Start Delay 启动延迟，如果启动了预热将不能使用延迟选项，延迟发射粒子 Start Lifetime 初始生命周期，以秒为单位 Start Speed 初始速度 Start Size 初始尺寸 Start Rotation 初始旋转角度 Start Color 初始颜色 Gravity Modifier 重力系数，对于在Physics Manager里设置的重力进行百分比缩放 Inherit Velocity 继承速度，初始速度 Simulation Space 模拟空间，选择在世界空间还是物体空间 Play On Awake 唤醒时播放，是否自动播放 Max Particles 最大粒子数量 Emission模块Emission模块控制粒子的发射量，可以在某刻大量发射粒子，对于爆炸这种需要一瞬间发射大量粒子的效果尤其实用。Emission模块的参数说明如下表所示。 参数 说明 Rate 每秒或者每移动一个单位距离所产生的粒子 Bursts 当勾选时间选项时开启Bursts选项 Time and Number of Particles 在周期内到达某个时间点的时候发射指定数量的粒子，最多可以添加4组 Shape Module模块Shape Module模块用来选择发射体的形状以及在体内的哪里被发射，参数说明如下表所示。 参数 说明 Shape 发射体的形状。有球体、半球体、圆锥体、盒子、网格、圆圈、边缘。如果是网格，需要指定是从顶点、基本三角形发射，还是从边缘发射 Random Direction 当激活时，所有粒子将被赋予随机的初始方向。不激活时，球体从内向外随机发射；半球体从内向外随机发射但不包括底部；圆锥体/盒子从底部向顶部发射；网格/圆圈在截平面内从圈内向圈外发射；边缘，其实是一条线，线向一个固定方向发射 Radius 网弧的度数（球体、半球体、圆锥体、圆圈、边缘） Angle 网锥体的角度，0是圆柱体，90是平面 Box X,Y,Z 为Box指定长宽高 Mesh 为Mesh指定网格 Emit from Shell 从体内还是体外发射粒子（球体、半球体），勾选时粒子在球面发射，不勾选时从球内发射 Emit from 从圆锥体的什么部位发射：Base从底部向顶部发射，Base Shell从底部的表面向顶部发射，Volume从阅锥体内向外发射，Volume Shell从圆锥体的表面向外发射 Arc 圆圈专有属性：360为圆圈，小于360为扇形 Emit From Edge 圆圈专有属性：勾选时从圆圈的边缘发射，不勾选时从圆圈的中心发射 Velocity over Lifetime模块Velocity over Lifetime模块设置整个生命周期的速度，参数说明如下所示。 X,Y,Z：粒子在各个轴向的速度。 Space：选择相对本地坐标系还是世界坐标系。Start Speed和Velocity的区别如下。 float startSpeed：基础速度标量，主要表示速度的大小。 Vector3 Velocity：速度向量，主要表示速度的方向。在某一个时间点的速度为startSpeed * Velocity。 Limit Velocity over Lifetime模块Limit Velocity over Lifetime模块主要用来限制粒子的速度，参数说明如下所示。 Separate Axis：是否分X、Y、Z轴单独设置各个轴向的限定速度。 Speed：设置限定速度。 Space：选择相对本地坐标系还是世界坐标系。 Dampen：当粒子速度的速度超过后限定速度后的衰减系数，范围是[0,1]。 Force over Lifetime模块Force over Lifetime模块对所有粒子施加力，使之具有加速度，参数说明如下所示。 X,Y,Z：力在3个轴向的值。 Space：选择相对本地坐标系还是世界坐标系。 流体经常在流动中受到力的影响，例如从火中冒起的烟受热气的轻微的力作用，可以通过设置速度在生命周期中的曲线来达到。一开始烟受热气上升，但是热气遇到冷空气后不再对烟施力，烟升腾到顶部会回落。 Color over Lifetime模块Color over Lifetime模块用来处理粒子颜色在生命周期内的变化，参数Color用来处理粒子的颜色。 很多自然的效果粒子的顏色是随时间变化的，例如火花飞溅的火星会在空气中冷却变暗乃至消失，那么最后以透明白色结束是最适合的。 Color by Speed模块粒子颜色也可以随速度变化，这就需要用到Color by Speed模块，该模块的参数如下所示。 Color：粒子的颜色 Speed Range：颜色对应的速度范围。 在火星四溅的效果中，快速的粒子会更亮（因为接触到更多的氧气，燃烧更剧烈），可以在Color的左端设置红色代表低速颜色,右段白色代表高速颜色。 Size over Lifetime模块Size over Lifetime模块根据生命周期设置粒子的大小，参数Size可以设置粒子在生命周期内的大小变化。 烟雾等特效通常会在远离中心点的同时改变。例如，烟雾趋向于散开。这时曲线可以设置为上升的斜坡，可以和Color Over Lifetime一同使用，而燃料引起的火焰则是先上升再下降的曲线。 Size by Speed模块Size by Speed模块根据速度设置粒子的大小，参数如下所示。 Size：曲线、定义粒子在速度范围内如何变化。 Speed Range：速度最小值和速度最大值，对应Size曲线的两端。 不光可以通过生命周期改变粒子大小，还可以通过速度。例如，爆炸效果中碎片向外飞溅。其中小碎片会飞得快些，而大碎片会飞得慢些。最好不要使用Limit Velocity Over Lifetime，除非想让粒子迅速缩小。 Rotation over Lifetime模块Rotation over Lifetime模块用来让粒子在生命周期内旋转，参数Angular Velocity用来设置旋转的角速度（度/秒）。 这个属性适合小型固体，如爆炸中的碎片。设置一个范围内的随意角速度会让效果看起来更真实，更自然，因为没有过多相似的粒子。 Rotation by Speed模块使用Rotation by Speed模块，可以通过速度来设置旋转，参数如下所示。 Angular Velocity：旋转的角速度（度/秒） Speed Range：当Angular Velocity为曲线时，该值对应速度最小值和速度最大值。该模块可以用来表现石头群从坡上滚落的效果。 External Forces模块外部力量模块。当勾选时，Wind Zone风域不仅可以作用于树术，还可以作用于粒子，参数如下所示。 External Forces：是否激活外部力量。 Multiplier：风域系数。 地形系统可以通过Wind Zone对树木施加力产生风吹的效果，激活外部力量使得风域同样可以作用于粒子系统，Multiplier可以设置得大一些，因为起风时粒子通常会比树枝被吹得猛烈得多。 Collision模块Collision模块控制粒子如何与场景中的碰撞体碰撞，主要分为World和Planes两种。World参数如下表所示。 参数 说明 Dampen 在碰撞后由于摩擦而损失速度的百分比。0代表在碰撞后不损失速度，1代表碰撞后速度为0 Bounce 弹性。0表示碰撞后不会弹起，1表示会最大弹起 Lifetime loss 碰撞所消耗的生命周期，0代表不会消耗，1代表完全消耗，也就是碰撞后粒子立刻消失 Min Kill Speed 当碰撞后小于此速度值的粒子将会消失 Collides With 粒子所能碰撞的layer层 Collision Quality 碰撞的精确度，如果选择low的话，有时粒子会穿过碰撞体 Send Collision Messages 如果激活，当有碰撞体受到粒子撞击时，会发送消息调用脚本中的OnParticleCollision()函数 Plane参数如下表所示。 参数 说明 Visualization 平面的显示方式。Grid：只在Scene视图下以线征的形式呈现。Solid：在Scene和Game视图下都会直接显示一个平面 Scale Plane 缩放可提化的平面（只与显示有关） Dampen 在碰撞后由于摩擦而损失速度的百分比。0代表在碰撞后不损失速度，1代表碰撞后的速度为0 Bounce 弹性。0表示碰撞后不会弹起，1表示会最大弹起 Lifetimse loss 碰撞所消耗的生命周期，0代表不会消耗，1代表完全消耗，也就是碰撞后粒子立刻消失 Min Kill Speed 当碰撞后小于此速度值的粒子将会消失 Particle Radius 粒子的大致尺寸，避免粒子与平面出现部分重叠 Send Collision Messages 如果激活，当有碰撞体受到粒子撞击时，会发送消息调用脚本中的onParticleCollision()函数 当其他物体包围粒子系统时，粒子系统与它们有良好的交互看起来会更真实。例如水或者碎片遇到一面墙的时候，应该被阻挡而不是直接穿过去。激活Collision就可以实现此效果。当选择World模式时，会默认能与所有物体碰撞，也可以在Collide With里设置哪些层可与粒子碰撞，哪些不可以。Plane模式可以添加一组游戏对象，表示平面与粒子系统碰撞。当实现粒子与楼梯、墙壁等碰撞时，Plane模式的CPU效率更高。当使用Plane模式时，可以添加一个或一组游戏对象至Planes属性上。 这些游戏对象会在本地的X、Z轴向展开无尽的平面，而Y的正向代表平面的法线方向，可以在Visualization里显示这些看不见的平面，以帮助我们设置。 当碰撞激活时会有一个问题：当粒子与物体碰撞时，有可能出现边缘重叠或者交错的情况，因为粒子的大小有可能在碰撞后的反弹前变化，Particle Radius这个属性可以很好地解决这个问题，例如设置得比原尺寸稍微大一点。 当用粒子表示固体(例如石头)从坡上滚下时，Dampen和Bounce两个属性非常有用。石头在落地时会弹起，而雪球在落地后会趋向于停下来，Lifetime Loss和Min Kill Speed可以设置在一个粒子碰撞后剩下的粒子跟随的情况，例如一个火球发生碰撞后，迸发出的火星粒子应该分开消散。 Sub Emitters模块Sub Emitters模块是子发射器，参数如下所示。 Birth：在粒子系统的起始阶段最多创建2个子粒子系统。 Collision：在粒子发生碰撞的时候最多创建2个子粒子系统。 Death：在粒子系统生命周期结束的时候最多创建2个子粒子系统。 例如，子弹离开舱膛时会有硝烟，而火球撞到目标时会发生爆炸。子发射器发射的粒子系统也是普通的粒子系统，只是发射粒子或激活粒子系统的时机由父粒子系统决定而已。子粒子系统依然可以有子粒子系统，但是用子发射器很容易产生大量的粒子，使用时一定要注意。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导航系统]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题:1.Navigation Area是干嘛用的？2.3. 本章涵盖： 1.实现导航系统 2.障碍物 3.分离网格链接 导航系统（Navigation System）可以让人物在场景里智能地移动、绕过障碍等。导航系统使用NavMesh（导航网格）来解析环境。下面我们来了解一下实现导航系统的步骤。 实现导航系统本节首先创建场景并烘焙导航网格，接着创建导航代理（Agent），以实现让角色绕过重重障碍到达终点的功能。 建立场景新建一个场景并命名为NavDemo，在Project视图右键-&gt;Import Package-&gt;Environment导入资源，再新建一个地形，将尺寸长、宽、高均设置为100，将贴图设置为“GrassRockyAlbedo”。请再新建3个立方体作为障碍物，新建一个圆柱体作为主角，新建一个球体作为导航目标，通过缩放移动摆放它们，如下图所示。 设置NavMesh在Hierarchy窗口中选中Terrain和3个立方体障碍物，在Inspector窗口中点击Static下拉菜单，在下拉菜单中勾选Navigation Static，如下图所示。 烘焙点击导航菜单栏-&gt;Window-&gt;Navagation按钮，打开导航窗口，切换到Bake标签页，点击右下角的Bake（烘焙）按钮，完成后的场景如下图所示。 接下来详细看看导航窗口（Navigation窗口），它有Object、Bake、Areas这3个标签页。 Object标签页如下图所示。在该标签页下可设置具体游戏对象的参数（参见下表），当选取游戏对象后，可以在此标签页中设置导航相关参数。 参数 说明 Navigation Static 是否具有导航静态属性 Generate OffMeshLinks 生成分离网格链接 Navigation Area 类型 烘焙标签页如下图所示，是导航窗口中最重要的标签页。在该标签页下可设置导航代理相关参数以及烘焙相关参数，参数说明如下表所示。 参数 说明 Agent Radius 导航代理半径 Agent Height 导航代理高度 Max Slope 导航代理行走的最大倾斜角度（最大允许输入60度） Step Height 导航代理一步能提高的高度，可以理解为能一步走上多高的阶梯 Drop Height 地形网格之间高度差低于此值则导航代理可跳落 Jump Distance 地形网格之间距离小于此值则导航代理可跃过 Manual Voxel Size 是否手动调整烘焙的单元尺寸 Voxel Size 烘焙的单元尺寸，控制烘焙的精度 Min Region Area 设置最小区域，一般小于此大小的烘焙区域将被移除 Height Mesh 当地形有落差时（如阶梯），是否生成精确的而不是近似的烘焙结果 Areas标签页如下图所示。在该标签页下可设置导航区域类型。导航区域类型有3个默认的不可更改的区域类型：Walkable、Not Walkable、Jump。剩余的是自定义的区域类型，Cost栏里的值要求填写浮点数，表示导航代理在此区域中行走的负担，也可以使用NavMeshAgent.SetAreaCost()设定特定代理在特定区域内行走的负担。不同的区域类型在Scene视图中以对应颜色显示，例如蓝色的Walkable类型就对应了烘焙后那张图中的蓝色半透明区域，表明这些区域都是可以行走的。 还请注意NavMesh里的Mesh，它指的是Mesh Render模型，和Collider无关。例如，有一个游戏对象，若有BoxCollider但是没有MeshRenderer，那么即使勾选了Navigation Static，也是不能作为NavMesh参与烘焙的。 设置导航代理导航代理（Navigation Agent）可以理解为去寻路的主体。选中之前创建的圆柱体并添加NavMeshAgent组件，如下图所示。 Nav Mesh Agent面板中各个导航代理参数的含义如下。 Steering（转向），用于设置导航代理的速度、角速度、加速度等与移动有关的参数。 Obstacle Avoidance（障碍物躲避），用于设置导航代理如何“智能”地躲避障碍物。 Path Finding（路径搜寻），用于设置导航代理如何“智能”地到达目标点。 导航代理各部分参数说明如下表所示。 部分 参数 说明 Base offset 圆柱体碰撞体相对于本地坐标原地的坐标偏移 Steering Speed 最大移动速度（米/秒） Angular Speed 最大角速度（度/秒） Acceleration 最大加速度 Stopping Distance 到达距离目标位置多少的距离停下来 Auto Braking 激活时，到达目标位置前，将“刹车”，就是减速 Obstacle Avoidance Quality 躲避障碍物的质量，当有大量导航代理时，降低质量能减少CPU使用率。如果设置为0，则不会躲避其他导航代理 Priority 设置自身的导航优先级，范围是[0,99]，值越小优先级越大。导航代理只会躲避比自身优先级高的其他代理 Path Finding Auto Traverse Off Mesh Link 激活时，将自动通过Off Mesh Link。不激活时，可以通过播放动画等方式通过 Auto Repath 当无法到达目标点的时候，导航代理会再次以相同路线来到一个距离目标点最近的位置 Area Mask 设置哪些区域类型此导航代理可以行走 下面，我们创建一个脚本并命名为MyAgent，代码如下所示。将代码添加至主体圆柱体，再将destinationTarget设置为目标球体，agent为圆柱体本身。 123456789101112131415using UnityEngine;using System.Collections;using UnityEngine.AI;public class MyAgent : MonoBehaviour &#123; public GameObject destinationTarget; public NavMeshAgent agent; void Start() &#123; // 设置导航代理的目标位置 agent.destination = destinationTarget.transform.position; &#125;&#125; 运行场景，圆柱体会移动并绕过障碍，最终到达球体的位置。 障碍物一般来说，不可攀爬的Nav Mesh会被视作障碍物（Nav Mesh Obstacle），我们还可以直接将物体指定为障碍物。也就是说，我们为对象添加Nav Mesh Obstacle组件。有别于普通的Nav Mesh，Nav Mesh Obstacle是一种不需要烘焙的障碍物，形状可以选择为立方体或者是胶囊体。 使用方法是直接在游戏对象上添加Nav Mesh Obstacle。 请将场景存为NavDemo2。新建两个立方体并置于之前创建的“通道”中，如下图所示。添加Nav Mesh Obstacle组件，如图所示，Shape有立方体或胶囊体可选。Carve是指NavMesh生成的可通过区域是否会被Nav Mesh Obstacle切割。 再次运行场景，圆柱体会绕过Nav Mesh Obstacle并到达终点。 分离网格链接分离网格链接（Off-Mesh Links）用于在不相连的导航区域间创建路径，我们可将其理解为“传送门”。 将场景NavDemo2另存为NavDemo3，并将地形复制到右侧，将球体目标移动至右侧地形。 再新建一个空游戏对象，命名为Off Mesh Link Left，置于左侧地形的右下角。然后，新建一个空游戏对象，命名为Off Mesh Link Right，置于右侧地形的左下角。烘焙后，Off Mesh Link Left和Off Mesh Link Right以两个黑点显示，其间以一条黑线连接，如下图所示。 最后新建一个空游戏对象并命名为Off Mesh Link，添加Off Mesh Link组件，并指定Start为Off Mesh Link Left，End为Off Mesh Link Right。 运行场景，圆柱体导航代理会在移动到Off Mesh Link Left后再转移到Off Mesh Link Right，最终到达终点。 参数 说明 Start 起点 End 终点 Cost Override 重定义负担。当值小于0时，Cost为下面Navigation Area栏中设定的导航类型的Cost，当值大于等于0时为直接赋值这条链接的负担。默认值为-1 Bi Directional 是否是双向链接。默认激话 Activated 是否激活。默认激活 Auto Update Positions 激活：每次调整Start和End点后会自动更新Off Mesh Link；不激话：调整Start和End点后不更新Off Mesh Link Navigation Area Off Mesh Link的区域类型 小结本章主要介绍了如何使用Unity的导航系统，涵盖了导航网格、导航代理、障碍物、分离网格链接等知识点。 习题1.实现导航系统有哪些步骤？2.简述什么是Off-Mesh Links。3.用导航系统做一个吃豆人的小游戏。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建人物]]></title>
    <url>%2F2019%2F02%2F25%2F%E5%88%9B%E5%BB%BA%E4%BA%BA%E7%89%A9%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 以下代码自己实现一遍。 添加摄像机新建一个名为ThirdPersonCam的脚本。代码如下： 123456789101112131415161718192021222324252627using UnityEngine;using System.Collections;public class ThirdPersonCam : MonoBehaviour&#123; // 摄像机所跟随的对象 public Transform follow; // 摄像机在水平方向与对象的距离 public float distanceAway; // 摄像机在垂直方向与对象的距离 public float distanceUp; // 过渡速度 public float smooth; // 摄像机的目标速度 private Vector3 targetPosition; // 在LateUpdate中执行摄像机操作，确保在对象的操作完成之后 void LateUpdate () &#123; // 计算目标位置 targetPosition = follow.position + Vector3.up * distanceUp - follow.forward * distanceAway; // 对当前位置进行插值计算 transform.position = Vector3.Lerp(transform.position, targetPosition, Time.deltaTime * smooth); // 使摄像机观察对象 transform.LookAt(follow); &#125;&#125; 将参数进行如下设置。 Follow：设置为player游戏对象。 Distance Away：设置为5。 Distance Up：设置为2。 Smooth：设置为3。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using UnityEngine;using System.Collections;public class PlayerManager_5: MonoBehaviour &#123; private Animator animator; private CharacterController charController; void Awake() &#123; //得到Animator组件 animator = GetComponent&lt;Animator&gt;(); charController = GetComponent&lt;CharacterController&gt;(); &#125; void Update () &#123; //得到Joystick水平轴向输入的值 float v = Input.GetAxis("Vertical"); //得到Joystick水平轴向输入的值 float h = Input.GetAxis("Horizontal"); //将该值传递至animator的Speed参数 animator.SetFloat("Speed", h*h+v*v); //将该值传递至animator的Direction参数 animator.SetFloat("Direction", h, 0.25f, Time.deltaTime); //得到Animator中序号为0的layer，也就是Base Layer的状态信息 AnimatorStateInfo stateInfo = animator.GetCurrentAnimatorStateInfo(0); if (stateInfo.shortNameHash == Animator.StringToHash("Run")) &#123; //Base Layer为Run状态，当检测到按下开火按钮，设置Jump为true if (Input.GetButton("Fire1")) animator.SetBool("Jump", true); &#125; else &#123; //当Base Layer为其他状态时,设置Jump为false animator.SetBool("Jump", false); &#125; if (stateInfo.shortNameHash == Animator.StringToHash("Jump")) &#123; //当Base Layer为Jump状态，将CharController的高度设置为与ColliderHeight曲线对应 if(!animator.IsInTransition(0)) charController.height = animator.GetFloat("ColliderHeight"); &#125; //得到Animator中序号为1的layer，也就是RightArm Layer的状态信息 AnimatorStateInfo stateInfo2 = animator.GetCurrentAnimatorStateInfo(1); if (stateInfo2.shortNameHash == Animator.StringToHash("Wave")) &#123; //当RightArm Layer为挥手状态时 animator.SetBool("Wave", false); &#125; else &#123; //当RightArm Layer为其他状态时 //当按下鼠标右键时 if(Input.GetButtonDown("Fire2") ) &#123; animator.SetBool("Wave", true); &#125; &#125; &#125;&#125; 反向动力学当开启iKPass后，会在每一帧里调用MonoBehaviour的OnAnimatorIK()函数。IK的处理也只能在OnAnimatorIK()函数里。 角色上绑定的IKCtrl脚本代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667using UnityEngine;using System;using System.Collections;// 要求游戏对象必须有Animator组件[RequireComponent(typeof(Animator))]public class IKCtrl: MonoBehaviour &#123; private Animator animator; // IK的开关 public bool iKPositionActive; public bool iKLookAtActive; public bool iKRotationActive; // SetIKPosition和SetLookAtPosition的对象 public Transform rightHandObj; // SetIKRotation的对象 public Transform rightHandRotationObj; void Start () &#123; animator = GetComponent&lt;Animator&gt;(); &#125; void OnAnimatorIK() &#123; if(iKPositionActive) &#123; // 当开启IK位置时 // 设置右手的IK位置权重为1 animator.SetIKPositionWeight(AvatarIKGoal.RightHand, 1.0f); // 设置右手的IK位置为rightHandObj的位置 animator.SetIKPosition(AvatarIKGoal.RightHand, rightHandObj.position); &#125;else &#123; // 当不开启IK位置时，重置IK位置的权重为0 animator.SetIKPositionWeight(AvatarIKGoal.RightHand, 0f); &#125; if(iKLookAtActive) &#123; // 当开启IK的LookAt时 // 设置IK的LookAt权重为1 animator.SetLookAtWeight(1); // 设置头部看向rightHandObj animator.SetLookAtPosition(rightHandObj.transform.position); &#125;else &#123; // 当不开启IK的LookAt时，重置IK的LookAt的权重为0 animator.SetLookAtWeight(0f); &#125; if(iKRotationActive) &#123; // 当开启IK旋转时 // 设置右手的IK旋转权重为1 animator.SetIKRotationWeight(AvatarIKGoal.RightHand, 1.0f); // 设置右手的IK旋转角度为rightHandObj的旋转角度 animator.SetIKRotation(AvatarIKGoal.RightHand, rightHandObj.rotation); &#125; else &#123; // 当不开启IK旋转时，重置IK旋转的权重为0 animator.SetIKRotationWeight(AvatarIKGoal.RightHand, 0f); &#125; &#125;&#125; 需要注意Unity中IK的限制，AvatarIKGoal也就是IK的目标只有RightHand、LeftHand、RightFoot和LeftFoot这4种，而且IK是某个身体部分（比如右臂）的反向动力学，并不是全身的。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画系统]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.Mesh Filter和Mesh Renderer组件的作用分别是什么？2.FBX导入以后，为什么建议不要选中Import Materials复选框？3.什么是Prefab？如果场景中的两个Prefab，一个需要设置阴影，一个设置不接收阴影，怎么办？4.如何监听Prefab保存事件？5.导入类动画如何确定命名规则？ Unity的动画系统支持引擎内编辑动画，也支持外部导入FBX动画。由于引擎内置的动画编辑器没有提供骨骼动画的概念，所以只能编辑每一帧模型的Transform信息、整体的旋转、缩放和平移。假设是飘带一类的东西，它自身需要发生一些变化，此时引擎内置的编辑器就做不到了。可以用3ds Max来制作带骨骼信息的动画，然后将其导出FBX文件，最终放入Unity来使用。 此外，Unity还支持FBX网格文件的优化、动画重定向等功能。由于每个模型可能有很多动画，这样它们的切换管理就比较复杂。Unity提供了Animator组件，它是可视化的状态机编辑工具，可以更方便地预览自身动画之间的切换关系，以及动画混合方式。 然后游戏中可能同时会有很多模型，Unity又提供了TimeLine编辑工具，它用时间线来管理模型的进度关系，像游戏中常用的过场动画、技能编辑器或者3D动画片等。 模型Unity显示模型必须给游戏对象提供Mesh Filter和Mesh Renderer组件，如下图所示，前者表示模型显示需要用的Mesh文件，后者通过材质的贴图和Shader最终将这个模型渲染出来。 Mesh FilterMesh Filter需要绑定一个Mesh资源，它记录的就是模型的顶点信息。如果是外部导入Unity的FBX文件，它会自动生成Mesh信息，但是这个信息只能是只读的，无法二次修改它。不过可以读取原始FBX的Mesh信息，重新生成一个Mesh资源，这样以后就可以读写它了。 如下图所示，FBX导入以后，建议不要选中Import Materials复选框，不然它会自动生成3ds Max中配置的材质文件。即使在Project视图中删除了它，该资源再次导入时，又会自动生成出来，多余的材质文件会影响到AssetBundle打包的依赖关系。 Mesh Renderer模型的网格设置好后，就需要Mesh Renderer将它渲染出来了。这里需要提供一个材质，然后可以在材质上面设置贴图以及Shader。此外，它还可以设置灯光阴影的接收信息以及烘焙的参数。 Prefab游戏场景中需要很多模型，如果未来某一天想批量给某一个模型添加或修改一些参数，总不能每一个都手动地调一遍吧，所以需要引用Prefab的概念。制作Prefab的方法很简单，在Hierarchy视图中选择需要制作的游戏对象，然后将其直接拖入Project视图即可生成Prefab。我们可以将它理解成一个快捷方式，修改原Prefab后，将自动影响所有引用到的地方。遗憾的是，目前Unity还没有提供Prefab嵌套的功能。 这就带来一个问题：如果场景中的两个Prefab，一个需要设置阴影，一个设置不接收阴影，那么如果把原Prefab改了，这岂不会把所有的Prefab都影响了？Prefab自身有一个优化，如果Hierarchy视图中二次修改了引用的某个参数，那么Prefab修改后，此参数将不会被同步。如下图所示，选择Prefab后，可单击Revert（还原）或者Apply（应用到所有）按钮。另外，如果想取消Prefab的引用关系，可以在导航菜单栏中选择GameObject-&gt;Break Prefab Instance菜单。如果想彻底取消，建议直接删除。 下面在Editor中做一个小例子，来监听Prefab保存事件。监听PrefabUtility.prefabInstanceUpdated事件即可知道Prefab何时被保存，并且在下面输出它的文件路径。 12345678910111213141516using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;public class Script_07_01 &#123; [InitializeOnLoadMethod] static void InitializeOnLoadMethod() &#123; // 监听Prefab保存事件 PrefabUtility.prefabInstanceUpdated = delegate(GameObject instance) &#123; Debug.LogFormat("Prefab &#123;0&#125; 被保存", AssetDatabase.GetAssetPath(PrefabUtility.GetPrefabParent(instance))); &#125;; &#125;&#125; 动画编辑器Unity动画编辑器主要使用在Unity的Primitive物体上，原理就是通过时间线来修改组件的信息，比如修改Transform位置信息、修改Renderer组件或修改颜色信息，控制模型显示隐藏；此外，还可以在时间线上添加动画事件。编辑后的动画可以用在很多地方，比如UI元素、2D元素或模型等，只要是游戏对象都可以，它需要配合Animator组件使用。 编辑器面板使用Window-&gt;Animation菜单，即可打开编辑器窗口。请记住，需要提前选择一个游戏对象，并且让在它身上绑定Animator组件。如下图所示，左上角的New Animation就是当前选择的动画，再点击一下可以创建新的动画。上面有个“小红点”，点开后即可开启实时编辑模式。我们可以在Scene视图中旋转、缩放和平移当前帧模型，其中右边的Samples表示帧率（1秒多少帧）。右边有两个小标志，第一个表示新添加一帧，第二个表示给当前帧添加一个事件。下面的Add Property按钮用于添加需要编辑的组件信息，包括模型下的所有子对象信息。在窗口最下面，还有个Curves按钮，它可以进入曲线编辑界面，拖动时间线就可以查看动画效果了。如果想整体播放动画，可以单击上面的播放按钮，最终动画信息将保存在.anim文件中。 在动画编辑器中添加事件首先，给待编辑的对象（比如一个Cube）身上绑定脚本。如果需要添加public方法，最多能有一个编辑参数，参数类型可以是int、bool、string或GameObject等常用类型。如下图所示，在动画编辑器的时间线上单击鼠标右键，在弹出的快捷菜单中选择Add Animation Event命令，即可添加一个事件，然后在Event面板中设置参数即可。 如下代码所示，我们绑定了MyCustomEvent()方法，这里添加一个整型参数。点击Add Animation Event后，就可以添加事件了。 123456789101112131415using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Events;public class AnimationEvent:UnityEvent&lt;int&gt;&#123;&#125;public class AnimationListener : MonoBehaviour &#123; public static AnimationEvent animationEvent = new AnimationEvent (); public void MyCustomEvent(int intValue) &#123; animationEvent.Invoke (intValue); &#125;&#125; UnityEvent事件默认是不带参数的，如果需要参数，就要继承UnityEvent，其中T表示参数的数据类型，可以填入多个参数。 导入类动画美术人员将在3ds Max中制作好的模型以及动画FBX文件导入Unity就可以使用了。首先，需要和美术人员约定命名规则。如下图所示，多动画文件共用同一份Mesh文件，动画文件以@标记动画名称，命名保持一致，这样Unity会自动认定这是一组模型加动画。 导入后，还可以对它们做很多特殊的设置，比如设置模型缩放比例，自动优化网格，自动优化动画等。导入类动画一共可分3种模式：Humanoid（人形重定向动画）、Generic（通用动画）和Legacy（老版动画）。 人形重定向动画人形重定向动画就是多个身形不同的人物模型也可以共用一份骨骼动画，此技术应用在游戏中会大量减少内存和包体大小，不过目前只支持人形动画。如下图所示，它会根据模型自动创建Avatar对象，里面记录着人物骨骼节点信息以及肌肉拉伸信息。重定向动画的原理就是将不同身形的骨骼信息套入相同的动画中来运算。前面讲过，动画需要以@命名方式保持格式统一，这样点击Update reference clips按钮时，就会自动将模型关联到所有动画上了。选中Optimize GameObject复选框，会把游戏对象下骨骼运动的节点信息删掉。由于有些节点中程序可能需要做逻辑，例如手上拿一把武器一类的，所以可以将特殊节点添加在Extra Transform to Expose中，此时这些节点将会保留下来。 单击Configure按钮，可以手动配置模型的骨骼节点以及信息。如下图所示，它会根据模型自动计算出正确的节点信息。不过我们也可以手动修改它。单击Muscles &amp; Settings选项卡，可以配置骨骼的肌肉拉伸信息。 可是有时候美术人员提供的模型并不完全是人形，比如武器、披风和头发等也做在了人物模型中，这样播放动画时就会出问题，因为默认并没有处理非人形的骨骼。要解决这个问题，可以设置兼容播放所有骨骼。具体操作方法是：选择模型文件，切到Animation分页，如下图所示，在Definition下拉框中选择Create From This Model选项，在下面的Transform中选中剩余需要响应的骨骼节点。选中后，就表示如果这个动画被重定向，那么如果别的模型要播放这个动画，也需要这些骨骼节点信息了。最后，单击Apply按钮即可。 通用动画通用动画就比较好理解了。它不支持重定向动画，美术人员做成什么样，拿进来就是什么样。如下图所示，在模型文件的Avatar Definition下拉框中选择Create From This Model选项，将创建Avatar对象。而动画文件会依赖Avatar对象。Root node就是支持带位移的动画，游戏中尽可能不要使用它，因为它可能和自己的控制系统冲突。Optimize Game Object和Extra Transform to Expose与人形动画功能类似。 导入类动画事件在Project视图中选择动画文件，在Animation分页中展开Events标签，可以添加自定义动画事件，如下图所示。单击左上角的加号图标，可以添加一个新事件。其中Function就是事件回调的方法名称，Float、Int、String和Object表示参数。这里回调的方法为MyCustomEvent()，其代码如下： 1234public void MyCustomEvent(int intvalue)&#123; Debug.Log(intvalue);&#125; 动画控制器Unity动画控制器的原理就是状态机。传统的状态机是需要在代码里写一个很大的switch…case来处理状态，而Unity为我们提供了可视化的编辑工具，不需要程序员也可以编辑动画的状态。此外，它还提供了子状态机和动画混合的功能。由于状态机的原理是同一时刻只能有一个状态，所以Unity还提供了层的概念来将动画分成两个层来同时编辑。 系统状态动画控制器默认会提供3个状态，我们无法删除它，并且除了Exit状态以外，其他状态都无法连接它。如下图所示，首先是Entry状态，它表示当前控制器的初始状态。右击该状态，选择Make Transition命令，即可连接新的状态。状态机会按照连接的状态一次切换动画。橘黄色的状态表示默认状态，如果想切换默认状态，选择另一个状态，选择另一个状态，具体操作方法时单击鼠标右键，从弹出的快捷菜单中选择Set as Layer Default State命令。接着是Any State状态，比如角色死亡一类的，需要从现有状态切换到另一个动画。如下图所示，可以从Any State状态连线到立刻播放的特殊状态，等它的状态处理完后，再连线回到默认状态，继续原有逻辑。 最后是Exit状态。状态机可以创建子状态。如果子状态需要回到父状态Base Layer，可以将子状态再连线到Exit状态，如下图所示。 切换条件状态机中复杂的状态通过连线来确定关联关系，但是如果切换状态时发现有多条线，如何决定选择哪一条呢？这时就需要设置切换条件了。如下图所示，状态机一共支持4种条件：Float、Int、Bool和Trigger，其中前三个都是普通的数据类型，Trigger就像bool一样，设置true后需要立即设置false。 条件定义完毕后，就可以配置条件了。如下图所示，单击两个状态之间的连线，然后在右下角就可以添加满足的条件了，这里支持添加多个条件。状态机在同一时刻只能执行一个状态，即使两个状态的条件都满足了，也只能进入其中一个。右上角的Solo复选框表示即使当前别的条件达成了，也只能进入选中Solo的状态。Mute复选框表示即使当前条件达成了，也不能进入选中Mute的状态。下面的Has Exit Time复选框表示不同动画切换时是否启动动画过渡，可以调节蓝色半透明区域来设置过渡的时间。下面代码首先获取动画组件，然后可以动态设置它的条件。 12345Animator animator = GetComponent&lt;Animator&gt;();animator.SetFloat("New Float", 1f);animator.SetInteger("New Int", 1);animator.SetBool("New Bool", true);animator.SetTrigger("New Trigger"); 状态机脚本我们可以给每个状态添加脚本来监听一些状态事件，比如状态开启、状态更新和状态退出等。另外，脚本也可以添加在子状态机上。如下图所示，选择一个状态，然后单击Add Behaviour按钮即可添加脚本。此外，也可以序列化常用数据，如int、string、bool和object等，然后在面板中输入参数即可。例如进入某个状态，播放一个特定的音乐或者做一些特殊的逻辑等。NewMachineBehavior类的代码如下： 1234567891011121314151617181920212223242526272829303132using System.Collections;using System.Collections.Generic;using UnityEngine;public class NewMachineBehaviour : StateMachineBehaviour &#123; public string testValue; // OnStateEnter is called when a transition starts and the state machine starts to evaluate this state override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) &#123; &#125; // OnStateUpdate is called on each Update frame between OnStateEnter and OnStateExit callbacks override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) &#123; &#125; // OnStateExit is called when a transition ends and the state machine finishes evaluating this state override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) &#123; &#125; // OnStateMove is called right after Animator.OnAnimatorMove(). Code that processes and affects root motion should be implemented here override public void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) &#123; &#125; // OnStateIK is called right after Animator.OnAnimatorIK(). Code that sets up animation IK (inverse kinematics) should be implemented here. override public void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) &#123; &#125;&#125; 有了这些回调事件后，就可以在各个方法中添加自己的代码了。 IK动画IK动画的全名是Inverse Kinematics，其意思就是反向动力学，就是子骨骼节点带动父骨骼节点运动。比如跳街舞的少年用手撑着身体在地上转圈，手就是子骨骼，身体就是它的父骨骼，这样运动时手就需要带动身体来移动。如下图所示，单击Layers选项卡的右上角，设置勾选IK Pass复选框。如下图所示，在左手和右手分别绑定一个球体，移动球体离开控制IK影响手部位的动画。如下代码所示，在OnAnimationIK()方法中就可以处理IK动画了。这里调用了SetIKPosition()方法设置手的位置，以便带动胳膊移动。 123456789101112131415161718192021222324252627282930313233343536using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;public class Script_07_03 : MonoBehaviour &#123; public Animator animator; public Transform rightHandObj; public Transform leftHandObj; void OnAnimatorIK(int layerIndex) &#123; if(animator) &#123; // 设置动画权重 animator.SetIKPositionWeight(AvatarIKGoal.LeftHand,1f); animator.SetIKRotationWeight(AvatarIKGoal.LeftHand,1f); animator.SetIKPositionWeight(AvatarIKGoal.RightHand,1f); animator.SetIKRotationWeight(AvatarIKGoal.RightHand,1f); if(rightHandObj != null) &#123; // 设置右手根据目标点而旋转移动父骨骼节点 animator.SetIKPosition(AvatarIKGoal.RightHand,rightHandObj.position); animator.SetIKRotation(AvatarIKGoal.RightHand,rightHandObj.rotation); &#125; if(leftHandObj != null) &#123; // 设置左手根据目标点而旋转移动父骨骼节点 animator.SetIKPosition(AvatarIKGoal.LeftHand,leftHandObj.position); animator.SetIKRotation(AvatarIKGoal.LeftHand,leftHandObj.rotation); &#125; &#125; &#125;&#125; Root MotionRoot Motion就是播放带位移变化的动画，并且它将影响到游戏对象的Transform信息。带位置的编辑可以在3ds Max中完成。如下图所示，首先需要选中Apply Root Motion复选框，这表示开启动画Transform位移，不选中则不会影响Transform信息。选中bake Into Pose复选框，表示动画播放完毕后才同步位移信息，不选中表示位移随着动画同时改变。另外，在脚本中可以监听位移动画的移动更新事件。注意，位移移动事件是在Update()方法之后执行的。如下代码所示，在OnAnimatorMove()方法中，控制位移动画。 12345678910111213141516171819using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;public class Script_07_04 : MonoBehaviour &#123; public Animator animator; void OnAnimatorMove() &#123; if (animator) &#123; Vector3 newPosition = transform.position; newPosition.z += 1f * Time.deltaTime; transform.position = newPosition; &#125; &#125;&#125; Avatar MaskAvatar Mask可以限制某些骨骼不播放动画。在Project视图中选择Create-&gt;Avatar Mask命令，即可创建它。如下图所示，如果是人形动画（Humanoid），那么可以直接设置人形遮罩骨骼，其中红色的部分表示禁止这部分骨骼的播放动作。如下图所示，如果是通用动画（Generic），需要单独选中需要禁止播放动画的骨骼节点，编辑好后保存即可。 层层是用来做动画融合的，同一套骨骼上的两个动画同时播放，例如FPS游戏或者篮球类游戏。下半身跑动的过程中，上半身还可以旋转投篮等。为了让上下部分的骨骼相互不影响，可以设置它们的Avatar Mask。如下图所示，点击Layers面板右上角的加号，即可添加新层。可以让Base Layer来处理整体逻辑，而让New Layer专门用来做动画融合，Weight可以设置融合的权重，Mask就是遮罩的文件了，Blending设置的Override表示直接覆盖掉其他层的动画。 Blend TreeBlend Tree（混合树）用来做动画混合。动画混合和前面提到的动画融合是不同的概念。动画混合指两个动画切换的时候，为了避免太过生硬而混合在一起的过程，比较经典的例子就是控制角色向前跑、向左跑和向右跑，左右切换跑的时候就要用到它。Animator提供Blend Tree来专门处理混合。 在Layer中单击鼠标右键，从弹出的快捷菜单中选择Create State-&gt;From New Blend Tree命令即可创建它。双击打开它，如下图所示，选择Blend Tree后，单击鼠标右键，从弹出的快捷菜单中选择Add Motion命令即可添加动画文件，这里添加了三组动画，分别是向左跑、向前跑和向右跑。接着在右上方设置TreeValue参数，取值范围为-96 ~ 96。将动画文件拖到右边Motion面板中，取消选择Automate Thresholds复选框，即可手动设置动画的阈值了。最后，可以通过方向键来控制角色左右混合动画了，如下图所示。如下代码所示，在Update()方法中根据左右方向设置TreeValue的值，控制动画左右混合。 1234567891011121314using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;public class Script_07_05 : MonoBehaviour &#123; public Animator animator; void Update() &#123; animator.SetFloat ("TreeValue", Input.GetAxis ("Horizontal") * 96.0f); &#125;&#125; 非运行播放动画通常，在做编辑器的时候，需要在非运行模式下也能播放动画。如下图所示，在“动画”下拉框中选择当前Animator组件绑定的所有动画，然后拖动进度条来调节动画的播放。如下代码所示。SampleAnimation()方法用于采样动画。拖动进度条设置采样事件，即可调节动画了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System.Collections;using System.Collections.Generic;using UnityEngine;#if UNITY_EDITORusing UnityEditor;using UnityEditor.Animations;using System.Linq;#endif[RequireComponent(typeof(Animator))]public class Script_07_06 : MonoBehaviour &#123;&#125;#if UNITY_EDITOR[CustomEditor(typeof(Script_07_06))]public class ScriptEditor_07_06 :Editor &#123; private AnimationClip[] m_Clips = null; private Script_07_06 m_Script = null; void OnEnable() &#123; m_Script = (target as Script_07_06); Animator animator = m_Script.gameObject.GetComponent&lt;Animator&gt; (); AnimatorController controller = (AnimatorController)animator.runtimeAnimatorController; m_Clips = controller.animationClips; &#125; private int m_SelectIndex = 0; private float m_SliderValue = 0; public override void OnInspectorGUI () &#123; base.OnInspectorGUI (); EditorGUI.BeginChangeCheck (); m_SelectIndex = EditorGUILayout.Popup("动画",m_SelectIndex,m_Clips.Select(pkg =&gt; pkg.name).ToArray()); m_SliderValue = EditorGUILayout.Slider ("进度",m_SliderValue, 0f, 1f); if (EditorGUI.EndChangeCheck ()) &#123; AnimationClip clip = m_Clips [m_SelectIndex]; float time = clip.length * m_SliderValue; clip.SampleAnimation(m_Script.gameObject, time); &#125; &#125;&#125;#endif Animator Override Controller前面我们介绍了Animator Controller可以编辑动画之间的切换状态。在游戏中，很多模型动画的切换事件的逻辑可能都是一样的，比如游戏中的很多怪物，它们之间的区别可能就是动画文件不一样，总不能每一个怪物都编辑一套相同的Animator Controller控制行为吧，此时就需要使用Animator Override Controller了。如下图所示，在Controller处绑定需要覆盖的Controller文件，Original会自动列出所用到的动画文件，将它更换成新的动画文件即可。如果以后需要修改它，修改原文件，即可自动修改所有引用到的Animator Override Controller了。 RuntimeAnimatorControllerRuntimeAnimatorController是用来处理Animator Controller动态更新的。如下代码所示，可以通过Resource.Load()最终将对象赋值给animator。 12345678910111213141516171819202122using System.Collections;using System.Collections.Generic;using UnityEngine;[RequireComponent(typeof(Animator))]public class Script_07_07 : MonoBehaviour &#123; public Animator animator; void OnGUI() &#123; if (GUILayout.Button ("&lt;size=50&gt;读取&lt;/size&gt;")) &#123; RuntimeAnimatorController controller = Resources.Load&lt;RuntimeAnimatorController&gt; ("New Animator Controller"); animator.runtimeAnimatorController = controller; &#125; if (GUILayout.Button ("&lt;size=50&gt;删除&lt;/size&gt;")) &#123; animator.runtimeAnimatorController = null; &#125; &#125;&#125; TimeLine编辑器创建TimelineActivation TrackAnimation TrackAudio TrackControl TrackPlayable Track自定义TrackPlayables播放动画动画混合音频混合自定义脚本ConstraintAim ConstraintParent Constraint脚本控制约束小结]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光照贴图的烘焙和使用]]></title>
    <url>%2F2019%2F02%2F20%2F%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE%E7%9A%84%E7%83%98%E7%84%99%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[光影效果在游戏中是十分重要的。在游戏的开发过程中需要加入很多种光源来提高游戏画面质感，但是若是每次都实时地计算物体根据灯光产生的阴影明显是不明智的。由于大多数阴影都是不变的，或许可以通过某种手段使这些不变的阴影固化在场景中，这样就省去了很多不必要的计算。 光照贴图就是用来解决这类问题的。它的基本原理就是使用一张包含有场景中不会变化的物体的阴影的贴图，附加在整个场景中，这样就制作出了相似度非常高的“假阴影”。注意，这样产生的假阴影是不根据光源和物体的位置变化而变化的，所以只适用于场景中不会运动形变的物体，如建筑、雕塑等。 对场景进行光照烘焙(1)首先搭建一个简单的场景，该场景包含若干3D游戏对象，以及一个Plane作为地板。将每个3D物体勾选为“Lightmap Static”，如下图所示。 (2)创建一个平行光光源（用于产生阴影），在光源上的Light组件中将Mode属性选为Baked，并开启阴影，如下图所示。 (3)接下来Window-&gt;Lighting-&gt;Settings打开光照烘焙窗口，有关于光照烘焙的所有参数的设置都可以在该窗口中完成。 (4)开始烘焙前，请检查场景中的3D物体是否都是Lightmap Static模式，光源的Light组件中的Mode是否设置为Baked。确认无误后在新打开的Lighting窗口中的Scene面板中单击下方的Generate Lighting按钮就可以对场景进行烘焙了，注意这时使用的都是默认的光照烘焙参数。注意将按钮旁边的Auto Generate（自动烘焙）开关关闭。 (5)等待烘焙结束后，场景中会自动应用烘焙好的光照贴图。这时可以发现，即使将场景中的灯光关闭，在地面上依旧可以看到阴影。若是把产生阴影的物体挪开，则会发现地上的阴影并没有根据物体的位置改变而改变位置。这是因为阴影已经固化到场景中了，类似于纹理图。 如果选中了Auto Generate复选框，将会自动烘焙。但是如果场景中元素很多，可能会造成卡顿，因此不建议开启。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态对象-1]]></title>
    <url>%2F2019%2F02%2F20%2F%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 静态对象是什么？ 如何在运行时更换烘焙贴图？ 静态对象是Unity提供的一个属性，它可以附加在游戏对象或者Prefab上。它的原理是限制物体在运行中不能发生位移变化，预先生成一些辅助的数据，从而达成一种用内存换时间的优化方式。静态元素的种类很多。如下图所示，选择任意游戏对象，单击右上角的Static下拉框，即可设置该对象的静态元素了，具体如下。 Lightmap Static：用来表示接受烘焙光照计算，可烘焙光照贴图。 Occluder Static：表示自身可以被遮挡剔除掉。 Batching Static：表示支持静态合批。 Navigation Static：表示可烘焙寻路网格。 Occludee Static：表示自身是否可以遮挡其他元素。 Off Mesh Link Generation：寻路连接不同区域的点，就像角色从山顶跳下来。 Reflection Probe(探测) Static：反射探头，就像玻璃反射一样的镜面效果。 LightmapLightmap技术的原理是将场景中的灯光与物体产生的光照与阴影信息烘焙在一张或者多张Lightmap贴图中，这些物体将不再参与实时光照计算，从而减少了大量的性能开销。它的缺点就是参与烘焙计算的对象在游戏过程中不能发生移动，所以游戏中通常会将物体分成两类：一类是可发生位移变化的，它们使用实时光照计算；另一类是不可发生位移变化的，它们采取预先烘焙Lightmap。 设置烘焙贴图首先，需要在场景中选中需要参与烘焙计算的游戏对象，设置为Lightmap Static。接着，下面就会出现烘焙信息参数了，我们可以单独调整某一个对象。如下图所示。 当烘焙对象都设置完毕后，在导航菜单栏中选择Window-&gt;Lighting-&gt;Setting命令，即可打开烘焙面板，如下图所示。同样，设置完烘焙参数后，单击右下角的Bake Reflection Probes命令，即可开始烘焙。如果选中了左边的Auto Generate复选框，将会自动烘焙。但是如果场景中元素很多，可能会造成卡顿，因此不建议开启。 实时光和烘焙光共存在游戏中，少部分物体确实需要实时光，例如控制主角移动时，需要动态地产生光照和阴影信息。如下图所示，可以在Mode中设置灯光的属性，其中Realtime表示实时光，Mixed表示实时光和烘焙光的混合模式，Baked表示仅烘焙光。所以，游戏中更多的会使用Mixed模式。 灯光管理游戏做到后期，光源是非常多的，如何管理就是个问题。新版的Unity提供了管理光源的菜单，在导航菜单栏中选择Window-&gt;Lighting-&gt;Light Explorer命令即可，如下图所示。我们可以快速设置灯光开关状态、灯光类型和模式等，并且点击其中一个光源，即可快速在Scene视图中找到它，使用起来确实很方便。 运行时更换烘焙贴图如果游戏中有一个白天场景和夜晚场景，那么就需要烘焙出多张烘焙贴图了。在程序中，可以动态更换白天和夜晚的烘焙贴图，如下图所示。 如下代码所示，首先创建LightmapData对象，最终将需要更换的烘焙贴图放入LightmapSettings.lightmaps中即可。将脚本放到摄像机下。 123456789101112131415161718192021222324using UnityEngine;public class ChangeLightmap : MonoBehaviour&#123; public Texture2D lightmap1; public Texture2D lightmap2; void OnGUI() &#123; if (GUILayout.Button("&lt;size=50&gt;lightmap1&lt;/size&gt;")) &#123; LightmapData data = new LightmapData(); data.lightmapColor = lightmap1; LightmapSettings.lightmaps = new LightmapData[1] &#123; data &#125;; &#125; if (GUILayout.Button("&lt;size=50&gt;lightmap2&lt;/size&gt;")) &#123; LightmapData data = new LightmapData(); data.lightmapColor = lightmap2; LightmapSettings.lightmaps = new LightmapData[1] &#123; data &#125;; &#125; &#125;&#125; 在上述代码中，我们通过点击按钮来动态切换烘焙贴图，例如切换白天与夜晚的效果。 动态更换游戏对象光照和阴影信息都记录在烘焙贴图上，但是如果需要动态地加载Prefab，就没有烘焙信息了，此时可以给它绑定一个脚本，在生成Prefab的同时将烘焙信息写入这个脚本中，以便在实例化Prefab时再将信息写入。 如下图所示，当场景烘焙完后，选择任意游戏对象，然后在菜单中选择Light-&gt;ToPrefab命令，接着在代码中智能判断这个对象是否已经生成Prefab，如果没有生成，则创建新的，最终将烘焙信息序列化在PrefabLightmap脚本中。当以后这个Prefab实例化进场景时，将保存的烘焙预制信息重新赋值给它即可。 单击Load按钮后，在代码中实例化Prefab，相关代码如下： 1234567891011121314using UnityEngine;public class PrefabLightmap :MonoBehaviour&#123; public GameObject prefab; void OnGUI() &#123; if(GUILayout.Button("&lt;size=50&gt;Load&lt;/size&gt;")) &#123; GameObject.Instantiate&lt;GameObject&gt; (prefab); &#125; &#125;&#125; 如下代码所示，Prefab对象绑定了PrefabLightmap脚本，所以在使用Awake()的时候，可以将之前保存的烘焙信息重新赋值给它。 123456789101112131415161718192021222324252627282930313233using UnityEngine;using UnityEditor;using System.Collections.Generic;public class Script_09_03 :MonoBehaviour&#123; [MenuItem("Tool/DuplicateGameObject %#d")] static void DuplicateGameObject() &#123; if (Selection.activeTransform) &#123; Dictionary&lt;string, Renderer&gt; save = new Dictionary&lt;string, Renderer&gt; (); //根据相对路径保存Renderer信息 foreach (var renderer in Selection.activeTransform.GetComponentsInChildren&lt;Renderer&gt; ()) &#123; string path = AnimationUtility.CalculateTransformPath (renderer.transform, Selection.activeTransform); save [path] = renderer; &#125; //执行复制 EditorApplication.ExecuteMenuItem ("Edit/Duplicate"); //还原烘焙信息 foreach (var renderer in Selection.activeTransform.GetComponentsInChildren&lt;Renderer&gt; ()) &#123; string path = AnimationUtility.CalculateTransformPath (renderer.transform, Selection.activeTransform); if (save.ContainsKey (path)) &#123; renderer.lightmapIndex = save [path].lightmapIndex; renderer.lightmapScaleOffset = save [path].lightmapScaleOffset; &#125; &#125; &#125; &#125;&#125; 通过上述代码可以看到，更换烘焙贴图实际上就是设置正确的lightmapIndex和lightmapScaleOffset。 复制游戏对象光照和阴影信息场景烘焙完毕后，如果直接按Command+D快捷键来复制游戏对象，烘焙信息就是不对的，如下图所示，必须要重新烘焙才行。如果不想重新烘焙，可以自己拓展一个菜单，定义一个新的快捷键Command+Shift+D来执行复制游戏对象的操作，并且动态设置烘焙信息给它。新复制出来的对象中烘焙信息就正确了。需要注意的是，我们只能复制物体身上的光照烘焙信息，物体产生的阴影是无法复制的。 如下代码所示，复制游戏对象的同时，将lightmapIndex和lightmapScaleOffset信息赋值给新对象即可。 123456789101112131415161718192021222324252627282930313233using UnityEngine;using UnityEditor;using System.Collections.Generic;public class Script_09_03 :MonoBehaviour&#123; [MenuItem("Tool/DuplicateGameObject %#d")] static void DuplicateGameObject() &#123; if (Selection.activeTransform) &#123; Dictionary&lt;string, Renderer&gt; save = new Dictionary&lt;string, Renderer&gt; (); //根据相对路径保存Renderer信息 foreach (var renderer in Selection.activeTransform.GetComponentsInChildren&lt;Renderer&gt; ()) &#123; string path = AnimationUtility.CalculateTransformPath (renderer.transform, Selection.activeTransform); save [path] = renderer; &#125; //执行复制 EditorApplication.ExecuteMenuItem ("Edit/Duplicate"); //还原烘焙信息 foreach (var renderer in Selection.activeTransform.GetComponentsInChildren&lt;Renderer&gt; ()) &#123; string path = AnimationUtility.CalculateTransformPath (renderer.transform, Selection.activeTransform); if (save.ContainsKey (path)) &#123; renderer.lightmapIndex = save [path].lightmapIndex; renderer.lightmapScaleOffset = save [path].lightmapScaleOffset; &#125; &#125; &#125; &#125;&#125; 遮挡剔除游戏中的元素非常多，但是摄像机能看到的内容是有限的，并且有些元素会被另外一些元素挡住，例如城墙一类的，城墙后面的元素就会被它挡住。如果不处理的话，这些元素也会带来一定的开销，此时可以使用遮挡剔除技术来剔除掉这些被挡住的元素。只有摄像机能看到的内容才会被动态保留下来。 遮挡和被遮挡遮挡关系是由遮挡物与被遮挡物构成的，例如一面墙后面放了很多元素，那么墙属于遮挡物，元素就属于被遮挡物。按照遮挡剔除的原理，墙后面的元素会被剔除掉，这样就会有一个新问题：如果墙是一面透明的墙，显示时它就不会挡住后面的元素了。因此，我们需要设置元素的遮挡与被遮挡关系了。 首先，在场景中将需要参与遮挡以及被遮挡的游戏对象中，选中Occluder Static和Occludee Static标记；接着在导航菜单栏中选择Window-&gt;Occlusion Culling命令，打开烘焙面板，如下图所示。我们可以在这里设置最小的遮挡距离、最小的遮挡空隙以及背面的阈值。最后，单击Bake按钮，即可烘焙当前场景。烘焙结束后，Unity会自动在场景所在的位置创建一个同名的文件夹，并且往其中放入OcclusionCullingData.asset文件。 运行游戏后，移动摄像机的位置，当墙完全挡住背景的元素时，将自动剔除背景墙后面的元素。 如果这面墙是透明的，那么当背景元素被剔除时，显示就有问题了，此时墙后面的元素可以取消选择Occludee Static标志。这样无论如何移动摄像机，墙后面的元素都会被剔除掉。如果墙后的元素同样也是一面墙，并且还需要剔除后面的元素，它自身只需要选择Occluder Static标志即可。 遮挡与被遮挡事件当发生遮挡剔除时，Unity会自动调用GameObject.SetActive(false)方法，这样整个对象的渲染就会被暂停，直到它重新被启动。如下代码所示，可以监听OnBecameInvisible()和OnBecameVisible()方法来处理即将隐藏或显示的逻辑。 1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Events;public class OcclusionEvent : UnityEvent&lt;GameObject&gt;&#123;&#125;public class OcclusionListener : MonoBehaviour &#123; public static OcclusionEvent onInvisible = new OcclusionEvent(); public static OcclusionEvent onVisible = new OcclusionEvent(); //隐藏状态 void OnBecameInvisible() &#123; onInvisible.Invoke (gameObject); &#125; //显示状态 void OnBecameVisible() &#123; onVisible.Invoke (gameObject); &#125;&#125; 如下代码所示，我们在代码初始化的地方，自动给所有的Renderer组件挂上脚本，统一监听它的剔除以及显示的方法。如果想主动判断某个对象是否在摄像机显示区域内，也可以调用Renderer.isVisible()方法。 1234567891011121314151617181920using UnityEngine;public class Script_09_04 :MonoBehaviour&#123; void Start() &#123; foreach (var item in GameObject.FindObjectsOfType&lt;Renderer&gt;()) &#123; item.gameObject.AddComponent&lt;OcclusionListener&gt; (); &#125; OcclusionListener.onInvisible.AddListener (delegate(GameObject gameObject) &#123; Debug.LogFormat("gameobject &#123;0&#125; 隐藏",gameObject); &#125;); OcclusionListener.onVisible.AddListener (delegate(GameObject gameObject) &#123; Debug.LogFormat("gameobject &#123;0&#125; 显示",gameObject); &#125;); &#125;&#125; 动态剔除在游戏对象中，一旦勾选Occluder Static或Occludee Static标记，运行期间就无法修改它们的Transform信息了。如下图所示，可以在Mesh Renderer组件中勾选Dynamic Occluded复选框，表示它将被动态剔除掉。 运行游戏后，在Scene视图中将Mesh Renderer移出摄像机的显示区域，它立刻就被剔除掉了，如下图所示。注意它只会剔除掉渲染，Update还是会更新。默认情况下，建议选中Dynamic Occluded复选框。 自定义遮挡剔除遮挡剔除虽然很方便，但也未必是好事。如果参与烘焙的元素多了，每次移动摄像机时，遮挡剔除会产生大量的计算，尤其移动平台更为明显。 其实，我们可以自己来实现遮挡剔除。比如，可以将场景上的元素按位置来划分成若干个格子，每个格子里面就是场景中的游戏对象了。无论游戏场景有多大，玩家同一时刻关心的只有1 ~ 9这些区域中的元素。当角色向左上方移动并超出当前格子的位置时，那么红色区域表示需要新加载的，黄色区域表示需要保留的，蓝色区域表示需要释放的。 这可以保证最小化管理所有游戏对象，而且这么做还有个好处：当需要在主角范围内查找最近单元时，参与判断的对象如果很多，就会带来for循环判断的开销，但是由于我们只保留格子范围内的元素，判断就会非常快了。至于遮挡剔除，由于需要管理的对象已经很少了，遮挡剔除的优化几乎可以忽略，所以在移动摄像机的时候，就不会再带来额外的开销了。 如下代码所示，只需要调用StaticBatchingUtility.Combine()方法即可动态设置合批。 12345678910using UnityEngine;public class Script_09_05 :MonoBehaviour&#123; public GameObject[] datas; void Start () &#123; StaticBatchingUtility.Combine(datas, gameObject); &#125;&#125; 这段代码的含义就是将数组中的游戏对象合并在同一个Root节点下，也就是第二个参数指定的。另外，运行游戏后，合并过的Mesh对象是不可以发生位移的，但是可以移动它指定的Root节点。Root游戏对象可以在运行时任意修改位置。 动态合批动态合批是全自动的，我们不需要做任何事情。但它是有要求的，Mesh的顶点数量需要小于300.如果Shader中使用了顶点位置、法线、UV0、UV1和切线，Mesh的顶点数必须小于180。可能会有朋友问：这么小限制的动态合批适用于哪里呢？其实在粒子特效中它发挥了很大的优势。由于每个特效喷射出来以后都是Mesh，如果不开启动态合批，DrawCall就会非常大。 静态合批的隐患静态合批的原理就是自动生成Mesh，但是不同Mesh保存的信息可能是不同的。例如Mesh中可能会保存color和tangent，但是大部分Mesh都是不需要这个信息的，如果静态合批中有一个Mesh包含了这个信息，那么合并以后整个Mesh都会带上它，这样无疑会增加一些额外的开销。更多的时候是由于美术人员在导出FBX时，操作不当导致添加了没用的color或tangent信息，所以可以利用FBX官网提供的FBX接口，自己写一个Python脚本来删除它们。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity中的动画系统和Timeline]]></title>
    <url>%2F2019%2F02%2F17%2FUnity%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E5%92%8CTimeline%2F</url>
    <content type="text"><![CDATA[可以给任意原始类型的游戏物体施加动画，每个组件基本上都是可以控制的。 普通动画新建项目AnimationProject，在Project视图下新建Scenes、Scripts、Prefabs、Animations文件夹。保存场景为01-Normal Animation，在场景中创建一个Cube。 选中Cube，再选择Window里面的Animation，出来一个专门创建动画的窗口，如下图所示。 Animation Clip就是一个动画的文件。点击Create，动画有什么功能就取相应的名字，取名为CubeMove，后缀为anim，保存到Animations文件夹中。此时Cube多了一个Animator组件，如下图所示。 Animator是用来播放状态机的，Animator的Controller属性就是状态机，Animation是动画。CubeMove是动画，Cube是Animator Controller，是一个状态机，这个状态机里面管理了CubeMove。一个动画可看做是一个状态。 新建一个AnimatorControllers文件夹，把Cube放进此文件夹中。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Siki</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mecanim动画系统]]></title>
    <url>%2F2019%2F02%2F17%2FMecanim%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[旧版动画系统中，游戏开发人员只能通过代码操控角色动画的播放，随着动画个数的增多，其代码复杂度也随之增加。同时，动画的过渡需要烦琐的代码控制，这就使得缺乏编程经验的游戏动画师很难对动画效果进行处理。Mecanim动画系统就是为了解决这个问题，该动画系统使游戏动画师能够参与到游戏的开发中来。 Unity与建模软件单位的比例关系Unity默认的系统单位为m，例如在Unity中新建一个Cube游戏对象，其长宽高都是一个单位，即1m。但3D建模软件默认的系统单位并不都是m。为了让模型可以按照理想的尺寸导入Unity，就需要调整建模软件的系统单位或者尺寸。在3D建模软件中，应尽量使用“米”制单位。 导入模型将模型导入Unity中，依次单击菜单栏的“Assets-&gt;Import New Assets…”立刻弹出导入资源对话框，找到并选中模型，单击“Import”按钮就可完成导入。此时Unity的Assets面板里就会出现此模型。 角色动画的配置导入了角色动画资源之后，需要对角色动画进行适当的配置才能被Mecanim动画系统所识别和使用。Mecanim动画系统非常适合用于对人形角色动画的控制。 1.创建骨骼结构映射–Avatar 把带动画的模型文件拖曳进Unity 3D中时，系统会自动为模型文件生成一个Avatar文件作为其子对象。Avatar是Mecanim动画系统自带的人形骨骼结构与模型文件中的骨骼结构间的映射，但此时选中Avatar文件时只会出现空白视口，且无法对其进行配置。 选中人形角色模型文件，在右边的Inspector视口中单击“Rig”按钮，出现视图，点击Animation Type下拉按钮，选择Humanoid选项，并单击右下角的“Apply”按钮应用该选择。至此，该模型文件已经被指定为人形角色模型，同时，系统重新为其创建了Avatar文件。 Animtion Type下拉列表有四个选项，分别为“None”、“Legacy”、“Generic”和“Humanoid”，分别对应无模式、旧版动画模式、其他动画模式和人形角色动画模式。运用于Mecanim动画系统中的人形角色动离都要选择“Humanoid”。 2.配置Avatar (1)首先选择模型文件下的Avatar文件，在Inspector视口中就会出现一个“Configure Avatar”按钮。只需单击该按钮即可进入Avatar的配置窗口。 (2)同时，系统会弹出提示窗口，用于提示是否保存场景中的所有信息。这是由于在配置Avatar的时候，系统会关闭原场景窗口，并开启一个临时Scene视口作为配置Avatar的实时显示窗口，并在配置结束后关闭该临时窗口。 (3)单击“Configure Avatar”按钮之后Inspector就会变成下图的视口。同时，Scene视口会出现骨骼，Inspector中参数的改变会实时显示在Scene视口中，可以在Scene视口中实时地看到Avatar的效果，而不必再重建场景验证其准确性。 (4)可分别单击Avatar配置视口中的“Body”、“Head”、“Left Hand”和“Right Hand”等按钮进行Avatar不同层次的配置。可以在不同的窗口进行不同部位的骨骼配置，这样做的好处是各个骨骼层次配置互不影响，并能同时播放。 (5)一般情况下Uniy 3D都会正确地对Avatar初始化，但有时候会因为骨骼的名字不规范等原因，Unity 3D不能准确地识别到相应的骨骼，此时就需要使用系统自带的工具手动对其进行校正。 (6)当遇到这种情况的时候，可以在Hierarchy视口中找到正确的骨骼，然后将正确的骨骼拖曳到Inspector视口中Optional Bone下的指定位置中。若所有骨骼都变成绿色，则代表Avalar已经配置完成。 3.Muscle的配置 实际的开发过程中，开发人员可能会遇到一些骨骼动画动作过于夸张的情况，如果使用的是旧版动画，就需要重新制作该动画，而Mecanim动画系统则为其提供了一套解决方案，读者可以通过设置Avatar中的Muscle参数，来限制角色模型各个部位的运动范围，防止某些骨骼运动范围超过合理值。 (1)单击Avatar视口中的“Muscles”按钮进入Muscle的配置窗口。该窗口由预览窗口、设置窗口及附加配置窗口组成。 (2)下面以左脚骨骼为例对其进行调整。选中设置窗口中的Left Leg参数，其附带的所有子参数也会随之展开，可以通过拖动参数左边的拖拉条，观察指定的骨骼的运动范围，同时Scene视口会在对应的骨骼上生成若干个扇形，代表骨骼旋转的范围。 (3)单击Upper Leg Front-Back参数可展开配置参数。可通过拖动其拖拉条或设置其左右参数对该骨骼的运动范围进行调整，Scene窗口中骨骼对应扇形的大小也会随之改变。下图所示的就是Upper Leg FrontBack范围为0 ~ 10的预览窗口。 (4)设置完毕之后单击配置窗口右下角的“Done”按钮结束Muscle的配置。重新播放该动画，如果骨骼的最大运动范围与动画中的运动范围有相交，则在更改后的动画中，其骨骼只会在设置的范围内运动。 除了防止过于夸张或错误的动作，设置Muscle参数还可以实现对原动画的修改。比如原动画是一个边奔跑边招手的动作，而开发所需的仅仅是一个单纯奔跑的动画，那通过限制手部的运动，便可以快速地完成动画的修改。 动画控制器的创建Mecanim动画系统引入了动画控制器的概念，通过动画控制器可以把大部分动画相关的工作从代码中分离出来，游戏动画师可以独立地完成动画控制器的创建，且不涉及任何代码。下面将介绍动画控制器的创建。 (1)首先创建一个名为“Mecanimstudy”的工程项目，然后将资源目录下的Animations、Models、Textures等文件夹依次复制进本项目中的Assets资源文件夹下，然后创建一个名为“AniControllers”的空文件夹，用于存放项目所需的动画控制器文件。 (2)读者可在AniControllers文件夹中单击鼠标右键，在弹出菜单中依次单击“Create-&gt;Animator Controller ”创建一个动画控制器，并命名为“StaticAnimatorController”。双击该动画控制器，进入动画控制器编辑窗口。 动画控制器的配置配置动画控制器是学习Mecanim动画系统的重点。 1.动画状态机和过渡条件 理解动画控制器中的方块的含义之前，需先理解Mecanim动画系统中动画状态机的概念。该动画系统基于状态机思想对游戏动画进行控制。通过使用动画状态机，游戏动画师可以进行无代码的可视化开发。下面通过下表向读者展示了动画控制器中必要的状态机意义。 名称 说明 State Machine 动画状态机，可包含若干个动画状态单元 State 动画状态单元，动面状态机机制中的最小单元 Sub-State Machine 子动画状态机，可包含若干个动画状态单元成子动画状态机 Blend Tree 动画混合树，一种特殊的动画状态单元 Any State 特殊的状态单元，表示任意动画状态 Entry 本动画状态机的入口 Exit 本动画状态机的出口 每一个动画控制器都可以有若干个动画层，每个动画层都是一个动画状态机，动画状态机中可以同时包含若干个动画状态单元或子动画状态机。每一个动画状态机都必然会含有“Any State”、“Entry”、“Exit”动画状态单元，用于实现该状态机不同的必须功能。 下面简单介绍一下动画状态单元和动画过渡条件的搭建，其详细步骤如下所示。 (1)可以通过单击鼠标右键，在弹出菜单中选择“Create State-&gt;Empty”创建空动画状态单元，也可以将动画片段直接拖曳进动画状态机编辑窗口中进行创建。在此笔者通过向编辑窗口拖曳进“Boy@ForwardKick”和“Boy@KickBack”两个动画文件，创建两个动画状态单元。 (2)然后将鼠标箭头放在动画状态单元上，单击鼠标右键选择“Make Transition”创建动画过渡条件，并再次点击在另一个动画状态单元上，完成动画过渡条件的连接。Mecanim动画系统通过动画过渡条件实现各个动画片段之间的逻辑，开发人员只需控制这些过渡条件即可实现对动画的控制。 (3)为了实现所需效果，笔者已将该动画状态机搭建成下图所示的状态，读者可按着笔者所搭建的状态进行连接，在这个动画状态机中，Idle被设为默认动画且显示为黄色，其他动画状态单元则显示为灰色，读者可以在任意非默认动画单元上单击鼠标右键选择“Set As Default”将其设置为默认动画。 2.过渡条件的参数设置 动画状态机和过渡条件搭建完成之后，就需要对状态机间的过渡条件进行设置。为了实现对各个过渡条件的操控，需要创建一个或多个参数与之搭配。Mecanim支持的过渡参数类型有Float、Int、Bool及Trigger，其在动画控制器代表的意义需要游戏动画师提前设计好。 (1)下面向游戏控制器添加一个Float类型的参数实现对游戏过渡条件的控制。点击Parameters视口中的“+”添加一个Float类型的参数，并命名为“AniFlag”，设置其初始值为-1.0。 (2)然后选中任意一个过渡条件，在Inspector视口中的Conditions列表中点击“+”按钮添加参数控制，读者进行参数的设置，为参数添加对比条件。Mecanim动画系统为Float类型的参数提供了“Greater”和“Less”对比条件。 3.代码对游戏控制器的控制 (1)动画控制器创建和配置完成之后，接下来创建一个名为“MecanimBehaviour”的场景来测试该游戏控制器是否可用，在该场景中创建一个地形，给地形添加绿色草地纹理，再将Models文件夹下的Boy模型文件拖曳到场景中，并调整光照方向至合适角度。 (2)接下来进行UI界面的开发。读者可依次单击“GameObject-&gt;UI-&gt;Button”创建一个按钮，并命名为“Button0”，按照此步骤再创建一个“Button1”按钮，这两个按钮分别用于对两个动画的控制，当按下任意一个按钮时，系统将启动对应的动画过渡。 (3)选中Boy游戏对象，为其添加一个Animator组件，并将先前创建的StaticAnimatorController动画控制器掩曳到Animator组件下的“Controller”框中。然后再新建一个C#脚本，将其命名为“StaticAniCtrl.cs”，并把脚本拖曳给Boy对象。 StaticAniCtrl脚本用于实现对动画控制器的控制、游戏按钮的响应以及摄像机的跟随。 12345678910111213141516171819202122232425262728293031323334353637383940using UnityEngine;using System.Collections;public class StaticAniCtrl : MonoBehaviour &#123; Animator myAnimator; // 声明Animator组件 Transform myCamera; // 声明摄像机对象 void Start () &#123; myAnimator = GetComponent&lt;Animator&gt;(); // 初始化Animator组件 UIInit(); // 初始化UI界面 myCamera = GameObject.Find("Main Camera").transform; // 初始化摄像机对象 &#125; void Update() &#123; myCamera.position = transform.position + new Vector3 (0, 1.5f, 5); // 摄像机对象跟随 myCamera.LookAt(transform); // 摄像机对象朝向 &#125; void UIInit() &#123; // 按钮位置 GameObject.Find("Canvas/Button0").transform.GetComponent&lt;RectTransform&gt;().localPosition = new Vector3(Screen.height / 6- Screen.width / 2, Screen.height * 2/ 5 - Screen.height /2); // 按钮大小 GameObject.Find("Canvas/Button0").transform.GetComponent&lt;RectTransform&gt;().localScale = Screen.width / 600.0f * new Vector3(1, 1, 1); // 按钮位置 GameObject.Find("Canvas/Button1").transform.GetComponent&lt;RectTransform&gt;().localPosition = new Vector3(Screen.height / 6 - Screen.width / 2, Screen.height / 6 - Screen.height /2); // 按钮大小 GameObject.Find("Canvas/Button1").transform.GetComponent&lt;RectTransform&gt;().localScale = Screen.width / 600.0f * new Vector3(1, 1, 1); &#125; public void ButtonOnClick(int index) &#123; Debug.Log(index); myAnimator.SetFloat("AniFlag", index); // 向动画控制器传递参数 &#125;&#125; 第1-20行用于Start方法和Update方法的开发。在Start方法中，初始化了Animator组件和摄像机对象， Aniamtor用于动画的播放控制，而摄像机对象则在Update方法中进行调用。Update方法中进行了摄像机对象的跟随操作，使摄像机对象与游戏角色对象相互关联。 第22-33行用于UIInit方法的开发，用于初始化游戏按钮，使本案例在任意分辨率的屏幕中都能正常运行，不至于被拉伸。 第35-38行用于按钮回调方法的开发，当被指定的按钮被按下时，系统将会调用此方法。本函数将会根据按下按钮的不同，向Animator组件传递相对应的参数值，动画控制器获得该参数之后，将对指定的过渡条件进行调控，从而实现对动画播放的操控。 (4)给Button0和Button1的On Click()添加回调，参数分别设置为1和2，如下图所示。 (5)单击运行按钮之后，案例的运行效果会显示在Game窗口中。点击屏幕上的两个按钮，可以使场景中的小男孩做出不同的动作。 角色动画的重定向角色动画的重定向是Mecanim动画系统的一大特色功能。Unity 3D提供了一套用于人形角色动画的重定向机制，游戏美工只需独立地制作好所有角色模型，而游戏动画师也可独立地进行动画的制作，且两者不互干涉，只需在Mecanim动画系统中稍做处理即可使用。 1.角色动画重定向原理 人形角色模型绑定的骨骼架构所包含的骨骼数量和名称不尽相同，难以实现动画的通用。为了解决这一个问题，Mecanim动画系统提供了一套简化过的人形角色骨骼架构，而Avatar文件就是模型骨骼架构与系统自带骨骼架构间的桥梁，重定向的模型骨骼架构都要通过Avatar与自带骨骼架构搭建映射。 映射后的模型骨骼可能通过Avatar驱动系统自带骨骼运动，这样就会产生一套通用的骨骼动画，其他角色模型只需借助这套通用的骨骼动画，就可以做出与原模型相同的动作，即实现角色动画的重定向。通过这项技术的运用，可以极大地减小开发者的工作量，以及项目文件和安装包的大小。 2.角色动画重定向的应用 (1)新建一个场景，在场景中创建两个游戏对象用于演示，将其分别命名为“Boy”和“Girl”，如下图所示，再创建一个动画控制器并命名为“SetParController”，然后再分别拖曳到两个游戏对象的Animator组件中的Controller选择框内。 (2)然后再创建一个C#脚本并将其命名为“AniController”，然后把脚本拖曳到Boy对象上。该脚本用于操控角色动画的播放、实现动画按钮的回调、实现摄像机对象的跟随。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using UnityEngine;using System. Collections;public class AniController : MonoBehaviour &#123; #region Variables Animator animator; // 声明Boy对象动画控制器 Animator girlAnimator; // 声明Girl对象动画控制器 Transform myCamera; // 声明摄像机对象 #endregion #region Function which be called by system void Start () &#123; animator = GetComponent&lt;Animator&gt;(); // 初始化Boy对象动画控制器 girlAnimator = GameObject.Find("Girl").GetComponent&lt;Animator&gt;(); // 初始化Girl对象动画控制器 UIInit(); // 初始化界面 myCamera = GameObject.Find("Main Camera").transform; // 初始化摄像机对象 &#125; void Update () &#123; myCamera.position = transform.position + new Vector3(0, 1.5f, 5);//摄像机跟随 myCamera.LookAt(transform);//摄像机朝向 &#125; #endregion #region UI recall function and setting public void ButtonOnclick(int Index) // 按钮回调事件 &#123; bool[] pars = new bool[] &#123;true, false&#125;; // 声明启动数组 animator.SetBool("JtoR", pars[Index]); // 传递控制参数 animator.SetBool("RtoJ", pars[(Index+1) % 2]); // 传递控制参数 girlAnimator.SetBool("JtoR", pars[Index]); // 传递控制参数 girlAnimator.SetBool("RtoJ", pars[(Index + 1) % 2]);//传递控制参数 &#125; void UIInit() &#123; //按钮位置 GameObject.Find("Canvas/Button0").transform.GetComponent&lt;RectTransform&gt;().localPosition = new Vector3(Screen.height / 6 - Screen.width / 2, Screen.height * 2 / 5 - Screen.height /2); //按钮大小 GameObject.Find("Canvas/Button0").transform.GetComponent&lt;RectTransform&gt;().localScale = Screen.width / 600.0f * Vector3.one; //按钮位置 GameObject.Find("Canvas/Button1").transform.GetComponent&lt;RectTransform&gt;().localPosition = new Vector3(Screen.height / 6 - Screen.width / 2, Screen.height / 6 - Screen.height / 2); //按钮大小 GameObject.Find("Canvas/Button1").transform.GetComponent&lt;RectTransform&gt;().localScale = Screen.width / 600.0f * Vector3.one; &#125; #endregion&#125; 第6-9行是进行参数的声明。 第14-26行的主要功能是Start方法和Update方法的开发。在Start方法中，进行了两个Animator组件的初始化，以便后续代码中进行参数传递，同时进行了UI界面的初始化，使其在不同分辨率的屏幕中都可以正常运行。 第31-38行的主要功能是进行按钮回调事件的开发和UI界面的初始化，当有任意一个按钮被按下时，系统将会调用此方法，并根据按下按钮的不同，进行不同的操作，向动画控制器传递一个特定的参数，从而实现对动画的操控。 (3)接下来单击运行按钮，其运行效果就会呈现在Game窗口中。当读者点击任意一个按钮时，两个游戏角色对象就会做出相同的动作。两个角色对象通过Mecanim中的动画重定向功能，同时播放同一个动画。 角色动画的混合–创建动画混合树实际的游戏开发过程中，有时候会有将两个动画混合成一个动画的需求，比如要做一个边跑边招手的动作等。在Unity 3D 4.0版本以前，想要做这样的动作只能重新制作一个动画，而如今Mecanim动画系统为开发人员提供了另一种途径，那就是角色动画的混合。 (1)首先新建一个动画控制器，并将其命名为“BlendController”。打开动画控制器编辑窗口，单击鼠标右键后依次单击“Create State-&gt;From New Blend Tree”创建一个角色动画混合树，并命名为“Blend Tree”。 (2)不难发现，动画混合树的创建按钮是“Create State”的子按钮，从中可以发现动画混合树实际上也是一个动画状态单元，在动画状态机看来，其体现出来的作用与普通动画状态单元并无区别，只是动画混合树能够将若干个动画混合成一个动画进行处理而已。 (3)双击前面创建的动画混合树，进入混合树编辑窗口。接下来新建一个Float类型的参数，并将其命名为“BlendPar”，该参数用于对动画混合的控制，Mecanim动画系统会根据这个参数值的大小，对该动画混合树进行配置。 (4)回到Inspector窗口，将Parameter参数设置为“BlendPar”，然后在Motion列表的右下角点击“+”符号添加两个动画条目，然后将Assets\Animations\FighAnis目录下的“Boy@JumpTurnKick”和“Boy@StepSideKick”动画分别拖曳到对应框内。 (5)接下来搭建一个场景，并命名为“MecanimBlend”，接着将Assets\Models目录下的Boy角色模型拖曳到场景中去。将BlendController动画控制器拖曳给Boy对象的Animator组件，然后单击运行按钮，在Game窗口中就显示了其运行效果。 开发这个动画混合树时，笔者使用了简单的1D混合方式进行混合，BlendPar参数在其中充当了混合因子的作用。除了1D混合方式，Mecanim动画系统还同时支持其他动画混合方式。 角色动画的混合–混合类型介绍角色动画混合的强大之处在于动画混合树的混合方式，不同的混合方式和巧妙的参数设置，可以混合出丰富的动画效果。动画混合树编辑窗口中的“Blend Type”下拉列表中有多个选项，下面将详细讲解这几个参数的意义和用法。 1.1D混合方式1D混合方式是最简单的动画混合方式，也是最常用的一种。每个被混合的子动画都会被分配到一个可修改的Float类型的值，开发人员通过改变挂载的混合参数实现不同的混合效果，混合参数越接近某个动画值，则该动画在混合结果中占的比例就越大。 这种混合方式的缺点是每个混合动画只能由最多两个原动画混合而成，这在一些特殊情况下就很难满足要求。而Mecanim动画系统提供的2D混合方式则刚好解决了这个问题。 2.2D Simple Directional混合方式2D Simple Directional以两个混合参数作为被混合结果动画的横纵坐标值，混合动画和混合动画以正方形的形式分布在混合面板中，各自的混合比例用正方形外围的圆圈表现出来。每个动画的分布也以颜色深浅形象地表现出来。 3.2D Freeform Directional混合方式使用了2D Freeform Directional混合方式的动画混合时，原动面的分布以另外一种方式存在。每个原动画都是一个放射性的显示面板，颜色越白动画权重越大；反之则越小同时读者可以通过移动原动画点，对显示面板进行调整。 4.2D Freeform Cartesian混合方式而2D Freeform Cartesian则是另一种混合方式，原动画用与其他动画相连的渐变表示。与其他混合方式相同，这种混合方式也通过两个混合参数控制混合动画效果，并以混合面板中的颜色深浅代表各个子动画在混合动画中的权重。 动画控制树中的混合参数在使用的过程中不可以设置为刚好等于某个原动画的值，否则将出现不可知错误。要知道，动画混合树充当的仅仅是混合的作用，不带任何的逻辑成分，不要试图通过混合树实现某段动画的关闭或开启，那样的功能只能通过搭建状态单元和过渡条件来完成。 Mecanim中的代码控制1.StateMachineBehaviour脚本开发人员可以为动画状态机或动画状态单元添加继承于StateMachineBehaviour类的脚本，用于在指定动画的播放过程中进行自定义操作，可在该脚本中进行下表所示方法的重写，这些方法在StateMachineBehaviour类中已经被定义。 方法签名 说明 OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) 当动画开始播放的时候被调用一次 OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) 当动画已经在播放时，每一帧调用一次 OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) 当动画结束播放时播放一次 OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) 当动画被移动时播放 OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) 当动面触发逆向运动学时调用此方法 简单的案例：(1)首先创建一个C#脚本，将其命名为“FKBehaviour”，并使其维承于StateMachineBehaviour类。该脚本的主要功能是实现对角色对象挂载的脚本的开启和关闭。与其他脚本不同的是，该脚本的挂载对象是动画状态单元，而不是游戏对象。其详细代码如下所示。 12345678910111213141516171819using UnityEngine;using System.Collections;public class FKBehaviour : StateMachineBehaviour &#123; // 动画开始播放时进行的操作 override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) &#123; // 开启脚本 GameObject.Find("Boy").GetComponentInChildren&lt;MeleeWeaponTrail&gt;().enabled = true; &#125; // 动画结束时进行的操作 override public void OnStateExit(Animator animator, AnimatorStateInfo stateInto, int layerIndex) &#123; // 关闭脚本 GameObject.Find("Boy").GetComponentInChildren&lt;MeleeWeaponTrail&gt;().enabled = false; &#125;&#125; 该脚本主要用于OnStateEnter和OnStateExit方法的重写。这两个方法分别在被挂载动画开始播放和结束播放时运行，并开启和关闭挂在Boy对象上的Melee Weapon Trail脚本。 (2)接下来打开前面创建的MecanimBehaviour场景，把Assets/Scripts目录下的Melee Weapon Trail脚本拖曳给Hierarchy窗口中的Boy/Boy/Boy Pelvis/Boy Spine/Boy R Thigh/Boy R Calf下的Boy R Foot对象上。Melee Weapon：近战武器Pelvis：骨盆Spine：脊柱Thigh：大腿calf：小腿肚 (3)然后给Boy R Foot创建名为Base和“Tip”子对象，再将这两个子对象分别拖曳到Melee Weapon Trail脚本中的Base和Tip条目中。该脚本主要用于使Boy对象的右脚产生一个划痕，前面开发的FKBehaviour脚本通过开启和关闭本脚本来说明其作用。 (4)双击前面创建的StaticAnimatorController动画控制器，选中ForwardKick状态单元，单击Inspector窗口中的“Add Behaviour”，在弹出的下拉框中选择FKBehaviour脚本。 (5)然后单击运行按钮，观察Game窗口。当点击按钮1时，Boy对象播放KickBack动画，此时运行效果与其他动画相比并无异样；而当点击按钮0时，Boy对象播放ForwardKick动画，Boy对象的右脚就会出现一道划痕。 2.通过代码生成动画控制器如果需要创建一个带有10个动画状态单元的动画控制器，任意一个动画都可以过渡到其他动画包括自身，那就需要为这个动画控制器搭建100个过渡条件，直接搭建不仅工作量大，也不便于以后的修改和维护，因此有必要掌握通过代码动态生成动画控制器的方法。下面通过一个简单的案例讲解动态生成动画控制器的方法。(1)打开MecanimStudy工程项目，在Assets目录下创建一个名为“Editor”的文件夹，该文件夹用于存放编辑器类脚本文件。在该文件夹中创建一个C#脚本,并命名为“CreateController”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using UnityEngine;using System.Collections;using UnityEditor.Animations;using UnityEditor;public class CreateController : Editor // 该类继承于编辑器类&#123; [MenuItem("CreateAnimator/CreateDynamicController")] //指定按钮 static void Run() &#123; // 生成控制器 AnimatorController dynamicController = UnityEditor.Animations.AnimatorController.CreateAnimatorControllerAtPath("Assets/AniControllers/DynamicController. controller"); // 根动画 AnimatorStateMachine rootStateMachine = dynamicController.layers[0].stateMachine; AnimatorState[] states = new AnimatorState[10]; // 声明动画状态单元集合 for (int i = 0; i &lt; states.Length; i++) // 遍历动画状态单元集合 &#123; states[i] = rootStateMachine.AddState("state" + i); // 向状态机添加动画 states[i].speed = 1.5f; // 初始化动画播放速度 &#125; rootStateMachine.defaultState = states [0]; // 初始化根动画 AnimationClip[] anis = new AnimationClip[10]; // 声明动画片段集合 for (int i = 0; i &lt; anis.Length; i++) // 获取动画片段 &#123; anis[i] = AssetDatabase.LoadAssetAtPath("Assets/Animations/AnisWithNum/Ani" + i + ".FBX", typeof(AnimationClip)) as AnimationClip; // 获取动面片段 states[i].motion = anis[i]; // 设置动画状态中的动画片段 states[i].iKOnFeet = false; // 关闭逆向运动学 &#125; for (int i = 0; i &lt; states.Length; i++) // 构建动画过渡条件 &#123; for (int j = 0; j &lt; states.Length; j++) &#123; dynamicController.AddParameter("state" + i +"TOState" + j, AnimatorControllerParameterType.Trigger); // 在动画控制器中生成一个触发器参数 AnimatorStateTransition trans = states[i].AddTransition(states[j], false); // 生成触发器 trans.AddCondition(AnimatorConditionMode.If, 0, "state" +i + "TOstate" + j); // 指定触发器参数 &#125; &#125; states[states.Length - 1].AddExitTransition(); // 指定输出动画 &#125;&#125; 口第1-25行的主要功能是进行动画控制器的创建，同时在动画控制器中创建10个动画状态单元，然后把Assets/Animations/AnisWithNum目录下的10个动画分别配置到这10个动画状态单元中去，最后再进行动画速度和逆向运动学的设置，统一其运行效果。 口第26-32行的主要功能是给前面创建的任意动画状态单元之间创建动画过渡条件，同时为每一个过渡条件创建并匹配一个过渡参数，这些参数根据前后动画名进行命名，以便在控制脚本中进行控制，最后给动画控制器指定结束动画，完成本脚本的开发。 (3)现在打开Unity 3D，可以在菜单栏见到”CreatAnimator/CreateDynamicController”按钮,如图10-109所示,该按钮在CreateController脚本中声明。单击该按钮,在Assets/AniControllers目录下将会生成一个名为”DynamicController”的动画控制器,如图10-110所示。 (4)双击刚生成的DynamicController动画控制器，可在动画控制器编辑窗口查看其详情，拖动上面的动画状态单元，可发现其结构比想像中的复杂得多，同时，该动画控制器携带了大量的过渡参数。而这些复杂的结构均由CreateController脚本动态生成。 (5)接下来创建一个场景来检验一下动态动画控制器的可行性。新建一个名为“MecanimCreate”的场景，并将AssetsModels目录下的Boy模型文件拖曳到场景中，并创建10个按钮。然后把前面创建的DynamicController动画控制器拖曳到Boy对象的Animator组件中。 (6)接下来创建一个C#脚本，并将其命名为“DynamicAniCtr”，然后再拖曳到Boy对象上。该脚本用于操控角色动画的播放、实现动画按钮的回调、实现摄像机对象的跟随。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using UnityEngine;using System.Collections;public class DynamicAniCtrl : MonoBehaviour&#123; private Animator myAnimator; // 声明Animator组件 private Transform cameraHandle; // 声明摄像机对象 void Start() &#123; cameraHandle = GameObject.Find("Main Camera").transform; // 初始化摄像机对象 myAnimator = GetComponent&lt;Animator&gt;(); // 初始化动画组件 UIInit(); // 进行UI界面的初始化 &#125; void Update() &#123; cameraHandle.position = transform.position + new Vector3(0, 1.2f, 4); // 摄像机跟随 cameraHandle.LookAt(transform); // 摄像机朝向 &#125; void UIInit() &#123; //UI界面的初始化 Transform uiCanvas = GameObject.Find("Canvas").transform; //获取UI引用 for (int i = 0; i &lt; uiCanvas.childCount; i++) //遍历UI集合 &#123; // 设置按钮位置 uiCanvas.GetChild(i).GetComponent&lt;RectTransform&gt;().localPosition = new Vector3(-Screen.width * 0.4f * i / 5 * Screen.height / 6, Screen.height / 3 - i % 5 * Screen.height / 6, 0); // 设置按钮大小 uiCanvas.GetChild(i).GetComponent&lt;RectTransform&gt;().localScale = Screen.width / 600.0f * new Vector3(1, 1, 1); &#125; &#125; public void ButtonOnClick(int index) // 按钮回调事件 &#123; for (int i = 0; i &lt; 10; i++) // 遍历所有按钮 &#123; if (myAnimator.GetCurrentAnimatorStateInfo(0).IsName("state" + i)) // 当按下指定按钮 &#123; myAnimator.SetTrigger("state" + i + "TOstate" + index); // 激活指定触发器 return; // 结束遍历 &#125; &#125; &#125; &#125; 口第1-14行的主要功能是进行Start和Update方法的开发。在Start中进行了摄像机对象和Animator组件的声明和初始化,同时进行了UI界面的初始化，使该案例在任意分辨率屏幕中都可以正常运行。Update方法实现了摄像机对象的实时跟随和朝向。 口第15-28行的主要功能是进行了UIInit和ButtonOnClick方法的开发。UIInit根据当前屏幕的尺寸和分辨率，进行了按钮的位置和大小的初始化。ButtonOnClick方法实现了按钮的回调，当按下任意一个按钮时，系统将向动画控制器发送指令，使其播放相对应对动画。 (7)最后单击运行按钮,其运行效果会出现在Game窗口中,如图10-115所示。场景中的Boy对象挂载了前面通过代码生成的动画控制器,读者点击其中的任意一个按钮之后,场景中的Boy对象将会调用Animator组件中的动画控制器播放指定的动画片段,如图10-116所示。 (1)首先创建一个场景，并命名为“MecanimScene”。然后把Models文件夹中的Boy模型文件拖曳到Scene窗口中，接着再创建一个地形，并命名为“Terrain”。调整灯光朝向，使场景足够明亮。 (2)接下来导入一个EasyTouch的插件。双击该插件，导入该插件，再打开Unity，可发现菜单栏多了图10-119所示的按钮。然后依次单击“Hedgehog Team-EasyTouch-Extensions”下的“Adding a new joystick”和“Adding a new button”添加一个虚拟据杆和四个按钮。 (3)在场景创建完成之后，开始进行动画控制器的创建和配置。首先新建一个动画控制器，并命名为“AniController”。该动画控制器将用于对本案例中所有动画的播放控制。 (4)双击该动画控制器，进入动画控制器的编辑窗口，然后将Assets/Animations/FightAnis目录下的“ldle” “Walk” “JumpDodge” “TurnKick “ “StepSideKick”以及”CartWheel”等动画拖曳进动画控制器编辑窗口。 (5)然后为动画控制器依次添加”Tigger2SSK “ “Trigger2JD” “Trigger2cW” “Trigger2TK””TriggerZExit”Triger walk”和”Trgger2ldle”等触发器类型的动画过渡参数,如图10-123所示。这些参数将分别用于操控动画控制器中各个动画的播放。 (6)然后为动画控制器搭建过渡条件至图10-124所示效果,并为所有过渡条件添加过渡参数。由于篇幅所限,各个过渡条件与参数间的详细搭配关系在此就不再赘述,读者可参考随书光盘/第10章/Mecanimstudy/Assets/AniControllers目录下的”AniController”文件进行配置。 (7)把AniController动画控制器拖曳到Boy对象的Animator组件下面。接下来在Scripts 文件夹中新建一个C#脚本,并命名为”HeroController”,该脚本用于实现对动画播放的控制,然后将这个脚本拖曳到Boy对象上。该脚本的详细代码如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071using UnityEngine;using System.Collections;public class HeroController : MonoBehaviour&#123; #region Variables private Animator myAnimator; // 声明Animator组件 private Transform myCamera; // 声明摄像机对象 private EasyJoystick myJoystick; // 声明摇杆 private EasyButton[] myButtons = new EasyButton[4]; // 声明游戏按钮 private string[] triggerStrings = new string[] &#123; "Trigger2SSK", "Trigger2JD", "Trigger2CW", "Trigger2TK"&#125;; // 声明游戏控制器参数名 public static bool isWalk; // 是否正在播放行走动画 # endregion #region StartFunction void Start() &#123; myAnimator = GetComponent&lt;Animator&gt;(); // 初始化Animator组件 myCamera = GameObject.Find("Main Camera").transform; // 初始化摄像机对象 myJoystick = GameObject.Find("MyJoystick").GetComponent&lt;EasyJoystick&gt;(); // 初始化摇杆 for (int i = 0; i &lt; myButtons.Length; i++) // 遍历按钮集合 &#123; myButtons[i] = GameObject.Find("Button" + i).GetComponent&lt;EasyButton&gt;(); // 初始化按钮 &#125; &#125; #endregion #region UpdateFunction void Update() &#123; CameraBehaviour(); // 摄像机控制操作 DirectBehaviour(); // 摇杆响应操作 &#125; void CameraBehaviour() &#123; myCamera.position = transform.localPosition + new Vector3(0, 2, -5); // 摄像机对象跟随 myCamera.LookAt(transform); // 摄像机对象朝向 &#125; void DirectBehaviour() &#123; if (myJoystick.JoystickTouch != Vector2.zero) // 当摇杆有所触碰时 &#123; if(!isWalk) &#123; myAnimator.SetTrigger("Trigger2Walk"); // 传递行走参数 &#125; isWalk = true; // 修改标志位 transform.LookAt(new Vector3(myJoystick.JoystickTouch.x * 10000, transform.position.y, myJoystick.JoystickTouch.y * 10000)); // 对象朝向设置 &#125; else &#123; if(isWalk) &#123; myAnimator.SetTrigger("Trigger2Idle"); &#125; isWalk = false; &#125; &#125; void ButtonOnClick(string button) &#123; myAnimator.SetTrigger(triggerStrings[button.ToCharArray()[button.Length -1] - 48]); // 传递参数 &#125; #endregion&#125; 口第1-20行的主要功能是进行Start方法的开发。在该方法中进行了动画组件、摄像机对象及U1界面的声明和初始化,同时声明一个参数集合,便于在开发过程中对动画播放进行控制。口第21-44行的主要功能是行Update方法的开发。该方法主要调用了CameraBehaviour和DirectBehaviour函数,这两个函数分别进行了摄像机对象跟随的开发和虚拟摇杆的监控,使场景中的Boy对象实时地朝向摇杆所指向的地方。 口第45-49行的主要功能是实现四个UI按钮的监听。当读者按下任意一个按钮时,系统将调用该方法,向动画控制器传递相对应的参数,实现对动画播放的控制。 (8)最后读者可通过单击运行按钮来运行本案例, Game窗口将显示本案例的运行效果,如图10-125所示。当读者操控虚拟摇杆时,场景中的Boy对象将按摇杆指向的方向行走;当读者点击四个按钮中的任意一个时,场景中的Boy对象将执行相对应的动作,如图10-126所示。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity游戏开发技术详解与典型案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用旧版动画系统的简单案例]]></title>
    <url>%2F2019%2F02%2F15%2F%E4%BD%BF%E7%94%A8%E6%97%A7%E7%89%88%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1.首先创建一个3D项目，命名为“OldAnimation”。创建一个场景，命名为“Demo”。 2.接下来导入准备好的模型资源包，该文件夹包含了带角色动画的人物模型以及模型贴图。依次单击Unity菜单栏的“Assets-&gt;Import New Assets…”，找到模型资源，将其导入Unity。该模型自带了6个动画片段。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旧版动画系统]]></title>
    <url>%2F2019%2F02%2F15%2F%E6%97%A7%E7%89%88%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[该动画系统主要使用脚本控制动画的播放。 导入角色动画资源Unity 3D中导入角色动画的常见方式有两种：使用多个模型文件导入动画和使用动画分割技术导入动画。使用多个模型文件导入会增加模型文件的数量，但这种方法便于进行管理，而使用动画分割导入只需导入少量的模型，但对动画制作和后期分割都有较高要求。 1.使用多个模型文件导入动画Unity 3D支持FBX格式的模型文件格式，可以通过Maya、3D Studio Max、 MotionBuilder等建模软件进行角色模型的建模，并将其导出为FBX格式的3D文件，然后再导入到Unity 3D中去。在建模的过程中需要对角色模型进行骨骼绑定和蒙皮处理，以便在动画系统中进行处理。 口 读者可以导出带骨骼动画的人形角色模型文件，或只有骨骼动画的FBX文件。建议使用第二种方法导出动画，并另外导出一个经过骨骼绑定和蒙皮处理且不带骨骼动画的角色模型，这样可以最大限度地减小项目文件的大小，同时不影响各个动画的使用。 口导出带骨骼动画的模型文件时，需要遵循“角色模型名@动作名”的命名方案，该命名方案可以使动画文件迅速匹配到角色模型，为开发提供方便，遵循该命名方案有助于提高开发效率. 2.使用动画分割导入动画除了上一节中介绍的使用多个模型文件逐个导入动画的方式外,读者还可以直接导入一个包含多个动画的模型文件，然后在Unity 3D中将其分割成多个动画文件。这种方法可以极大地减小项目文件的大小。下面将向读者详细介绍这种技术的使用。 口导出带动画的角色模型文件，将其拖曳到Unity 3D中去，选中角色模型文件，在Inspecton窗口中单击Animations按钮，会得到下图所示的分割操作窗口，动画分割操作将在此窗口中进行，其相关参数如下表所示。 参数 说明 Start 动画片段的第一帧 End 动画片段的最后一帧 Loop Time 是否设定该动画片段为循环动画 Loop Pose 是否设定该动画片段的姿势循环 Cycle Offset 为该动画片段指定一定的偏移量 口动画分割操作并不复杂，可单击动画片段列表右下角的“+”或“.”符号来进行动画片段的增删操作。拖动动画滑杆或修改“Start”和“End”参数可以修改该动画片段的长度，而分割出的动画片段就会变成模型文件的子对象，如下图所示。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相机、渲染和场景]]></title>
    <url>%2F2019%2F02%2F15%2F%E7%9B%B8%E6%9C%BA%E3%80%81%E6%B8%B2%E6%9F%93%E5%92%8C%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[一般地讲，相机可表示为视见点并以此渲染场景，即3D空间内的一点，并以此产生场景视图，根据既定视角和视域，经捕捉后，将以像素形式光栅化至纹理中。此后，结合之前的渲染结果，渲染至屏幕上。 相机Gizmo当相机在Scene选项卡中被选取，且开启Gizmo显示时，将根据某些属性，例如视域，显示视锥Gizmo。其中，可查看相机在场景中的位置，以及基于当前视图的相机视见内容。 Gizmo对于所选相机的定位十分重要，并可据此获得最佳的场景视图。但是，会想要在未被选择的相机中定位对象。此时用户需要在相机的视锥体内移动特定对象，并确保对象相对于该相机可见。默认条件下，当相机处于未选取状态时，通常并不会显示其视锥Gizmo。这意味着，当移动对象时，需要持续选取相机，以检测移动对象是否真正位于相机视锥体内，并在必要时调整其位置。需要提供稳定的视锥体Gizmo查看机制，即使当前相机未被选中。将以下代码作为相机的组件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using UnityEngine;using System.Collections; [ExecuteInEditMode][RequireComponent(typeof(Camera))]public class DrawFrustumRefined : MonoBehaviour&#123; private Camera Cam = null; public bool ShowCamGizmo = true; void Awake() &#123; Cam = GetComponent&lt;Camera&gt;(); &#125; void OnDrawGizmos() &#123; //Should we show qizmo? if (!ShowCamGizmo) return; //Get size (dimensions) of Game Tab Vector2 v = DrawFrustumRefined.GetGameViewSize(); float GameAspect = v.x / v.y; //Calculate tab aspect ratio float FinalAspect = GameAspect / Cam.aspect; Matrix4x4 LocalToWorld = transform.localToWorldMatrix; Matrix4x4 ScaleMatrix = Matrix4x4.Scale(new Vector3(Cam.aspect * (Cam.rect.width / Cam.rect.height)， FinalAspect， 1)); Gizmos.matrix = LocalToWorld * ScaleMatrix; Gizmos.DrawFrustum(transform.position， Cam.fieldOfView， Cam.nearClipPlane， Cam.farClipPlane， FinalAspect); Gizmos.matrix = Matrix4x4.identity; //Reset gizmo matrix &#125; //Function to get dimensions of game tab public static Vector2 GetGameViewSize() &#123; System.Type T = System.Type.GetType("UnityEditor.GameView， UnityEditor"); System.Reflection.MethodInfo GetSizeOfMainGameView = T.GetMethod("GetSizeOfMainGameView"， System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static); return (Vector2)GetSizeOfMainGameView.Invoke(null， null); &#125;&#125; Gizmos.DrawFrustum()函数接收世界场景空间内的参数（而非局部空间），例如位置和旋转状态，即全部位置参数须首先通过某一矩阵从局部空间转换至世界空间，并可通过Transform类的localToWorldMatrix成员予以实现。除此之外，还需进一步计算实际视口高度和宽度，以及游戏窗口宽度和高度之间的宽高比参数。 GetGameViewSize()函数返回2D向量，并以此表示Game选项卡视图的实际像素尺寸。该函数通过非正式发布的编辑器特性接收此类数据值。这里，请注意函数调用的“非正式”特性，代码的有效性很容易受到某些特性，甚至是维护性版本的影响。 下图显示了视锥体效果。 可见性对象X是否相对于相机Y可见？对象X是否相对于任意相机均可见？或者，针对特定相机或任意相机，对象何时处于可见状态或不可见状态？如果相机Y移至位置Z，则对象X是否可见？需要根据全部的相机位置，并针对当前帧考察对象的可见性。了解对象（例如敌方角色）相对于相机的可见性有助于定义其运动行为和AI：当对象处于不可见状态时，某些行为和计算则无须进一步执行，进而可节省处理的载荷量。进一步讲，若知晓相机移动过程中对象的可见性，则可预测对象在下一帧中的可见性，进而提前进行准备。下面先讨论狭长场景中对象的可见性。 关于对象的可见性，存在两种主要概念，即视锥体和遮挡行为。具体而言，各种透视相机均包含了视锥体，该视锥体表示为梯形空间体，从相机镜头处向外扩展，并包含了视域定义的对应区域，以及剪裁面距离属性。实际上，视锥体从数学角度定义了相机的视野，即相机可潜在观察到的场景区域。这里，术语“潜在”是指，即使处于活动状态的可见对象位于相机视锥体内，但并不意味着相对于相机可见，其原因可解释为：某些视锥体内的对象可遮挡其中的其他对象，较近的对象可全部或部分遮挡或掩盖其后的对象。因此，实际的可见性测试至少涉及了两个处理步骤：首先，需要确定对象是否位于视锥体内；其次，还应进一步确定该对象是否被遮挡。仅当对象通过了上述两个测试，方可归类于相机可见对象中。随后，可见对象将被着色器或其他后处理操作进行渲染。 检测对象的可见性最为简单、直接的对象可见性测试则是判断对象何时相对于相机可见。 针对包含渲染器组件的任意对象，两个伴随事件OnBecameVisible和OnBecamelnvisible将自动被调用，包括MeshRenderer和SkinnedMeshRenderer。 当然，空游戏对象并不会被调用，即使此类对象位于相机的视见范围内。从技术上讲，这一类对象并未包含任何可见成分，尽管其中的全部内容均实现了空间定位。此类事件的处理过程如示例代码所示。 123456789101112131415using UnityEngine;using System. Collections;public class ViewTester : MonoBehaviour&#123; void OnBecameVisible() &#123; Debug.Log("Became visible")； &#125; void OnBecameInvisible() &#123; Debug.Log("Became Invisible")； &#125;&#125; 此处，需要注意OnBecameVisible和OnBecameInvisible事件。首先，这里所讨论的可见性仅表示对象位于相机视锥体内，可被其他较近的对象所遮挡，因而实际不一定可见。其次，事件应用于全部相机，而非某一特定相机。OnBecameVisible事件调用一次后表明，之前的不可见对象进入了相机（至少一部相机）的视锥体。类似地，OnBecamelnvisible事件调用一次后表明，之前的可见对象当前离开全部相机的视锥体。最后，此类函数还涵盖了场景相机的可见性。这也说明，如果用户利用Scene选项卡测试游戏，且对象在该选项卡中可见，则该对象即处于可见状态。简而言之，仅当用户行为依赖于场景中的全部可见性（或不可见）时， OnBecameVisible和OnBecamelnvisible方法将十分有用。其中，可见性仅对应于视锥体的呈现效果。换而言之，此类事件可用于对相关行为进行切换，例如与可见性相关的AI行为、NPC的恐慌行为，以及其他NPC的交互类型。 关于对象可见性的其他问题除了测试对象何时进入/离开相机的可见性范围之外，另一项重要的检测则是对象与特定相机间的可见性。与OnBecame Visible和OnBecamelnvisible不同（当对象进入或驶离视锥体时，执行单次调用），该测试类型关注对象的当前状态，并假设对其之前的情况并不了解。对此，可采用OnWillRenderObject事件。该事件持续在某一对象上被调用，针对各可见相机每帧调用一次。这里，可见性是指“位于相机视锥体内部”。再次强调，其中并未涉及遮挡测试。在如下示例代码中，需要注意的是，该事件内部的Camera.current成员可用于获取指向（对象可见）相机的引用，同时也包括场景视见相机。 1234void OnWillRenderObject()&#123; Debug.Log(Camera.current.name)； &#125; 视锥体测试-渲染器用户可能会简单地测试某一相机是否可看到渲染器；可见对象是否处于不可见状态；相机是否可查看到空间内的特定点：如果相机移至新位置，相机是否可观察到特定对象。此类内容均可视为不同环境下的重要可见性测试，且需要执行某种程度上的手动测试。 相关函数经过适当整合后将作为静态函数定义于CamUtility类中。下面首先创建一个函数，并测试特定渲染器是否位于特定Camera对象的视锥体内，如示例代码所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using UnityEngine;using System.Collections;public class CamUtility&#123; //Function to determine whether a renderer is within frustum of a specified camera //Returns true if renderer is within frustum, else false public static bool IsRendererInFrustum(Renderer Renderable, Camera Cam) &#123; //Construct frustum planes from camera //Each plane represents one wall of frustrum Plane[] planes = GeometryUtility.CalculateFrustumPlanes(Cam); //Test whether renderable is within frustum planes return GeometryUtility.TestPlanesAABB(planes, Renderable.bounds); &#125; //Function to determine whether a point in the scene is within frustum of a specified camera //Returns true if point is within frustum, else false //The out param ViewPortLoc defines the location of the point on screen, if function returns true public static bool IsPointInFrustum(Vector3 Point, Camera Cam, out Vector3 ViewPortLoc) &#123; //Create new bounds with no size Bounds B = new Bounds(Point, Vector3.zero); //Construct frustum planes from camera //Each plane represents one wall of frustrum Plane[] planes = GeometryUtility.CalculateFrustumPlanes(Cam); //Test whether point is within frustum planes bool IsVisible = GeometryUtility.TestPlanesAABB(planes, B); //Assign viewport location ViewPortLoc = Vector3.zero; //If visible then get viewport location of point if(IsVisible) ViewPortLoc = Cam.WorldToViewportPoint(Point); return IsVisible; &#125; //Function to determine whether an object is visible (in frustum and has unbroken line to camera) public static bool IsVisible(Renderer Renderable, Camera Cam) &#123; //If in frustrum then cast line if(CamUtility.IsRendererInFrustum(Renderable, Cam)) return !Physics.Linecast(Renderable.transform.position, Cam.transform.position); //Is direct line between camera and object? return false; //No line found or not in frustum &#125;&#125; GeometryUtility类用来生成平面对象数组，并以此描述相机的视锥体。相应地， 3D空间内的平面对应于2D空间内的直线，并定义了3D空间内的虚构延展表面。此处，视锥体平面表示为6个平面构成的集合，在3D空间内经过适当的旋转和对齐操作，进而表示为完整的梯形相机视锥体。随后，TestPlanesAABB函数、轴对齐包围盒（AABB）均会使用到该数组，并以此判断网格渲染器的碰撞包围体是否位于上述平面所定义的视锥体内部。 视锥体测试-点当然，用户并非总是针对可见性测试渲染器。相反，某些时候需要对点进行测试，其中包含了两个原因。首先，用户需要了解某一对象，例如粒子或射击目标位置，是否真实可见。其次，用户不仅需要知晓一点是否可见，同时还需进一步确定该点在屏幕空间内的具体位置。对应结果通过相机进行渲染。示例代码5-5实现了这一功能，其中，代码测试了某一点是否位于相机视锥体内。若是，则返回该点在规范化视口空间内、屏幕上的渲染位置(位于0-1之间)。 视锥体测试-遮挡如前所述，严格意义上的可见性的处理过程包含了两个阶段。当前，全部可见性测试仅检测了对象在相机视锥体内的呈现结果。通常情况下，该过程已然足够且应用范围广泛。但在视锥体内的诸多对象中，对象间可能存在彼此遮挡这一状况。例如，较远的对象可能会被较近的对象部分或全部遮挡。就自身而言，这并非绝对意义上的问题且时有发生。确定对象可见性的主要目标是，针对一组性能敏感的行为(例如AI行为)，需要知晓相机与其是否足够近。该目标并非是真正意义上的可见性测试，而是一种距离计算。其中，重点内容并非是对象间的遮挡行为，而是对象是否位于视锥体内。尽管如此，某些时候依然需要对遮挡行为予以考虑。例如，当玩家查看特定对象时，将显示GUI元素或消息内容。期间，遮挡行为将变得较为重要-对象的GUI不应在墙外加以显示。某些时候，用户可通过碰撞器、触发器以及准确的对象定位避免此类行为；但在某些场合下，则只能通过遮挡测试剔除视锥体内的对象。视锥体中的对象遮挡测试占用了较大的性能开销，对此，较好的做法是使用相对简单的Physics.LineCast方法调用，并确定相机与目标对象间的虚构直线是否与碰撞器相交。通常，该方法工作良好，但读者也应对其局限性有所了解。首先，该方案假设全部可见对象均具有碰撞器，否则将无法通过LineCast方法进行检测。其次，碰撞器仅近似表达了网格包围体，且并未包含全部网格顶点。若网格包含内部孔洞，则LineCast方法将会失效。最后，包含透明材质的网格(可查看到其后方对象)通常无法正常调用LineCast方法。下面考察示例代码5-6. 相机前、后视觉在某些游戏中，例如RTS游戏或休闲游戏，相机的远剪裁面并不十分重要-相机仅查看其前方事物。此时，当对象位于视锥体外部时，该对象仅在x和y平面中位于外部，而非局部2轴上。也就是说，隐藏对象之所以处于隐藏状态，只因相机未直接对其进行查看。然而，当对相机的方向进行适当调整时，对象的距离将被拉近，其不会超出远剪裁面。其中，可见性测试转化为简单、快速的方向测试。因此，问题从“对象是否位于视锥体内且未被遮挡”变为“对象位于相机的前方还是后方”。相应地，最终答案也有所变化，问题不再是可见性计算，而是方向计算，即相机和目标对象之间的方向关系：目标对象位于相机的前方或是后方。当对此进行测试时，可采用向量的点积计算。这里，点积接收两个向量作为参数，并将其简化为一维数值计算作为输出结果。该值描述了两个输入向量之间的角度关系。在示例代码5-7中， CamFieldView类与相机绑定，并检测相机是否可查看到目标对象，目标对象位于相机前方的既定视域内。 1234567891011121314151617181920212223242526272829303132333435363738using UnityEngine;using System.Collections;public class CamFieldView : MonoBehaviour &#123; //Field of view (degrees) in which can see in front of us //Measure in degrees from forward vector (left or right) public float AngleView = 30.0f; //Target object for seeing public Transform Target = null; //Local transform private Transform ThisTransform = null; // Use this for initialization void Awake () &#123; //Get local transform ThisTransform = transform; &#125; // Update is called once per frame void Update () &#123; //Update view between camera and target Vector3 Forward = ThisTransform.forward.normalized; Vector3 ToObject = (Target.position - ThisTransform.position).normalized; //Get Dot Product float DotProduct = Vector3.Dot(Forward, ToObject); float Angle = DotProduct * 180f; //Check within field of view if(Angle &gt;= 180f-AngleView) Debug.Log ("Object can be seen"); &#125;&#125; 正交相机默认状态下， Unity中新创建的相机对象均设置为透视相机，当然，用户可对此进行调整。这一类相机模型接近于真实相机设备：在3D空间内具有一定的位置，配备了曲面透镜，并通过相关方法将捕捉到的图像转换至2D平面上，例如屏幕。这一类相机的特征主要体现在透视收缩方面，并应用于渲染对象上。特别地，随着距离的增加，渲染对象将随之变小。另外，随着与视见中心之间距离的不断增加，对象的形状和外观也将发生变化。与此同时，全部平行线相交于远处(地平线或辅助线)某一消失点。与透视相机相比，正交相机适合创建真正的2D等轴测游戏，而非等轴测仿制游戏。当采用正交相机时，其镜头展为一个平面且不再具备透视收缩特征，即平行线处于平行状态，对象不再随距离的变化而收缩，即使远离视见中心位置， 2D内容依然保持2D状态，等等。通过Object Inspector中的Projection类型设置，用户可方便地在Perspective和Orthographi之间进行切换，如图5-3所示。 在将Perspective类型转换为Orthographic之后，相机的视锥体也随之从梯形转换为盒体形状。其中，盒体内的全部内容均处于可见状态，且近距离对象将遮挡远处的对象。除此之外，全部深度信息均将丢失，如图5-4所示，因而此类相机适用于2D游戏。 当与正交相机协同工作时，核心问题是如何在世界单位(场景)与像素(屏幕)之间生成1：1的关系。在2D游戏和GUI中，正交相机可通过默认的正确尺寸(定义于纹理文件中)将图形显示于屏幕上。相比较而言，在大多数3D游戏中，纹理贴图、透视缩减以及透视关系意味着纹理将产生变形，并投影至3D对象表面上。即使在照片编辑软件中，对应内容也将以透视方式展示。对于2D游戏和精灵对象，情况则有所不同-图形多采用直视方式进行查看。因此，可通过默认尺寸和逐像素方式显示此类图像。这种显示方式称作完美像素，其中，纹理中的各个像素均以不变的方式显示于屏幕或游戏中，实际操作过程中则需要采用特殊的方案。简而言之，将1个世界单位映射为1个像素， Camera选项卡中的Size文本框需要将游戏的垂直分辨率设置为一半。因此，如果游戏在1024x768分辨率下运行，则Size应为364 (768 /2=364) ，如图5-5所示。 用户可直接在编辑器中设置Size值，但这仅在游戏分辨率不变的情况下有效。如果用户重新调整游戏窗口，并改变了游戏的分辨率，则需要在脚本中更新相机的尺寸，如示例代码5-8所示。 123456789101112131415161718192021222324using UnityEngine;using System.Collections;[RequireComponent(typeof(Camera))] //Requires camera component to workpublic class OrthoCam : MonoBehaviour&#123; //private reference to camera component private Camera Cam = null; //Reference to Pixels to World Units Scale public float PixelsToWorldUnits = 200f; void Awake () &#123; //Get camera reference Cam = GetComponent&lt;Camera&gt;(); &#125; void LateUpdate () &#123; //Update orthographic size Cam.orthographicSize = Screen.height / 2f / PixelsToWorldUnits; &#125;&#125; 需要注意的是，第13行代码中添加了成员变量PixelsToworldUnits，并根据导入后的精灵对象纹理中的Pixels To Units缩放正交尺寸，如图5-6所示。当在屏幕上显示时，这可确保精灵对象以正确的像素尺寸予以显示。除此之外，全部精灵对象还将通过该值进行缩放，进而将纹理的像素尺寸映射至世界单位。 相机渲染和后处理Unity相机和对象针对场景的渲染方式提供了较大的灵活性，且常见于后处理操作中。特别地，针对常规渲染之外的内容，其中涉及了辅助编辑和修正操作，包括模糊效果、色彩调整、鱼眼效果等。 将尝试构建一个相机变化系统，相机间呈现为平滑的淡入淡出效果。也就是说，相机间不会直接切换，而是通过渐变方式改变相机的景深。具体地讲，第一部相机的输出内容将以非透明方式逐渐切换，进而显示第二部相机的输出内容。下面将对此展开讨论。 图5-7所示场景项目包含了两个独立的区域。其中，各区域应绑定独立的相机对象，因而场景中设置了两部相机，且各相机组件应处于禁用状态--这可防止相机对其自身进行自动渲染。此处将通过手动方式渲染相机，进而整合源自各相机的渲染器，以实现二者间的淡入淡出效果。 各部相机均移除了AudioListener组件，其原因在于，任意时刻， Unity场景仅可包含一个处于活动状态的AudioListener。 随后，可在场景原点处创建第三部相机（标记为MainCamera)，并设置空剔除遮罩，以确保相机处于活动状态，但不会对任何内容进行渲染。这定义为主场景相机，并整合了源自其他相机的渲染器，如图5-8所示。 当前场景包含了3部相机，其中，两部独立相机（相机x和相机Y）位于不同位置且处于禁用状态，一部主相机（相机Z）位于场景原点处。在此基础上，相机Z采用了示例代码5-9，并在按空格键时在相机x和相机Y之间实现渐变效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Class to fade from camera 0 to 1, and back from 1 to 0//This class assumes there are only two scene camerasusing UnityEngine;using System.Collections;public class CameraFader : MonoBehaviour&#123; //Reference to cameras (all cameras in the scene to be composited) public Camera[] Cameras; //Reference to camera color (color to multiply with render) public Color[] CamCols = null; //Fade in/out time in seconds (total time for a fade in one direction) public float FadeTime = 2.0f; //Final material to apply to render (Can be used to apply a shader to final rendered pixels) public Material Mat = null; void Start () &#123; //Assign render textures to each camera foreach(Camera C in Cameras) C.targetTexture = new RenderTexture(Screen.width, Screen.height, 24); //Create texture &#125; //This function is called once per frame after the camera has //finished rendering but before the render is shown //It has a companion function OnPreRender (which is called before rendering) void OnPostRender() &#123; //Define screen rect Rect ScreenRct = new Rect(0,0,Screen.width,Screen.height); //Source Rect Rect SourceRect = new Rect(0,1,1,-1); //Render each camera to their target texture for(int i = 0; i&lt;Cameras.Length; i++) &#123; //Render camera Cameras[i].Render(); //Draw camera textures to screen using this camera GL.PushMatrix(); GL.LoadPixelMatrix(); //Get pixel space matrix Graphics.DrawTexture(ScreenRct, Cameras[i].targetTexture, SourceRect, 0,0,0,0, CamCols[i]); //Draws each camera as layer GL.PopMatrix(); //Reset matrix &#125; &#125; //This function is called afer OnPostRender //And when final pixels are to be shown on screen //src = current render from camera //dst = texture to be shown on screen void OnRenderImage(RenderTexture src, RenderTexture dst) &#123; //Frame finished rendering, now push final pixels to screen with Mat applied (can apply custom shader here) Graphics.Blit(src, dst, Mat); &#125; //Function to lerp between color From to Color To over period TotalTime //This function is used to fade alpha for topmost rendered camera CamCols[1] public IEnumerator Fade(Color From, Color To, float TotalTime) &#123; float ElapsedTime = 0f; //Loop while total time is not met while(ElapsedTime &lt;= TotalTime) &#123; //Update color CamCols[1] = Color.Lerp(From, To, ElapsedTime/TotalTime); //Wait until next frame yield return null; //Update Time ElapsedTime += Time.deltaTime; &#125; //Apply final color CamCols[1] = Color.Lerp(From, To, 1f); &#125; //Sample update function for testing camera functionality //Press space bar to fade in and out between cameras void Update() &#123; //Fade camera in or out when space is pressed if(Input.GetKeyDown(KeyCode.Space)) &#123; StopAllCoroutines(); //Should we fade out or in if(CamCols[1].a &lt;= 0f) StartCoroutine(Fade(CamCols[1], new Color(0.5f,0.5f,0.5f,1f), FadeTime)); //Fade in else StartCoroutine(Fade(CamCols[1], new Color(0.5f,0.5f,0.5f,0f), FadeTime)); //Fade out &#125; &#125;&#125; 示例代码5-9中的部分解释内容如下所示。口第011-020行代码：CamerFader类负责处理Camera[0]和Camera[1]之间的渐变效果，对此需要定义多个变量。Cameras数组维护一个相机列表，当前示例中包含了两部相机。另外， CamCols数组链接至Cameras上且定义了颜色值，并与相机的渲染器执行乘法运算，其中的Alpha值可使渲染器处于透明状态。变量FadeTime定义了相机某一方向上的淡入淡出时间(以秒计)。最后， Mat变量引用有效的材质并应用于源自主相机的渲染器上。也就是说，完整渲染器中的像素，包括其他相机照的全部内容。 口第023-038行代码：Start方法针对各个相机创建了RenderTexture，并将纹理赋予其TargetTexture成员中。实际上，各相机将赋予内部纹理，其渲染器于本地对其进行合成。 口第033-052行代码：针对场景中的活动相机对象， Unity自动调用OnPostRender事件，每帧调用一次，并在相机完成了其常规渲染后进行。此时，对象可在渲染完毕的数据上渲染其他相机或元素。这里， Cameras数组中各相机的Render方法将被调用，并采用手动方式将相机渲染至其渲染器纹理中，而非屏幕上。该纹理渲染结束后， Graphics.DrawTexture函数将各相机的RenderTexture按照数组中的顺序渲染至屏幕上，且依次叠加。需注意的是，各DrawTexture调用将纹理乘以CamCols颜色值，其中也涉及透明度中的Alpha分量。 口第059-063行代码：类似于OnPostRender事件， Unity也会在活动相机对象上自动调用OnRenderlmage事件，且每帧调用一次，其调用顺序位于OnPostRender之后，相机渲染器呈现于屏幕之前。该事件提供了两个参数，即src和dst，其中， src参数表示为指向渲染器纹理的引用，包含了源自相机的完整的渲染器，并表示为源自OnPostRender的输出结果。参数dst引用则定义了渲染器纹理，当OnRenderImage事件结束后将显示于屏幕上。简单地讲，该函数可通过代码以手动方式或者通过着色器编辑渲染器的像素。此处， Graphics.Blit函数将被调用，并将源数据复制至目标渲染器纹理中，并采用了与材质引用Mat关联的着色器。 口第067-085行代码： Fade表示为一个协同例程(CoRoutine) ，其中，颜色From在一段时间内(TotalTime)渐变为To颜色。该CoRoutine在0-1之间渐变相机颜色中的Alpha值，即从透明状态转变为不透明状态。图5-9显示了淡入淡出相机效果。 相机震动相机和动画在相机漫游动画中，相机处于运动和旋转状态并途经多个特定位置，进而实现某种影视效果，其重要性主要体现于创建过场动画。相机漫游对于第三人称相机以及鸟瞰视野均十分有效。一种预定义方式是使用Unity中的动画编辑器，或者第三方工具，例如Maya、Blender或3ds Max。然而，某些时候，也需要通过编程方式对相机进行控制，进而通过手动方式调整其位置（偏离其平均中心位置），利用平滑的曲线运动方式，途经多个点并跟随特定的预置路径。本节将对此介绍3种实现方案。 或许，跟随相机是一种较为常见的方式，即相机跟随特定的场景对象，并在二者间保持一定的距离。这对于第三人称相机十分有用，例如RTS游戏中的过肩视角，以及鸟瞰视角。 对于此类相机，简单的跟随行为通常难以满足要求（例如简单地将相机作为当前对象的父对象）。通常情况下，相机运动应呈现某种平缓或阻尼效果，也就是说，速度衰减使得相机逐渐停止并到达目标处，而非相机全速运动过程中的夏然而止。对此，可使用Quaternion.Slerp和Vector3.SmoothDamp函数。示例代码中的类可与任何相机进行绑定，并实现对象的平滑跟随效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using UnityEngine;using System.Collections;public class CamFollow : MonoBehaviour&#123; // Follow target public Transform Target = null; // Reference to local transform private Transform ThisTransform = null; // Linear distance to maintain from target (in world units) public float DistanceFromTarget = 10.0f; // Height of camera above target public float CamHeight = 1f; // Damping for rotation public float RotationDamp = 4f; // Damping for position public float PosDamp = 4f; void Awake() &#123; //Get transform for camera ThisTransform = GetComponent&lt;Transform&gt;(); &#125; void LateUpdate() &#123; // Get output velocity Vector3 Velocity = Vector3.zero; // Calculate rotation interpolate ThisTransform.rotation = Quaternion.Slerp(ThisTransform.rotation, Target.rotation, RotationDamp * Time.deltaTime); // Get new position Vector3 Dest = ThisTransform.position = Vector3.SmoothDamp(ThisTransform.position, Target.position, ref Velocity, PosDamp * Time.deltaTime); // Move away from target ThisTransform.position = Dest - ThisTransform.forward * DistanceFromTarget; // Set height ThisTransform.position = new Vector3(ThisTransform.position.x, CamHeight, ThisTransform.position.z); // Look at dest ThisTransform.LookAt(Dest); &#125;&#125; 相机和曲线对于场景切换、菜单背景以及简单的相机漫游效果，相机可采用直线运动方式。当然，在相机运动过程中也允许出现某些曲线运动，以及速度上的起伏。期间，相机以初始速度运动，在该过程中，速度缓慢下降并到达路径的终点。相应地，用户可通过Unity的动画编辑器使用预置脚本动画，或者使用动画曲线，后者提供了较大的灵活性，并可在操作过程中控制对象的转换。 当创建相机控制脚本并控制对象的速度和运动行为时，包括曲线运动以及平缓的阻尼效果，对应代码如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using UnityEngine;using System.Collections;public class CameraMover : MonoBehaviour&#123; // Total time for animation public float TotalTime = 5.0f; // Total Distance to move on each axis public float TotalDistance = 30.0f; // Curves for motion public AnimationCurve XCurve; public AnimationCurve YCurve; public AnimationCurve ZCurve; // Transform for this object private Transform ThisTransform = null; void Start() &#123; // Get transform component ThisTransform = GetComponent&lt;Transform&gt;(); // Start animation StartCoroutine(PlayAnim()); &#125; public IEnumerator PlayAnim() &#123; // Time that has passed since anim start float TimeElapsed = 0.0f; while(TimeElapsed &lt; TotalTime) &#123; // Get normalized time float NormalTime= TimeElapsed / TotalTime; // Sample graph for X Y and Z Vector3 NewPos = ThisTransform.right.normalized * XCurve.Evaluate(NormalTime) * TotalDistance; NewPos += ThisTransform.up.normalized * YCurve.Evaluate(NormalTime) * TotalDistance; NewPos += ThisTransform.forward.normalized * ZCurve.Evaluate(NormalTime) * TotalDistance; // Update position ThisTransform.position = NewPos; // Wait until next frame yield return null; // Update time TimeElapsed += Time.deltaTime; &#125; &#125;&#125; 当使用CameraMover类时，可将脚本绑定至相机上，在Object Inspector中，可单击各个X、Y、Z曲线文本框，并标绘相机的距离和速度数据。通过单击Graph样板，用户可编辑图线，添加点并定义应用于该轴向上的运动行为。需要注意的是，X、Y、Z运动相对于对象的局部轴进行设置（前、上和右向），而非世界轴（x，y，z）。当体现动画数据的相关性时，这可实现运动的相对性，并提供对象的根级控制。 Unity并未提供可编程运动路径，这可使得GameObject（例如相机对象）通过球面插值平滑地跟随一条路径或样条。其中，路径定义为一系列的连接游戏对象。这一特性在实际应用过程中已有所体现，且相机运动行为可采用预置脚本动画定义，并在Unity的动画编辑器中创建。 对于相对灵活的运动路径可编程控制行为，路径可采用一系列的路点定义，并可通过代码对其进行调整。该功能十分有用，例如，在太空射击游戏中，敌方飞船的轨迹将遵循平滑的曲线路径，并可根据玩家飞船的位置对该路径进行调整。在Unity中，存在多种方式可实现这一效果，其中较为简洁、方便的方法是使用免费的扩展组件iTween，并可直接从Unity的Asset Store中下载并导入。 除了默认的iTween包之外，还可免费下载Visual iTween Path Editor。 待导入iTween包后，下一步则是据此创建路径上的动画对象。当采用漫游相机时，可将脚本iTweenPath拖曳至相机对象上。该脚本可生成独立的路径，其中包含了多个路点。 当定义路径上的多个路点时，可在Node Count中输入全部路点数量。随后可在Scene视口中选择各节点的Gizmo。需要注意的是，各点所绘制的曲线路径仅大致描述了相机的运动路径。 随后，可令相机在运行期内跟随该路径，并向相机添加如下代码。 12345678910using UnityEngine;using System.Collections;public class cam_itween_mover : MonoBehaviour&#123; void Start() &#123; iTween.MoveTo(gameObject, iTween.Hash("path", iTweenPath.GetPath("Camera Fly"), "time", 4f, "easetype", iTween.EaseType.easeInOutSine)); &#125;&#125; 本章小结本章主要讨论了与相机相关的多项任务。相机在Unity以及游戏引擎中不可或缺，并体现了场景相对于屏幕的渲染视角。 本章首先介绍了渲染中的Gizmo--即使在相机未被选择的情况下，也可在场景视口中渲染相机Gizmo。 随后讨论了对象与相机之间的可见方式，其中涉及了多种重要的测试行为，例如视锥体表达方式以及遮挡测试。 另外，本章还阐述了正交相机的创建和配置方法，并在无透视偏差的基础上渲染2D元素。 接下来本章考察了基于渲染器纹理的、相机渲染器的编辑和增强方式，并重新定义了一系列的相机事件，以及源自其他相机的混合渲染器，进而生成相机的淡入淡出效果。 与此同时，本章还探讨了高级相机运动行为的构建方式，例如相机的震动效果。 最后，本章考察了相机路径问题。其中，对应路径通过一系列的游戏对象路点加以定义；抑或简单地表示为所跟随的对象。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity脚本设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI系统]]></title>
    <url>%2F2019%2F02%2F13%2FUGUI%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[旧版GUI使用时有很多不便，而且没有可视性。GUI代码需要在OnGUI函数中调用才能绘制，GUI的控件一般都需要传入Rect参数来指定屏幕绘制区域，例如Rect(0, 10, 200, 300)，对应的屏幕矩形区域左上角的坐标为（0，10），宽度为200，高度为300。在Unity GUI中，屏幕坐标系以左上角为原点。旧版的核心就是OnGUI函数，都需要在里面绘制，现在已经很少使用了。 UGUI创建UGUI控件开始介绍UGUI系统前，首先要了解如何去创建一个UGUI控件。选择GameObject-&gt;UI就会出现所有的UGUI控件。选中一个想要的控件，如Button控件，单击它就可以完成创建。 创建好一个Button控件后就会在Hierarchy面板中看到结构。其中，Canvas是画布，在该界面中创建的所有控件都会自动变为Canvas游戏对象的子对象。若是场景中没有Canvas对象，在创建控件时Canvas对象会被自动创建。 创建第一个UGUI控件时，若场景中没有已经存在的Canvas游戏对象，就会自动创建一个，并将UGUI控件设置为Canvas的子对象，同时会自动创建一个名为EventSystem的游戏对象，上面挂载了若干可供设置的事件监听的相关组件。 Canvas 画布Canvas是一个游戏对象，自带一个Canvas游戏组件，所有的UI元素都必须是Canvas的子对象。若场景中没有一个Canvas，那么当创建一个新的UI元素时会自动生成一个Canvas游戏对象。 UI元素的绘制顺序UI元素在Canvas里的绘制顺序和它们在Hierarchy面板中的排序是一致的，即第一个子对象最先绘制，然后是第二个子对象，以此类推。如果两个UI元素有重叠部分，那么之后绘制的元素会挡在先绘制的元素上面。可以参考下图来帮助理解。 在图中，A、B两个对象是两个Image控件，用于显示图片。当A在B上方时，A被后渲染的B挡住；当B在A上方时，A把先渲染的B挡住。这样在Hierarchy面板中简单的拖曳就可以改变出现在最上层的UI元素或控件。 Render Modes（渲染模式）在Canvas中还可以通过设置渲染模式来确定UI元素在Screen Space上还是World Space上渲染。在Unity 3D中支持的渲染模式有3种：Screen Space-Overlay、Screen Space-Camera和World Space。 Screen Space-Overlay该渲染模式是默认的渲染模式。在该模式下会将所有的UI元素都渲染在场景中的最上层（类似于计算机屏幕上的贴膜，所有的UI元素都在这层贴膜上）。如果屏幕尺寸或者分辨率发生变化，Canvas也会自动去和变化后的尺寸相适应。 Screen Space-Camera该渲染模式和Screen Space-Overlay类似。在该模式下，Canvas游戏对象放置在一个预先设置好的摄像机的特定距离外，UI元素通过该摄像机进行渲染。所以使用该模式时应该创建一个摄像机并将其指定给Canvas组件下的Render Camera。改变该摄像机的设置，UI元素的显示效果也会跟着改变。 World Space该渲染方式使得Canvas更像一个游戏对象，可以手动改变其Rect Transform组件，从而更改其大小与旋转。在渲染时UI元素会根据它们在3D场景中的位置被渲染在其他游戏对象之前或之后，使其成为游戏视图中的一个成分。在做动态效果较多的界面时使用该模式比较方便。效果如下图所示。 在Screen Space的两种渲染模式下，UI独立于游戏场景，不会被场景中的其他对象遮挡，始终保持在最上层；而在World Space渲染模式下，UI元素会被场景中的3D游戏物体遮挡，并且Canvas可旋转缩放等，适合制作一些非常酷炫的UI效果。 Graphic Raycaster每个Canvas都有一个Graphic Raycaster组件，用于获取用户选中的UGUI控件。多个Canvas之间的事件响应顺序由其显示顺序决定，在Hierarchy面板中越靠上的Canvas越后响应。当Canvas使用World Space或Camera Space渲染模式时，Graphic Raycaster的Block选项可以用来设置遮挡目标。 EventSystem组件创建一个UGUI元素后，Unity会创建一个游戏对象，其名为EventSystem，上面挂载了一系列用于控制各类事件的组件，如下图所示。其自带的Input Module组件用于响应标准输入。在Input Module中封装了对Input模块的调用，用于根据用户操作触发对应的Event Trigger事件。 EventSystem组件统一管理Input Module和各种Raycaster。该组件每帧调用多个Input Module处理用户的操作，同时还调用多个Raycaster用于获取用户单击到的UGUI控件或2D、3D物体。 EventSystem是Unity中的事件管理系统，对于UGUI中控件的单击监听等方法的实现将在下面进行介绍，在此只需要了解到EventSystem是一种将基于输入的事件发送到应用程序的对象，包括键盘、鼠标或自定义输入。 Rect Transform组件UGUI中每个控件都包括Canvas，Canvas会带一个Rect Transform组件。该组件继承自Transform，用于控制UI元素的Transform信息。当向一个Empty Object（空对象）添加UI Component组件时，Transform组件会自动变为Rect Transform。其参数介绍如下表所示。 参数 含义 PosX、PosY、PosZ UI元素的位置 Width、Height UI元素的长度和高度 Anchors 相对于父对象的锚点 Pivot UI元素的中心 Rotation 按轴旋转 Scale 按轴缩放 单击Rect Transform组件中左上角的准星图标，可以在打开的Anchor Presets面板中进行快速设置。按住Shift键能同时设置Pivot，这时控件虽然不动，但Position已经改变。如果按住Alt键，则在设置Anchor的同时设置Position。如果同时按住Shift键和Alt键，那么就能同时设置Anchor、Pivot和Position。 Panel控件执行GameObject-&gt;UI-&gt;Panel，就会在Canvas游戏对象下创建一个Panel控件。该控件是一个覆盖屏幕的平面，一般可以用来显示UI的背景，如下图所示。在其Image控件中，Source Image用于放置需要显示的Sprite，Color属性可以更改其颜色及透明度。读者也可以自行调配材质，然后拖曳到Material属性中。 Panel控件在默认情况下会自动根据屏幕的大小来调整自身的大小，所以不用担心其屏幕自适应问题。 Button控件按钮是每个界面的重要组成元素之一。在UGUI中执行GameObject-&gt;UI-&gt;Button，就可以创建一个按钮控件。创建出来的Button控件中包含一个Text子对象，控制Button上显示的字样，若不需要按钮上显示字样，也可以将该子对象删除。 组件介绍 接下来介绍Button控件挂载的组件。每个按钮都挂载有Button组件和Image组件，其中Image组件用于管理按钮的显示图片，Button组件用于管理按钮被单击后的变化以及监听。具体内容如下： Image组件Button控件上的Image组件和之前介绍的Panel控件上的Image组件没有任何区别，在Source Image中可以放上合适的Sprite图片精灵，Color和Material可以设置图片的颜色和材质。 Button组件按钮上挂载的Button组件实现了按钮的全部功能，包括单击后的特效、单击的事件监听方法挂载。Button组件中各个参数的含义如下表所示。 参数 含义 Interactable 该按钮是否启用 Transition 按钮状态变化模式 Navigation 导航，使用键盘方向键切换选中按钮时的切换顺序 Visualize 可视化，使Navigation顺序在Scene面板中可视化 Button组件中的Transition过渡选项定义了4种过渡模式，分别为None、Color Tint、Sprite Swap和Animation。除了None模式，其他过渡模式中每个按钮都有4种状态：Normal (正常状态)、Highlight (突出显示)、Pressed (按下状态）和Disable（禁用），可以对每个状态的按钮过渡进行自定义，具体区别如下。 (1) Color Tint。当使用该模式时，可以分别通过Color属性对按钮的4种状态进行设置，在对应的状态下时按钮的颜色就会变成设置的颜色，与正常状态产生区别。 (2) Sprite Swap。该过渡模式为精灵换图，同样地，其按钮有4种状态可以设置，用户可以为每种状态下的按钮设置一个图片Sprite，设置完毕后，当按钮处于对应状态下时就会显示出对应的图片。注意，在各种状态设置图片时，图片也应当是一个Sprite，设置步骤可以参考Button控件Image组件部分的说明。 (3) Animation。该过渡模式是UGUI的特色，该功能可以使UGUI系统和Unity中的动画系统完美地结合，使用动画状态机可以对不同状态下的按钮的位置、大小、旋转、图片等参数进行设置，功能非常全面。接下来将介绍一个使用Animation过渡模式的例子。 ①选择GameObject-&gt;UI-&gt;Button，创建一个按钮，将其Button组件中的Transition选为Animation。单击Auto Generate Animation按钮，在弹出的对话框中找到合适的目录创建一个动画控制器。如下图所示。 ②创建好动画控制器后，按步骤Window-&gt;Animation，打开动画编辑器窗口，单击Hierarchy面板中的上一步创建的Button组件，在Animation面板中单击左上角的下拉列表就可以选择想要编辑的按钮状态。如下图所示。 ③想要达到的效果是单击按钮后按钮进行弹性缩放，所以将当前编辑的按钮状态设置为Pressed，然后单击Add Property按钮。展开Rect Transform，单击Scale右边的“+”按钮，操作如下图所示。 ④单击Animation面板中的Curves按钮，进入曲线编辑模式，在该模式下可以对按钮Scale中X、Y、Z这3个参数进行设置。本示例的动画曲线如下图所示。 ⑤到此动画设置结束，关闭Animation面板，运行场景。当玩家单击按钮时，按钮会进行弹性缩放。 按钮点击监听挂载本部分将介绍如何给创建好的按钮挂载单击监听。当然，为按钮挂载单击监听的方法有很多，这里介绍的是通过Button组件中的On Click()事件参数添加按钮单击监听，具体步骤如下。 (1)首先创建UGUIOnClick.cs脚本，然后挂载到Canvas游戏对象上。声明一个返回类型为空的方法，里面加上输出信息即可。 12345678910using UnityEngine;using System.Collections;public class UGUIOnClick: MonoBehaviour&#123; public void Onbt1Click() // 监听方法 &#123; Debug.Log("This is bt1"); // 输出 &#125;&#125; Onbt1Click方法就是场景中的按钮单击事件监听方法。在Unity中将该方法添加到按钮的单击事件列表中后，单击按钮就会自动回调该方法。 (2)单击Button组件On Click()下方的“+”按钮，为监听列表添加一个事件。将挂载有UGUIOnClick.cs脚本的游戏对象Canvas拖到选框中，展开有No Function字样的下拉列表，选择UGUIOnClick.Onbt1Click即可。如下图所示。 (3)运行场景，单击按钮后就会在Console面板中看到输出的This is bt1字样。在指定监听方法时还可以传递参数，修改上述代码，为Onbt1Click方法添加一个int类型的参数，然后保存，具体代码如下。 12345678910using UnityEngine;using System.Collections;public class UGUIOnclick : MonoBehaviour&#123; public void Onbt1Click(int index) // 声明方法 &#123; Debug.Log("This is bt" + index); // 输出信息 &#125;&#125; 在按钮的事件列表中为Onbt1Click设置参数，单击该按钮，就会调用该方法，并且传入设置好的参数。在示例中传入的参数类型是int型，这样在方法中就可以收到相应的参数了。 (4)重新在Button组件的OnClick()列表中指定方法后，下方会多出一个文本框。在其中输入对应的int类型参数即可，如下图所示。设置完毕后运行游戏场景，单击按钮就可以看到输出信息This is bt5。 Text控件Unity的控件中有一个名为Text的控件，该控件的主要功能是在对应的区域内显示相应的文本。虽然在游戏中大部分文本为了美观需要使用Image来代替，但是Text控件依旧可以在开发中省却很多步骤。该控件中包含的参数如下表所示。 参数 含义 Best Fit 最佳匹配方式（字体大小会根据内容多少和Text控件大小自动更改） 接下来的代码用于更改Text控件中的显示内容及字体颜色，可以将该代码挂载到Canvas游戏对象上，并将新建的Text控件指定给该脚本中对应的变量。具体代码如下。 1234567891011121314using UnityEngine;using System.Collections;using UnityEngine.UI;public class UGUIText : MonoBehaviour&#123; public Text tt; void Start() &#123; tt.color = Color.red; // 设置Text的颜色 tt.text = "this is text"; // 设置显示文本 &#125;&#125; 在Unity中支持导入外带的字体包，TTF格式的字体一般都可以使用。具体导入方法是将下载好的TTF文件放在项目目录下的Assets/Font目录下（没有请自己创建），在字体的Font参数中就可以找到导入的字体了。 Image控件Image控件即图片控件，该控件用于显示一个非交互式的图片精灵Sprite。作为游戏中最常用的控件之一，Image控件可以用于装饰界面、图标等。 在Image组件中，Source Image用于显示Sprite，所以当需要使用自己的图片时可以将其设置为Sprite格式。具体步骤为单击图片，在Inspector面板中将Texture Type选为Sprite(2D and UI)，单击Apply按钮即可。 Raw Image控件Raw Image控件用于显示一个非交互式的图像，这点与Image控件非常类似，区别在于Image控件只能显示Sprite（图片精灵），而Raw Image控件可以显示任何纹理。 参数 含义 Raycast Target 是否接受射线事件 UV Rect 图片在控件矩形中显示的偏移和大小 由于Raw Image控件不需要精灵纹理Sprite，因此它可以用于显示在游戏中使用WWW类从某个URL下载的图像或渲染纹理，也可以使用场景中某个特定摄像机的渲染图在UI中呈现出该摄像机拍摄到的画面。下面将介绍如何使用Raw Image控件呈现出场景中的摄像机Camera1所拍摄的画面。 (1)在Project面板中右击，执行Create-&gt;RenderTexture命令，创建一个渲染图片，并将其命名为Camera1RT。在场景中创建一个名为Camera1的摄像机，并将Camera组件中的Target Texture设置为Camera1RT。 (2)在Raw Image控件上的RawImage组件中将Texture设置为Camera1RT。设置完毕后运行该游戏场景。这时Raw Image控件显示的就是Camera1拍摄到的画面。 Slider控件选择GameObject-&gt;UI-&gt;Slider，即可创建一个Slider控件（滑块控件），如图所示。其子对象结构如下图所示。该控件可由玩家滑动以操控其值的大小，可以用来制作游戏中的音量大小滑块等。 Slider控件的子对象中，Background是滑块主题背景，本身为一个Image控件；Fill Area下的子对象Fill代表已经被选中的部分，它会随着滑块的左右滑动而改变长度；Handle子对象是玩家单击的滑块按钮。Slider控件中的参数含义如下表所示。 参数 含义 Interactable 是否启用该控件 Transition 过渡模式 Navigation 导航，使用键盘方向键切换选中按钮时的切换顺序 Visualize 可视化，使Navigation顺序在Scene面板中可视化 FillRect Fill子对象的RectTransform组件的引用 HandleRect Handle子对象的RectTransform组件的引用 Direction 滑块的方向，默认是从左到右 Min Value 滑块的最小值 Max Value 滑块的最大值 Whole Number 滑块的值是否只能是整数 Value 滑块当前的值 在Slider控件最下方的On Value Changed(Single)中还可以为Slider控件绑定事件监听方法，该控件发出的事件是“值发生改变”，所以绑定的监听方法就会在滑块值发生变化时回调。具体设置步骤如下。 (1)创建一个脚本，命名为UGUISlider.cs，并将其挂载到Canvas游戏对象上，将其sd参数指定为Slider，脚本代码如下。 123456789101112using UnityEngine;using System.Collections;using UnityEngine.UI;public class UGUISlider : MonoBehaviour&#123; public Slider sd; public void OnsdValueChange() // 值发生改变后回调的方法 &#123; Debug.Log(sd.value); // 输出变化后的值 &#125;&#125; 该脚本较为简单，里面仅有一个OnsdValueChange方法，在Unity中将该脚本中的监听方法挂载给对应的滑块后，若滑块的值发生改变，系统就会自动回调OnsdValueChange方法。 (2)单击On Value Changed(Single)下方的“+”按钮添加一个事件监听，将挂载有脚本UGUISlider.cs的游戏对象Canvas拖曳到Runtime下的GameObject选框中。在右边选择其监听方法为UGUISlider.OnsdValueChange，如下图所示。这时运行场景，若滑块的值变化，就会打印出变化后的滑块值。 Scrollbar控件Scrollbar控件即滚动条控件，执行GameObject-&gt;UI-&gt;Scrollbar，即可以创建出一个Scrollbar控件，如下图所示。其子对象结构如图所示。Scrollbar控件和Slider控件功能相似，其具体参数如下表所示。 参数 含义 Interactable 是否启用控件 Transition 过渡模式 Navigation 导航，使用键盘方向键切换选中按钮时的切换顺序 Handle Rect Handle子对象的Rect Transform组件 Direction Scrollbar的方向，默认从左到右 Visualize 可视化，使Navigation顺序在Scene窗口中可视化 Value Scrollbar的值 Size 滑块的大小 Number of Steps 进行分段，滚动条的显示分段 Toggle控件游戏的设置界面中经常能见到各种开关，在UGUI中开关控件Toggle就实现了开关的功能。执行GameObject-&gt;UI-&gt;Toggle，即可创建一个Toggle控件，其内部结构如下图所示。 Toggle控件的子对象中包含Background，它是一个Image控件，作为开关的背景；Checkmark也是一个Image控件，用于显示选中后的图案，如上图中的“√”图样；Lable是一个Text控件，可用来显示开关的信息，如上图中的Toggle字样。在游戏中若是用不到Lable可以将其删除。Toggle控件的参数及其含义如下表所示。 参数 含义 Interactable 是否启用该控件 Navigation 导航，确认控件的顺序 Transition 过渡模式 Visualize 使导航顺序在Scene窗口中可视化 Togele Transition 开关的消隐模式，有none和Fade（褪色消隐）两种模式 Group 成组（将一组开关变成多选一开关） Is On 开关的状态（“开”或“关”） Graphic Checkmark（复选标记）子对象的引用 接下来将介绍如何使用开关的Group参数。 (1)在Hierarchy面板中选中Canvas游戏对象，右击，选择Create Empty，创建一个空对象，方便管理。依次创建3个Toggle控件，将其设置为GameObject（刚才创建的空对象）的子对象，如下图所示。在这里需要将创建的3个Toggle控件中的Is On设置为关闭状态。 (2)选中上一步中创建的GameObject空对象，执行Component-&gt;UI-&gt;Toggle Group，添加一个Toggle Group组件，如下图所示。其中的Allow Switch Off参数决定是否可以取消选中打开的开关。 (3)依次选中第（1）步创建的3个Toggle控件，将其Toggle控件中的Group参数选为挂载有Toggle Group组件的GameObject游戏对象。这样3个Toggle控件就成组了，最多只能同时选中其中的一个。 Input Field控件Input Field控件是UGUI中的文本框控件，用户在移动设备上单击到该控件时，就会弹出用于输入的键盘，常见于各个游戏中给游戏人物取名等地方。在文本框没有输入时，会显示默认的提示文本，其内部结构如下图所示。 在Input Field控件的子对象中，Placeholder用于显示默认提示信息的文本框，如下图中的Enter text字样；Text用于显示用户输入的文本，若想改变默认提示文本，直接改变Placeholder的Text属性即可。Input Field控件包含的参数如下表所示。 参数 含义 Interactable 是否启用该控件 Transition 过渡模式 Navigation 导航 Visualize 使导航顺序在Scene面板中可视化 Text Component 用于用户输入的文本框的引用 Text 用户输入文本框中的内容 Character Limit 可以输入到文本框中的最多文字数 Content Type 指定文本框的类型 Line Type 换行方式，包括单行显示、自动换行、自定义换行 Placeholder 提示文本框的引用 Caret Blink Rate 光标的闪烁速度 Caret Width 光标的宽度 Custom Caret Color 光标的颜色 Selection Color 选中文本框中文本时文本框的颜色 Hide Mobile Input 在移动设备上输入时是否隐藏 Read Only 是否只读 Input Field控件可以发出两个事件：OnValueChanged和OnEndEdit，分别在当值发生改变时发出和结束编辑时发出。用户可以自行单击事件下方的“+”按钮添加事件监听方法，两个事件监听的添加方法完全相同。 DropDown控件在游戏的设置界面中有时能见到各种下拉菜单，UGUI的DropDown控件就实现了下拉菜单的功能。选择GameObject-&gt;UI-&gt;DropDown，即可创建一个下拉DropDown控件，其内部结构如下图所示。 DropDown控件的子对象中，Label是一个Text控件，用于显示下拉菜单的信息；Arrow是一个Image控件，用于显示下拉箭头的图案，如上图所示的箭头图样；Template是一个下拉列表控件，用于显示下拉菜单的信息。DropDown控件包含的参数如下表所示。 参数 含义 Interactable 是否启用该控件 Transition 过渡模式 Navigation 导航，确认控件的顺序 Visualize 使导航顺序在Scene面板中可视化 Template 下拉列表模板的Rect Transform Caption Text 保存当前选定选项文本的文本组件 Caption Image 用于保存当前选定选项图像的图像组件 Item Text 用于保存项目文本的文本组件 Item Image 用于保存项目文本的图像组件 Value 当前选择选项的索引。0是第一个选项，1是第二个选项，依此类推 Options 可以为每个选项指定文本字符串和图像 DropDown控件可以发出一个事件：OnValueChanged，具体意义是当值发生改变时发出此事件。可以自行单击事件下方的“+”按钮添加事件监听方法。 Scroll View控件Scroll View（滚动视图）控件在游戏中非常常见，比如游戏中的背包内容太多而无法一次显示完毕时就需要一个滚动视图，让玩家可以上下拖动以显示更多内容。选择GameObject-&gt;UI-&gt;Scroll View，即可创建一个Scroll View控件，其内部结构如下图所示。 用一个小示例介绍Scroll View控件，步骤如下。(1)在Hierarchy面板中选中Content对象，选择Add Component-&gt;Layout-&gt;Grid Layout Group，为Content对象添加一个网格布局组件，参数如下图所示。在Content对象下创建12个Image控件，以此充当滚动视图的内容，如下图所示。 (2)修改Scroll Rect的参数，取消选中Horizontal复选框，表示滚动视图不支持横向滑动，如下图所示。为了使滚动视图纵向适配视图内容，需要在Content对象上添加一个内容尺寸适配器，参数设置如下图所示。 (3)至此，滚动视图创建完毕。最后为Image赋予贴图后，运行场景，便可上下拖动滚动视图，运行效果如下图所示。 UGUI布局管理的使用及相关组件介绍接下来讲解如何管理、布局多个控件。这部分知识的运用常见于游戏的奖励窗口，由于预先不知道获得奖励的数量，但是依旧需要让获得的奖励道具按照一定的布局整齐地出现在界面中，这时就需要用到布局的知识了。 Unity自带的布局组分为3种，分别为水平布局、垂直布局和网格布局，还有其他一些适配器、布局元素等组件。首先创建5个Image控件，并将其放在空对象UIMain下成为其子对象，如下图所示。 ** 1.Horizontal Layout Group（水平布局） ** 选中UIMain空对象，选择Add Component-&gt;Layout-&gt;Horizontal Layout Group，即可为该游戏对象添加一个水平布局管理组件。顾名思义，在该组件的作用下，UIMain的子对象将按照一定的要求进行水平排列。该组件如下图所示，组件包含的参数如下表所示。 参数 含义 Padding 布局的边缓填充（即偏移） Spacing 布局内的元素间距 Child Alignment 对齐方式 Child Force Expand 自适应宽和高 Control Child Size 是否控制子物体缩放 为UIMain添加Horizontal Layout Group组件后，它所有UI元素子对象都会根据对Horizontal Layout Group组件的设置进行水平自动排列。如下图所示。 ** 2.Vertical Layout Group（垂直布局） ** 选中UIMain游戏对象，选择Add Component-&gt;Layout-&gt;Vertical Layout Group，即可给该游戏对象添加一个垂直布局管理组件。如下图所示。该组件的功能是将UI元素按照一定的规则进行整齐的垂直排列，其内部参数和Horizontal Layout Group的参数基本一样。 ** 3.Grid Layout Group（网格布局） ** Grid Layout Group是网格布局管理器组件，该组件会将其管理下的UI元素进行自动的网格型的排列，如下图所示。此外，它还实现了自动换行等功能。该组件常见于各个游戏中的背包内部的储物格。Grid Layout Group组件包含的参数如下表所示。 参数名 含义 Padding 偏移 Cell Size 内部元素的大小 Spacing 每个元素间的水平间距和垂直间距 Start Corner 第一个元素的位置 Start Axis 元素的主轴线 Child Alignment 对齐方式 Constraint 指定网格布局的行或列 以上即为Unity中自带的3种布局管理模式，大部分情况下可以满足开发的需要。在游戏运行时随时将新实例化的UI控件或者游戏对象设置为挂载有Layout Group组件（3种中任意一个皆可）的游戏对象的子对象，Layout Group组件便会对其进行自动布局排列。 1234567891011121314using UnityEngine;using System.Collections;public class UGUILayout : MonoBehaviour &#123; public GameObject UIMain; // 挂载有Layout group组件的游戏对象 public GameObject items; // 需要实例化的UI控件或者游戏对象的预制件 void Start () &#123; GameObject item = (GameObject)Instantiate(items); // 实例化items item.transform.parent = UIMain.transtorm; // 将实例化的游戏对象设置为UIMain的子对象 &#125; &#125; 在Start方法中新实例化出了一个items预制件，将其设置为挂载有布局管理器组件的UIMain的子对象，然后观察场景，就会发现新实例化的预制件已经被自动排列好了。这在游戏开发中非常方便，可以随时实例化UI元素而不用再三考虑排列布局问题。 ** 4.Layout Element（布局元素） ** Layout Element是布局元素组件，该组件常用于管理带有布局组对象的子物体。选择Add Component-&gt;Layout-&gt;Layout Element，即可给该游戏对象添加一个布局元素组件，如下图所示。Layout Element组件包含的参数如下表所示。 参数 含义 Ignore Layout 是否受布局组影响 Min Width 布局元素的最小宽度 Min Height 布局元素的最小高度 Preferred Width 布局元素的最大宽度 Preferred Height 布局元素的最小高度 Flexible Width 宽度拉伸布局比例 Flexible Height 高度拉伸布局比例 5.Content Size Fitter（内容尺寸适配器） 6.Aspect Ratio Fitter（宽高比适配器） UGUI中不规则形状的按钮的碰撞检测UGUI中自带的按钮是标准的矩形，虽然可以由玩家任意换图，但是其碰撞检测区域始终是矩形的。在有些时候，可能会用到特殊形状的按钮，当然其碰撞检测区域也要是符合按钮形状的。下面就使用UGUI中的知识来创建一个不规则形状的按钮。具体步骤如下。 1.首先创建一个Button控件，命名为“bt1”，由于这里不需要它的Text子对象，所以可以将其删除。选中bt1后执行“Component-&gt;Physics2D-&gt;Polygon（多边形） Colloder（对撞机） 2D”命令，为bt1添加一个多边形碰撞器组件。 2.单击Polygon Colloder 2D组件中的Edit Collider按钮，在Scene界面中将想要的碰撞检测区域勾选出来，如图中五边形边上的亮线所示。勾选出来的五边形即为该按钮的碰撞检测区域。 3.接下来要实现将按钮的碰撞区域和Polygon Colloder 2D组件勾选区域的挂钩，这一步要重写Image类。新建一个C#脚本，将其命名为”UGUIImagePlus.cs”，该脚本需要引用UnityEngne.UI命名空间，并维承Image类，脚本代码如下。 12345678910111213141516171819using UnityEngine;using System.Collections;using UnityEngine.UI;public class UGUIImagePlus : Image &#123; PolygonCollider2D collider; //多边形碰撞器组件 void Awake() &#123; collider = GetComponent&lt;PolygonCollider2D&gt;(); //获取2D多边形碰撞器组件 &#125; public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCanera) &#123; bool inside = collider.OverlapPoint(screenPoint); //判断触摸是否在围出的多边形区域内 return inside; //返问是否在多边形内 &#125;&#125; 本脚本继承自UnityEngine.UI.Image类，并重写了该类的IsRaycastLocationValid说明 方法。这个方法用于返回触摸点（screenPoint）是否在图片范围内。在该方法中使用Collider2D.OverlapPoint方法判断点是否在多边形区城内。 4.接下来将bt1上面挂载的Image组件移除，单击Inspector面板中的Image组件右边的设置按钮，选择Remove Component。将UGUIImagePlus.cs类拖拉到bt1上形成UGUIImagePlus组件以代替。 5.挂载好UGUIImagePlus组件后，重新为该组件指定好纹理图。这样，图片已经可以检测到由Polygon Colloder 2D组件勾选出来的区域内的触摸了。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity游戏开发技术详解与典型案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[资源的下载与上传]]></title>
    <url>%2F2019%2F02%2F12%2F%E8%B5%84%E6%BA%90%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[游戏通常需要从网络下载资源，例如网络游戏中新推出的地图或者人物需更换的新皮肤等。本章主要通过两个Unity系统实现这一功能：通过WWW系统下载和上传，通过Asset Bundle系统将资源压缩打包。 下载在Unity中，下载功能主要是通过UnityEngine.WWW这个类下的接口实现的。 新建一个场景，然后新建一个Cube立方体，旋转使其相对于摄像机呈一定角度。再新建一个Material，命名为“1.Mat”，将立方体的Mesh Renderer组件所使用的材质设置为“1.Mat”。最后，新建空的游戏对象并为其添加脚本。 12345678910111213141516171819202122232425262728293031323334using UnityEngine;using UnityEngine.WWW;using System.Collections;public class DownloadDemo : MonoBehaviour&#123; public Material mat; // 将要设置贴图的材质 public string localAddress; // 本地地址 public string webAddress; // 网络地址 void Awake() &#123; localAddress = "file:/"; webAddress = "www."; &#125; void OnGUI() &#123; if (GUILayout.Button("Load")) &#123; // 使用协程下载 StartCoroutine(Load(localAddress)); StartCoroutine(Load(webAddress)); &#125; &#125; IEnumerator Load(string url) &#123; Debug.Log(url); WWW www = new WWW(url); yield return www; mat.mainTexture = www.texture; &#125;&#125; 运行场景，点击“Load”按钮。至此，白色立方体有了下载的贴图。如下图所示。 WWW既可以下载网络资源，也可以通过为URL地址添加前级”fle://“获取本地资源。在代码清单13-1中,反注释第19行代码并注释第20行代码,然后再次运行场景即从本地获取图片。 mat.mainTexture -www. texture;,这行代码表明ww所下载的资源作为贴图使用。ww用于下载,不仅支持texture格式,还支持audioclip, bytes, text等多种格式,使用方法与此类似。在下载完成后,你可用w.oispose函数清除MW对象。 上传从服务器下载资源时,我们通常需要告诉服务器设备信息,用户信息等以便下载对应资源。参数或者文件可以通过UnityEngine.MForm类作为ww的参数上传。 设备类型可以通过Application. plat form得到,例如Runt imePlatform. IPhonePlayer或者RuntimePlatform. Android. 设备内在大小可以通过Systemlnfo.system”enorysize得到,例如服务器通过内存大小来决定返回给客户端普通资源还是高清资源 接下来通过实例演示如何使用UnityEngine.MForm,首先在本地路径“工程路径Asssets/Chapterl3”下准备文档”ifo.t”作为将被下载的内容,然后新建一个场景并命名为”13.1”,新建游戏对象并命名为”wwwManager”,为其添加脚本,如代码清单13-2所示。本实例模拟的是向服务器上传数据,服务器根据数据返回对应资源的过程,还可通过unityEngine.MMForm上传用户信息以及高分记录等数据。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5.X游戏开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为游戏开发图形]]></title>
    <url>%2F2019%2F02%2F12%2F%E4%B8%BA%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[本章涵盖 了解美术资源 了解白盒 在Unity中使用2D图像 导入自定义3D模型 构造粒子效果 用于构建游戏的5种主要类型的美术资源。 类型 定义 2D图像 扁平的图片。以真实世界为例，2D图像就像图面和图片 3D模型 3D虚拟对象（通常是“网格对象”的同义词），以真实世界为例，3D模型就像雕塑 材质 打包了任何被附加对象的表面属性的信息。这些表面属性包括颜色、发光甚至精细的粗糙信息 动画 动画打包了关联对象的运动信息。这些信息描述提前创建的运动序列，而不是及时计算位置的代码 粒子系统 一个用于创建并控制大量小型对象的规则机制，很多可视化效果通过这种方式实现，例如火焰、烟雾或喷水]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity5实战-使用C#和Unity开发多平台游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多媒体]]></title>
    <url>%2F2019%2F01%2F31%2F%E5%A4%9A%E5%AA%92%E4%BD%93%2F</url>
    <content type="text"><![CDATA[在游戏中，都需要播放声音与视频，其中声音又可以分为音乐和音效两种。音乐就和背景音乐一样，一直在循环播放；而音效用得就更多了，例如释放技能、被攻击所带来的声音，而且音效很可能同时需要播放好几组。为了满足更加逼真的效果，Unity还提供了强大的混音模式以及3D音频模式，这就好比远处和近处都有怪物在发生攻击的音效，听起来需要有3D的层次感。另外，Unity还提供了AudioMixer组件，它可以很方便地在编辑模式下组合播放各种声音以及混合播放多音频。新版的视频功能用起来非常方便，既可以将它输出在摄像机的前面或后面，也可以很容易地将视频放在UI以及场景中间，还可以将视频材质输出并自定义渲染在贴图上。 音频音频由多个Audio Source组件和一个Audio Listener组件组成，其中Audio Listener负责监听所有的Audio Source，最终通过设备的扬声器播放出来。如果是3D音效，Unity会自动判断Audio Listener与音频的距离，从而增强或者减少音量。另外，同一个场景只能有一个Audio Listener组件启用，它会默认添加在主摄像机上。 音频文件首先，Unity支持的音频文件是非常丰富的，最常用的就是.mp3和.ogg声音文件了。首先，我们将一个.mp3文件拖入Project视图中。我们可以单独设置声音文件是否在后台加载，以及声音文件的压缩格式等。这些设置并不是修改了声音文件本身，而是Unity在导入时会自动生成一个新的音频文件，它与原始文件只有简单的引用关系，将来打包发布后，其实使用的是新的音频，而使用者是毫无感知的。如图所示，在右下角处，可以预览播放当前选择的声音文件，并且设置是否循环播放。 Audio Source给任意游戏对象绑定Audio Source组件，即可播放声音。如下图所示，将音频文件绑定在AudioClip处，再选中Play On Awake和Loop复选框，直接运行游戏，就可以循环播放声音了。 3D音频3D音频就是根据声源与主角的距离自动增加以及减弱的音频。由于Audio Listener是绑定在主摄像机上的，所以控制摄像机的远近即可满足3D音频的条件。不过默认情况下，Audio Source是2D音频。如上图所示，调节Spatial Blend，其中0表示2D音频、1表示3D音频、0和1之间表示2D和3D之间的插值音频。另外，Priority表示声音的优先级。由于同时播放的音频是有最大上限的，一旦超过上限，会自动关闭一个优先级最高的音频，所以背景音乐一类的就适合设置成0。Volume表示声音的音量，Pitch表示音频的播放速度，Stereo Pan表示左声道和右声道占比，Reverb Zone Mix用于设置回音混合。 开启3D音频后，就可以调节最小距离以及最大距离了。两个球形区域表示3D声音最大区域和最小区域，点击周围的蓝色小方块，拖动鼠标即可调节它的区域。如果角色在最小音频区域内听到的音量最大，在最小区域与最大区域之间听到的音量递减，则当角色超出最大区域时，会保持递减后最小的音量。最后播放游戏后，直接移动场景中的摄像机，即可听到效果。 代码控制播放视频渲染模式与自适应]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UGUI游戏界面-1]]></title>
    <url>%2F2019%2F01%2F31%2FUGUI%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么时候取消Raycast Target的选中？ 怎么修改UGUI的材质？ 如何给Text添加描边和阴影？ 什么是动态字体？如何给Unity添加字体？ UGUI提供的基础元素包括文本、图片、按钮、滑动条和滚动组件等，配合UI还提供了强大的EventSystem事件系统来管理UI元素。从Unity2017开始还引入了图集的概念，让UGUI的功能更加全面，用起来更灵活。UGUI在自适应处理上显然下了功夫，提供了锚点、布局、对齐方式和Canvas，专门用来解决分辨率不同所带来的自适应屏幕问题。 基础元素UI是游戏开发中非常重要的一部分，所有交互都需要在其中完成。界面中的元素是多元化的，例如文本、图片和按钮互相组合，搭配排列出完美的界面。UI提供了Rect Transform组件，用来设置锚点以及对齐方式。布局方式对于UI元素都是通用的，它的参数也比之前的Transform多了很多。 TextHierarchy视图Create-&gt;UI-&gt;Text，即可创建一个文本组件。如下所示，文本需要使用TTF字体。电脑上可以找到很多TTF字体，大多都会有无用的字符，最好使用FontCreator软件来精简一下字体库。 Text组件提供了横向、纵向自动换行的功能，分为横向与纵向两种。请注意Raycast Target复选框，如果UI元素不需要点击事件，一定不要勾选它。因为UGUI的事件系统会遍历出所有带Raycast Target的组件，这无疑会带来一些不必要的开销。还有UGUI默认的材质我们是无法修改的，但是可以重写它，只需要将新的材质拖入Material处。 warp：包裹 overflow：溢出 raycast：投射 emoticons：表情 geometry：几何 描边和阴影在Text游戏对象上添加Outline和Shadow，即表示支持文本的描边和阴影。可以设置它们的颜色以及描边的距离。 描边的原理就是在原有Text组件的基础上在上、下、左、右个多画了一遍，所以它的效率是很低的。阴影会比描边好很多，因为它只需多画一遍，所以能用阴影就不要用描边。 动态字体UGUI动态字体的原理是根据传入的字体以及字体的大小生成到一张纹理上，最终将纹理上的字体显示出来。这就带来一个问题：Text中设置了3个完全相同的字体，只是字体的大小不一样，然而在纹理中却生成了3份。所以，游戏中是不太建议使用动态字体的。 导入的字体文件默认Character都是Dynamic，也就是说它是一个动态字体，那么动态字体到底是个什么东西呢，它有什么用呢？点一下Character，下拉菜单如下图： 出现了Unicode、ASCII…也就是说这个动态字体是跟编码有关系的，好，我们选一个编码不太全的字体为例。 用FontCreator工具打开字体，发现，这个字体只有英文和一些符号已经一些不认识的字母，没有中文。 在Unity3D中添加字体： 1、在Assets中新建文件夹Fonts； 2、在系统盘c盘中找到C:\Windows\Fonts 3、把相应的字体拖入到Fonts即可。 除了聊天和起名等必须由用户自己主动输入的文字外，游戏中大量的文字实际上并不需要使用动态字体，此时可以使用SDF字体。它的原理就是用位图来保存矢量信息，记录到边的最短距离，最后再用Shader还原回来。TextMesh Pro这个插件就使用了这个原理，建议在游戏中使用此插件。 字体花屏UGUI的动态字体会动态生成材质，它开始是256x256（像素），然后根据使用字体的情况慢慢扩大，直到4096x4096（像素）。当文字太多不够放的时候，会触发UGUI内部重建字体贴图命令，接着就可能造成文字花屏了。若要解决这个问题，就要监听它内部重建的事件，然后整理刷新一下当前场景中的所有字体即可。 如下代码所示，监听Font.textureRebuilt字体重建事件，记录当前待重建的字体，在下一帧更新的时候，调用FontTextureChanged()方法刷新所有Text文本。 1234567891011121314151617181920212223242526272829303132333435363738using UnityEngine;using System.Text;using UnityEngine.UI;public class Script_05_01 : MonoBehaviour&#123; // 标记某个字体发生了重建 private Font m_NeedRebuildFont = null; void Start() &#123; // 监听字体贴图重建事件 Font.textureRebuilt += delegate (Font font) &#123; m_NeedRebuildFont = font; &#125;; &#125; void Update() &#123; if (m_NeedRebuildFont) &#123; // 找到当前场景中的所有Text，重新刷新一下 Text[] texts = GameObject.FindObjectsOfType&lt;Text&gt;(); if (texts != null) &#123; foreach (Text text in texts) &#123; if (text.font == m_NeedRebuildFont) &#123; text.FontTextureChanged(); &#125; &#125; &#125; m_NeedRebuildFont = null; &#125; &#125;&#125; 这里使用GameObject.FindObjectsOfType()方法取到当前Hierarchy视图中的所有字体，依次遍历后，重新刷新它即可。 Image组件 Image组件用来显示图片。图片一共分为以下4种格式。 Simple：直接显示图片。 Sliced：通过九宫格方式显示图片，可用SpriteEditor来编辑九宫格的区域。 Tiled：平铺图片。 Filled：像技能CD一样，可以旋转图片。 Preserve Aspect复选框表示是否强制等比例显示图片。单击下方的Set Native Size按钮后，可重新格式化图片大小。 Raw Image组件Image组件只能显示Sprite，Raw Image组件既可以显示任意Texture，也可以使用Sprite，不过它还是以Texture方式显示的。Image组件使用Sprite时，可以使用Atlas来合并批次，但是Raw Image组件却不能，每个Raw Image就占一次DrawCall。所以，一般不太建议使用Raw Image组件。 但是有时候又不能不使用Raw Image组件，比如Render Texture，需要将摄像机渲染到纹理中，就必须使用它。如下图所示，Raw Image组件的参数也比较简单，不想Image那样有很多类型，它挂上图片就可以使用了。Raw Image属于原始显示图片的组件，初始化速度也是最快的。但是由于它无法合并DrawCall，所以大量UI系统不建议使用它。 Button组件Button组件必须依赖Image组件。按钮有普通、点击、抬起和悬浮这几种状态，切换各状态可以改变它的颜色，也可以更换Sprite图片样式，再或者使用Animation动画系统来控制各状态。Button组件直接提供了点击方法来监听点击事件。下图显示了Button组件的参数。 如下代码所示，调用onClick.AddListener()方法就可以给按钮添加监听点击的事件了。 123456789101112131415using UnityEngine;using UnityEngine.UI;public class Script_05_02 : MonoBehaviour&#123; public Button button; void Start () &#123; button.onClick.AddListener(delegate () &#123; Debug.Log("click"); &#125;); &#125;&#125; 需要说明的是，按钮不仅可以通过代码来添加点击事件，也可以通过在按钮组件面板中来添加。选择OnClick事件，在下拉框中选择对应的方法名，前提是该方法需要为public属性的公有方法。开发中，在代码中对按钮进行监听更加灵活，不建议在面板中添加点击方法。 Toggle组件Toggle组件就像单项选择一样，选择其中一个选项，剩下的会自动取消选择。记得要把所有Toogle对象都关联进同一个ToogleGroup里。下面来监听一下它的选择/取消选择事件。Toogle组件可以使用onValueChanged()方法来监听切换事件。 123456789101112131415161718using UnityEngine;using UnityEngine.UI;public class Script_05_03 : MonoBehaviour&#123; public Toggle[] toogles; private void Start() &#123; foreach (var toogle in toogles) &#123; toogle.onValueChanged.AddListener(delegate (bool selected) &#123; Debug.LogFormat("toogle = &#123;0&#125; selected = &#123;1&#125;", toogle.name, selected); &#125;); &#125; &#125;&#125; 如果运行时需要用脚本单独改变其中的某一个，可以使用toogle.isOn来设置它的选中状态。 Slider组件Slider组件就是一个滑块在进度条上左右拖动，游戏中经常会使用它来做人物的血条。如下图，滑动Slider组件，可以更改血条的显示方式。 如下代码所示，使用OnValueChanged()方法监听Slider组件的滚动事件，并且可以取到滚动的进度。 12345678910111213141516171819using UnityEngine;using UnityEngine.UI;public class Script_05_04 : MonoBehaviour&#123; public Slider slider; private void Start() &#123; // 设置取值范围内的最小值/最大值 slider.minValue = 0; slider.maxValue = 100; slider.onValueChanged.AddListener(delegate (float value) &#123; Debug.LogFormat("value = &#123;0&#125;", value); &#125;); &#125;&#125; 如果运行时需要用脚本更改它，则可以使用slider.value来设置新的值。另外，Slider和Toggle都是使用onValueChanged()来监听事件的，但是它们传递的UnityEvent是不同的，并且回调的参数也是不同的。 Scrollbar &amp; ScrollView组件Scroll Rect组件由Scrollbar组件（拖动条）和ScrollView组件（滑动区域）组成。它的原理就是使用Scroll Rect组件设置一个滑动区域，然后挂上Scrollbar组件监听滑动的事件，这和Slider组件类似。 使用ScrollRect组件制作游戏摇杆ScrollRect是UGUI提供的基础拖动组件，给它的Content绑定一个滑块就能工作了。利用这个特性来做游戏摇杆再合适不过了。 如下代码所示，继承ScrollRect后，重写OnDrag()方法来监听滑动摇杆事件。其中，contentPosition.magnitude计算滑动摇杆的长度，我们需要让摇杆保持在圆形区域内。 1234567891011121314151617181920212223242526using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;public class Script : ScrollRect&#123; protected float mRadius = 0f; protected override void Start() &#123; base.Start(); // 计算摇杆半径 mRadius = (transform as RectTransform).sizeDelta.x * 0.5f; &#125; public override void OnDrag(PointerEventData eventData) &#123; base.OnDrag(eventData); var contentPosition = this.content.anchoredPosition; if (contentPosition.magnitude &gt; mRadius) &#123; contentPosition = contentPosition.normalized * mRadius; SetContentAnchoredPosition(contentPosition); &#125; &#125;&#125; 在上述代码中，mRadius表示摇杆滑动圆形区域的半径，contentPosition.normalized表示摇杆的单位向量，两者相乘，即可得出摇杆最终所在的位置。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏脚本]]></title>
    <url>%2F2019%2F01%2F31%2F%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 发布后，Unity将DLL转换成了什么？ 脚本模板是做什么用的？在哪个位置？ 添加脚本模板的缺点是什么？怎么解决这个问题？ 监听脚本绑定事件是什么意思？什么时候触发？如何监听？ 游戏对象和脚本的禁用状态和哪两个生命周期方法有关？ 游戏脚本是整个游戏的核心组件，使用它可以创建游戏对象、控制图形渲染，接受并处理用户输入事件，控制内存等。Unity系统提供了很多脚本，它们拥有一套完整的生命周期。在开发模式下，Unity使用Mono来跨平台地编译和解析C#脚本。游戏发布后，Unity还提供了自动将DLL转成IL2CPP（中间语言转换成C++）的方式，这可以提升代码编译后的执行效率以及稳定性。只需在设置界面简单操作一下即可。 创建脚本脚本需要放在除Editor以外的任意目录或子目录下，因为Editor目录下的代码会被系统认为是编辑模式代码，打包后会被自动剥离。 脚本模板菜单中还有两类脚本--Testing和Playables，前者是用来做单元测试的，后者是Unity新功能TimeLine中引入的全新概念，用于管理时间线上每一帧的动画、声音和视频等。 脚本创建完毕后，会自动生成一套模板代码，而模板文件在”安装目录\Editor\Data\Resources\ScriptTemplates”下，如下图所示，其中C#脚本、Testing脚本、Playables脚本以及Shader都在ScriptTemplates目录下。我们可以修改脚本模板的格式，这样以后再创建脚本时，就会按照修改后的格式来。模板文件名前面的数字代表菜单栏的排序，如果想新增一套模板，可以按照这个加一套新的。 添加自定义模板其实很有意义。例如，程序使用一些框架来编写，它们的基础模板需要拓展，如果每次创建脚本后，都将其手动添加到代码中，那就太麻烦了，此时就可以使用自定义模板。 拓展脚本模板添加模板的缺点就是无法进行版本化管理，项目组里的每个人都需要手动在本地安装的Unity目录下修改这个模板，未来如果要修改模板，也需要每个人单独改自己电脑文件下的模板文件，没有办法即时方便的同步。下面介绍一种新的添加模板的方式。首先将代码模板C# Script-MyNewBehaviourScript.cs.txt放入”项目/Assets/Editor/ScriptTemplates”目录下。该模板的代码如下： 1234567891011using System.Collections;using System.Collections.Generic;using UnityEngine;public class #NAME# : MonoBehaviour&#123; void MyFunction() &#123; &#125;&#125; 接下来需要在Project视图的Create菜单中添加C# MyScript菜单项，如下图所示。因为创建脚本时，需要监听用户输入的名字，所以代码需要继承EndNameEditAction来监听Callback，最终根据用户输入的名称自动创建对应的模板类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using UnityEngine;using UnityEditor;using System;using System.IO;using System.Text;using UnityEditor.ProjectWindowCallback;using System.Text.RegularExpressions;public class CustomScriptTemplate&#123; // 脚本模板所在的目录 private const string MY_SCRIPT_DEFAULT = "Assets/Editor/ScriptTemplates/C# Script-MyNewBehaviourScript.cs.txt"; [MenuItem("Assets/Create/C# MyScript", false, 80)] public static void CreateMyScript() &#123; string locationPath = GetSelectedPathOrFallback(); ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0, ScriptableObject.CreateInstance&lt;MyDoCreateScriptAsset&gt;(), locationPath + "/MyNewBehaviourScript.cs", null, MY_SCRIPT_DEFAULT); &#125; public static string GetSelectedPathOrFallback() &#123; string path = "Assets"; foreach (UnityEngine.Object obj in Selection.GetFiltered(typeof(UnityEngine.Object), SelectionMode.Assets)) &#123; path = AssetDatabase.GetAssetPath(obj); if (!string.IsNullOrEmpty(path) &amp;&amp; File.Exists(path)) &#123; path = Path.GetDirectoryName(path); break; &#125; &#125; return path; &#125; class MyDoCreateScriptAsset : EndNameEditAction &#123; public override void Action(int instanceId, string pathName, string resourceFile) &#123; UnityEngine.Object o = CreateScriptAssetFromTemplate(pathName, resourceFile); ProjectWindowUtil.ShowCreatedAsset(o); &#125; internal static UnityEngine.Object CreateScriptAssetFromTemplate(string pathName, string resourceFile) &#123; string fullPath = Path.GetFullPath(pathName); StreamReader streamReader = new StreamReader(resourceFile); string text = streamReader.ReadToEnd(); streamReader.Close(); string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(pathName); // 替换文件名 text = Regex.Replace(text, "#NAME#", fileNameWithoutExtension); bool encoderShouldEmitUTF8Identifier = true; bool throwOnInvalidBytes = false; UTF8Encoding encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier, throwOnInvalidBytes); bool append = false; StreamWriter streamWriter = new StreamWriter(fullPath, append, encoding); streamWriter.Write(text); streamWriter.Close(); AssetDatabase.ImportAsset(pathName); return AssetDatabase.LoadAssetAtPath(pathName, typeof(UnityEngine.Object)); &#125; &#125;&#125; 这段代码的核心部分在CreateScriptAssetFromTemplate()回调方法中。这里可以拿到用户输入的名称以及文件将创建的目录，进行简单的字符串替换后，就会创建一个全新的模板脚本类。 脚本的生命周期Unity脚本有一套完整的生命周期，脚本需要挂在任意游戏对象上，并且同一个游戏对象可以挂不同的脚本，各脚本执行自己的生命周期，它们可以相互组合并且互不干预。下图这张图完整地描述了脚本的生命周期。 生命周期中的所有方法都是Unity系统自己回调的，不需要手动调用，主要有编辑脚本、初始化、物理碰撞事件、更新回调、渲染和销毁等。 脚本绑定事件在编辑模式下，Unity并没有提供脚本的绑定事件，但是我们可以通过生命周期中的Reset()方法来实现。Reset()方法仅在非运行模式下才会生效，当把脚本挂在某个游戏对象上时，或者右击已经挂上脚本的对象，从弹出菜单中选择Reset菜单项（如下图所示）时，就可以监听脚本绑定时的事件了。 如下代码所示，在脚本中添加Reset()方法，就可以监听脚本绑定时的事件了。 1234567891011121314using System.Collections;using System.Collections.Generic;using UnityEngine;public class Script_04_02 : MonoBehaviour&#123; #if UNITY_EDITOR void Reset() &#123; Debug.LogFormat("GameObject: &#123;0&#125; 绑定Script_04_02.cs脚本", gameObject.name); &#125; #endif&#125; 脚本初始化和销毁脚本挂在游戏对象上，运行时就会立即执行初始化方法Awake()，它是一个同步方法，而Start()方法会在下一帧执行。如果游戏对象被删除，或者挂在它身上的脚本被删除，就会执行OnDestroy()销毁方法。需要记住的是，初始化或销毁在脚本的生命周期中只会执行一次。 此外，游戏对象还有个状态，叫禁用状态。左上角的复选框控制整个游戏对象（包括绑定的所有脚本）的激活或禁用状态，下面脚本左边的复选框只控制某个脚本是否激活或禁用。在程序运行的过程中，可以多次设置激活/禁用，同时系统会分别回调生命周期中的OnEnable()和OnDisable()方法。 如下代码所示，在代码中添加脚本生命周期方法。该脚本绑定在任意对象后，运行游戏即可查看它们的执行顺序。 123456789101112131415161718192021222324252627282930313233343536using System.Collections;using System.Collections.Generic;using UnityEngine;public class Script_04_03 : MonoBehaviour&#123; void Awake() &#123; Debug.Log("Awake用于初始化并且永远只会执行一次"); &#125; void OnEnable() &#123; Debug.Log("OnEnable在绑定的对象或脚本每次激活时执行一次"); &#125; void Start() &#123; Debug.Log("Start在初始化后的下一帧执行，并且永远只会执行一次"); &#125; void OnDisable() &#123; Debug.Log("OnDisable在绑定的对象或脚本每次取消激活时，执行一次"); &#125; void OnDestroy() &#123; Debug.Log("OnDestroy用于在绑定的对象删除或脚本移除时执行并且永远只会执行一次"); &#125; void OnApplicationQuit() &#123; Debug.Log("应用程序退出时执行一次"); &#125;&#125; 脚本更新与协程任务在整个生命周期中，主要提供了如下3种更新方法。 Update()：每一帧执行时，都会立即调用此方法。 LateUpdate()：Update()方法执行后，都会调用此方法。 FixedUpdate()：固定更新。默认情况下，系统每0.02秒调用一次，具体的间隔时间可以在TimeManager中配置。在导航菜单栏中选择Editor-&gt;Project Settings-&gt;Time菜单项，即可打开Time Manager。 总体来说，Update()和LateUpdate()属于立即更新，更新之间的频率是不固定的，比如某一帧有一个耗时操作时，就会影响到下一帧更新的时间，所以对更新频率要求比较稳定的物理系统就不太适合在这里处理更新。 FixedUpdate()虽然是固定更新，但是其实也是相对固定的，比如某一帧耗了好几秒，它依然会卡住。不过正常的程序会优化耗时操作，小范围的频率波动是正常的，可以让它更新的时间间隔稍微长一点，这样它的更新是比较平滑的。在实际的开发中，例如以秒为单位的倒计时，并不需要每一帧去判断时间，所以用FixedUpdate()就再合适不过了。 Unity的脚本只支持单线程，不过它引入了C#语言协程的概念，可以用来模拟多线程，而不是真正的多线程。举个实际点的例子，每等一秒就创建一个游戏对象，这在Update()中写就比较麻烦，但是引入协程的概念后，就可以直接用for循环来写了。使用StartCoroutine()方法，即可启动一个协程任务。在for循环中，我们使用yield return语句，告诉Unity需要等待多久再执行下一个循环。相关代码如下。 1234567891011121314151617181920using System.Collections;using System.Collections.Generic;using UnityEngine;public class Script_04_04 : MonoBehaviour&#123; void Start () &#123; StartCoroutine(CreateCube()); &#125; IEnumerator CreateCube() &#123; for (int i = 0; i &lt; 100; i ++) &#123; GameObject.CreatePrimitive(PrimitiveType.Cube).transform.position = Vector3.one * i; // 往右前上方每个一秒形成一个Cube yield return new WaitForSeconds(1f); &#125; &#125;&#125; 停止协程任务在协程任务启动的过程中，如果需要重新启动它，必须停掉之前的协程。每次启动协程时，StartCoroutine()将返回这个协程的对象，需要停止的时候使用StopCoroutine()传入对象即可。当然，也可以调用StopAllCoroutine()停止这个脚本所启动的所有协程任务。如下代码所示，启动CreateCube()协程方法，在循环中每隔一秒创建一个立方体对象。 12345678910111213141516171819202122232425262728293031323334353637using System.Collections;using System.Collections.Generic;using UnityEngine;public class Script_04_05 : MonoBehaviour&#123; IEnumerator CreateCube() &#123; for (int i = 0; i &lt; 100; i++) &#123; GameObject.CreatePrimitive(PrimitiveType.Cube).transform.position = Vector3.one * i; yield return new WaitForSeconds(1f); &#125; &#125; private Coroutine m_Coroutine = null; void OnGUI() &#123; if (GUILayout.Button("StartCoroutine")) &#123; if (m_Coroutine != null) &#123; StopCoroutine(m_Coroutine); &#125; m_Coroutine = StartCoroutine(CreateCube()); &#125; if (GUILayout.Button("StopCoroutine")) &#123; if (m_Coroutine != null) &#123; StopCoroutine(m_Coroutine); &#125; &#125; &#125;&#125; 使用OnGUI显示FPSGUI是Unity4.6版本之前的UI系统，因为其功能比较单一并且效率不高，已经被新版的UGUI所替代。如果想显示一些辅助信息或者调试按钮等，大多还会使用它。下面用OnGUI显示FPS。 FPS的含义就是一秒钟Update被执行了多少次。其计算原理就是先记一个初始时间，接着取当前时间减去初始时间，这期间Update执行的次数就是FPS了。 如下代码所示，在Update()中获取每一秒所执行的次数，最终在OnGUI()方法中将FPS打印在屏幕右上角。 123456789101112131415161718192021222324252627282930313233343536373839using System.Collections;using System.Collections.Generic;using UnityEngine;public class Script_04_06 : MonoBehaviour &#123; public float updateInterval = 0.5F; private float accum = 0; private int frames = 0; private float timeleft; private string stringFps; void Start() &#123; timeleft = updateInterval; &#125; void Update() &#123; timeleft -= Time.deltaTime; accum += Time.timeScale / Time.deltaTime; ++frames; if (timeleft &lt;= 0.0) &#123; float fps = accum / frames; string format = System.String.Format ("&#123;0:F2&#125; FPS", fps); stringFps = format; timeleft = updateInterval; accum = 0.0F; frames = 0; &#125; &#125; void OnGUI() &#123; GUIStyle guiStyle = GUIStyle.none; guiStyle.fontSize = 30; guiStyle.normal.textColor = Color.red; guiStyle.alignment = TextAnchor.UpperLeft; Rect rt = new Rect(40, 0, 100, 100); GUI.Label(rt, stringFps, guiStyle); &#125;&#125; 需要说明的是，FPS值越高，游戏就越流畅。但是手机上如果FPS太高，可能会影响发热并且会费电，所以可以考虑降低FPS。下面的代码强制设置FPS最高30帧： 1Application.targetFrameRate = 30f; // 强制设置FPS最高30帧 多脚本管理Unity脚本可以灵活地挂载多个游戏对象上，此时就衍生出一个问题：脚本多了，如何来管理，如何控制不同脚本执行的先后顺序。启动游戏后，Unity会同时处理所有脚本。比如，执行脚本中的Awake()方法时，Unity会先找到此时需要初始化的所有脚本，然后同时执行这些脚本的所有Awake()方法。计算机是没有同时这个概念的，它们都是有先后顺序的，也就是说排在前面的脚本会优先执行。 脚本的执行顺序脚本既可以在运行时动态添加在游戏对象上，也可以运行游戏前预制挂在游戏对象上。动态添加的脚本按添加的先后顺序决定执行顺序。但是静态脚本因为提前挂在了游戏对象上，所以初始化的顺序就不一样了。如下图所示，在Project视图中点击脚本，再点击Execution Order，可以设置脚本的执行顺序。 这就说明为什么在脚本生命周期中会提供Start()方法。例如，A脚本先执行B脚本后执行，如果A脚本在自己的Awake()方法中获取B脚本的数据，那么可能就会出错。因为此时B脚本的初始化方法还没有执行，所以Awake()方法适合做初始化，而在Start()方法中才适合安全地访问其他脚本数据。 多脚本优化脚本挂得越多，执行效率就越低。这些脚本都需要执行生命周期的方法，此时Unity需要遍历它们，然后再反射调用每个脚本的方法。一次全局的Update调用会在Unity内部干很多事情。 所以我们能做的优化就是避免挂太多的脚本，避免在脚本中写入这种空方法，如果不需要用，就把它删除掉： 123void Start()&#123;&#125; 脚本序列化脚本可以通过序列化和反序列化来保存游戏数据，换句话说，就是脚本自身并没有保存数据，而是将数据保存在文件中，使用的时候不需要自己重新组织数据，而是通过语法直接访问即可。如下图所示，脚本挂在GameObject上，而GameObject属于Scene游戏场景，所以Inspector面板中写入的最终将保存在Scene.Unity这个文件中。 接着再复制一份对象，并将其起名为Prefab。我们将它从Hierarchy视图拖入Project视图中，如下图所示，这份资源将变成预制体（Prefab.prefab）。如果在Project视图中赋值的话，所序列化的数据将会保存在Prefab.prefab文件中。但是如果在Hierarchy视图中赋值Prefab的话，数据将会保存在Scene.unity文件中。 查看数据Unity可以设置资源编辑器中的保存格式，如下图所示，其中Mixed表示混合模型，而Force Binary表示二进制格式。这里推荐使用 单例脚本Unity的脚本也属于一种特殊的C#类，它不能new出来，而需要绑定在游戏对象，而且脚本会随着游戏对象的删除而自动被释放掉。如果代码逻辑都写在了脚本中，那么出现切换场景一类的情形时，脚本的逻辑就走不了了。虽然Unity提供了DontDestroyOnLoad()方法，它可以在切换场景时不卸载游戏对象，但是总不能给所有对象都添加这个属性。总之，游戏中大量的逻辑代码是不需要写在脚本中的，除了依赖脚本生命周期中的回调方法以外。 有些功能比较单一且需要用到脚本生命周期方法的类，就比较适合使用单例脚本了。单例脚本的特点是它必须依赖游戏对象，并且必须保证这个游戏对象不能被卸载掉。 如下代码所示，Global脚本在它自己的static构造方法中创建对象并且设置DontDestroyOnLoad()，这样就能保证它自己不被主动卸载掉，并且构造方法只会执行一次。 1234567891011121314151617181920212223242526using System.Collections;using System.Collections.Generic;using UnityEngine;public class Global : MonoBehaviour &#123; public static Global instance; static Global() &#123; GameObject go = new GameObject("#Globa#"); DontDestroyOnLoad(go); instance = go.AddComponent&lt;Global&gt;(); &#125; public void DoSomeThings() &#123; Debug.Log("DoSomeThings"); &#125; void Start () &#123; Debug.Log("Start"); &#125;&#125; Global脚本不需要在编辑模式下绑定在某个对象上，运行时直接获取它的实例就能操作它了。具体使用方法如下所示： 12// 调用单例脚本的方法Global.instance.DoSomeThings(); 定时器协程任务是可以做定时器的，但是有个最大的问题，那就是必须用在脚本中，但是我们游戏的逻辑大部分都在C#代码中，所以需要封装一个不依赖于脚本实现的定时器。 如下代码所示，利用协程程序来做定时器。给WaitTime()传入定时时间以及时间结束后的回调方法，外部代码就可以处理定时解决的事件了。 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Events;public class WaitTimeManager &#123; private static TaskBehaviour m_Task; static WaitTimeManager() &#123; GameObject go = new GameObject("#WaitTimeManager#"); GameObject.DontDestroyOnLoad(go); m_Task = go.AddComponent&lt;TaskBehaviour&gt; (); &#125; // 等待 static public Coroutine WaitTime(float time,UnityAction callback) &#123; return m_Task.StartCoroutine (Coroutine(time,callback)); &#125; // 取消等待 static public void CancelWait(ref Coroutine coroutine) &#123; if (coroutine != null) &#123; m_Task.StopCoroutine (coroutine); coroutine = null; &#125; &#125; static IEnumerator Coroutine(float time,UnityAction callback)&#123; yield return new WaitForSeconds (time); if (callback != null) &#123; callback (); &#125; &#125; // 内部类 class TaskBehaviour : MonoBehaviour&#123;&#125;&#125; 无论是脚本还是类，在需要定时器的地方调用它即可，相关代码如下： 12345// 开启定时器Coroutine coroutine = WaitTimeManager.WaitTime(5f, delegate&#123;Debug.Log("等待5秒后回调"); &#125;);// 等待过程中取消它WaitTimeManager.CancelWait(ref coroutine); 脚本编译编译规则优化编译编译DLL脚本跨平台程序集定义日志Unity提供了Debug类来打印日志，常用的就是如下几种： 123Debug.Log("Log");Debug.LogError("LogError");Debug.LogWarning("LogWarning"); 在开发阶段，多打印日志可以方便地查看程序的行为。但是一旦发布以后，一定要把日志关闭掉，因为它会有一些额外的开销。如下代码所示，可以在初始化的位置设置条件编译，在非编辑模式下运行时，则关闭掉所有日志的输出： 123#if !UNITY_EDITOR Debug.unityLogger.logEnabled = false;#endif 另外，错误日志并不是我们主动打印出来的。错误日志的现场往往是非常珍贵的，我们需要尽可能地将错误日志保存下来。如果是移动平台，那么保存和提取日志其实挺不方便的，所以可以监听错误以及异常，并且及时将其打印到屏幕上。如下代码所示，监听Application.logMessageReceived事件即可捕获错误日志，最终在OnGUI()方法中将它们打印在屏幕上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384using System;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 下面这个类是将错误打印到一个新建的窗口中。/// &lt;/summary&gt;public class AddNewLogShowMethod : MonoBehaviour&#123; // 错误详情 private List&lt;String&gt; m_logEntries = new List&lt;String&gt;(); // Entry是条目的意思，可以用来作为变量名 // 是否显示错误窗口 private bool m_IsVisible = false; // 窗口显示区域 private Rect m_WindowRect = new Rect(0, 0, Screen.width, Screen.height); // 窗口滚动区域 private Vector2 m_scrollPositionText = Vector2.zero; // scroll是滚动的意思 private void Start() &#123; // 监听错误 // 委托的好处和必要性： // 委托的作用之一是动态增加方法，比如日志处理，在日志出来的时候执行委托。 // 日志可以用多种记录方式，可以写进数据表，可以直接打印，可以发邮件。 // 日志出来的地方直接执行委托函数。以后比如想日志在新设计的窗口展示，则扩展委托函数即可。 // 日志出来的地方不用动。对扩展开放，对修改关闭。实现了开闭原则。 // 比如此处，Application.logMessageReceived肯定在日志出现的地方执行了 // 这里直接赋予一个新的函数，则不影响原来的日志记录同时也可以执行新增的方法。 Application.logMessageReceived += (condition, stackTrace, type) =&gt; &#123; if (type == LogType.Exception || type == LogType.Error) &#123; if (!m_IsVisible) &#123; m_IsVisible = true; &#125; m_logEntries.Add(string.Format("&#123;0&#125;\n&#123;1&#125;", condition, stackTrace)); &#125; &#125;; // 创建异常以及错误 // 触发日志记录函数，执行新增的方法 for (int i = 0; i &lt; 10; i++) &#123; Debug.LogError("momo"); &#125; int[] a = null; a[1] = 100; &#125; void OnGUI() &#123; if(m_IsVisible)&#123; m_WindowRect = GUILayout.Window(0, m_WindowRect, ConsoleWindow, "Console"); &#125; &#125; // 日志窗口 void ConsoleWindow(int windowID) &#123; GUILayout.BeginHorizontal(); if (GUILayout.Button("Clear", GUILayout.MaxWidth(200))) &#123; m_logEntries.Clear(); &#125; if (GUILayout.Button("Close", GUILayout.MaxWidth(200))) &#123; m_IsVisible = false; &#125; GUILayout.EndHorizontal(); m_scrollPositionText = GUILayout.BeginScrollView(m_scrollPositionText); foreach (var entry in m_logEntries) &#123; Color currentColor = GUI.contentColor; GUI.contentColor = Color.red; GUILayout.TextArea(entry); GUI.contentColor = currentColor; &#125; GUILayout.EndScrollView(); &#125;&#125; 错误的调用栈已经打印在屏幕上。如果错误比较多，那么右侧需要一个滚动条。此外，还提供了Clear和Close操作。 脚本调试]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓展编辑器]]></title>
    <url>%2F2019%2F01%2F29%2F%E6%8B%93%E5%B1%95%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Unity提供了灵活多变的编辑器拓展API接口，通过代码反射，可以修改一些系统自带的编辑器窗口。此外，丰富的EditorGUI接口也可以拓展出各式各样的编辑器窗口。 拓展Project视图属于编辑模式下的代码，需要放在Editor文件夹下；属于运行时执行的代码，放在任意非Editor文件夹下即可。Editor文件夹的位置比较灵活，它还可以作为多个目录的子文件夹存在，这样开发者就可以按功能来划分，将不同功能的编辑代码放在不同的Editor目录下。例如可以有多个Editor目录，它们各自处理各自的逻辑。 拓展右键菜单选中资源 1234567891011121314151617using UnityEngine;using UnityEditor;public class Script_03_01&#123; [MenuItem("Assets/My Tools/Tools 1", false, 2)] static void MyTools1() &#123; Debug.Log(Selection.activeObject.name); &#125; [MenuItem("Assets/My Tools/Tools 2", false, 1)] static void MyTools2() &#123; Debug.Log(Selection.activeObject.name); &#125;&#125; Create按钮 1234567891011121314151617using UnityEngine;using UnityEditor;public class Script_03_02&#123; [MenuItem("Assets/Create/My Create/Cube", false, 2)] static void CreateCube() &#123; GameObject.CreatePrimitive(PrimitiveType.Cube); &#125; [MenuItem("Assets/Create/My Create/Sphere", false, 1)] static void CreateSphere() &#123; GameObject.CreatePrimitive(PrimitiveType.Sphere); &#125;&#125; 拓展布局在右侧拓展自定义按钮，在代码中既可以设置拓展按钮的区域，也可监听按钮的点击事件。在方法前面添加[InitializeOnLoadMethod]表示此方法会在C#代码每次编译完成后首先调用。监听EditorApplication.projectWindowItemOnGUI委托，即可使用GUI方法来绘制自定义的UI元素。GUI还提供了丰富的元素接口，可以用来添加文本、图片、滚动条和下拉框等复杂元素。 1234567891011121314151617181920212223242526272829using UnityEngine;using UnityEditor;public class Script_03_03&#123; [InitializeOnLoadMethod] static void InitializeOnLoadMethod() &#123; EditorApplication.projectWindowItemOnGUI = delegate (string guid, Rect selectionRect) &#123; // 在Project视图中选择一个资源 if (Selection.activeObject &amp;&amp; guid == AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(Selection.activeObject))) &#123; // 设置拓展按钮区域 float width = 50f; selectionRect.x += (selectionRect.width - width); selectionRect.y += 2f; selectionRect.width = width; GUI.color = Color.red; // 点击事件 if (GUI.Button(selectionRect, "click")) &#123; Debug.LogFormat("click : &#123;0&#125;", Selection.activeObject.name); &#125; GUI.color = Color.white; &#125; &#125;; &#125;&#125; 监听事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using UnityEngine;using UnityEditor;using System.Collections.Generic;public class Script_03_04 : UnityEditor.AssetModificationProcessor&#123; [InitializeOnLoadMethod] static void InitializeOnLoadMethod() &#123; // 全局监听Project视图下的资源是否发生变化（添加、删除和移动） EditorApplication.projectWindowChanged = delegate () &#123; Debug.Log("change"); &#125;; &#125; // 监听“双击鼠标左键，打开资源”事件 public static bool IsOpenForEdit(string assetPath, out string message) &#123; message = null; Debug.LogFormat("open : &#123;0&#125;", assetPath); // true表示该资源可以打开，false表示不允许在Unity中打开该资源 return true; &#125; // 监听“资源即将被创建”事件 public static void OnWillCreateAsset(string path) &#123; Debug.LogFormat("create : &#123;0&#125;", path); &#125; // 监听“资源即将被保存”事件 public static string[] OnWillSaveAssets(string[] paths) &#123; if (paths != null) &#123; Debug.LogFormat("save : &#123;0&#125;", string.Join(",", paths)); &#125; return paths; &#125; // 监听“资源即将被移动”事件 public static AssetMoveResult OnWillMoveAsset(string oldPath, string newPath) &#123; Debug.LogFormat("move : &#123;0&#125; to &#123;1&#125;", oldPath, newPath); // AssetMoveResult.DidMove表示该资源可以移动 return AssetMoveResult.DidMove; &#125; // 监听“资源即将被删除”事件 public static AssetDeleteResult OnWillDeleteAsset(string assetPath, RemoveAssetOptions option) &#123; Debug.LogFormat("delete : &#123;0&#125;", assetPath); // AssetDeleteResult.DidNotDelete表示该资源可以被删除 return AssetDeleteResult.DidNotDelete; &#125;&#125; 拓展Hierarchy视图Hierarchy视图中出现的都是游戏对象，这些对象之间同样具有一定的关联关系。Hierarchy视图中的游戏对象会通过摄像机最终投影在发布的游戏中。 拓展菜单1234567891011using UnityEngine;using UnityEditor;public class Script_03_05&#123; [MenuItem("GameObject/My Create/Cube", false, 0)] static void CreateCube() &#123; GameObject.CreatePrimitive(PrimitiveType.Cube); &#125;&#125; 拓展布局12345678910111213141516171819202122232425262728using UnityEngine;using UnityEditor;public class Script_03_06&#123; [InitializeOnLoadMethod] static void InitializeOnLoadMethod() &#123; EditorApplication.hierarchyWindowItemOnGUI = delegate (int instanceID, Rect selectionRect) &#123; // 在Hierarchy视图中选择一个资源 if (Selection.activeObject &amp;&amp; instanceID == Selection.activeObject.GetInstanceID()) &#123; // 设置拓展按钮区域 float width = 50f; float height = 20f; selectionRect.x += (selectionRect.width - width); selectionRect.width = width; selectionRect.height = height; // 点击事件 if (GUI.Button(selectionRect, AssetDatabase.LoadAssetAtPath&lt;Texture&gt;("Assets/unity.png"))) &#123; Debug.LogFormat("click : &#123;0&#125;", Selection.activeObject.name); &#125; &#125; &#125;; &#125;&#125; 重写菜单123456789101112131415161718192021222324252627282930313233343536373839404142using UnityEngine;using UnityEditor;public class Script_03_07&#123; [MenuItem("Window/Test/Test")] static void Test() &#123; &#125; [MenuItem("Window/Test/Test1")] static void Test1() &#123; &#125; [MenuItem("Window/Test/Demo/Test2")] static void Test2() &#123; &#125; [InitializeOnLoadMethod] static void StartInitializeOnLoadMethod() &#123; EditorApplication.hierarchyWindowItemOnGUI += OnHierarchyGUI; &#125; static void OnHierarchyGUI(int instanceID, Rect selectionRect) &#123; if (Event.current != null &amp;&amp; selectionRect.Contains(Event.current.mousePosition) &amp;&amp; Event.current.button == 1 &amp;&amp; Event.current.type &lt;= EventType.MouseUp) &#123; GameObject selectedGameObject = EditorUtility.InstanceIDToObject(instanceID) as GameObject; // 这里可以判断selectedGameObject的条件 if (selectedGameObject) &#123; Vector2 mousePosition = Event.current.mousePosition; EditorUtility.DisplayPopupMenu(new Rect(mousePosition.x, mousePosition.y, 0, 0), "Window/Test", null); Event.current.Use(); &#125; &#125; &#125;&#125; 在上述代码中，使用Event.current来获取当前的事件。当监听到鼠标抬起的事件后，并且满足游戏对象的选中状态，开始执行自定义事件。其中，EditorUtility.DisplayPopupMenu用于弹出自定义菜单，Event.current.Use()的含义是不再执行原有的操作，所以就实现了重写菜单。 此外，Hierarchy视图还可以重写系统自带的菜单行为。例如，觉得Unity创建的Image组件不好，可以复写它的行为。创建Image组件时，会自动勾选RaycastTarget。如果图片不需要处理点击事件，这样会带来一些额外的开销。下面的代码让RaycastTarget默认不勾选。由于重写了菜单，所以需要通过脚本自行创建Image对象和组件。接着，获取到image组件对象，直接设置它的raycastTarget属性即可。 12345678910111213141516171819202122using UnityEngine;using UnityEditor;using UnityEngine.UI;public class Script_03_08&#123; [MenuItem("GameObject/UI/Image")] static void CreateImage() &#123; if (Selection.activeTransform) &#123; if (Selection.activeTransform.GetComponentInParent&lt;Canvas&gt;()) &#123; Image image = new GameObject("image").AddComponent&lt;Image&gt;(); image.raycastTarget = false; image.transform.SetParent(Selection.activeTransform, false); // 设置选中状态 Selection.activeTransform = image.transform; &#125; &#125; &#125;&#125; 拓展Inspector视图拓展源生组件摄像机就是典型的源生组件。可以在摄像机组件的最上面添加一个按钮。它的局限性就是拓展组件只能加在源生组件的最上面或者最下面。 12345678910111213using UnityEngine;using UnityEditor;[CustomEditor(typeof(Camera))]public class Script_03_09 : Editor&#123; public override void OnInspectorGUI() &#123; if (GUILayout.Button("拓展按钮")) &#123; &#125; base.OnInspectorGUI(); &#125;&#125; 拓展继承组件123456789101112131415161718192021222324using UnityEngine;using UnityEditor;using System.Reflection;[CustomEditor(typeof(Transform))]public class Script_03_10 : Editor&#123; private Editor m_Editor; void OnEnable() &#123; m_Editor = Editor.CreateEditor(target, Assembly.GetAssembly(typeof(Editor)).GetType("UnityEditor.TransformInspector", true)); &#125; public override void OnInspectorGUI() &#123; if (GUILayout.Button("拓展按钮")) &#123; &#125; // 调用系统绘制方法 m_Editor.OnInspectorGUI(); //base.OnInspectorGUI(); &#125;&#125; 组件不可编辑12345678910111213141516171819202122232425262728using UnityEngine;using UnityEditor;using System.Reflection;[CustomEditor(typeof(Transform))]public class Script_03_11 : Editor&#123; private Editor m_Editor; void OnEnable() &#123; m_Editor = Editor.CreateEditor(target, Assembly.GetAssembly(typeof(Editor)).GetType("UnityEditor.TransformInspector", true)); &#125; public override void OnInspectorGUI() &#123; if (GUILayout.Button("拓展按钮上")) &#123; &#125; // 开始禁止 GUI.enabled = false; m_Editor.OnInspectorGUI(); // 结束禁止 GUI.enabled = true; if (GUILayout.Button("拓展按钮下")) &#123; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829using UnityEngine;using UnityEditor;public class Script_03_12 &#123; [MenuItem("GameObject/3D Object/Lock/Lock", false, 0)] static void Lock() &#123; if (Selection.gameObjects != null) &#123; foreach (var gameObject in Selection.gameObjects) &#123; gameObject.hideFlags = HideFlags.NotEditable; &#125; &#125; &#125; [MenuItem("GameObject/3D Object/Lock/UnLock", false, 1)] static void UnLock() &#123; if (Selection.gameObjects != null) &#123; foreach (var gameObject in Selection.gameObjects) &#123; gameObject.hideFlags = HideFlags.None; &#125; &#125; &#125;&#125; Context菜单123456789101112131415161718using UnityEngine;using UnityEditor;public class Script_03_13&#123; [MenuItem("CONTEXT/Transform/New Context 1")] public static void NewContext1(MenuCommand command) &#123; // 获取对象名 Debug.Log(command.context.name); &#125; [MenuItem("CONTEXT/Transform/New Context 2")] public static void NewContext2(MenuCommand command) &#123; Debug.Log(command.context.name); &#125;&#125; 123456789101112131415161718using UnityEngine;#if UNITY_EDITORusing UnityEditor;#endifpublic class Script_03_14 : MonoBehaviour&#123; public string contextName; #if UNITY_EDITOR [MenuItem("CONTEXT/Script_03_14/New Context 1")] public static void NewContext2(MenuCommand command) &#123; Script_03_14 script = (command.context as Script_03_14); script.contextName = "hello world!"; &#125; #endif&#125; 拓展Scene视图辅助元素12345678910111213using UnityEngine;public class Script_03_15 : MonoBehaviour&#123; private void OnDrawGizmosSelected() &#123; Gizmos.color = Color.red; // 画线 Gizmos.DrawLine(transform.position, Vector3.one); // 立方体 Gizmos.DrawCube(Vector3.one, Vector3.one); &#125;&#125; 辅助UI1234567891011121314151617181920212223242526using UnityEngine;using UnityEditor;[CustomEditor(typeof(Camera))]public class Script_03_16 : Editor&#123; private void OnSceneGUI() &#123; Camera camera = target as Camera; if (camera != null) &#123; Handles.color = Color.red; Handles.Label(camera.transform.position, camera.transform.position.ToString()); Handles.BeginGUI(); GUI.backgroundColor = Color.red; if (GUILayout.Button("click", GUILayout.Width(200f))) &#123; Debug.LogFormat("click = &#123;0&#125;", camera.name); &#125; GUILayout.Label("Label"); Handles.EndGUI(); &#125; &#125;&#125; 常驻辅助UI12345678910111213141516171819using UnityEngine;using UnityEditor;public class Script_03_17 : Editor&#123; [InitializeOnLoadMethod] static void InitializeOnLoadMethod() &#123; SceneView.onSceneGUIDelegate = delegate (SceneView sceneView) &#123; Handles.BeginGUI(); GUI.Label(new Rect(0f, 0f, 50f, 15f), "标题"); GUI.Button(new Rect(0f, 20f, 50f, 50f), AssetDatabase.LoadAssetAtPath&lt;Texture&gt;("Assets/unity.png")); Handles.EndGUI(); &#125;; &#125;&#125; 禁用选中对象12345678910111213141516171819202122using UnityEngine;using UnityEditor;public class Script_03_18&#123; [InitializeOnLoadMethod] static void InitializeOnLoadMethod() &#123; SceneView.onSceneGUIDelegate = delegate (SceneView sceneView) &#123; Event e = Event.current; if (e!= null) &#123; int controlID = GUIUtility.GetControlID(FocusType.Passive); if (e.type == EventType.Layout) &#123; HandleUtility.AddDefaultControl(controlID); &#125; &#125; &#125;; &#125;&#125; 拓展Game视图MenuItem菜单面板拓展脚本挂在游戏对象上时，右侧会出现它的详细信息面板，这些信息是根据脚本中声明的public可序列化变量而来的。此外，也可以通过EditorGUI来对它进行绘制，让面板更具可操作性。 Inspector面板EditorGUI和GUI的用法几乎完全一致，目前来说前者多用于编辑器开发，后者多用于发布后调试编辑器。总之，它们都是起辅助作用的。EditorGUI提供的组件非常丰富，常用的绘制元素包括文本、按钮、图片和滚动框等。做一个好的编辑器，是离不开EditorGUI的。如下图所示，将EditorGUI拓展在Inspector面板上了。 1234567891011121314151617181920212223242526272829303132333435363738using UnityEngine;using UnityEditor;using UnityEditor.Experimental.UIElements;using UnityEngine.Experimental.UIElements;using UnityEngine.Experimental.UIElements.StyleEnums;public class Script_03_33 : EditorWindow&#123; [MenuItem("UIElementsTest/Style")] public static void ShowExample() &#123; Script_03_33 window = GetWindow&lt;Script_03_33&gt;(); window.titleContent = new GUIContent("Script_03_33"); &#125; public void OnEnable() &#123; var root = this.GetRootVisualContainer(); // 添加style.uss样式 root.AddStyleSheetPath("style"); var boxes = new VisualContainer(); // 设置自动换行 boxes.style.flexDirection = FlexDirection.Row; boxes.style.flexWrap = Wrap.Wrap; for (int i=0;i&lt;20;i++) &#123; TextField m_TextField = new TextField(); boxes.Add(m_TextField); Button button = new Button(delegate () &#123; Debug.LogFormat("Click"); &#125;); button.text = "我是按钮我要自适应"; boxes.Add(button); &#125; root.Add(boxes); &#125;&#125; 在上述代码中，将脚本部分和Editor部分的代码合在一个文件中。如果需要拓展的面板比较复杂，建议分成两个文件存放，一个是脚本，另一个是Editor脚本。 EditorWindows窗口Unity提供编辑器窗口，开发者可以自由拓展自己的窗口。Unity编辑器系统自带的视图窗口其实也是用EditorWindows实现的。如下图所示，它绘制元素时同样适用EditorGUI代码。 使用EditorWindow.GetWindow()方法即可打开自定义窗口，在OnGUI()方法中可以绘制窗口元素。注意代码中EditorWindos窗口的生命周期。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667using UnityEngine;using UnityEditor;public class Script_03_24 : EditorWindow&#123; [MenuItem("Window/Open My Window")] static void Init() &#123; Script_03_24 window = (Script_03_24)EditorWindow.GetWindow(typeof(Script_03_24)); window.Show(); &#125; private Texture m_MyTexture = null; private float m_MyFloat = 0.5f; private void Awake() &#123; Debug.LogFormat("窗口初始化时调用"); m_MyTexture = AssetDatabase.LoadAssetAtPath&lt;Texture&gt;("Assets/unity.png"); &#125; private void OnGUI() &#123; GUILayout.Label("Hello World!!", EditorStyles.boldLabel); m_MyFloat = EditorGUILayout.Slider("Slider", m_MyFloat, -5, 5); GUI.DrawTexture(new Rect(0, 30, 100, 100), m_MyTexture); &#125; private void OnDestroy() &#123; Debug.LogFormat("窗口销毁时调用"); &#125; private void OnFocus() &#123; Debug.LogFormat("窗口拥有焦点时调用"); &#125; private void OnHierarchyChange() &#123; Debug.LogFormat("Hierarchy视图发生改变时调用"); &#125; private void OnInspectorUpdate() &#123; //Debug.LogFormat("Inspector每帧更新"); &#125; private void OnLostFocus() &#123; Debug.LogFormat("失去焦点"); &#125; private void OnProjectChange() &#123; Debug.LogFormat("Project视图发生改变时调用"); &#125; private void OnSelectionChange() &#123; Debug.LogFormat("在Hierarchy或者Project视图中选择一个对象时调用"); &#125; private void Update() &#123; // Debug.LogFormat("每帧更新"); &#125;&#125; EditorWindows下拉菜单在EditorWindows编辑窗口的右上角，有个下拉菜单，也可以对该菜单中的选项进行拓展，不过这里需要实现IHasCustomMenu接口。 12345678910111213141516171819202122232425262728293031using UnityEngine;using UnityEditor;public class Script_03_25 : EditorWindow, IHasCustomMenu&#123; void IHasCustomMenu.AddItemsToMenu(GenericMenu menu) &#123; menu.AddDisabledItem(new GUIContent("Disable")); menu.AddItem(new GUIContent("Test1"), true, () =&gt; &#123; Debug.Log("Test1"); &#125;); menu.AddItem(new GUIContent("Test2"), true, () =&gt; &#123; Debug.Log("Test2"); &#125;); menu.AddSeparator("Test/"); menu.AddItem(new GUIContent("Test/Test3"), true, () =&gt; &#123; Debug.Log("Test3"); &#125;); &#125; [MenuItem("Window/Open My Window")] static void Init() &#123; Script_03_25 window = (Script_03_25)EditorWindow.GetWindow(typeof(Script_03_25)); window.Show(); &#125;&#125; 上述代码中，通过AddItem()方法来添加列表元素，并且监听选择后的事件。 预览窗口选择游戏对象或者游戏资源后，Inspector面板下方将会出现它的预览窗口，但是有些资源是没有预览信息的，不过可以监听它的窗口方法来重新绘制它。如下图所示。 1234567891011121314151617using UnityEngine;using UnityEditor;[CustomPreview(typeof(GameObject))]public class Script_03_26 : ObjectPreview&#123; public override bool HasPreviewGUI() &#123; return true; &#125; public override void OnPreviewGUI(Rect r, GUIStyle background) &#123; GUI.DrawTexture(r, AssetDatabase.LoadAssetAtPath&lt;Texture&gt;("Assets/unity.png")); GUILayout.Label("Hello World!!!"); &#125;&#125; 这段代码的原理就是继承ObjectPreview并且重写OnPreviewGUI()方法，接着就可以通过代码进行绘制了。[CustomPreview(typeof(GameObject))]中的GameObject代表需要重新绘制的预览对象，也可以换成别的系统对象或自定义的脚本对象。 获取预览信息有些资源是有预览信息的，比如模型资源。在预览窗口中，可以看到它的样式。如果需要在自定义窗口中显示它，就需要获取它的预览信息。如下图所示，选择一个游戏对象后，会在自定义窗口中显示它。 1234567891011121314151617181920212223242526272829303132using UnityEngine;using UnityEditor;public class Script_03_27 : EditorWindow&#123; private GameObject m_MyGo; private Editor m_MyEditor; [MenuItem("Window/Open My Window")] static void Init() &#123; Script_03_27 window = (Script_03_27)EditorWindow.GetWindow(typeof(Script_03_27)); window.Show(); &#125; private void OnGUI() &#123; // 设置一个游戏对象 m_MyGo = (GameObject)EditorGUILayout.ObjectField(m_MyGo, typeof(GameObject), true); if (m_MyGo != null) &#123; if (m_MyEditor == null) &#123; // 创建Editor实例 m_MyEditor = Editor.CreateEditor(m_MyGo); &#125; // 预览它 m_MyEditor.OnPreviewGUI(GUILayoutUtility.GetRect(500, 500), EditorStyles.whiteLabel); &#125; &#125;&#125; 在上述代码中，预览对象首先需要通过Editor.CreateEditor()拿到它的Editor实例对象，接着调用OnPreviewGUI()方法传入窗口的显示区域。 Unity编辑器的源码Unity编辑器几乎都是用C#编写而成，视图中也大量使用EditorGUI来编辑布局。例如，对于常见的5大布局视图，所有的代码都放在UnityEditor.dll中。打开Unity安装目录，在Unity\Editor\Data\Managed子目录中存放着引擎所需要用到的所有DLL文件。 查看DLL拿到UnityEditor.dll以后，就可以通过第三方工具来分析和查看了。常用的工具包括.NET Reflector以及ILSpy。其实Unity的C#版API接口都在UnityEngine.dll里，只是源码的核心功能都是在C/C++中完成的，DLL只负责中间调用接口而已。 清空控制台日志系统日志以及Debug.Log()产出的日志都输出在Console窗口中。在Console窗口的左上角，有个Clean按钮，它用于清空控制台日志。如果希望脚本可以灵活自动清空日志，就必须使用反射了。首先找到控制台的窗口类（ConsoleWindows.cs），接着在OnGUI()方法中可以看到：点击Clean按钮后，Unity会执行LogEntries.Clear()方法。 1234567891011121314151617181920212223using UnityEngine;using UnityEditor;using System.Reflection;public class Script_03_28&#123; [MenuItem("Tools/CreateConsole")] static void CreateConsole() &#123; Debug.Log("CreateConsole"); &#125; [MenuItem("Tools/CleanConsole")] static void CleanConsole() &#123; // 获取assembly Assembly assembly = Assembly.GetAssembly(typeof(Editor)); // 反射获取LogEntries对象 MethodInfo methodInfo = assembly.GetType("UnityEditor.LogEntries").GetMethod("Clear"); // 反射调用它的Clear方法 methodInfo.Invoke(new object(), null); &#125;&#125; 获取EditorStyles样式1234567891011121314151617181920212223242526272829303132333435363738using UnityEngine;using UnityEditor;using System.Reflection;using System.Collections.Generic;public class Script_03_29 : EditorWindow&#123; static List&lt;GUIStyle&gt; styles = null; [MenuItem("Window/Open My Window")] public static void Test() &#123; EditorWindow.GetWindow&lt;Script_03_29&gt;("styles"); styles = new List&lt;GUIStyle&gt;(); foreach (PropertyInfo fi in typeof(EditorStyles).GetProperties(BindingFlags.Static|BindingFlags.Public|BindingFlags.NonPublic)) &#123; object o = fi.GetValue(null, null); if (o.GetType() == typeof(GUIStyle)) &#123; styles.Add(o as GUIStyle); &#125; &#125; &#125; public Vector2 scrollPosition = Vector2.zero; private void OnGUI() &#123; scrollPosition = GUILayout.BeginScrollView(scrollPosition); for (int i =0;i&lt;styles.Count;i++) &#123; GUILayout.Label("EditorStyles." + styles[i].name, styles[i]); &#125; GUILayout.EndScrollView(); &#125;&#125; 获取内置图标样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using UnityEngine;using UnityEditor;using System.Reflection;using System.Collections.Generic;using System;public class Script_03_30 : EditorWindow&#123; [MenuItem("Window/Open My Window")] public static void OpenMyWindow() &#123; EditorWindow.GetWindow&lt;Script_03_30&gt;("icons"); &#125; private Vector2 m_Scroll; private List&lt;string&gt; m_Icons = null; private void Awake() &#123; m_Icons = new List&lt;string&gt;(); Texture2D[] t = Resources.FindObjectsOfTypeAll&lt;Texture2D&gt;(); foreach (Texture2D x in t) &#123; Debug.unityLogger.logEnabled = false; GUIContent gc = EditorGUIUtility.IconContent(x.name); Debug.unityLogger.logEnabled = true; if (gc != null &amp;&amp; gc.image != null) &#123; m_Icons.Add(x.name); &#125; &#125; Debug.Log(m_Icons.Count); &#125; private void OnGUI() &#123; m_Scroll = GUILayout.BeginScrollView(m_Scroll); float width = 50f; int count = (int)(position.width / width); for (int i=0;i&lt;m_Icons.Count;i+=count) &#123; GUILayout.BeginHorizontal(); for (int j=0;j&lt;count;j++) &#123; int index = i + j; if (index&lt;m_Icons.Count) &#123; GUILayout.Button(EditorGUIUtility.IconContent(m_Icons[index]), GUILayout.Width(width), GUILayout.Height(30)); &#125; &#125; GUILayout.EndHorizontal(); &#125; EditorGUILayout.EndScrollView(); &#125;&#125; 拓展默认面板1234567891011121314151617using UnityEngine;using UnityEditor;[CustomEditor(typeof(UnityEditor.DefaultAsset))]public class Script_03_31 : Editor&#123; public override void OnInspectorGUI() &#123; string path = AssetDatabase.GetAssetPath(target); GUI.enabled = true; if (path.EndsWith(string.Empty)) &#123; GUILayout.Label("拓展文件夹"); GUILayout.Button("我是文件夹"); &#125; &#125;&#125; UIElements1234567891011TextField&#123; height:100; width:100px;&#125;Button&#123; height:50; width:100px;&#125; 1234567891011121314151617181920212223242526272829303132333435363738using UnityEngine;using UnityEditor;using UnityEditor.Experimental.UIElements;using UnityEngine.Experimental.UIElements;using UnityEngine.Experimental.UIElements.StyleEnums;public class Script_03_33 : EditorWindow&#123; [MenuItem("UIElementsTest/Style")] public static void ShowExample() &#123; Script_03_33 window = GetWindow&lt;Script_03_33&gt;(); window.titleContent = new GUIContent("Script_03_33"); &#125; public void OnEnable() &#123; var root = this.GetRootVisualContainer(); // 添加style.uss样式 root.AddStyleSheetPath("style"); var boxes = new VisualContainer(); // 设置自动换行 boxes.style.flexDirection = FlexDirection.Row; boxes.style.flexWrap = Wrap.Wrap; for (int i=0;i&lt;20;i++) &#123; TextField m_TextField = new TextField(); boxes.Add(m_TextField); Button button = new Button(delegate () &#123; Debug.LogFormat("Click"); &#125;); button.text = "我是按钮我要自适应"; boxes.Add(button); &#125; root.Add(boxes); &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[资源加载与优化（1）]]></title>
    <url>%2F2018%2F12%2F05%2F%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 编辑模式下的资源分为几类？ 在编辑模式下读取工程内的资源使用什么类，需要什么硬性条件？如果不满足，使用什么类读取？ Resources目录是干什么用的？ 本章涵盖： 编辑模式下的资源管理 版本管理 运行模式下的资源管理 AssetBundle 在游戏开发中，资源管理是非常重要的，管理不好，就容易导致内存溢出，引起闪退或者整体游戏卡顿的现象。Unity提供了强大的Profiler工具，它专门查看每一帧内存的占用以及加载的耗时。此外，它还提供了自定义接口，开发者也可以自行定义一个查看区间。另外，Unity还提供了Frame Debugger，它可以查看每一帧渲染的详细过程。如果DrawCall很多的话，可以参照它来想办法合并。另外，Unity也提供了丰富的资源加载接口，我们可以在编辑模式下加载资源，在运行模式下加载本地资源和下载资源。总之，管理好资源的加载以及优化，才能让游戏更加流畅。 编辑模式编辑模式并非打包后的运行模式，而仅仅是在编辑器下运行。它可以访问加载到硬盘上的任意资源，这对拓展引擎内置的编辑器是非常好的。引擎可以读取任意资源来丰富编辑器。但是如果游戏发布后，就会有很多限制，比如编辑模式下可使用的大量代码在运行时无法使用。 加载资源编辑模式下的资源可分为两类：一类是引擎可识别的资源，例如Prefab、声音、视频、动画和UI等；另一类是引擎无法识别的资源，例如外部导入的资源，这类资源需要通过第三方工具将它的信息解析出来，最终组织成引擎内可识别资源才可以使用（例如Excel文件）。 在编辑模式下，Unity提供了一个标志性的类AssetDatabase，它专门负责读取工程内的资源。需要保证所有资源必须放在项目的Assets目录下，不然AssetDatabase是无法读取的，只能使用File类或者其他第三辅助类来读取。 接着，在编辑模式下实例化一个Prefab到场景中。如下图所示，Prefab被实例化到了Main Camera节点下，但是为什么它不是“蓝色”的呢？并且坐标为什么没有回归原点呢？因为GameObject.Instantiate()只能创建新对象，这样将丢失Prefab的引用。坐标没有回归原点是因为transform.SetParent会继承世界坐标。通过这段代码可以看出，只要提供一个Assets内的相对路径，使用AssetDatabase.LoadAssetAtPath()方法即可读取任意对象。 12345678910111213141516171819using UnityEngine; using UnityEditor;public class Script_11_01&#123; [MenuItem("Assets/My Tools/Load", false, 2)] static void MyLoad() &#123; // 先选取Main Camera再点击Load按钮 if (Selection.activeTransform) &#123; //读取Prefab GameObject prefab = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;("Assets/Cube.prefab"); //实例化到Scene中 GameObject go = GameObject.Instantiate&lt;GameObject&gt;(prefab); //设置它的父节点 go.transform.SetParent(Selection.activeTransform); &#125; &#125;&#125; 实例化Prefab在编辑模式下，实例化Prefab需要使用PrefabUtility.InstantiatePrefab()方法。如下图所示，实例化后的Prefab已经变成了“蓝色”，并且Transform的坐标已经回归原点。此外，除了Prefab以外，FBX也属于一种特殊的引用关系的资源，它也可以使用这种方法，这样会保持它的一些引用关系。 将Prefab实例化到Hierarchy视图中。其中，PrefabUtility.InstantiatePrefab ()方法可以保持原有的引用关系，并非克隆一份新的。另外，给transform. SetParent()的第二个参数传入false，表示它不被父坐标影响，所以就会回归原 点。 123456789101112131415161718192021using UnityEngine; using UnityEditor;public class Script_11_02&#123; [MenuItem("Assets/My Tools/LoadPrefab", false, 2)] static void LoadPrefab() &#123; if (Selection.activeTransform) &#123; // 读取Prefab GameObject prefab = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;("Assets/Cube.prefab"); // 实例化到Scene中 // GameObject go = GameObject.Instantiate&lt;GameObject&gt;(prefab); GameObject go = PrefabUtility.InstantiatePrefab(prefab) as GameObject; // 设置它的父节点 // go.transform.SetParent(Selection.activeTransform); go.transform.SetParent(Selection.activeTransform, false); &#125; &#125;&#125; 创建Prefab使用PrefabUtility.CreatePrefab()方法可以创建Prefab，此时需要提供保存的目录以及当前的游戏对象。其中，ReplacePrefabOptions.ConnectToPrefab表示创建Prefab的同时自动关联到创建它的这个游戏对象。如以下代码所示，在Hierarchy视图中选择任意游戏对象，并且选择Create Prefab菜单项，在资源目录下创建Prefab，并将它关联到创建的这个游戏对象本身。 1234567891011121314151617181920212223using UnityEngine; using UnityEditor;public class Script_11_03&#123; [MenuItem ("Assets/My Tools/Create Prefab", false, 3)] static void CreatePrefab() &#123; if (Selection.activeTransform) &#123; string path = "Assets/Prefab.prefab"; // 如果文件已经存在,删除它 if (AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path)) &#123; AssetDatabase.DeleteAsset(path); // 创建新的Prefab PrefabUtility.CreatePrefab("Assets/Prefab.prefab", Selection.activeGameObject, ReplacePrefabOptions.ConnectToPrefab); // 刷新Project视图目录 AssetDatabase.Refresh(); &#125; &#125; &#125;&#125; 更新Prefab使用PrefabUtility.ReplacePrefab()方法可以更新Prefab，不过在更新前，需要判断Hierarchy选择的游戏对象是否为Prefab，如果不是Prefab，也可以考虑创建新的。相关代码如下所示。 12345678910111213141516171819202122using UnityEngine; using UnityEditor;public class Script_11_04&#123; [MenuItem ("Assets/My Tools/Update Prefab", false, 3)] static void UpdatePrefab() &#123; if(Selection.activeTransform) &#123; // 确保Hierarchy视图中当前选择的是Prefab Object prefab = PrefabUtility.GetPrefabParent(Selection.activeGameObject); if (prefab) &#123; // 替换它 PrefabUtility.ReplacePrefab(Selection.activeGameObject, prefab, ReplacePrefabOptions.ConnectToPrefab); // 刷新Project视图目录 AssetDatabase.Refresh(); &#125; &#125; &#125;&#125; 在上述代码中，我们通过PrefabUtility.GetPrefabParent()判断当前选择的是否为Prefab：如果是Prefab，则更新它；如果不是Prefab，则创建一个新的。 卸载资源在编辑模式下，只能使用GameObject.DestroyImmediate()方法来卸载游戏对象。如果需要卸载游戏对象引用的资源，则第二个参数填true，其默认值是false。 如以下代码所示，选择Hierarchy视图中的任意游戏对象，点击Delete菜单项即可删除它。 1234567891011121314using UnityEngine; using UnityEditor;public class Script_11_05&#123; [MenuItem("Assets/My Tools/Delete", false, 3)] static void Delete() &#123; if (Selection.activeTransform)&#123; // 第二个参数表示是否卸载游戏对象引用的资源 GameObject.DestroyImmediate(Selection.activeGameObject, true); &#125; &#125;&#125; 游戏对象与资源的关系游戏对象与资源是一种引用关系。例如一个模型是由贴图和Mesh组成，将它拖入场景中时，生成的游戏对象就会引用这两种资源。当程序调用GameObject.Destroy()或者GameObject.DestroyImmediate()方法时，只会卸载掉它的对象，它身上引用的贴图和Mesh还在内存中。 Unity这么做是有原因的：很多游戏对象的加载与卸载是很频繁的，如果每次卸载都将引用的资源清理掉，无疑会造成IO的阻塞。但是如果长时间不卸载这些资源，那么内存必然涨上去，所以Unity又提供了一个方法来自动卸载无用资源。其中，无用资源表示没有被别的对象或者代引用的资源。如以下代码所示，调用EditorUtility.UnloadUnusedAssetsImmediate方法即可卸载编辑器下无用的资源了。在运行时也存在类似的资源，后面会讲到。 1234567891011using UnityEngine; using UnityEditor;public class Script_11_06&#123; [MenuItem("Assets/My Tools/UnloadUnusedAssetsImmediate", false, 3)] static void UnloadUnusedAssetsImmediate() &#123; EditorUtility.UnloadUnusedAssetsImmediate(); &#125;&#125; 版本管理多人同时开发游戏时，需要对项目的版本进行管理，通常会将整个工程上传SVN或者Git，然而资源在导入Unity的时候，会自动生成很多中间资源，这些资源是不需要上传的。如下图所示，只需要将Assets、ProjectSettings文件夹下的所有文件以及.meta文件上传即可。 meta文件meta文件是Unity自动生成的。每个游戏资源都会有一个对应的.meta文件，它会标记在引擎中的一些设置信息，我们可以在资源视图面板中重新设置这些资源的参数。此时meta文件中将会保留这些参数。将资源拖入工程时，就会利用这些参数重新压缩资源。换句话说，在用户无感知的情况下被Unity优化了。如下图所示，首先需要在Editor Settings中设置显示.meta文件。 接着，随便打开一张贴图对应的.meta文件，如下图所示。每个meta文件都会记录guid这个重要信息。guid就是用来关联资源与游戏对象的引用的。比如场景中有个模型，引用了这张贴图，那么模型对应Prefab的.meta文件中就会引用这个guid；如果模型不是Prefab，只是保持在场景中，那么场景的.meta文件就会引用这个guid。所以说，Unity中所有资源的引用关系都是这样来计算的。 再回到这个贴图资源。引擎内可以设置每张贴图的压缩格式、大小和mipmap等，这些信息都会保存在.meta文件中，Unity会根据这些参数重新压缩这个贴图。最终呈现给玩家的贴图，已经不是当初我们放入Unity中的了。所以说，开发者只需要设置一些参数，Unity就实现了无感知的优化。 另外，.meta文件也一定要上传到SVN或Git中，不然别人在更新到这个资源的时候，无法用它本地的Unity对资源做正确的设置了。 多工程游戏项目会多角色进行参与，如程序员、策划人员和美术人员等，如果不希望一部分代码被美术人员和策划人员看到，那么项目就需要分成两个工程了。分工程很容易，但是合并两个工程就比较麻烦了。如下图所示，在Project视图中选择需要导出的资源，单击鼠标右键，从弹出的快捷菜单中选择Export Package命令，可导出一个包。打开新的工程，把刚刚导出的包导入即可实现两个工程的同步。 同步文件首先，需要保证美术资源都放在一个最顶层的文件夹下。资源可以按子文件夹归类，但引用关系只能在最顶层的文件夹中。同步文件其实就是同步目录，此时使用Expot Package命不太方便了，可以使用代码直接复制文件夹。这里可能有人有疑问：直接复制会赖的改变？其实是不会的。因为美术资源都放在同一个顶层文件，这样依赖部文件夹下，即使复制出来以后，还会保留原有的依赖。如以下代码所示，我们来实现文件夹的复制同步功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using UnityEngine; using UnityEditor; using System.IO; public class Script_11_07&#123; ///&lt;summary&gt; ///复制目录 ///&lt;/summary&gt; ///&lt;param name="raw"&gt;Raw.&lt;/param&gt; ///&lt;param name="copy"&gt;Copy.&lt;/param&gt; static public void CopyFolder(string strSource, string strDestination) &#123; clearFolder(strDestination); foreach (string from in Directory.GetFiles(strSource, "*.*", Searchoption.AllDirectories)) &#123; if (!from.Contains(".svn")) &#123; CopyFile(from, from.Replace(strSource, strDestination)); &#125; &#125; &#125; ///&lt;summary&gt; ///复制文件 ///&lt;/summary&gt; ///&lt;param name="raw"&gt;Raw.&lt;/param&gt; ///&lt;param name="copy"&gt;Coy.&lt;/param&gt; static private void CopyFile(string raw, string copy) &#123; string extenision = Path.GetExtension(raw); if(extenision != ".Ds_store") &#123; if(File.Exists(copy)) &#123; File.Delete(copy); &#125; if(File.Exists(raw)) &#123; string path = Path.GetDirectoryName(copy); if(!Directory.Exists(path)) &#123; Directory.createDirectory(path); File.copy(raw, copy); &#125; &#125; &#125; &#125; ///&lt;summary&gt; ///清空文件央下的所有资源 ///&lt;/summary&gt; ///&lt;param name="path"&gt;Path.&lt;/param&gt; static private void clearFolder(string path) &#123; if (Directory.Exists(path)) &#123; Directory.Delete(path, true); AssetDatabase.Refresh() ; &#125; &#125;&#125; 运行模式运行模式和编辑模式是完全不同的，编辑模式下可以放成千上万的资源，那么这些资源是否需要都打包在发布的游戏包中呢？显然是不可能的！打包时，Unity会自动删除掉没有引用的资源，只会保留Resources目录以及StreamingAssets目录下的资源。 引用资源只有被引用的资源Unity才会打包，那么如何分辨资源是否被引用呢？在下图中： B贴图被New Material材质引用； New Material材质被Cube引用； Cube被Scene引用。 如果这个Scene被添加到了Scene In Build中，那么以上这几种资源都会被打入游戏包中。但是这个Cube在代码中是无法直接操作的，因为没有办法去加载它，只能在打开场景时自动实例化它。 ResourcesResources文件夹是Unity中标志性的目录，这个目录下的资源无论是否有引用关系，都会被强制打在游戏包中。如下图所示，Resources文件夹可以是顶层目录，也可以是某个文件夹的子目录。打包后，Unity会自动将它们合并在一起，接着在代码中动态读取这些资源，并且加载它。 我们可以通过Resources.Load来加载各类游戏资源。 1234567891011121314151617181920using UnityEngine;using UnityEditor;using System.IO;public class Script : MonoBehaviour&#123; void Start() &#123; // 读取材质 Material material = Resources.Load&lt;Material&gt;("New Material"); // 读取贴图 Texture texture = Resources.Load&lt;Texture&gt;("B"); // 读取Prefab GameObject prefab = Resources.Load&lt;GameObject&gt;("Cube"); // 实例化游戏对象 GameObject go = GameObject.Instantiate&lt;GameObject&gt;(prefab); // 挂在主摄像机节点下 go.transform.SetParent(Camera.main.transform, false); &#125;&#125; 由于Resources目录下的资源都会被打包，所以尽可能不要把不需要运行时加载的资源，或者已经废弃掉的资源放进去，因为这无疑会增大包体。此外，Resources目录下的资源尽量不要直接引用在场景中，不然这个资源会被场景和Resources达成两份。 删除对象运行时，需要使用GameObject.Destroy()GameObject.DestroyImmediate()方法删除游戏对象。其中，GameObject.Destroy()会等一帧再彻底删除。因为有可能在这一帧的后面还有地方在操作这个对象，所以一般建议使用它来删除对象。GameObject.DestroyImmediate()表示立即删除。如果这局代码后面有地方操作删除的对象，立刻就会报错，具体代码如下所示。 12345678910111213141516171819using UnityEngine;using System.IO;public class Script : MonoBehaviour&#123; public GameObject g1; public GameObject g2; public GameObject g3; void Start() &#123; // 删除游戏对象 GameObject.Destroy(g1); // 一秒后删除 GameObject.Destroy(g2, 1f); // 立即删除 GameObject.DestroyImmediate(g3); &#125;&#125; 删除资源游戏对象和游戏资源的关系是什么？游戏对象删除了，它引用的资源其实并没有删除。如下图所示，在Profiler中依然能看到这个贴图在内存中。不过我们可以使用Resources.UnloadAsset()以及Resources.UnloadUnusedAssets()方法强制卸载资源。由于卸载资源是异步操作，所以可以使用isDone来判断是否完成。 如下代码所示，释放游戏对象后，Resources.UnloadUnusedAssets()会释放无用资源，然后在Update()方法中判断isDone是否释放结束。 1234567891011121314151617181920212223242526272829using UnityEngine;using System.IO;public class Script : MonoBehaviour&#123; public GameObject g1; private AsyncOperation m_Operation; void Start() &#123; GameObject.Destroy(g1); m_Operation = Resources.UnloadUnusedAssets(); // 也可以强制卸载对象引用的资源 // Resources.UnloadAsset(g1); &#125; void Update() &#123; if(m_Operation != null) &#123; if(m_Operation.isDone) &#123; m_Operation = null; Debug.Log("资源卸载完成"); &#125; &#125; &#125;&#125; GC在C#中，可能还会有很多临时对象引用这个游戏资源，这很可能会导致Resources.UnloadUnusedAssets()无法释放掉。因此，在卸载无用资源前，需要保证C#完成垃圾收集工作，而且有时候进行一遍垃圾回收工作是没用的，最好调用两遍GC()和Resources.UnloadUnusedAssets()。 如下代码所示，这里封装了一个内部的GC类，调用完UnloadUnusedAssets()后，再调用一次UnloadUnusedAssets()进行充分的垃圾回收。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using UnityEngine;using System.IO;using UnityEngine.Events;public class Script : MonoBehaviour&#123; public GameObject g1; private AsyncOperation m_Operation; void Start() &#123; GameObject.Destroy(g1); GC gc = GetComponent&lt;GC&gt;() ?? gameObject.AddComponent&lt;GC&gt;(); gc.UnloadUnusedAssets(delegate()&#123; gc.UnloadUnusedAssets(delegate()&#123; Debug.Log("彻底卸载掉资源！！"); &#125;); &#125;); &#125; public class GC : MonoBehaviour &#123; public AsyncOperation m_Operation; public UnityAction m_Callback; public void UnloadUnusedAssets(UnityAction callback) &#123; m_Callback = callback; System.GC.Collect(); m_Operation = Resources.UnloadUnusedAssets(); &#125; void Update() &#123; if(m_Operation != null) &#123; if(m_Operation.isDone) &#123; m_Operation = null; m_Callback(); // 删除自身 DestroyImmediate(this); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL系统函数]]></title>
    <url>%2F2018%2F11%2F30%2FMySQL%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持久化数据]]></title>
    <url>%2F2018%2F11%2F30%2F%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE-1%2F</url>
    <content type="text"><![CDATA[游戏中持久化数据一般可分为两种：第一种是静态数据，例如Excel数据表中由策划人员编辑的数据，其特点是运行期间程序只需要读取，不需要修改；另一种是游戏存档数据，例如记录玩家在游戏过程中的进度，其特点是运行期间既需要读取，也需要修改，并且在版本升级的时候需要考虑老数据是否需要删除或者重置。 Excel策划人员通常都会在Excel中配置静态数据，例如道具表，它由主键、道具名称、描述、功能和参数等一系列数据组成。前后端使用道具主键来进行数据的通信，最终前端将主键所包含的整个数据信息展示在游戏中。 EPPlus在Windows下，提供了很多解析Excel的方法。但是作为一个跨平台引擎，可能需要在多个平台都能解析Excel，所以我们需要引用一个第三方DLL库EPPlus来处理跨平台解析Excel，首先，需要从它的网站上将其下载下来，接着将DLL文件拖入Unity即可使用了。也可以直接NuGet安装，新建一个项目，然后工具-&gt;NuGet包管理器-&gt;管理解决方案的NuGet程序包，最后将项目路径\packages\EPPlus.4.5.2.1\lib\net35下的EPPlus.dll放进Assets/Plugins下。 读取Excel首先，我们需要创建Excel文件。如下图所示，可以分别在不同的工作表中添加数据，接着在代码中读取这两个工作表中的所有数据。 如ExcelDemo.cs代码所示，根据Excel文件的路径得到FileStream，并且创建ExcelPackage对象，接着就可以用它对Excel进行读取了。 12345678910111213141516171819202122232425262728293031323334353637383940using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;using System.IO;using OfficeOpenXml;public class ExcelDemo&#123; [MenuItem("Excel/Load Excel")] static void LoadExcel() &#123; string path = Application.dataPath + "/Excel/test.xlsx"; // 读取Excel文件 using (FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)) &#123; using (ExcelPackage excel = new ExcelPackage(fs)) &#123; ExcelWorksheets workSheets = excel.Workbook.Worksheets; // 遍历所有工作表 for (int i = 1; i &lt;= workSheets.Count; i++) &#123; ExcelWorksheet workSheet = workSheets[i]; int colCount = workSheet.Dimension.End.Column; // 获取当前工作表的名字 Debug.LogFormat("Sheet &#123;0&#125;", workSheet.Name); for (int row = 1, count = workSheet.Dimension.End.Row; row &lt;= count; row++) &#123; for (int col = 1; col &lt;= colCount; col++) &#123; // 读取每个单元格中的数据 var text = workSheet.Cells[row, col].Text ?? ""; Debug.LogFormat("下标:&#123;0&#125;, &#123;1&#125; 内容:&#123;2&#125;", row, col, text); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 在导航菜单栏中选择Excel-&gt;Load Excel命令，数据已经全部读取出来了，如下图所示。 写入Excel首先，需要使用FileInfo来创建一个Excel文件，接着使用ExcelPackage来向Excel文件中写入数据，如下所示。 如代码所示，在ExcelPackage对象中添加worksheet后，即可调用worksheet.Cells对每个单元格的行、列赋值，最终保存即可。 123456789101112131415161718192021222324252627282930313233using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;using System.IO;using OfficeOpenXml;using System;public class WriteExcel &#123; [MenuItem("Excel/Write Excel")] static void LoadExcel() &#123; //创建Excel文件 string path = Application.dataPath + "/Excel/" + DateTime.Now.ToString("yyyy-MM-dd--hh-mm-ss") + ".xlsx"; var file = new FileInfo(path); using (ExcelPackage excel = new ExcelPackage(file)) &#123; //向表格中写入数据 ExcelWorksheet worksheet = excel.Workbook.Worksheets.Add("sheet1"); worksheet.Cells[1, 1].Value = "Company name1"; worksheet.Cells[1, 2].Value = "Address1"; worksheet = excel.Workbook.Worksheets.Add("sheet2"); worksheet.Cells[1, 1].Value = "Company name2"; worksheet.Cells[1, 2].Value = "Address2"; // 保存 excel.Save(); &#125; AssetDatabase.Refresh(); &#125;&#125; 保存完单元格后，为了在Unity中立刻看到效果，需要调用AssetDatabase.Refresh()方法进行刷新。 JSON游戏运行时，我们是无法通过EPPlus读取Excel的，不过我们可以将它保存成自定义格式，例如CSV、JSON和ScriptableObject等，使用的时候将它读取进来就可以了。Unity支持JSON的序列化和反序列化。需要注意的是，参与序列化的类必须在上方声明[Serializable]属性，并且支持类对象的相互嵌套。我们可以使用JsonUtility.ToJson()以及JsonUtility.FromJson&lt;T&gt;()来进行序列化以及反序列化。比较遗憾的是，它并不支持字典类型的序列化。相关代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;using System;public class JsonDemo&#123; [MenuItem("Excel/Json")] static void LoadJson() &#123; Data data = new Data(); data.name = "Data"; data.subData.Add(new SubData() &#123; intValue = 1, boolValue = true, floatValue = 0.1f, stringValue = "one" &#125;); data.subData.Add(new SubData() &#123; intValue = 2, boolValue = true, floatValue = 0.1f, stringValue = "two" &#125;); string json = JsonUtility.ToJson(data); Debug.Log(json); data = JsonUtility.FromJson&lt;Data&gt;(json); Debug.LogFormat("name = &#123;0&#125;", data.name); foreach (var item in data.subData) &#123; Debug.LogFormat("intValue = &#123;0&#125; boolValue=&#123;0&#125; floatValue=&#123;0&#125; stringValue=&#123;0&#125;", item.intValue, item.boolValue, item.floatValue, item.stringValue); &#125; &#125; [Serializable] public class Data &#123; public string name; public List&lt;SubData&gt; subData = new List&lt;SubData&gt;(); &#125; [Serializable] public class SubData &#123; public int intValue; public bool boolValue; public float floatValue; public string stringValue; &#125;&#125; 如下图所示，将数据对象转成JSON字符串，再从JSON字符串还原数据对象，并且将数据输出。 JSON支持字典Unity的JSON是不支持字典的，不过可以继承ISerializationCallbackReceiver接口，间接地实现字典序列化，相关代码如下所示。 12345678910111213141516171819202122using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;public class DictionaryJson&#123; [MenuItem("Excel/Load Dictionary")] static void SerializableDictionary() &#123; SerializableDictionary&lt;int, string&gt; serializableDictionary = new SerializableDictionary&lt;int, string&gt;(); serializableDictionary[100] = "Unity"; serializableDictionary[200] = "好好学习"; serializableDictionary[300] = "天天向上"; string json = JsonUtility.ToJson(serializableDictionary); Debug.Log(json); serializableDictionary = JsonUtility.FromJson&lt;SerializableDictionary&lt;int, string&gt;&gt;(json); Debug.Log(serializableDictionary[100]); &#125;&#125; 如下SerializableDictionary.cs代码所示，序列化两个List元素来保存键和值，接着将C#的泛型传入，这样键和值就更加灵活了，在OnBeforeSerialize()和OnAfterDeserialize()进行序列化和反序列化赋值操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System.Collections;using System.Collections.Generic;using UnityEngine;public class SerializableDictionary&lt;K, V&gt; : ISerializationCallbackReceiver&#123; [SerializeField] private List&lt;K&gt; m_keys; [SerializeField] private List&lt;V&gt; m_values; private Dictionary&lt;K, V&gt; m_Dictionary = new Dictionary&lt;K, V&gt;(); public V this[K key] &#123; get &#123; if (!m_Dictionary.ContainsKey(key)) &#123; return default(V); &#125; return m_Dictionary[key]; &#125; set &#123; m_Dictionary[key] = value; &#125; &#125; public void OnAfterDeserialize() &#123; int length = m_keys.Count; m_Dictionary = new Dictionary&lt;K, V&gt;(); for (int i = 0;i&lt;length;i++) &#123; m_Dictionary[m_keys[i]] = m_values[i]; &#125; m_keys = null; m_values = null; &#125; public void OnBeforeSerialize() &#123; m_keys = new List&lt;K&gt;(); m_values = new List&lt;V&gt;(); foreach (var item in m_Dictionary) &#123; m_keys.Add(item.Key); m_values.Add(item.Value); &#125; &#125;&#125; 文件读取与写入游戏中有很多数据需要在运行期间读取或者写入，最典型的就是游戏存档功能。Unity自己也提供了一套存档的API，但是功能比较单一，只支持保存int、float和string这三种类型。不过C#支持文件的读写，我们可以灵活地扩展它。 PlayerPrefsPlayerPrefs是Unity自带的存档方法，它的优点是使用起来非常方便。引擎已经封装好GetKey以及SetKey的方法，并且还做保存数据的优化。由于保存数据可能是个耗时操作，频繁地保存可能会带来卡顿，所以Unity默认会在应用程序将切入后台时统一保存文件，开发者也可以强制调用PlayerPrefs.Save()来保存。然而它的缺点就是，编辑模式下查看存档非常不方便， Windows的存档在HKCU\Software\[company name]\[product name]注册表中。如下代码所示，我们使用PlayerPrefs对数据进行保存和读取操作。 12345678910111213141516171819202122232425262728293031using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerPrefsDemo : MonoBehaviour &#123; void Start () &#123; PlayerPrefs.SetInt("MyInt", 100); PlayerPrefs.SetFloat("MyFloat", 200f); PlayerPrefs.SetString("MyString", "Unity"); Debug.Log(PlayerPrefs.GetInt("MyInt", 0)); Debug.Log(PlayerPrefs.GetFloat("MyFloat", 0f)); Debug.Log(PlayerPrefs.GetString("MyString", "没有返回默认值")); // 判断是否有某个键 if (PlayerPrefs.HasKey("MyInt")) &#123; Debug.Log("has MyInt"); &#125; // 删除某个键 PlayerPrefs.DeleteKey("MyInt"); // 删除所有键 PlayerPrefs.DeleteAll(); // 强制保存数据 PlayerPrefs.Save(); &#125;&#125; EditorPrefs在编辑器模式下，Unity也提供了一组存档功能，它不需要考虑运行时的效率，所有没有采用PlayerPrefs优化的方式，而是立即就保存了。相关代码如下所示。 123456789101112131415161718192021222324252627282930using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;public class Script_08_06&#123; [MenuItem("Tools/Save")] static void Save() &#123; EditorPrefs.SetInt("MyInt", 100); EditorPrefs.SetFloat("MyFloat", 200f); EditorPrefs.SetString("MyString", "Unity"); Debug.Log(EditorPrefs.GetInt("MyInt", 0)); Debug.Log(EditorPrefs.GetFloat("MyFloat", 0f)); Debug.Log(EditorPrefs.GetString("MyString", "没有返回默认值")); //判断是否有某个键 if (EditorPrefs.HasKey("MyInt")) &#123; &#125; //删除某个键 EditorPrefs.DeleteKey("MyInt"); //删除所有键 EditorPrefs.DeleteAll(); &#125;&#125; PlayerPrefs保存复杂结构PlayerPrefs可以保存字符串，结合JSON的序列化和反序列功能，它就可以保存各种复杂的数据结构了。另外，保存存档取决于硬件当时的条件，完全有保存不上的情况，所以可以通过try…catch来捕获保存时的错误异常。 如下代码所示，使用JsonUtility.ToJson()方法将对象保存成JSON字符串，读取的时候再使用JsonUtility.FromJson将JSON字符串还原为类对象。 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;public class Script_08_07 : MonoBehaviour&#123; void Start() &#123; //保存游戏存档 Record record = new Record(); record.stringValue = "Unity"; record.intValue = 200; record.names = new List&lt;string&gt;() &#123; "test1"， "test2" &#125;; string json = JsonUtility.ToJson(record); //可以使用try…catch来捕获异常 try &#123; PlayerPrefs.SetString("record", json); &#125; catch (System.Exception err) &#123; Debug.Log("Got: " + err); &#125; //读取存档 record = JsonUtility.FromJson&lt;Record&gt;(PlayerPrefs.GetString("record")); Debug.LogFormat("stringValue = &#123;0&#125; intValue=&#123;1&#125;", record.stringValue, record.intValue); &#125; // 存档对象 [System.Serializable] public class Record &#123; public string stringValue; public int intValue; public List&lt;string&gt; names; &#125;&#125; 需要注意的是，凡是参与JSON序列化的对象都需要标记[System.Serializable]对象。 TextAssetTextAsset是Unity提供的一个文本对象，它可以通过Resources.Load()或者AssetBundle来读取数据，其中数据是string格式的。当然，我们也可以按byte[]读取。它支持读取的文本格式包括.txt，.html，.htm，.xml，.bytes，.json，.csv，.yaml和.fnt。如下代码所示，我们来读取Resources目录下的MyText文本。 1234567891011using System.Collections;using System.Collections.Generic;using UnityEngine;public class Script_08_08 : MonoBehaviour&#123; void Start() &#123; Debug.Log(Resources.Load&lt;TextAsset&gt;("MyText").text); &#125;&#125; 编辑期读写文本Unity可以利用C#的File类来读写文本，此时只需要提供一个目录即可。这里需要注意的是，编辑器模式下读写文本是很方便的，但是一旦打包发布， Assets/目录都不存在了，运行时是无法读取它目录下的文本的。如下代码所示，通过File.WriteAllText()和File.ReadAllText()来对文本进行读取和写入。 12345678910111213141516171819202122232425using System.Collections; using System.Collections.Generic; using UnityEngine;public class Script_08_09&#123; [MenuItem("Tool/File")] static void Start () &#123; string path = Path.Combine(Application.dataPath, "test.txt"); //如果文件存在，就删除它 if (File.Exists(path)) &#123; File.Delete(path); &#125; //写入文件 StringBuilder sb = new StringBuilder(); sb.AppendFormat("第一行:&#123;0&#125;", 100).AppendLine(); sb.AppendFormat("第二行:&#123;0&#125;", 200).AppendLine(); File.WriteAllText(path, sb.ToString()); //读取文件 Debug.Log(File.ReadAllText(path)); &#125;&#125; 运行期读写文本在游戏运行期间，只有Resources和StreamingAssets目录具有读取权限，其中Resources用来读取游戏资源，而StreamingAssets可使用File类来读取文件（除了个别平台外），但都是只读的，并不能写。只有Application.persistentDataPath目录是可读、可写的。分别在Resources和StreamingAssets目录下新建test.txt，分别写入“我是Resources目录”，“我是StreamingAssets目录”。 123456789101112131415161718192021222324252627282930313233343536using System.Collections;using System.Collections.Generic;using UnityEngine;using System.IO;using System.Text;using System;public class Script_08_10 : MonoBehaviour&#123; //可读不可写 string m_ResourcesTxt = string.Empty; //可读不可写 string m_StreamingAssetsTxt = string.Empty; //可读可写 string m_PersistentDataTxt = string.Empty; void Start() &#123; m_ResourcesTxt = Resources.Load&lt;TextAsset&gt;("test").text; m_StreamingAssetsTxt = File.ReadAllText(System.IO.Path.Combine(Application.streamingAssetsPath, "test.txt")); &#125; void OnGUI() &#123; GUILayout.Label(string.Format("&lt;size=50&gt;Resources : &#123;0&#125;&lt;/size&gt;", m_ResourcesTxt)); GUILayout.Label(string.Format("&lt;size=50&gt;StreamingAssets : &#123;0&#125;&lt;/size&gt;", m_StreamingAssetsTxt)); GUILayout.Label(string.Format("&lt;size=50&gt;PersistentDataPath : &#123;0&#125;&lt;/size&gt;", m_PersistentDataTxt)); if (GUILayout.Button("&lt;size=50&gt;写入并读取时间&lt;/size&gt;")) &#123; string path = Path.Combine(Application.persistentDataPath, "test.txt"); File.WriteAllText(path, DateTime.Now.ToString()); m_PersistentDataTxt = File.ReadAllText(path); &#125; &#125;&#125; 执行如下： PersistentDataPath目录PersistentDataPath目录本身并没有什么问题，但是如果平常开发中也在这个目录下进行读写操作的话，就会比较麻烦，因为它在Windows以及Mac下的目录是很难找的。例如，开发过程中需要验证一下保存的文件是否正确，我们随时都需要很快地找到它。调用EditorUtility.RevealInFinder()方法，就可以立即定位到指定目录。 123456789101112using System.Collections; using UnityEngine; using UnityEditor;public class Script_08_11 : MonoBehaviour&#123; [MenuItem("Assets/Open Persistent DataPath")] static void Open() &#123; EditorUtility.RevealInFinder(Application.persistentDataPath); &#125; &#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D游戏开发第2版-宣雨松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL备份]]></title>
    <url>%2F2018%2F11%2F30%2FMySQL%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[MySQL备份与恢复数据库管理员最为重要的任务就是防止数据丢失,或者发生数据丢失后将损失降到最低。通过数据库备份可以实现该任务目标,数据库备份就成了数据库管理员的日常工作。数据库的恢复是将数据库从某一种“错误”状态(如硬件故障、操作失误、数据丢失、数据不一致等状态)恢复到某一已知的”正确”状态。本章主要讲解数据库备份与恢复的方法、策略,通过本章的学习,读者可以掌握数据库备份与恢复的各种技术,并根据不同的应用场景,设计合理的备份与恢复策略。 备份与恢复概述MySQL服务实例运行期间,意外的停电、硬盘损坏、数据库管理员的误操作、服务器宕机等意外情况无法避免,且都会造成数据库一定程度的数据丢失。数据库管理员最为重要的工作莫过于:如何防止数据丢失,或者发生数据丢失后,如何确保数据库能够最大程度地恢复到”正确”状态。 防止数据丢失的方法对于数据库管理员而言,防止数据丢失的最简单方法就是:定期对原始数据进行备份,创建原始数据的副本;当原始数据丢失时,利用副本恢复数据。对于MySQL数据库而言,创建数据副本的常用方法有3种. 方法一:数据备份. 由于MySQL数据库的数据全部以文件的形式存储在硬盘上,因此最容易想到的数据备份方法就是备份数据库的各种文件,其中包括数据库目录、数据文件、索引文件、my.ini配置文件以及日志文件等。 方法二:使用二进制日志。 当数据库中的更新操作较为频繁时(例如某个时间点执行了多个更新语句) ,使用第一种方法不能实现数据库更细粒度的恢复,然而借助二进制日志文件可以实现数据库更细粒度的数据恢复。二进制日志记录了数据库的更新操作,数据丢失时,通过对完全备份进行二进制日志的重做,可以完成基于时间点或者操作点的恢复,继而实现数据库更细粒度的恢复。 方法三:数据库复制。 数据库复制实际上是通过二进制日志预防数据丢失,数据库复制可以实现数据库的异地备份和恢复。 数据库中防止数据丢失的方法较为复杂,没有任何一种单一的方法能够完美地解决所有应用场景的需要,更多时候各个方法之间需要相互配合。数据库管理员必须设计合理的备份与恢复策略，使用各种数据库工具,在不影响MySQL服务正常运行的前提下,定期对数据库进行备份,最大程度地防止数据丢失。 数据备份概述对于数据库管理员而言,数据备份是数据库管理中最常用且最重要的工作。简单地说,数据备份是指在外存中创建原始数据的副本。对于数据库而言,备份的内容包括数据库表结构、数据库表记录以及其他数据文件(例如索引文件、日志文件、配置文件等)。文件备份的方法较为简单,只需复制、粘贴即可,这里不再赘述。然而由于文件备份的方法粒度较粗,且不可编辑,因此本章主要讲解更细粒度的数据库备份及恢复方法。 (1)按照备份后产生的副本文件是否可以编辑,可以将MysQL的备份方法分为逻辑备份以及物理备份. 使用逻辑备份时,数据库管理员通常可以直接查看、编辑副本文件中的内容。逻辑备份产生的副本有两种情形。 情形一:副本是SQL脚本文件,该SQL脚本文件中包含了大量的create table语句与insert语句,用于创建表以及向各数据库表插入记录,继而实现数据库表的备份;编辑SQL脚本文件,执行SQL脚本文件即可实现数据库的恢复。 情形二:副本是指定格式的文本文件,该文本文件中的数据是数据库表的记录,文本文件中的数据以特定的分隔符进行分隔。编辑该文本文件,将文本文件的内容导入数据库表中即可实现数据库表的恢复, 物理备份产生的副本常常是二进制文件,通常不可编辑,例如数据库的各种文件。 (2)数据备份期间,按照是否需要停止MySQL服务实例,可以将MySQL的数据备份方法分为冷备份、温备份以及热备份。 冷备份是指停止MySQL服务的运行后再进行数据备份,这种备份方法想得容易,做起来难,因为真正的业务环境不允许停止MySQL服务的运行。然而这种备份方法却可以满足教学实验需要,读者可以使用冷备份的方法轻易地将数据库文件拷贝到U盘中,实现备份数据的随身携带,以便将U盘中的数据库文件快速地恢复到其他MySQL服务器中,继续下一章节的练习。 温备份介于热备份与冷备份之间,温备份允许MySQL服务实例继续运行,备份数据期间,温备份借助“读锁机制”保证备份数据的过程中不允许新数据的写入。例如,执行MySQL命令”flush tables with read lock;”后, MySQL首先将服务器内存中的数据刷新到外存中,然后再锁定所有数据库表,避免备份过程中修改表数据,这种备份方法就是温备份。 热备份是指不需要停止MySQL服务实例的运行即可实现数据备份的方法。如果数据库的更新操作较为频繁,在数据热备份期间,备份过的数据可能早已发生变化,因此热备份的实现方法较为复杂。通常热备份需要借助第三方工具实现,例如, MySQL提供的自带工具mysglhotcopy实现了MyISAM表的热备份, percona公司的Xtrabackup工具实现了InnoDB表的热备份。 (3)按照副本文件的缺失程度可以将数据备份分为完全备份以及增量备份。 完全备份是一个完整的数据备份,仅仅依拿该副本文件就可以将数据库恢复到某个正确状态。如果不借助热备份工具,完全备份可能需要暂停MySQL服务,此时将对其他数据库用户的业务操作造成影响。在真正的应用场景中很少单独使用完全备份,完全备份往往需要与其他备份方法(例如热备份)结合起来一起使用。 增量备份是指在完全备份的基础上,对更新的数据进行备份,数据恢复时需要借助完全备份产生的副本文件。目前, MySQL没有提供真正的增量备份方法,数据库管理员可以使用热备份工具模拟实现增量备份,也可以通过重新执行二进制日志中的更新语句模拟实现增量备份。 上述备份方法中,最简单的数据备份方法是复制数据库目录,拷贝数据库的数据文件、索引文件、日志文件等各种文件,这种备份方法既是物理备份方法,也是温备份方法或者冷备份方法,同时又是完全备份方法。事实上,从概念角度上讲,根本就无法对数据备份的方法进行严格的划分;从实施角度上讲,不可能仅仅使用一种备份方法就可以实现数据库的备份。只有各种备份方法相辅相成,才能满足不同场景的数据库备份需求。 逻辑备份与逻辑恢复逻辑备份与逻辑恢复的最大优点在于,对于不同存储引擎的表,都可以采用”同样的逻辑备份方法”产生副本文件;采用“同样的恢复方法”将数据库恢复到某个正确的状态。如果数据库中存在多种存储引擎的数据库表,选用逻辑备份恢复数据会简单一些。逻辑备份常用的工具有select.into outfile以及mysqldump等工具,前者产生的副本文件为指定格式的文本文件;后者产生的副本文件既可以是指定格式的文本文件,也可以是SQL脚本文件。逻辑恢复常用的工具有load data infilel以及mysqlimport等工具。 使用select…into outfile..备份表数据使用MysQL命令”select…into outfile”可以将一个数据库表中满足特定条件的记,录导出到指定格式的文本文件中,该文本文件使用特殊符号分隔各个字段的值。该命令的语法格式如下。 select语句into outfile文本文件[文本文件选项参数] 文本文件选项的参数及说明如下。 fields terminated by 字符串” :字段分隔符,默认是制表符”t. . fields escaped by字符:转义字符,默认是字符。 .fields [optionally] enclosed by “字符:字段引用符,负责向字段值两边加上字段引用符。如果使用optionally选项,则表示只在char,varchar以及text字符串型字段上添加字lines starting by “字符串:每条记录前添加该字符串,默认为空字符”.lines terminated by “字符串:每条记录末尾添加该字符串,默认为换行字符”n.例如,下面的MySQL命令是把choose表中及格的学生成绩导出到db bak2013文件中,以记事本方式打开db bak2013文件,如图12-1所示。select * from choose where score&gt; =60 into outfile ‘db bak2013 fieldsterminated by ‘l’ enclosed by “”lines terminated by “rn;说明在windows操作系统中,记录之间添加换行符时使用rin’,而在Linux操作系统中使用”n’.db_bak2013-记事本]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化表]]></title>
    <url>%2F2018%2F11%2F29%2FMySQL%E4%BC%98%E5%8C%96%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[优化表优化表同样可以提升数据库性能,其中包括优化表结构、表的拆分、分区、表的分析与检查等内容。 优化表结构1)尽量将字段定义为NOT NULL约束。这是由于:在MysQL中,含有空值的列很难进行查询优化,NULL值会使索引、索引的统计信息以及比较运算变得更加复杂。推荐使用0、一个特殊的值或者一个空字符串代替NULL值。 2)考虑使用enum、set等复合数据类型。对于一个只包含有限数目的特定值的字段,可以考虑将其设计为enum、set等复合数据类型。enum,set等复合数据类型的值可以更快地处理,因为它们在内部是以数值表示的。 3)虽然MysQL支持blob类型,可以存储二进制数据,但是设计数据库表时,图片、音频、视频等二进制数据不要使用数据库存储,毕竟处理这些二进制数据并不是数据库的强项 4)数值型(例如整型)字段的比较比字符串的比较效率高很多,这也符合一项优化原则:字段类型尽量使用最小、最简单的数据类型,典型的例子是IP地址的存储。当前还有很多应用使用char(15)存储IP地址,然而使用无符号整数存储IP地址效率会更高, MySQL提供了inet_aton()和inet_ntoa()函数来解决P地址与整数之间的转换。 表的拆分表的拆分是指将某个表按照某个(或些)条件拆分成两个或多个独立表。表的拆分分为垂直拆分与水平拆分。1.垂直拆分 垂直拆分按照字段(或者列)进行拆分,其实就是把组成一行的多个列分开,放到不同的表中。这些表具有不同的结构,拆分后的表含有更少的列,例如可以将频繁访问的列置于一张表中,不经常访问的列(例如长文本信息)置于另一张表中,然后在这两张表的记录与记录之间创建1:1关系。举例来说,对于一张用户表而言,不仅包含账号、账户名、密码、性别等基本信息,还包括兴趣爱好(不经常使用的信息)、自我介绍(长文本信息)等扩展信息。设计用户表时,可以将用户表拆分成两个表user1表与user2表,其中user1表中包含账号、账户名、密码、性别等基本信息, user2表中包含兴趣爱好、自我介绍等扩展信息。由于user1表中的记录与user2表中的记录存在1 :1关系,此时还需要在user2表中增加user1表的主键字段user1_no作为外键,并将外键设置为唯一性约束。user1表为父表, user2表为子表。user1 (user1_no, account_name, password, sex)user2 (user2_no, interest, introduction, user1_no) 使用垂直拆分的优点在于:垂直拆分可以使得列数据变小,一个数据块(Block)就可以存放更多行的记录,对频繁访问的字段执行select语句,硬盘I/O次数也会相应减少。另外,垂直拆分表可以达到最大化利用Cache的目的。 使用垂直拆分的缺点在于:由于拆分出来的两张表的记录与记录之间存在1 :1关系,这种1:1关系需要使用冗余字段进行维护。另外,一旦访问不经常使用的字段,会引起表之间的join连接操作,额外增加了CPU的负担。 2.水平拆分水平拆分按照记录(或者行)进行拆分,其实就是把一个表分成几个表,这些表具有相同的列,但是存放更少的数据。拆分的原则通常是按照日期时间维度、地区维度或者特殊的业务维度进行表的拆分. 案例1:某个公司销售记录数据量非常大,可以对销售记录按月进行水平拆分,每个月的销售记录拆分成一张独立表,共拆分成12张独立表。 案例2:某个集团在各个地区都有分公司,该集团的订单数据量非常大,可以按分公司所在的地区进行水平拆分。 案例3:某电信公司的话单按月份、地市水平拆分后,发现数据量依然很大,可以按号码段进行3次水平拆分。 使用水平拆分的优点在于:将维度作为查询条件执行select语句时,如果维度范围很小(例如查询12月份的销售记录) ,可以有效降低需要扫描的数据和索引的数据块数,加快查询速度。 使用水平拆分的缺点在于:水平拆分会给应用增加复杂度,它通常在查询时需要多个表名。查询所有数据需要union操作,有时,这种复杂度会超过它带来的优点。例如,将维度作为查询条件执行select语句时,如果维度范围很大(例如查询1月份到12月份的销售记录) ,此时需要进行11个union操作,硬盘I/O次数也会增加。 分区分区是按照指定的规则,跨文件系统分配单个表的多个部分。对于海量数据库或者OLAP的应用而言,对表进行适当的分区可以提升数据库性能。MySQL主要支持4种模式的分区,分别是range (范围)分区、list (预定义列表)分区、hash (哈希)分区以及key (键值)分区。无论使用哪一种分区模式,它们都是对表进行“水平分区” 。并且,如果表中存在主键或者唯一性约束字段,要求分区字段必须是主键字段或唯一性约束字段的一部分。分区的原则是按照日期时间维度、地区维度或者特殊的业务维度进行分区,这与水平拆分的原则相同,分区与水平拆分的不同之处如表14-1所示。 range (范围)分区: 这种分区模式允许数据库管理员将数据划分不同范围。例如,数据库管理员可以将销售记录表按照销售年度对该表划分分区。 list (预定义列表)分区: 这种分区模式允许系统通过数据库管理员定义的离散值列表进行分区。例如:数据库管理员建立了一个横跨3个分区的表,分别根据2011年、2012年和2013年所对应的数据进行分区 hash (哈希)分区: 这种分区模式允许数据库管理员通过对表的一个或多个列的hash值进行计算,最后通过这个hash码不同数值对应的数据区域进行分区。例如数据库管理员可以建立一个对表主键hash值进行分区的表 key (键值)分区: hash分区的一种延伸,这里的key由MySQL自动生成。 上述4种模式的分区中, range (范围)分区最为常用。下面以range分区为例讲解MySQL表分区的方法。下面的SQL语句首先创建一个sale销售记录表,然后再向该表添加销售年度分区(注意sale表的存储引擎为MyISAM) 。create table sale( sale_id int not null, sale_date datetime, money int)ENGINE = MyISAM CHARACTER SET = utf8 COLLATE = utf8_general_ci;alter table sale partition by range columns (sale_date) ( partition p01 values less than (‘2019-1-1’), partition p02 values less than (‘2020-1-1’));MyISAM的sale表经过分区后,产生分区定义文件sale.par、分区索引文件(sale#P#p01.MYI与sale#P#p02.MYI)以及分区数据文件(sale#P#p01.MYD与sale#P#p02.MYD)，如下图所示。 说明如果sale表的存储引擎为InnoDB,则sale表经过分区后,仅仅产生分区定义文件sale.par,如果sale表的存储引擎为InnoDB,并且使用的是独享表空间(ibd)文件,则sale表经过分区后,除了产生分区定义文件sale.par外,还会产生分区独享表空间文件sale#p#p01.ibd与sale#p#p02.ibd。 接着使用下面的SQL语句向sale表插入记录信息。insert into sale values(1, ‘2019-1-2’, 100);insert into sale values(1, ‘2020-1-2’, 100); 1526 - Table has no partition for value from column_list 注意:第二条记录插入失败,原因在于插入的值2020-1-2不在sale表的两个分区范围之内。对于此类问题,可以向sale表添加一个maxvalue(无穷大值)分区。这样,第二条记录就可以成功插入p03分区中。 alter table sale add partition(partition p03 values less than maxvalue); 查询2019年的销售记录可以使用下面的SQL语句示。explain partitions select * from sale where sale_date&lt;=’2019-12-31’ and sale_date&gt;=’2019-1-1’; 结果如下：+—-+————-+——-+————+——+—————+——+———+——+——+————-+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+——-+————+——+—————+——+———+——+——+————-+| 1 | SIMPLE | sale | p02 | ALL | NULL | NULL | NULL | NULL | 2 | Using where |+—-+————-+——-+————+——+—————+——+———+——+——+————-+ 通过explain partitions命令可以发现,查询优化器只需要搜索p02分区,查询范围的缩小可以有效提升检素性能。如果要删除2019年度的数据,只需要删除p02分区即可,可以使用下面的SQL语句。此时对应分区的物理文件也随之删除。alter table sale drop partition p02;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL日志]]></title>
    <url>%2F2018%2F11%2F28%2FMySQL%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[MySQL日志记录了MySQL服务实例的运行轨迹以及数据库用户使用、操作数据库的历史信息。MySQL事件（event）是能够自动执行或者定期执行的任务。本章首先详细讲解 MySQL 日志的功能以及使用方法，然后讲解MySQL事件的用法。通过本章的学习，读者可以掌握利用MySQL日志与事件维护、优化数据库的相关技术。 MySQL日志MySQL提供了表11-1所示的几种日志，供数据库管理员深入了解MySQL服务实例的历史状态，帮助数据库管理员追踪数据库曾经发生过的各种事件。默认情况下，所有的MySQL日志以文件方式存储，存放在数据库根目录下。 数据皆需要缓存众所周知，系统读取数据时，从内存中读取的速度比从外存（例如硬盘）中读取的速度要快百倍。故现在绝大部分系统软件都会最大程度地使用缓存机制（缓存是内存中的一段存储区域），提高数据的访问效率，MySQL也不例外。MySQL会最大限度地利用缓存，减少I/O请求次数，缩短寻道时间，提高数据访问效率。 MySQL在执行数据查询语句以及数据更新语句时，会将硬盘的数据、索引载入到内存中的缓存中，所有记录的修改、查询在内存中的缓存中完成，如图11-1所示。记录修改完成后，再将修改结果更新到硬盘，这样不仅可以减少I/O请求次数，同时也可以解决硬盘磁头频繁定位导致硬盘I/O效率低下等问题。图中假设某个应用程序执行若干条update语句，这些update语句影响的是硬盘中第9、10、1、4、200以及5数据块中的记录，并需要将修改结果写入硬盘中，通过缓存机制，可以将这些块排序后再写入硬盘，这样既可以大幅减少硬盘I/O请求次数，又可以解决磁头频繁定位导致I/O效率低下等问题，从而提高数据访问效率。 MySQL日志处理也使用了缓存机制，MySQL日志最初存放在MySQL服务器的内存缓存中，若超过指定的存储容量，内存缓存中的日志则写（或者刷新）到外存，以数据库表或者以文件的方式永久地保存到服务器硬盘中。 MySQL错误日志MySQL错误日志主要用于记录MySQL服务实例每次启动、停止的详细信息，以及MySQL服务实例运行过程中产生的警告或者错误信息。与其他日志不同，MySQL错误日志必须开启，无法关闭。与MySQL错误日志有关的参数包括1个。 log_error：设置了错误日志文件的物理位置（日志所在目录以及日志文件名）。使用MySQL命令“show variables like ‘log_error’;”可以查看错误日志文件的物理位置，默认情况下，错误日志文件所在的目录为数据库根目录，错误日志文件名为“主机名.err”（本书使用的主机名为mysql），如下所示。默认情况下，错误日志文件的扩展名为err。+—————+——————————————————————–+| Variable_name | Value |+—————+——————————————————————–+| log_error | D:\Install\phpStudy2018\PHPTutorial\MySQL\data\DESKTOP-G997OST.err |+—————+——————————————————————–+ 当MySQL服务实例意外停止或者无法启动时，可以通过错误日志文件的内容分析产生故障的原因。 注意：MySQL错误日志不会记录所有的错误信息，只有MySQL服务实例运行过程中发生的关键（critical）错误信息才会被记录。 MySQL普通查询日志MySQL 普通查询日志记录了 MySQL 服务实例的所有操作（例如查询语句、更新语句等 SQL语句），无论这些操作是否成功执行。另外，还包含一些其他事件，例如，MySQL客户机与MySQL服务器连接和断开连接的相关信息，无论连接成功还是失败。与 MySQL 普通查询日志有关的参数包括3个。 general_log：设置了普通查询日志是否开启。使用MySQL命令“show variables like ‘general_log’;”可以查看普通查询日志是否开启，使用 MySQL 命令“set @@global.general_log=1;”可以开启普通查询日志。关闭普通查询日志的方法以此类推，不再赘述。 general_log_file：普通查询日志一旦开启，MySQL服务实例将自动创建普通查询日志文件，general_log_file参数设置了普通查询日志文件的物理位置（日志文件所在目录以及日志文件名）。使用MySQL命令“show variables like ‘general_log_file’;”可以查看普通查询日志文件的物理位置，如下所示。默认情况下，普通查询日志文件所在的目录为数据库根目录，普通查询日志文件名为“主机名.log”（默认情况下，普通查询日志文件的扩展名为log）。mysql&gt; show variables like ‘general_log_file’;+——————+——————————————————————–+| Variable_name | Value |+——————+——————————————————————–+| general_log_file | D:\Install\phpStudy2018\PHPTutorial\MySQL\data\DESKTOP-G997OST.log |+——————+——————————————————————–+ 注意：由于普通查询日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，如果开启MySQL普通查询日志将大幅降低数据库服务器的性能，因此建议关闭普通查询日志。在特定时期，如果需要跟踪某些特殊的查询语句，可以临时打开普通查询日志。 log_output：设置了普通查询日志以及慢查询日志（慢查询日志稍后介绍）的输出格式，默认值为FILE，表示以文件的形式保存普通查询日志以及慢查询日志的内容，使用命令“show variables like ‘log_output’;”可以查看日志的输出格式，如下所示。mysql&gt; show variables like ‘log_output’;+—————+——-+| Variable_name | Value |+—————+——-+| log_output | FILE |+—————+——-+ MySQL还允许将普通查询日志以及慢查询日志的内容存储到数据库表中。例如，使用MySQL命令“set @@global.log_output=’table’;”可以将普通查询日志以及慢查询日志分别存储到mysql系统数据库中的general_log表以及slow_log表中（这两个表的存储引擎为CSV），此后查看新的普通查询日志内容时便可以使用SQL语句“select * from mysql.general_log;”。 MySQL慢查询日志使用MySQL慢查询日志可以有效跟踪“执行时间过长”或者“没有使用索引”的查询语句（包括select语句、update语句、delete语句以及insert语句等），为优化查询语句提供帮助。与普通查询日志的另一个区别在于，慢查询日志只包含成功执行过的查询语句。与MySQL慢查询日志有关的参数包括5个。 slow_query_log：设置了慢查询日志是否开启。使用MySQL命令“show variables like ‘slow_query_log’;”可以查看慢查询日志是否开启，使用 MySQL 命令“set @@global.slow_query_log=1;”可以开启慢查询日志。关闭慢查询日志的方法以此类推，这里不再赘述。 slow_query_log_file：慢查询日志一旦开启，MySQL 服务实例将自动创建慢查询日志文件，slow_query_log_file参数设置了慢查询日志文件的物理位置（日志所在目录以及日志文件名）。使用MySQL命令“show variables like ‘slow_query_log_file’;”可以查看慢查询日志文件的物理位置，默认情况下，慢查询日志文件所在的目录为数据库根目录，慢查询日志文件名为“主机名-slow.log”，如下所示。默认情况下，慢查询日志文件与普通查询日志文件的扩展名相同，都是log。mysql&gt; show variables like ‘slow_query_log_file’;+———————+————————————————————————-+| Variable_name | Value |+———————+————————————————————————-+| slow_query_log_file | D:\Install\phpStudy2018\PHPTutorial\MySQL\data\DESKTOP-G997OST-slow.log |+———————+————————————————————————-+ long_query_time：设置了慢查询的时间阈值，默认值是10秒。数据库管理员可以设置一个阈值，将运行时间大于（不包括等于）该值的所有查询语句记录到慢查询日志文件中。使用MySQL命令“show variables like ‘long_query_time’;”可以查看该阈值（单位为秒，精确到微秒），如下所示。mysql&gt; show variables like ‘long_query_time’;+—————–+———–+| Variable_name | Value |+—————–+———–+| long_query_time | 10.000000 |+—————–+———–+ 说明 @@long_query_time既是全局变量，又是会话变量。也可以通过修改my.ini配置文件的方法设置慢查询的时间阈值，例如，可以在my.ini配置文件的[mysqld]选项组中通过添加“long_query_time=1.000000”将该阈值设置为1秒。 log_queries_not_using_indexes：是否将“没有使用索引的查询语句”记录到慢查询日志中，无论它的执行速度有多快。使用MySQL 命令“show variables like ‘log_queries_not_using_indexes’;”可以查看该参数的值。默认情况下，log_queries_not_using_indexes的值为OFF（关闭），使用MySQL 命令“set @@global.log_queries_not_using_indexes=1;”可以将该参数的值设置为ON（开启）。开启该参数后，“没有使用索引的查询语句”将被记录到慢查询日志文件中，无论它们的执行速度有多快。 log_output：设置了普通查询日志以及慢查询日志的输出形式，默认值为FILE，有关该参数的其他知识请参看MySQL普通查询日志章节的内容。 MySQL慢查询日志的查看MySQL慢查询日志的查看可以分为两种情形：慢查询日志的输出形式设置为table以及慢查询日志的输出形式设置为file。 情形一：慢查询日志的输出形式设置为table。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化]]></title>
    <url>%2F2018%2F11%2F27%2FMySQL%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[影响MySQL性能的因素比较复杂，MySQL网络环境（例如网络拓扑结构）、MySQL服务器硬件配置（例如CPU、硬盘存储结构、内存）等都会对MySQL性能造成影响。为了简化问题描述，本章以MySQL服务器硬件配置、网络环境不变为前提，从缓存机制、MySQL服务实例的配置、锁机制、数据库设计、索引设计以及查询优化等几个方面收集了一些常用的MySQL优化方法，为读者提供了一套MySQL优化方案，希望能给读者带来一些启示。 基础知识MySQL调优强调的是如何提高MySQL的整体性能，是一套整体方案。根据木桶原理，MySQL的最终性能取决于系统中性能表现最差的组件。可以这样理解，即使MySQL拥有充足的内存资源、CPU资源，如果外存I/O性能低下（本书的外存主要以硬盘为例），那么系统的总体性能取决于当前最慢的硬盘I/O速度，而不是当前最优越的CPU或者内存资源。 影响数据库系统性能的组件典型的影响数据库系统的组件包括：CPU、内存、硬盘I/O、网络环境、SQL语句与索引，表结构设计、锁竞争、连接（connection）等。 内存：内存I/O的速度要比硬盘I/O读写快很多，为了提升数据库系统I/O整体性能，通常需要将常用的核心数据读入内存。然而与硬盘相比，内存的储存空间“小的可怜”，内存储存空间的不足通常会成为制约数据库系统整体性能提升的罪魁祸首。内存过小，将导致缓存过小，可能导致缓存失效，此时CPU将频繁地执行与应用需求无关的页面置换算法，白白占用了宝贵的CPU资源、硬盘I/O。 硬盘I/O：内存仅仅是数据、进程的“临时住所”，掉电后全部丢失，内存中的数据最终需要保存到硬盘。然而与内存相比，硬盘I/O读写的速度要比内存I/O慢很多，MySQL服务运行期间，低效的硬盘I/O会拖累整个数据库系统。 连接（connection）：MySQL客户机与MySQL服务器之间的连接是MySQL客户机与MySQL服务器反复“握手”的结果，每次“握手”经历身份认证、权限验证等环节，“握手”时需要占用一定的网络资源以及MySQL服务器内存资源。低效的连接（connection）不仅会影响MySQL用户的体验，还会消耗额外的网络资源以及MySQL服务器内存资源。 网络环境：对网络数据进行读写的情况与硬盘I/O类似。由于网络环境的不确定性，尤其是对互联网或者局域网的数据读写，网络的速度可能比本地硬盘I/O更慢。因此，如不加特殊处理，也极可能成为系统瓶颈。 CPU：多个运算性能要求较高的应用如果同时、长时间、不间断地占用CPU资源，那么对CPU的争夺将导致性能问题，如科学计算、空间数据处理等应用。 SQL语句与索引：引入索引是为了更快的检索，但索引会导致更新速度变慢，不合理的索引会导致更新频繁，得不偿失。不良的SQL语句可能导致索引失效，无法通过索引提升检索性能。 表结构设计：数据库的操作最终转化为数据库各种数据文件、索引文件的操作，不良的表结构导致某条SQL语句长时间占用某个数据文件、索引文件，导致锁竞争。 锁竞争:对于并发性能要求较高的数据库而言,如果存在激烈的锁竞争,对数据库的性能将是致命的打击。锁竞争将会明显增加线程上下文切换的开销,而且,这些开销都是与应用需求无关的系统开销,白白占用了宝贵的CPU资源、内存资源、连接资源。 参数信息与状态信息数据库管理员就像数据库服务器的”家庭医生” ,应该能够对其“体征”进行实时监控,迅速地诊断”病情”,并快速地进行修复,使得数据库服务器始终在健康、高效、稳定的状态下提供数据库服务。数据库管理员如何了解数据库服务器当前的“体征” ,从而快速地做出诊断? 对于MySQL而言,数据库管理员经常使用”show status;”命令以及”show variables”命令查看MySQL服务实例当前的”健康状况”,找到系统的瓶颈,继而优化MysQL服务实例。其中, “show variables”命令用于显示MySQL服务实例的各种系统变量(例如全局系统变量、会话系统变量、静态变量等),这些系统变量的值要么是编译MySQL时参数的默认值,要么是my.ini配置文件中的参数值。系统变量(或者参数)是一个静态的概念;默认情况下,系统变量名(或者参数名)全部是小写字母。 随着MySQL服务的运行, MySQL服务实例的状态信息时时刻刻发生变化, “show status;”命令用于显示当前MySQL服务器连接的会话状态变量信息,通过该命令可以实时了解当前MySQL会话的”血压”、“体温”等“体征”,状态变量是一个动态的概念。默认情况下,状态名的首字母大写。 与系统变量的划分方法相似,状态变量分为全局状态变量以及会话状态变量。使用MySQL命令”show global status;”可以查看当前MysQL服务实例的全局状态变量,全局状态变量保存的是所有MySQL会话的状态值,是MySQL服务实例的状态信息。全局状态变量的变量值对所有MysQL客户机有效,例如Open-tables状态变量。 使用MySQL命令”show status;”或者”show session status;”可以查看当前MySQL服务器连接的会话状态变量,会话状态变量的变量值对当前的MySQL客户机有效,例如Opened_tables, Opened_table_definitions状态变量。 通过查看状态信息,数据库管理员可以了解当前MysQL服务实例的”病情”,分析出系统瓶颈,对症下药,对系统变量的值进行适当调整,最终实现MySQL的优化。 ** 说明 ** MySQL服务重启后, MySQL服务实例的参数值恢复到默认值,而会话状态变量值也会进行初始化(例如清零)。使用MySQL命令”flush status;”也可以初始化当前会话状态变量。 缓存机制数据库服务器中,数据访问速度的最大性能瓶颈一般来自硬盘I/O,数据库服务器的缓存占用的是数据库服务器的内存空间,提供“缓存”的目的是为了让硬盘I/O的速度适应CPU的处理速度。很多数据库管理系统(包括MySQL )引入缓存机制减少硬盘I/O次数以及寻道时间,提高/0整体性能,加快数据的访问性能。 缓存之所以有效,主要是因为程序运行时对内存或者外存的访问呈现局部性特征,局部性分为“空间局部性”和“时间局部性”两方面。时间局部性是指刚刚访问过的数据近期可能被再次访问;空间局部性是指某个位置的数据被访问后,其相邻位置的数据可能很快被访问。而缓存机制就是把刚刚访问的数据(时间局部性)以及未来即将访问的数据(空间局部性)保存到缓存中,甚至是高速缓存中;访问数据时,首先访问缓存中的数据,避免直接从硬盘存取数据,继而提高I/O效率。 回想MysQL ,为了提升I/O性能, MySQL通常将频繁检索但不经常更新的数据加载到服务器内存中。例如MySQL服务启动时, MySQL自动地将权限表中的记录加载到MySQ服务器的内存中,这就是缓存机制的典型应用。按照缓存读写功能的不同,可以将MySQL的缓存分为Cache缓存和Buffer缓存。 简单地说, Cache缓存用于加速”读” ,把从硬盘上读取过来的数据保存到Cache缓存中。重新读取时,首先从Cache缓存中读取,若”命中”(找到需要的数据)则无需读硬盘,减少了硬盘I/O次数;若没有命中,则从硬盘读取数据,并将其放入Cache缓存中,以便将来使用。由于Cache缓存的容量有限, Cache缓存中的数据会根据读取频率进行组织,把最频繁读取的内容放在最容易找到的位置,把可能不再读的内容不断往后排,直至从Cache缓存中删除(例如缓存机制通常使用LRU算法进行页面置换)。查询缓存Query Cache是Cache缓存的典型应用,对于查询缓存而言,最忌讳的就是表数据的更新。更新操作会导致相应的查询缓存失效,降低Cache缓存命中率的同时,还会因为Cache缓存失效带来额外开销。 Buffer缓存用于缓冲”写”,把分散的写操作集中进行,减少硬盘I/O次数、硬盘碎片以及硬盘的反复寻道,从而提升I/O整体性能。InnoDB事务日志管理是Buffer缓存的典型应用,将事务日志信息写入事务日志缓存中,满足一定条件时(例如Buffer缓存已满或者提交事务时) ,才将缓存中的事务日志信息刷新(flush)到硬盘,永久地保存起来。通过Buffer缓存机制可以有效地减少硬盘I/O次数以及寻道时间,提升I/O整体性能。 简单来说: Cache缓存的内容一般是一些访问频繁但变更较少的数据,如果Cache缓存已满, MySQL将淘汰Cache缓存中”最近最久未使用”的page页(LRU算法) ,然后将正在使用的page页加载到Cache缓存。Buffer缓存的内容一般是计算结果(或者操作结果) ,这些计算结果需要保存到外存;如果Buffer缓存已满, MySQL通过刷新( flush )操作,将Buffer缓存中的数据写到外存,永久地保存起来。 小结: Cache缓存中的数据是从硬盘中读出来的,用于缓存读;而Buffer缓存中的数据是即将被写入硬盘的,用于加速写,如图14-1所示。适当地增加Cache缓存空间,可以有效地增加Cache的命中率,尽量使得检索在Cache缓存中进行,继而提升”读”性能;适当地增加Buffer缓存空间,可以有效地减少硬盘I/O的频率尽量使得更多的写操作在Buffer缓存中进行,可以有效地提升”写”性能。 缓存的分类除了可以将MySQL缓存分为Cache缓存以及Buffer缓存外,还可以按照缓存的生存周期长短,将MySQL缓存分为全局缓存、会话缓存、临时缓存。全局缓存在MySQL服务实例运行期间一直存在,这一类缓存针对所有MySQL客户机有效。例如,如果开启二进制日志,MySQL服务实例运行期间会分配binlog_cache_size大小的二进制日志缓存,该缓存是全局缓存。会话缓存在会话期间存在,这一类缓存对当前的MySQL客户机有效。例如, MySQL客户机成功连接MysQL服务器后, MySQL服务器会为该会话分配net_buffer_size”初始”大小的结果集缓存,该缓存是会话缓存。临时缓存临时存在。例如,如果select语句中包含派生表,该select语句运行期间,会将派生表产生的临时结果保存在内存临时表中。select语句运行结束后,内存临时表自动消失,内存临时表是临时缓存。 有些缓存是MySQL所提供的,有些缓存是某种存储引擎所独有的,按此划分,可以将MySQL缓存分为MySQL缓存、MyISAM缓存以及InnoDB缓存,如图14-2所示。 下面罗列了一些常用的全局缓存、会话缓存以及临时缓存。需要注意的是,极端情况下,会话缓存占用的内存空间是所有连接线程的倍数,设置会话缓存时,切不可为了片面地提升性能,盲目地增加会话缓存大小,应避免因为服务器内存不够而产生Out Of Memory异常或者是严重的Swap交换,否则会降低整体性能。 常见的全局缓存有:key_buffer_size,query_cache_size,max_heap_table_size,innodb_buffer_pool_size,innodb_additional_mem_pool_size,linnodb_log_buffer_size等。 常见的会话缓存有:preload_buffer_size,read_buffer_size,read_rnd_buffer_size, sort_buffer_size,join_buffer_size,thread_stack,net_buffer_length以及binlog_cache_size等。 常见的临时缓存有: tmp_table_size。上述参数仅仅定义了缓存的大小。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态设计模式]]></title>
    <url>%2F2018%2F11%2F26%2F%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 什么是状态模式状态（State）设计模式是GoF提出的最吸引人的模式之一，也是一种最有用的模式。游戏通常就采用状态模式，因为游戏中的对象往往会非常频繁地改变状态。状态模式的作用就是允许对象在状态改变时改变其行为。 还有很多其他模拟应用（不一定是游戏）也依赖于状态模式。图1用类图方式显示了这种基本设计模式。如图所示，这里没有Client类；不过，GoF指出Context是客户的主要接口。查看这个模式时，可以认为Client类通过ConText类做出请求。 图1 何时使用状态模式如前所述，游戏开发人员通常使用状态模式来处理不同的状态。PHP中几乎每一个应用都会有一些状态改变，一个对象依赖于它的状态时，它肯定会频繁地改变，在这种情况下，状态模式就有绝对的优势。 对象中频繁的状态改变非常依赖于条件语句。就其自身来说，条件语句本身没有什么问题（如switch语句或那些带else子句的语句）。不过，如果选项太多，以至于程序开始出现混乱，或者增加或改变选项需要花费太多时间，甚至成为一种负担，这就出现了问题。 先来看一个简单例子。假设有一个3x3的矩阵，也就是9个状态，不同的单元格（共有9个单元格）会有不同的选择。考虑图2中的矩阵。 图2 假设你创建了一个程序，可以上下移动和左右移动，但是不能沿对角线方向移动。如果在单元格5 (见图2)上，对象可以向任何方向移动（上下和左右都可以），不过除了这个单元格以外，采用传统方式编程时，对于其他单元格都需要某个条件语句。考虑单元格4的移动，可能会有类似下面的代码: 12345678910111213141516if($this-&gt;moveUp())&#123; $this-&gt;currentCell = $cell_1;&#125;elseif ($this-&gt;moveDown())&#123; $this-&gt;currentCell = $cell_7;&#125;elseif ($this-&gt;moveRight())&#123; $this-&gt;currentCell = $cell_5;&#125;elseif ($this-&gt;moveLeft())&#123; $this-&gt;currentCell = $errorMove;&#125; 在此基础上，程序必须跟踪对象在哪些单元格“中”。可以看到，条件语句的个数(或switch语句中的case个数)可能会大幅增长，使程序变得纠缠不清。 对于状态设计模式，每个状态都有自己的具体类，它们实现一个公共接口。我们不打算查看对象的控制流，而是从另一个角度来考虑，即对象的状态。下一节分析状态机，通过介绍，你将更好地理解“以状态为中心”的思路。 状态机状态机是一个模型，其重点包括不同的状态、一个状态到另一个状态的变迁，以及导致状态改变的触发器。要研究状态机，最好的起点是状态图(statechart) ，我们将用状态图来分析，而不是一个计算机流程图或类图。图10-3为一个简单的状态图，其中一个灯泡的状态从关(off)变为开(on) 。 与类图相似，状态图强调的是控制流以外的东西。从图10-3可以看到状态模型的本质: 状态（关灯和开灯） 变迁（从关灯到开灯，以及从开灯到关灯） 触发器（灯开关） 对于打开和关上的灯，其状态、变迁和触发器都非常简单。变迁是即时的，触发器就是灯开关。不过，触发器请求一个改变之后，有些变迁可能需要渐进完成，或者要采用更复杂的方式完成。例如，天气触发树叶颜色的改变，这个变迁就是渐进完成的。不过，可以使用这个状态模型来理解从夏天状态变换到秋天状态，另外只要是通过一个触发器激活从一个状态到另一个状态的状态变迁，这种情况都可以使用这个状态模型来理解。 开灯关灯:最简单的状态设计模式尽管状态机的概念相当简单，但要知道，即使是最基本的状态设计模式也可能很有难度。考虑到这一点，这个最简单的PHP模式例子将重点考虑创建模式的步骤。有一个好消息，如果你能完成一个简单的状态设计模式，那么更大规模的模式也能轻松应对。所以我们慢慢来，先来看这个模式中的各个参与者。 情境为王所有状态模式都需要一个参与者来跟踪对象所处的状态。例如，对于前面的灯泡状态例子，就很有必要记住图10-2中的矩形。如果当前状态是单元格4，系统需要知道可以通过哪些变迁进入其他状态。这正是ConText类要完成的任务。要知道第一个例子只处理两个状态，即灯的状态(关或开)。Context要知道当前状态是什么。使用图10-3中的状态图作为指导，可以看到初始状态为关(由一个带箭头的黑色小球指示)。 作为一个参考点，首先来看ConText类。下面几小节将分析这个上下文，了解它的各个部分以及各部分的角色: 1234567891011121314151617181920212223242526272829303132333435363738394041// Context.phpclass Context&#123; private $offState; private $onState; private $currentState; public function __construct() &#123; $this-&gt;offState = new OffState($this); $this-&gt;onState = new OnState($this); // 开始状态为off $this-&gt;currentState=$this-&gt;offState; &#125; // 调用状态方法触发器 public function turnOnLight() &#123; $this-&gt;currentState-&gt;turnLightOn(); &#125; public function turnOffLight() &#123; $this-&gt;currentState-&gt;turnLightOff(); &#125; // 设置当前状态 public function setState(IState $state) &#123; $this-&gt;currentstate = $state; &#125; // 获得状态 public function getOnState(): &#123; return $this-&gt;onState; &#125; public function getOffState() &#123; return $this-&gt;offState; &#125;&#125; ConText类建立了3个属性，可见性均为私有(private): 123$offState$onState$currentState 前两个分别是两个状态的实例，第三个属性用来跟踪给定时间系统所处的状态。 ConText类中的状态实例在构造函数中，Context实例化IState实现的两个实例--一个对应关(off)状态，另一个对应开(on)状态: 12$this-&gt;offState = new OffState($this);$this-&gt;onState = new OnState($this); 这个实例化过程用到了一种递归，称为自引用(self-referral)。构造函数参数中的实参写为$this，这是Context类自身的一个引用。状态类希望接收一个ConText类实例作为参数，为了在ConText类中实例化一个状态实例，它必须使用$this作为实参。 由于必然有某个状态作为启动时的当前状态，将$currentState属性赋为$offState值。(可以这样考虑，刚走进一个房间，当时灯是关着的。)这是offState类的一个实例。查看图10-3中的状态图，可以看到开始状态是off状态，所以代码只是遵循了状态图中的结构。 调用状态方法:上下文触发器方法Context类中的一些方法要调用状态类中的方法。可以把这些方法想成是触发器(triggers)。调用这些触发器，就会启动从当前状态到另外一个不同状态的变迁。举例来说，下面的方法就是一个触发器: 1234public function turnOnLight()&#123; $this-&gt;currentState-&gt;turnLightOn();&#125; 注意， context方法的名字与状态方法稍有不同:这里是turnOnLight而不是turnLightOn，这些差别只是为了将Context类中的触发器方法与状态实例中的方法相区别。 设置当前状态Context类最重要的作用是跟踪当前状态，从而为系统提供一个正确的上下文或窗口。再回到图10-2中的矩阵，矩阵中的每一步移动都取决于当前单元格。对于单元格9，可以移到单元格8或单元格6 (不允许沿对角线方向移动)。不过，系统必须知道它的当前状态是单元格9，这样才能知道有哪些选择。 要设置一个当前状态，必须以某种方式向Context类发送信息，指定当前状态。这是通过某个状态类完成的。一旦触发一个状态，这个状态就会向Context发送一个消息，指示“我是当前状态”: 1234public function setState(IState $state)&#123; $this-&gt;currentState = $state;&#125; setState()方法需要一个状态对象作为实参(由IState类型提示指示)。触发器方法触发时，它会调用一个状态和相关的方法。这个状态的方法必须向Context发送一个消息，指出现在该状态是当前状态。所以最近触发的状态会调用setState()方法，使它成为当前状态。 状态获取方法最后， context类需要有办法得到当前状态发送的消息。这个消息通过获取方法传递。对于每一个状态，context都要有相应的获取方法。由于这个例子有两个状态类，所以只需要两个获取方法。OffState的获取方法如下:. 1234public function getOffState()&#123; return $this-&gt;offState;&#125; OnState的获取方法如下: 1234public function getOnState()&#123; return $this-&gt;onState;&#125; 在实现的状态类中可以看到，这些方法将在设置当前状态时使用。 Context类小结Context实例化所有状态的实例，并设置默认状态。Context包含有一些方法，可以通过调用具体状态中的相应方法来触发不同的状态。设置方法会跟踪当前状态。为了帮助跟踪当前状态，对于每个状态Context还有一个获取方法，会在状态有改变调用。 状态如果了解了具体状态类如何实现Istate接口，就更能看出Context类的意义。这个接口只包含两个要实现的状态方法: 123456//IState.phpinterface IState&#123; public function turnLightOn(); public function turnLightOff();&#125; 在Context类中，这两个方法都称为状态改变触发器。不过，重要的细节都在以下这两个状态类的实现中: OnState和OffState. OnState1234567891011121314151617181920// OnState.phpclass OnState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "Light is already on-&gt; take no action&lt;br/&gt;"; &#125; public function turnLightOff() &#123; echo "Lights off!&lt;br/&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getOffState()); &#125;&#125; OffState12345678910111213141516171819// OffState.phpclass OffState implements IState&#123; private $context; public function __construct(Context $contextNow) $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "Lights on! Now I can see &lt;br/&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getOnState()); &#125; public function turnLightOff() &#123; echo "Light is already off-&gt; take no action&lt;br/&gt;"; &#125;&#125; OnState和OffState类是IState的简单实现，会有文本消息指示这些状态。状态类在构造函数中包含了Context类的一个引用。应该记得，Context会实例化状态实例，并为状态构造函数类提供一个自引用。 默认状态是OffState，它必须实现IState方法turnLightOn和turnLightOff。Context调用turnLightOn方法，这会显示”Lights on! Now I can see” (开灯了，现在我能看见了)。然后它向Context方法getOnState发送一个消息，将OnState作为当前状态。不过，如果是调用OffState中的turnLightOff，就只有一个消息指示灯已经关了，不会有任何动作。它不会重置Context中的当前状态，因为这已经是当前状态。基本说来，如果请求一个状态启动它自身，就什么也不会做。类似地，如果请求触发一个无法触发的状态，同样什么也不会做。 再来看图10-2中9个单元格的矩阵。从单元格3可以合法地移动到单元格2或单元格6。不过，在单元格3状态中，它不能上移或右移。所以，如果它接收到一个指令，要求启动一个它无法达到的状态，对于这种不可达到的状态，通常程序员会提供一个null条件。 客户通过上下文做出请求Client的所有请求都通过Context做出。 Client与任何状态类之间都没有直接连接，包括IState接口。下面的Client显示了触发两个状态类中所有方法的请求: 12345678910111213141516171819// Client.phpfunction __autoload($class_name)&#123; include $class_name . '.php';&#125;class Client&#123; private $context; public function __construct() &#123; $this-&gt;context = new Context(); $this-&gt;context-&gt;turnOnLight(); $this-&gt;context-&gt;turnOnLight(); $this-&gt;context-&gt;turnOffLight(); $this-&gt;context-&gt;turnOffLight(); &#125;&#125;$worker = new Client(); 实例化一个Context实例之后，初始请求是打开灯，因为灯的默认状态是“关”(off)状态。第二个请求是一样的，不过它只生成一个消息，指示系统目前所处的状态正是请求的这个状态，什么也不会发生。以下输出显示了这些请求的结果: 1234Lights on! Now I can see!Light is already on-&gt; take no actionLights off!Light is already off-&gt; take no action OffState请求的工作类似于OnState请求。如果变迁是从一个状态到另一个状态(off-&gt;on)，就会启动这个改变。不过，如果再次请求当前状态(off-&gt;off)，只会生成一个消息，指示什么也不会发生。 增加状态对于所有设计模式来说，很重要的一个方面是:利用这些设计模式可以很容易地做出修改。与其他模式一样，状态模式同样也很易于更新和改变。对于前面最简单的例子(只包含基本的on/off状态) ，为了查看增加状态有什么影响，下面这个例子会扩展on/off状态，变成一个3路灯泡。在这个新应用中，状态将加倍，变成4个状态: 关(Off) 开(On) 更亮(Brighter) 最亮(Brightest) 图10-4显示了这个更新后的4态状态图。 查看这4个状态，序列有所改变。“关”(off)状态只能变到“开”(on)状态，on状态不能变到off状态。实际上，现在规则有变化，on状态只能变到“更亮”(brighter)状态和“最亮”(brightest)状态。只有brightest状态可以变到“关”(off)状态。 改变接口要改变的第一个参与者是接口IState，这个接口中必须指定相应的方法，可以用来迁移到brighter和brightest状态: 12345678// IState.phpinterface IState&#123; public function turnLightOff(); public function turnLightOn(); public function turnBrighter(); public function turnBrightest();&#125; 现在所有状态类都必须包括这4个方法，它们都需要结合到Context类中。 改变状态状态设计模式中有改变时，这些新增的改变会对模式整体的其他各方面带来影响。不过，增加改变相当简单，因为状态图显示了变迁，而且在这种情况下，每个状态只有一个特定的变迁。我们不再使用文本，现在每个状态都有该状态的一个图形表示。如果变迁合法，就会显示一个特定的图像(如果变迁不合法，会显示nada.png图像) 。 OffState1234567891011121314151617181920212223242526272829// OffState.phpclass OffState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "&lt;img src='lights/on.png'&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getOnState()); &#125; public function turnBrighter() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrightest() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnLightOff() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125;&#125; OnState1234567891011121314151617181920212223242526272829// OnState.phpclass OnState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrighter() &#123; echo "&lt;img src='lights/brighter.png'&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getBrighterState()); &#125; public function turnBrightest() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnLightOff() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125;&#125; BrighterState1234567891011121314151617181920212223242526272829// BrighterState.phpclass BrighterState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrighter() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrightest() &#123; echo "&lt;img src='lights/brightest.png'&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getBrightestState()); &#125; public function turnLightOff() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125;&#125; BrightestState1234567891011121314151617181920212223242526272829// BrightestState.phpclass BrighterState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrighter() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrightest() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnLightOff() &#123; echo "&lt;img src='lights/off.png'&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getOffState()); &#125;&#125; 需要说明，各个状态的方法中有且仅有一个方法会建立负图像。不过，三路灯具正是采用这种方式使用三路灯泡。打开灯之后，它必须经过另外两个状态(brighter和brightest)，才会最后关掉。 更新Context类最后一步是更新Context类，增加新的触发器，并加入新状态。另外，Context还需要为每个新状态增加状态实例和获取方法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?php// Context.phpclass Context&#123; private $offState; private $onState; private $brighterState; private $brightestState; private $currentState; public function __construct() &#123; $this-&gt;offState = new OffState($this); $this-&gt;onState = new OnState($this); $this-&gt;brighterState = new BrighterState($this); $this-&gt;brightestState = new BrightestState($this); // 开始状态为Off $this-&gt;currentState = $this-&gt;offState; &#125; //调用状态方法 public function turnOnLight() &#123; $this-&gt;currentState-&gt;turnLightOn(); &#125; public function turnoffLight() &#123; $this-&gt;currentState-&gt;turnLightOff(); &#125; public function turnBrighterLight() &#123; $this-&gt;currentState-&gt;turnBrighter(): &#125; public function turnBrightestLight() &#123; $this-&gt;currentState-&gt;turnBrightest(); &#125; //设置当前状态 public function setState(IState $state) &#123; $this-&gt;currentState = $state; &#125; //获得状态 public function getOnState() &#123; return $this-&gt;onState; &#125; public function getOffState() &#123; return $this-&gt;offState; &#125; public function getBrighterState() &#123; return $this-&gt;brighterState; &#125; public function getBrightestState() &#123; return $this-&gt;brightestState; &#125;&#125;?&gt; 增加的代码与之前状态的方法以及实例化是一样的。尽管Context类增加了代码，不过与原来的代码很类似，只是有更多内容。 更新客户在最初的例子中， Client可以请求两个状态on或off。增加两个状态后，Client有了更多选择，不过默认状态仍然是off，第一个请求必然是on状态。一旦建立on状态，接下来可以请求brighter状态，然后是brightest状态，之后才能再次请求off: 12345678910111213141516171819202122// Client.phpfunction __autoload($class_name)&#123; include $class_name . '.php'; &#125;class Client&#123; private $context; public function __construct() &#123; $this-&gt;context = new Context(); $this-&gt;context-&gt;turnOnLight(); $this-&gt;context-&gt;turnBrighterLight(); $this-&gt;context-&gt;turnBrightestLight(); $this-&gt;context-&gt;turnOffLight(); $this-&gt;context-&gt;turnBrightestLight(); &#125;&#125;$worker = new Client(); 修改后的Client中，按正确的序列发出请求，首先变迁到on状态。不过，在经过各个不同状态回到off状态之后，Client请求返回brightest状态。此时，会出现“错误指示灯”。图10-5显示了请求序列得到的不同图像。 前面4个灯泡从左到右分别显示了on，brighter，brightest和off状态。不过，第5个灯泡指示请求出现错误。在典型的状态模式实现中，不会出现错误消息(或图像)。这个请求将被简单忽略。 状态这9个状态表示3 x3矩阵中的不同单元格。为了唯一地显示各个单元格,会分别显示一个图像作为标签(有不同的数字和颜色) 。这样一来,能够更清楚地看出穿过矩阵的路线。这9个状态类都包含实现IMatrix接口所需的4个方法。在前面的状态例子中,如果一种选择不合法(如三路灯泡中从on状态直接变到brightes状态) ,并不是显示一个不合法的调用,这里只提供了注释行,指示代码中有一个不合法的移动。 状态模式与PHP很多人把状态设计模式看做是实现模拟器和游戏的主要方法。总的说来,这确实是状态模式的目标,不过除此以外,状态模型(状态引擎)和状态设计模式在PHP中也有很多应用。用PHP完成更大的项目时,包括Facebook和WordPress,会有更多的新增特性和当前状态需求。Grady Booch (http:libm.colyCL6se)指出, Facebook一方面要保证网站更新,同时在以指数速度扩张时(即使有很多程序员也不能满足需要)仍要保持正常工作,要做到这一点难度越来越大。对于这种不断有改变和增长的情况,就可以采用可扩展的状态模式来管理。PHP开发人员如何创建包含多个状态的程序,将决定状态模式的使用范围。所以不仅状态机在游戏和模拟世界中有很多应用,实际上状态模型还有更多适用的领域。只要PHP程序的用户会用到一组有限的状态,开发人员就可以使用状态设计模式。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务机制]]></title>
    <url>%2F2018%2F11%2F26%2FMySQL%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[hljs.initHighlightingOnLoad(); 事务机制数据库与文件系统的最大区别在于数据库实现了数据的一致性以及并发性。对于数据库管理系统而言事务机制与锁机制是实现数据一致性与并发性的基石。 事务通常包含一系列更新操作，这些更新操作是一个不可分割的逻辑工作单元。如果事务成功执行，那么该事务中所有的更新操作都会成功执行，并将执行结果提交到数据库文件中，成为数据库永久的组成部分。如果事务中某个更新操作执行失败，那么事务中的所有更新操作均被撤销。简言之：事务中的更新操作要么都执行，要么都不执行，这个特征叫做事务的原子性。 说明 更新语句或更新操作主要是update、insert以及delete等语句。 由于MyISAM存储引擎暂时不支持事务，因此，使用的存储引擎为InnoDB存储引擎。 事务机制的必要性对于银行系统而言，转账业务是银行最基本、最常用的业务，有必要将转账业务封装成存储过程，银行系统调用该存储过程后即可实现两个银行账户间的转账业务。 场景描述1：假设某个银行存在两个借记卡账户（account）甲与乙，并且要求这两个借记卡账户不能用于透支，即两个账户的余额（balance）不能小于零。 步骤1：创建account账户表，并将其设置为InnoDB存储引擎。account_no字段是账户表的主键，其值由MySQL自动生成；account_name字段是账户名；balance字段是余额，由于余额不能为负数，将其定义为无符号数。 12345create table account( account_no int auto_increment primary key, account_name char(10) not null, balance int unsigned) ENGINE=innodb DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci; 步骤2：添加测试数据。下面的SQL语句向账户account表中插入了“甲”和“乙”两条账户信息，余额都是1000元。 123insert into account values(null,'甲',1000);insert into account values(null,'乙',1000); 步骤3：创建存储过程。下面的MySQL代码创建了transfer_proc()存储过程，将from_account账户的money金额转账到to_account账户中，继而实现两个账户之间的转账业务。 123456789101112delimiter $$ create procedure transfer_proc(in from_account int,in to_account int,in money int) modifies sql data begin update account set balance=balance+money where account_no=to_account; update account set balance=balance-money where account_no=from_account; end$$delimiter ; 步骤4：测试存储过程。下面的MySQL代码首先调用了transfer_proc()存储过程，将账户“甲”的800元转账到了“乙”账户中。然后查询了账户表中的所有账户信息，执行结果如图9-1所示，此时两个账户的余额之和为2000元。 123call transfer_proc(1,2,800);select * from account; 步骤5：再次测试存储过程。再次调用transfer_proc()存储过程，将账户“甲”的800元转账到“乙”账户中。由于账户余额不能为负数，甲的账户余额200元减去800元，产生了错误代码1690对应的错误信息（稍后为该错误代码定义错误处理程序）。1690 - BIGINT UNSIGNED value is out of range in ‘(test.account.balance - money@2)’ 然后查询账户表中的所有账户信息： 12call transfer_proc(1,2,800);select * from account; 执行结果如下。account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 2600 结论：甲账户的余额没有丝毫变化，但是乙账户的余额却凭空多出800元。甲、乙账户的余额之和由转账前2000元，变成了转账后的2800元，由此产生了数据不一致问题。 为了避免出现数据不一致问题，需要在存储过程中引入事务的概念，将transfer_proc()存储过程的两条update语句绑定到一起，让它们成为一个“原子性”的操作：两条update语句要么都执行，要么都不执行。 关闭MySQL自动提交默认情况下，MySQL开启了自动提交（auto_increment），这就意味着，之前编写的任意一条更新语句，一旦发送到MySQL服务器，MySQL服务实例会立即解析、执行，并将更新结果提交到数据库文件中，成为数据库永久的组成部分。 以转账存储过程transfer_proc()为例，该存储过程包含两条update语句，第一条update语句执行“加法”运算，第二条update语句执行“减法”运算。由于MySQL默认情况下开启了自动提交，因此第二条update语句无论执行成功还是失败，都不会影响第一条update语句的成功执行。如果第一条update语句成功执行，而第二条update语句执行失败，最终将导致数据不一致问题的发生。可以这样理解：产生上述数据不一致问题的根源在于MySQL开启了自动提交，并且没有引入事务的概念。 因此，对于诸如银行转账的业务逻辑而言，首要步骤是关闭MySQL自动提交，只有当所有的更新语句成功执行后，才提交（commit）所有的更新语句，否则回滚（rollback）所有的更新语句。关闭自动提交的方法有两种：一种是显式的关闭自动提交；另一种是隐式的关闭自动提交。 方法一：显式的关闭自动提交 使用MySQL命令“show variables like ‘autocommit’;”可以查看MySQL是否开启了自动提交。系统变量@@autocommit的值为ON或者1时，表示MySQL开启自动提交，默认情况下，MySQL开启了自动提交。系统变量@@autocommit 的值为OFF或者0时，表示MySQL关闭自动提交。使用MySQL命令“set autocommit=0;”可以显式的关闭MySQL自动提交。 说明 系统变量@@autocommit是会话变量，MySQL客户机A对该系统会话变量的更改，不会影响到MySQL客户机B中该系统会话变量的值。 方法二：隐式的关闭自动提交使用MySQL命令“start transaction;”可以隐式地关闭自动提交。隐式的关闭自动提交不会修改系统会话变量@@autocommit的值。 注意：对MyISAM存储引擎的表进行更新操作时，自动提交无论开启还是关闭，更新操作都将立即解析、执行，并将执行结果提交到数据库文件中，成为数据库永久的组成部分。 回滚关闭MySQL自动提交后，数据库开发人员可以根据需要回滚（也叫撤销）更新操作。 场景描述2：接场景描述1的步骤，当甲、乙账户的余额分别变为200元以及2600元后，打开MySQL客户机A，然后输入下面的MySQL命令。该MySQL命令首先关闭MySQL的自动提交，接着修改乙账户（account_no=2）的余额（加800元），然后查询所有账户的余额。 1234set autocommit=0;update account set balance=balance+800 where account_no=2;select * from account; 结果为：account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 3400 从运行结果可以看到，乙账户的余额已经从2600元修改为3400元，事实果真如此？打开另一个MySQL客户机B，选择当前的数据库为choose数据库，使用select语句再次查询所有账户的余额。 123use choose;select * from account; 结果为：account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 2600 从MySQL客户机B的执行结果可以看到乙的余额依然是2600元，并没有增加800元。对于这个问题，可以通过下图进行解释。从图中可以得知：MySQL客户机A的update操作影响的仅仅是内存中new记录的值，且该值并没有写入数据库文件；当MySQL客户机A执行select语句时，查询到的3400元实际上是MySQL服务器内存中new记录的字段值；MySQL客户机B执行select语句时，看到的2600元是外存数据2600在服务器内存的一个副本。 乙的最终余额究竟应该是多少元？这要取决于MySQL客户机A接下来的操作（可以分成两种情形：场景描述3与场景描述4）。 场景描述3：接场景描述2的步骤，在MySQL客户机A上执行MySQL命令“rollback;”，接着在MySQL客户机A、MySQL客户机B上执行select语句查询甲、乙账户的余额，两次执行结果相同（乙账户的余额均为2600），结果如下：account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 2600可以这样理解：MySQL客户机A关闭MySQL自动提交后，MySQL客户机A执行的所有更新操作，都会在MySQL服务器内存中产生若干条new记录。如果在MySQL客户机A上执行了rollback命令，MySQL服务器内存中，与MySQL客户机A对应的new记录将被丢弃，回滚了（也叫撤销了）MySQL客户机A执行的更新操作。 说明 insert语句产生new记录，delete语句产生old记录，update语句产生new记录以及old记录，关于这方面的知识请参看视图与触发器章节的内容。 提交MySQL自动提交一旦关闭，数据库开发人员需要“提交”更新语句，才能将更新结果提交到数据库文件中，成为数据库永久的组成部分。自动提交关闭后，MySQL的提交方式分为显式的提交与隐式的提交。显式的提交：MySQL自动提交关闭后，使用MySQL命令“commit;”可以显式的提交更新语句。 隐式的提交：MySQL自动提交关闭后，使用下面的MySQL语句，可以隐式的提交更新语句。begin、set autocommit=1、start transaction、rename table、truncate table等语句；数据定义（create、alter、drop）语句，例如create database、create table、create index、create function、create procedure、alter table、alter function、alter procedure、drop database、drop table、drop function、drop index、drop procedure等语句；权限管理和账户管理语句（例如grant、revoke、set password、create user、drop user、rename user等语句）；锁语句（lock tables、unlock tables）。举例来说，MySQL客户机A关闭MySQL自动提交后，执行了若干条更新语句。此时如果MySQL客户机A执行了“create table test_commit(a int primary key);”语句，该语句成功创建test_commit表后，还会提交之前的所有更新语句。 为了有效地提交事务，推荐数据库开发人员尽可能地使用显式的提交方式，尽量不要使用（或者避免使用）隐式的提交方式。 场景描述4：重做场景描述2中的所有操作，在MySQL客户机A上执行MySQL命令“commit;”，接着在MySQL客户机A、MySQL客户机B上执行select语句查询甲、乙账户的余额，两次执行结果相同（乙账户的余额增加了800元，变为3400）。从执行结果可以看出,MySQL客户机A执行commit命令后, MySQL服务器内存中的new记录被更新到数据库文件中,成为数据库永久的组成部分。 说明关闭MySQL的自动提交后,需要显式提交（或者隐式提交）更新语句,否则所有的更新语句影响的仅仅是MySQL服务器内存中的new记录,更新语句提交后,才会将new记录的值写入数据库文件。 无论开启自动提交,还是关闭自动提交,使用触发器时, InnoDB存储引擎都会保证触发事件与触发程序的原子性操作。 事务使用MySQL命令”start transaction;”可以开启一个事务,该命令开启事务的同时,会隐式的关闭MySQL自动提交。使用commit命令可以提交事务中的更新语句;使用rollback命令可以回滚事务中的更新语句。典型的事务处理使用方法如下图所示。 场景描述5:银行转账业务的两条update语句是一个整体,如果其中任意一条update语句执行失败,则所有的update语句应该撤销,从而确保转账前后的总额不变。使用事务机制、错误处理机制可以避免银行转账时数据不一致问题的发生 下面的MySQL代码,首先删除原有的transfer_proc()存储过程,然后重建ransfer_proc()存储过程,并将代码修改为下面的代码。其中, “declare continue handler for 1690”负责处理MysQL错误代码1690,当发生该错误时,执行回滚操作; “start transaction”负责开启事务,并隐式地关闭自动提交;”commit”负责提交事务。 12345678910111213141516drop procedure transfer_proc;delimiter $$create procedure transfer_proc (in from_account int,in to_account int,in money int) modifies sql data begin declare continue handler for 1690 begin rollback; end; start transaction; update account set balance=balance+money where account_no=to_account; update account set balance=balance-money where account_no=from_account; commit;end$$delimiter ; 说明如果账户余额balance字段定义为整数(不是无符号整数) ,那存储过程transfer_proc()也可以通过判断账户余额是否小于零,继而决定是否回滚(rollback)转账业务 默认情况下, InnoDB存储引擎既不会对异常进行回滚,也不会对异常进行提交,而这是十分危险的。异常发生后,数据库开发人员需要借助错误处理程序,显式地提交事务或者显式地回滚事务。可以这样理解:事务的提交与回滚,好比if-else语句中的then子句与else子句,两者只能选其一。 在实际的数据库开发过程中,不建议使用MySQL命令”set autocommit=0;”显式地关闭MySQL自动提交,建议选用”start transaction;”命令,该命令不仅可以开启新的事务,还可以隐式地关闭MySQL自动提交,而且”start transaction;”命令不会影响@@autocommit系统会话变量的值。 保存点默认情况下,事务一旦回滚,事务内的所有更新操作都将撤销。有些时候,仅仅希望撤销事务内的一部分更新操作,保存点(也称为检查点)可以实现事务的”部分”提交或者“部分”撤销。使用MySQL命令”savepoint 保存点名;”可以在事务中设置一个保存点,使用MySQL命令”rollback to savepoint 保存点名;”可以将事务回滚到保存点状态,如下图所示。当事务回滚到保存点后,那么数据库将进入到一致性状态B。 场景描述6:为了演示保存点的使用,下面两个存储过程save_point1_proc()与save_point2_proc()都试图在同一条事务中创建两个账号相同的银行账户。由于银行账号account_no是主键,两个银行账号不能相同,因此第二条insert语句会产生MySQL错误代码1062,两个存储过程处理MySQL错误代码1062的方法截然不同。 方法一:下面的MySQL代码创建了save_point1_proc()存储过程,该存储过程撤销了所有的insert语句。 12345678910111213141516delimiter $$ create procedure save_point1_proc()modifies sql data begin declare continue handler for 1062 begin rollback to B; rollback; end; start transaction; insert into account values(null,'丙', 1000); savepoint B; insert into account values(last_insert_id(),'丁', 1000); commit; end$$delimiter ; 说明存储过程save_point1_proc()中,为了保证”丙”与”丁”两个账户的账号相同,创建”丁”账户的insert语句使用last_insert_id()函数获取了”丙”账户的账号。第二条insert语句将抛出错误信息(ERROR 1062:主键不能相同) ,第二条insert语句出错后,错误处理程序将事务回滚到B保存点(rollback to B) ,然后回滚整个事务(rollback)如上图所示。调用存储过程save_point1_proc(),然后查询账户account表的所有记录。从查询结果可以看出,两条insert语句都被撤销。 12call save_point1_proc();select * from account; mysql&gt; call save_point1_proc();Query OK, 0 rows affected (0.03 sec) mysql&gt; select * from account;account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 34002 rows in set (0.08 sec) 方法二:下面的MySQL代码创建了save_point2_proc()存储过程,该存储过程仅仅撤销第二条insert语句,但提交了第一条insert语句。 12345678910111213141516delimiter $$create procedure save_point2_proc()modifies sql data begin declare continue handler for 1062 begin rollback to B; commit; end; start transaction; insert into account values(null,'丙', 1000); savepoint B; insert into account values(last_insert_id(),'丁', 1000); commit; end$$delimiter ; 存储过程save_point2_proc()中,第二条insert语句出错后,错误处理程序将事务回滚到B保存点(rollback to B),并提交事务(commit),导致第一条insert语句成功提交到数据库中,。 调用存储过程save_point2_proc(),然后查询账户account表的所有记录。从查询结果可以看出,第一条insert语句成功执行,第二条insert语句被撤销。 12call save_point2_proc();select * from account; mysql&gt; call save_point2_proc();Query OK, 0 rows affected (0.02 sec) mysql&gt; select * from account;+————+————–+———+| account_no | account_name | balance |+————+————–+———+| 1 | 甲 | 200 || 2 | 乙 | 3400 || 4 | 丙 | 1000 |+————+————–+———+3 rows in set (0.06 sec)说明“rollback to savepoint B”仅仅是让数据库回到事务中的某个”一致性状态B” ,而”一致性状态B”仅仅是一个“临时状态”,该“临时状态”并没有将更新回滚,也没有将更新提交。事务回滚必须借助于rollback(而不是”rollback to savepoint B”) ,而事务的提交需借助于commit 使用MySQL命令”release savepoint 保存点名;”可以删除一个事务的保存点。如果该保存点不存在,则该命令将出现错误信息: ERROR 1305 (42000): SAVEPOINT does not exist。如果当前的事务中存在两个相同名字的保存点,则旧保存点将被自动丢弃。 “选课系统”中的事务“选课系统”中,最为复杂的业务逻辑莫过于”学生选课”以及“学生调课”功能的实现,之前的章节已经编写了choose proc)存储过程,实现了学生的选课功能。本章将借用事务的概念编写调课存储过程replace course-proco,实现”选课系统”的调课功能。 场景描述7:使用存储过程实现“选课系统”的调课功能,图9-13所示的程序流程图阐述了某个学生的调课流程(其中, c before表示调课前的课程, c after表示目标课程或者调课后的课程)。从程序流程图中可以看到,调课时,首先要判断调课前的课程与目标课程是否相同,如果相同,则将调课的状态值state设置为-1;接着判断目标课程是否已经审1核,是否已经报满,如果课程未审核或者课程available字段值为0 (课程报满) ,则将状态值state设置为-2;如果调课成功,则将状态值state设置为调课成功后的课程course no。由于调课涉及3条update语句,为了保证它们的原子性,必须将它们封装到事务中。 下面的SQL语句创建了名字为replace course proc)的存储过程,该存储过程接收学生学号(s no)、课程号(c before)以及课程号(c after)为输入参数,经过存储过程一系列处理,返回调课state状态值。如果输出参数state的值大于0,则说明学生调课成功;如果输出参数state的值等于-1,则意味着该生调课前后选择的课程相同;如果输出参数state的值等于-2,则意味着目标课程未审核或者已经报满。请读者注意粗体字代码。 1234567delimiter $$create procedure replace course proc(in s no char(11),in c before int,in c after int,out state int)modifies sql databegindeclare s int;declare status char(8);set state =0;set status="未审核";if(c before=c after) thenset state =-1;elsestart transactionselect state into status from course where course no=c after;select available into s from course where course no-c after;if(s=0 1l status=未审核) therset state =-2:elseif(state=0) therupdate choose set course no-c after,choose time-now0) where student no=s no andcourse no=c before;update course set available-available+1 where course no-c beforeupdate course set available=available-1 where course no=c after;set state =c after;end if;commit;end if;end$:delimiter; 下面的MySQL语句负责调用replace-course-proc)存储过程,对该存储过程进行简单的测试。首先使用下面的select语句查看学号2012002的选课信息,执行结果如图9-14所示。select * from choose where student no=2012002; 接着将该生选修的课程号3,调换为课程号1,执行下面的MySQL命令,执行结果如图9-15所示。set @s no =’2012002;set @c before =3;set @c after =1;set @state =0;call replace course proc(@s no,@c before,@c after,@state);select @state最后使用下面的select语句查看学号2012002最终的选课信息,验证调课是否成功,执行结果如图9-16所示。select * from choose where student no=2012002; 说明学生选课以及学生调课是”选课系统”的核心功能。存储过程与游标章节编写的”选课存储过程” chooseproco使用了触发器维护course表的available字段值。由于InnoDB存储引擎中,触发器已经保证了触发事件与触发程序的原子性,因此choose proc)存储过程可以保证insert语句与insert触发程序的原子性。而本章编写的”调课存储过程” replace course proc)使用事务的概念,将3条update语句封装到一个事务中,同样也可以保证3条update语句的原子性操作。在真正的项目案例中,推荐使用事务实现更新语句的原子性操作,不建议使用触发器。 一般情况下,一系列关系紧密的更新语句(例如insert, delete或者update语句)都需要封装到一个事务中。由于查询语句不会导致数据发生变化,因此一般不需要封装到事务中。细心的读者会发现,在replace course proc)存储过程中,粗体字的select语句负责”查询目标课程的available字段值” ,该select语句也封装到了事务中,具体原因在”锁机制”章节中进行讲解]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL锁机制]]></title>
    <url>%2F2018%2F11%2F26%2FMySQL%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在同一时刻，如果数据库仅仅为单个MySQL客户机提供服务，仅通过事务机制即可实现数据库的数据一致性。但更多时候，在同一时刻，多个并发用户往往需要同时访问（检索或者更新）数据库中的同一个数据，此时仅仅通过事务机制无法保证多用户同时访问同一数据的数据一致性（参看场景描述2），因此有必要引入另一种机制实现数据的多用户并发访问。锁机制是MySQL实现多用户并发访问的基石。 锁机制的必要性MySQL客户机A与MySQL客户机B执行同一条SQL语句”select * from account;”时产生的结果截然不同，继而产生数据不一致问题。这种数据不一致问题产生的深层次原因在于，内存中的数据与外存中的数据不同步造成的（或者说是由内存中的表记录与外存中的表记录之间存在“同步延迟”造成的）。 MySQL客户机A访问数据时，如果能够对该数据“加锁”，阻塞（或者延迟）MySQL客户机B对该数据访问，直到MySQL客户机A数据访问结束，内存与外存中的数据同步后，MySQL客户机A对该数据“解锁”，“解锁”后，被阻塞的MySQL客户机B“被唤醒”，继而可以继续访问该数据，这样就可以实现多用户下数据的并发访问，如下图所示。 简言之，内存数据与外存数据之间的同步延迟，可以通过锁机制将“并发访问”延迟，进而实现数据的一致性访问以及并发访问。 当然，单条更新语句运行期间也会产生同步延迟。例如，场景描述2中，MySQL客户机A执行下面的update语句时，该update语句的执行过程可以简单描述为如下步骤，如下图所示。 1update account set balance = balance + 800 where account_no = 2; 步骤1：使用索引查询是否存在“account_no=2”的账户信息。步骤2：若存在，将该账户信息从外存加载到内存，在内存中生成old记录。步骤3：修改old记录中的balance字段值，在内存中生成new记录。步骤4：将内存中的new记录写入到外存，完成update操作。 上述每一个步骤的执行都需要一定的时间间隔（虽然短暂）。单个update语句运行期间，从步骤1运行到步骤4同样会产生延迟，这种延迟根本就无法避免，数据库开发人员也无需理会这种延迟，毕竟单条SQL语句运行期间会作为一个“原子”操作运行。数据库开发人员需要考虑的问题是:如何借助锁机制，解决多用户并发访问可能引起的数据不一致问题？ MySQL锁机制的基础知识简单地说，MySQL锁机制涉及的内容包括：锁的粒度、隐式锁与显式锁、锁的类型、锁的钥匙以及锁的生命周期等。 锁的粒度锁的粒度是指锁的作用范围。就像读者有了防盗门的钥匙就可以回到“家”中，有了卧室的钥匙就可以进到卧室，有了保险柜的钥匙就可以打开保险柜，每一种“资源”存在一个与之对应“粒度”的锁，数据库亦是如此。对于MySQL而言，锁的粒度可以分为服务器级锁（server-level locking）和存储引擎级锁（storage-engine-level locking）。 服务器级锁是以服务器为单位进行加锁，它与表的存储引擎无关。在MySQL基础知识章节中讲解数据库备份时，为了保证数据备份过程中不会有新的数据写入，使用MySQL命令“flush tables with read lock;”锁定了当前MySQL服务实例，该锁是服务器级锁，并且是服务器级“读锁”。 也就是说， MySQL客户机A执行了MySQL命令“flush tables with read lock;”，锁定了当前MySQL服务实例后，MySQL客户机A针对服务器的写操作（例如insert，update，delete以及create等语句）抛出如下错误信息。 1ERROR 1223（HY000）: Can't execute the query because you have a conflicting read lock 其他MySQL客户机（例如MySQL客户机B）针对服务器的写操作（例如insert，update，delete以及create等语句）被阻塞。 只有MySQL客户机A执行“unlock tables;”命令或者关闭MySQL客户机A的服务器连接，释放服务器级读锁后，才会“唤醒”MySQL客户机B的写操作，MySQL客户机B的写操作才能得以继续执行。MySQL客户机A施加的服务器级锁，只有MySQL客户机A才能解锁。 例如，在MySQL客户机A上锁定了当前MySQL服务实例后，在MySQL客户机B上创建视图test view将被阻塞，而在MySQL客户机A上创建视图test view将产生错误信息（ERROR 1223）。MySQL客户机A解锁后，MySQL客户机B才能成功创建视图test view，如下图所示（注意图中的粗体字）。从执行结果可以看出，MySQL客户机A施加服务器级锁后，该锁对MySQL客户机A的后续操作以及对MySQL客户机B的后续操作产生的效果并不相同。 存储引擎级锁分为表级锁以及行级锁。表级锁是以表为单位进行加锁，MyISAM与InnoDB存储引擎的表都支持表级锁。行级锁是以记录为单位进行加锁，在MyISAM与InnoDB存储引擎中，只有InnoDB存储引擎支持行级锁。 小结：服务器级锁的粒度最大，表级锁的粒度次之，行级锁的粒度最小。锁粒度越小，并发访问性能就越高，越适合做并发更新操作（InnoDB表更适合做并发更新操作）；锁粒度越大，并发访问性能就越低，越适合做并发查询操作（MyISAM 表更适合做并发查询操作）。另外，锁粒度越小，完成某个功能时所需要的加锁、解锁的次数就会越多，反而会消耗较多的服务器资源，甚至会出现资源的恶性竞争，甚至发生死锁问题。 对于“选课系统”而言，系统需要为上百名学生，甚至几百名学生同时提供选课、调课、退课服务。为了提高并发性能，“选课系统”将选用行级锁，这也是“选课系统”的各个数据库表使用InnoDB存储引擎的原因（InnoDB存储引擎支持行级锁）。 隐式锁与显式锁MySQL锁分为隐式锁以及显式锁。多个MySQL客户机并发访问同一个数据时，为保证数据的一致性，数据库管理系统会自动地为该数据加锁、解锁，这种锁称为隐式锁。隐式锁无需数据库开发人员维护（包括粒度、加锁时机、解锁时机等）。 如果应用系统存在多用户并发访问数据的行为，有时单靠隐式锁无法实现数据的一致性访问要求（例如多个学生同时选修同一门课程），此时需要数据库开发人员手动地加锁、解锁，这种锁称为显式锁。对于显式锁而言，数据库开发人员不仅需要确定锁的粒度，还需要确定锁的加锁时机（何时加锁）、解锁时机（何时解锁）以及锁的类型。 锁的类型锁的类型包括读锁（read lock）和写锁（write lock），其中读锁也称为共享锁，写锁也称为排他锁或者独占锁。 读锁（read lock）：如果MySQL客户机A对某个数据施加了读锁，加锁期间允许其他MySQL客户机（例如MySQL客户机B）对该数据施加读锁，但会阻塞其他MySQL客户机（例如MySQL客户机C）对该数据施加写锁，除非MySQL客户机A释放该数据的读锁。简言之，读锁允许其他MySQL客户机对数据同时“读”，但不允许其他MySQL客户机对数据任何“写”（如下图所示）。如果“数据”是表，则该读锁是表级读锁；如果“数据”是记录，则该读锁是行级读锁。 写锁（write lock）：如果MySQL客户机A对某个数据施加了写锁，加锁期间会阻塞其他MySQL客户机（例如MySQL客户机B）对该数据施加读锁以及写锁，除非MySQL客户机A释放该数据的写锁。简言之，写锁不允许其他MySQL客户机对数据同时“读”，也不允许其他MySQL客户机对数据同时“写”（见下图）。如果“数据”是表，则该写锁是表级写锁；如果“数据”是记录，则该写锁是行级写锁。 锁的钥匙多个MySQL客户机并发访问同一个数据时，如果MySQL客户机A对该数据成功地施加了锁，那么只有MySQL客户机A拥有这把锁的“钥匙”，也就是说，只有MySQL客户机A能够对该锁进行解锁操作。 锁的生命周期锁的生命周期是指在同一个MySQL会话内，对数据加锁到解锁之间的时间间隔。锁的生命周期越长，并发访问性能就越低；锁的生命周期越短，并发访问性能就越高。另外，锁是数据库管理系统重要的数据库资源，需要耗费一定的服务器内存，锁的生命周期越长，该锁占用服务器内存的时间间隔就越长；锁的生命周期越短，该锁占用服务器内存的时间间隔就越短。因此为了节省服务器资源，数据库开发人员必须尽可能的缩短锁的生命周期，尽可能早地释放锁资源。 小结：不恰当的锁粒度、锁生命周期不仅会影响数据库的并发性能，还会造成锁资源的浪费。 MyISAM表的表级锁对MyISAM存储引擎的表进行检索（select）操作时，select语句执行期间（时间间隔虽然短暂），MyISAM存储引擎会自动地给涉及到的MyISAM表施加“隐式读锁”；select语句执行完毕后，MyISAM存储引擎会自动地为这些表进行“解锁”。因此select语句的执行时间就是“隐式读锁”的生命周期。 对MyISAM存储引擎的表进行更新（insert、update以及delete）操作时，更新语句（例如insert、update以及delete）执行期间（时间间隔虽然短暂），MyISAM存储引擎会自动地给涉及到的MyISAM表施加“隐式写锁”；更新语句执行完毕后，MyISAM存储引擎会自动地为这些表进行解锁，更新语句的执行时间就是“隐式写锁”的生命周期。 可以看到，任何针对MyISAM表的查询操作或者更新操作，都会隐式地施加表级锁。隐式锁的生命周期非常短暂，且不受数据库开发人员的控制。 有时，应用系统要求数据库开发人员延长MyISAM表级锁的生命周期，MySQL为数据库开发人员提供了显式地施加表级锁以及显式地解锁的MySQL命令，以便数据库开发人员能够控制MyISAM表级锁的生命周期，MySQL客户机A施加表级锁以及解锁的MySQL命令的语法格式如下图所示。 注意事项： （1）上述语法格式主要针对MyISAM表显式地施加表级锁以及解锁，该语法格式同样适用于InnoDB表。只不过因为InnoDB表支持行级锁，在InnoDB表中表级锁的概念比较淡化。 （2）read与write选项的功能在于说明施加表级读锁还是表级写锁。对表施加读锁后，MySQL客户机A对该表的后续更新操作将出错，错误信息如上图所示；MySQL客户机B对该表的后续查询操作可以继续进行，而对该表的后续更新操作将被阻塞。出错与阻塞是两个不同的概念。 MySQL客户机A对表施加写锁后，MySQL客户机A的后续查询操作以及后续更新操作都可以继续进行；MySQL客户机B对该表的后续查询操作以及后续更新操作都将被阻塞。 MySQL客户机A为某个表加锁后，加锁期间MySQL客户机A对该表的后续操作，MySQL客户机B对该表的后续操作以及MySQL客户机B对该表加锁之间的关系如下表所示。 （3）MySQL客户机A使用lock tables命令可以同时为多个表施加表级锁（包括读锁或者写锁），并且加锁期间，MySQL客户机A不能对“没有锁定的表”进行更新及查询操作，否则将抛出“表未被锁定”的错误信息。例如，在MySQL客户机A上运行下面的MySQL代码，对account表施加读锁，加锁期间对book表的查询操作将抛出错误信息。读者可以自行分析，使用显式锁后，锁的生命周期是否延长。 123456alter table account engine=MyISAM;alter table book engine=MyISAM;lock tables account read;select * from account; ERROR 1100（HY000）: Table 'book' was not locked with LOCK TABLESselect * from book;unlock tables; （4）如果需要为同一个表同时施加读锁与写锁，那么需要为该表起两个别名，以区分读锁与写锁。例如，下面的MySQL代码首先将account表的存储引擎设置为MyISAM。然后向account表同时施加读锁（account表的别名为a）以及写锁（account表的别名为b）。接着将account表重命名为a进行查询操作，将account表重命名为b进行查询操作。如果直接查询account表中的所有记录，则将抛出错误信息，原因是并没有为account表施加一个名字为account的锁，抛出错误信息”account表未被锁定”也在情理之中，执行结果如下所示。读者可以自行分析，使用显式锁后，锁的生命周期是否延长。 123456alter table account engine=MyISAM;lock tables account as a read，account as b write;select * from account as a;select * from account as b;select * from account; ERROR 1100（HY000）: Table 'account' was not locked with LOCK TABLESunlock tables; 说明为了便于理解，读者可以认为每个表的锁必须有锁名，且默认情况下锁名就是表名。当某个表既存在读锁又存在写锁时，需要为表名起多个别名，且每个别名对应一个锁名。 （5）read local与read选项之间的区别在于，如果MysQL客户机A使用read选项为某个MyISAM表施加读锁，加锁期间，MySQL客户机A以及MySQL客户机B都不能对该表进行插入操作。如果MySQL客户机A使用read local选项为某个MyISAM表施加读锁，加锁期间，MySQL客户机B可以对该表进行插入操作，前提是新记录必须插入到表的末尾。对InnoDB表施加读锁时，read local选项与read选项的功能完全相同。 场景描述8: read local与read选项之间的区别。首先在MySQL客户机A上执行下面的MySQL命令，并为account表施加local读锁。 12alter table account engine=MyISAM;lock tables account read local; 然后打开MySQL客户机B，在MySQL客户机B上执行下面的insert语句，向account表中添加一条记录。从执行结果可以看出，MySQL客户机A为account表施加local读锁后，MySQL客户机B可以向account表中添加记录。local关键字使得MyISAM表最大限度地支持查询和插入的并发操作。 1insert into account values（null， '丁'， 1000）; 最后在MySQL客户机A上执行下面的MySQL命令，为account表解锁。 1unlock tables; （6）MySQL客户机A对某个表施加读锁的同时， MySQL客户机B对该表施加写锁，默认情况下会优先施加写锁，这是因为更新操作比查询操作更为重要。如果MySQL客户机C…Z对该表同时也施加了写锁，可能造成读锁“饿死”。为了避免读锁“饿死”，MySQL客户机B….Z可以使用low_priority write选项降低写锁的优先级，以便MySQL客户机A及时取得读锁，不被饿死。 （7）unlock tables用于解锁，它会解除当前MySQL服务器连接中所有MyISAM表的所有锁。 （8）lock tables与unlock tables语句会引起事务的隐式提交。 （9）MySQL客户机一旦关闭， unlock tables语句将会被隐式地执行。因此，如果要让表锁定生效就必须一直保持MySQL服务器连接。 InnoDB表的行级锁InnoDB表的锁比MyISAM表的锁更为复杂，原因在于InnoDB表既支持表级锁，又支持行级锁，又存在意向锁，再把事务掺入其中，会给初学者的学习带来不少麻烦。使用lock tables命令为InnoDB表施加表级锁与使用lock tables命令为MyISAM表施加表级锁的用法基本相同，不再赘述，这里主要讨论InnoDB行级锁以及意向锁的用法。 InnoDB提供了两种类型的行级锁，分别是共享锁（S）以及排他锁（X），其中共享锁也叫读锁，排他锁也叫写锁。InnoDB行级锁的粒度仅仅是受查询语句或者更新语句影响的那些记录。在查询（select）语句或者更新（ insert，update以及delete）语句中，为受影响的记录施加行级锁的方法也非常简单。 方法1:在查询（select）语句中，为符合查询条件的记录施加共享锁，语法格式如下所示。 select * from 表 where 条件语句 lock in share mode; 方法2:在查询（select）语句中，为符合查询条件的记录施加排他锁，语法格式如下所示。 select * from 表 where 条件语句 for update; 方法3:在更新（insert，update以及delete）语句中， InnoDB存储引擎将符合更新条件的记录自动施加排他锁（隐式锁），即InnoDB存储引擎自动地为更新语句影响的记录施加隐式排他锁。 说明方法1与方法2是显式地施加行级锁，方法3是隐式地施加行级锁。这3种方法施加的行级锁的生命周期非常短暂，为了延长行级锁的生命周期，最为通用的做法是开启事务。事务提交或者回滚后，行级锁才被释放，这样就可以延长行级锁的生命周期，此时事务的生命周期就是行级锁的生命周期。 场景描述9:通过事务延长行级锁的生命周期。 步骤1:在MySQL客户机A上执行下面的MySQL语句，开启事务，并为student表施加行级写锁。 123use choose;start transaction;select * from student for update; 步骤2 :打开MySQL客户机B ，在MySQL客户机B上执行下面的MySQL语句，开启事务，并为student表施加行级写锁。此时， MySQL客户机B被阻塞。 123use choose;start transaction;select * from student for update; 步骤3:在MySQL客户机A上执行下面的MySQL命令，为student表解锁。此时，MySQL客户机A释放了student表的行级写锁， MySQL客户机B被“唤醒” ，得以继续执行。 1commit; 可以看到，通过事务延长了MySQL客户机A针对student表的行级锁的生命周期。 结论:事务中的行级共享锁（S）以及行级排他锁（X）的生命周期从加锁开始，直到事务提交或者回滚，行级锁才会释放。MySQL客户机A使用”select * from 表 where 条件语句 lock in share mode;”为InnoDB表中符合条件语句的记录施加共享锁后，加锁期间，MySQL客户机A可以对该表的所有记录进行查询以及更新操作。加锁期间，MySQL客户机B可以查询该表的所有记录（甚至施加共享锁），可以更新不符合条件语句的记录，然而为符合条件语句的记录施加排他锁时将被阻塞。 MySQL客户机A使用”select * from 表 where 条件语句 for update;”或者更新语句（例如insert，update以及delete）为InnoDB表中符合条件语句的记录施加排他锁后，加锁期间，MySQL客户机A可以对该表的所有记录进行查询以及更新操作。加锁期间，MySQL客户机B可以查询该表的所有记录，可以更新不符合条件语句的记录，然而为符合条件语句的记录施加共享锁或者排他锁时将被阻塞。 为了便于读者更好地理解共享锁以及排他锁之间的关系，可以参看表9-2所示的内容。 “选课系统”中的行级锁场景描述10 :实现调课功能的存储过程replace_course_proc（）存在功能缺陷。考虑这样的场景:张三与李四”同时”选择同一门目标课程，且目标课程就剩下一个席位（此时目标课程available的字段值为1）。张三以及李四为了实现调课功能，”同时”调用存储过程replace_course_proc（），假设两人“同时”执行存储过程中的select语句”查询目标课程available字段值”： 1select available into s from course where course_no=c_after; 张三以及李四可能都读取到available的值为1（大于零），最后的结果是张三与李四都选择了目标课程。 可以看出，存储过程replace_course_proc（）读取课程的available字段值时，有必要为张三与李四选择相同的目标课程施加排他锁，避免多名学生同时读取同一门课程的available字段值。将存储过程replace_course_proc（）中的代码片段: 1select available into s from course where course_no=c after; 修改为如下的代码片段： 1select available into s from course where course_no=c_after for update; 说明为了延长行级排他锁的生命周期，将该select语句写在了start transaction语句后，封装到事务中。 此时，当张三、李四以及其他更多的学生同时“争夺”同一门目标课程的最后一个席位时，可以保证只有一个学生能够读取该席位，其他学生将被阻塞（如图9-27所示）。这样就可以防止张三与李四都选择了目标课程的最后一个席位。很多读者可能觉得:多个学生同时选择最后一个席位”的可能性微乎其微，但如果最后的一个”席位”是春运期间某趟列车的最后一张火车票呢?现实生活中，类似的”资源竞争”问题还有很多（例如团购、秒杀等），使用锁机制可以有效解决此类“资源竞争”问题。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash算法和数据库实现]]></title>
    <url>%2F2018%2F11%2F25%2FHash%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.什么是Hash表和Hash算法？2.一个好的Hash函数需要满足什么条件？ Hash算法与数据库实现Hash表（HashTable）又称散列表，通过把关键字Key映射到数组中的一个位置来访问记录，以加快查找的速度。这个映射函数称为Hash函数，存放记录的数组称为Hash表。 Hash函数Hash函数的作用是把任意长度的输入，通过Hash算法变换成固定长度的输出，该输出就是Hash值。这种转换是一种压缩映射，也就是Hash值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从Hash值来唯一地确定输入值。 一个好的Hash函数应该满足以下条件：每个关键字都可以均匀地分布到Hash表任意一个位置，并与其他已被散列到Hash表中的关键字不发生冲突。这是Hash函数最难实现的。 Hash算法关键字k可能是整数或者字符串，可以按照关键字的类型设计不同的Hash算法。整数关键字的Hash算法有以下几种。 直接取余法直接取余法原理比较简单，直接用关键字k除以Hash表的大小m取余数，算法如下： 1h (k) = kmodm 例如，如果Hash表的大小为m-12，所给关键字为k=100，则h (k)=4，这种算法只需要一个求余操作，速度比较快。 乘积取整法乘积取整法首先使用关键字k乘以一个常数A (0&lt;A&lt;1 )，并抽取出kA的小数部分。然后用Hash表大小m乘以这个值，再取整数部分即可。算法如下: 1h (k) =floor (m* (KA mod1)) 其中，kA mod 1表示kA的小数部分，floor是取整操作。 当关键字是字符串的时候，就不能使用上面的Hash算法。因为字符串是由字符组成，所以可以把字符串所有字符的ASCII马加起来得到一个整数，然后再按照上面的Hash算法去计算即可。算法如下： 1234567891011function hash ($key, $m) &#123; $strlen = strlen ($key ); $hashval = 0; for ($i=0; $i&lt;$strlen; $i++) &#123; $hashval += ord ($key &#123;$i&#125;); &#125;; return $hashval% $m;&#125; 虽然这是最简单的Hash算法，而且效果也不好，但可以描述Hash算法的基本原理。 经典Hash算法Times33经过计算机科学家们多年的研究,创造了一些非常有效的Hash算法,比较有名的包括: ELFHash, APHash和Times33等。下面是经典的Times33算法: 12345678unsigned int DJBHash (char"str") &#123; unsigned int hash=5381; while (*str) &#123; hash+= (hash&lt; &lt;5) +(*str++); return (hash&amp;Ox7FFFFFFF);&#125; Times33算法思路就是不断乘以33，其效率和随机性都非常好，广泛运用于多个开源项目中，如Apache、Perl和PHP等。]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的索引]]></title>
    <url>%2F2018%2F11%2F24%2FMySQL%E7%9A%84%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：1.MySQL数据库中，数据是如何检索的？2.什么是前缀索引？什么是复合索引？3.什么是主索引和聚簇索引？4.索引越多越好吗？5.索引与约束有什么关系？6.最左前缀原则是什么意思？ 创建数据表时，初学者通常仅仅关注该表有哪些字段、字段的数据类型以及约束条件等信息，很容易忽视数据表中的另一个重要的概念“索引”。 理解索引想象一下《现代汉语词典》的使用方法，就可以理解索引的重要性。《现代汉语词典》将近1800页，收录汉字达1.3万多个，如何在众多汉字中找到某个字（例如“祥”）？从现代汉语词典的第一页开始逐页逐字查找，直到查找到含有“祥”字的那一页？相信读者不会这么做。词典提供了“音节表”，“音节表”将汉语拼音“xiang”编入其中，并且“音节表”按“a”到“z”的顺序排序，故而读者可以轻松地在“音节表”中先找到“xiang-&gt;1488”，然后再从1488页开始逐字查找，这样可以快速地检索到“祥”字。“音节表”就是《现代汉语词典》的一个“索引”，其中“音节表”中的“xiang”是“索引”的“关键字”，该“关键字”的值必须来自于词典正文中的“xiang”（或者说是词典正文中“xiang”的复制），索引中的“1488”是“数据”所在起始页。数据库表中存储的数据往往比《现代汉语词典》收录的汉字多得多，没有索引的词典对读者而言变得不可想象，同样没有“索引”的数据库表对于数据库用户而言更是“悲催”。 ** （1）索引的本质是什么？ ** 本质上，索引其实是数据表中字段值的复制，该字段称为索引的关键字。 ** （2） MySQL数据库中，数据是如何检索的？ ** 简言之， MySQL在检索表中的数据时，先按照索引“关键字”的值在索引中进行查找，如果能够查到，则可以直接定位到数据所在的起始页；如果没有查到，只能全表扫描查找数据了。 ** （3）一个数据库表只能创建一个索引吗？ ** 当然不是。想象一下《现代汉语词典》，除了将汉语拼音编入“音节表”实现汉字的检索功能外，还将所有汉字的部首编入“部首检字表”实现汉字的检索功能，“部首检字表”是《现代汉语词典）的另一个“索引”。同样对于数据库表而言，一个数据库表可以创建多个索引。 ** （4）什么是前缀索引？ ** “部首检字表”的使用方法是：首先确定一个字的部首，结合笔画可以查找到该字所在的起始页。例如部首“礻”，结合“羊”的笔画是6，可以快速地在“部首检字表”中查到“祥-&gt;1488”。 “部首检字表”中的部首“礻”仅仅是汉字的一个部分（part），不是整个汉字的拷贝。同样对于数据库表而言，索引中关键字的值可以是索引“关键字”字段值的一个部分，这种索引称为“前缀索引”。例如，可以仅仅对教师姓名（例如“张老师”）中的“姓”（“张”）建立前缀索引。 ** （5）索引可以是字段的组合吗？ ** 当然可以。《现代汉语词典》中的“部首检字表”中，部首是“索引”的第一关键字（也叫主关键字），部首相同时，“笔画”未必相同，笔画是“索引”的第二关键字（也叫次关键字），同样对于数据库而言，索引可以是字段的组合。数据库表的某个索引如果由多个关键字构成，此时该索引称为“复合索引”。无论索引的关键字是一个字段，还是一个字段的组合，需要注意的是，这些字段必须来自于同一张表，并且关键字的值必须是表中相应字段值的拷贝。另外，数据库为了提高查询“索引”的效率，需要对索引的关键字进行排序。 ** （6）能跨表创建索引吗？ ** 当然不能。这个问题如同在问：是否可以在《牛津高阶英汉双解词典》创建一个“偏旁部首”索引？数据库中同一个索引允许有多个关键字，但每个关键字必须来自同一张表。 ** （7）索引数据需要额外的存储空间吗？ ** 当然需要。翻开词典后，几十页甚至上百页的内容存放的是“索引”数据（音节表、部首检字表）。对于数据库表的索引而言，索引关键字经排序后存放在外存中。对于MyISAM表而言，索引数据存放在外存MYI索引文件中。对于InnoDB数据库表而言，索引存在InnoDB表空间文件中（可能是共享表空间文件，也可能是独享表空间文件）。就像“音节表”是按照“从a到z”的升序顺序排放，部首检字表是按照笔画的升序顺序排放一样。为了提升数据的检索效率，无论MyISAM表的索引，还是InnoDB表的索引，索引关键字经排序（默认为升序排序）后存放在外存文件中。 ** （8）表中的哪些字段适合选作表的索引？什么是主索引？什么是聚簇索引？ ** 想象一下，单独的笔画能作为《现代汉语词典》的索引吗？显然不能，原因在于同一个笔画的汉字太多。反过来说，由于表的主键值不可能重复，表的主键当作索引最合适不过了。 对于MyISAM表而言，MySQL会自动地将表中所有记录主键值的“备份”及每条记录所在的起始页编入索引中，像“部首检字表”一样形成一张“索引表”，存放在外存，这种索引称为“主索引” （primary index）， MyISAM表的MYI索引文件与MYD数据文件位于两个文件，通过MYI索引文件中的“表记录指针”可以找到MYD数据文件中表记录所在的物理地址。如果teacher表是MyISAM存储引擎， teacher表的主索引如下图所示。 MyISAM存储引擎teacher表的主索引以及普通索引 ** 说明 **图中teacher表的记录，并没有按照教师的工号teacher_no字段进行排序，即主索引关键字的顺序与表记录主键值的顺序无需一致。 InnoDB表的“主索引”与MyISAM表的主索引不同。InnoDB表的“主索引”关键字的顺序必须与InnoDB表记录主键值的顺序一致，严格地说，这种“主索引”称为“聚簇索引”，并且每一张表只能拥有一个聚簇索引，如下图所示。假设一个汉语拼音只对应一个汉字，《现代汉语词典》中的“音节表”就变成了汉语词典的聚簇索引。 InnoDB存储引擎teacher表的聚簇索引 MySQL的聚簇索引与其他数据库管理系统不同之处在于，即便是一个没有主键的MySQL表， MySQL也会为该表自动创建一个“隐式”的主键。对于InnoDB表而言，必须有聚簇索引（有且仅有一个聚簇索引） 。 前面曾经提到，由于InnoDB表记录与索引位于同一个表空间文件中，因此InnoDB表就是聚簇索引，聚簇索引就是InnoDB表。就像一本撕掉音节表、部首检字表的汉语词典一样，读者同样可以通过拼音直接在汉语词典中查找汉字，原因在于，撕掉音节表、部首检字表后的汉语词典本身就是聚簇索引。 对于InnoDB表而言，MySQL的非聚簇索引统称为“辅助索引”（secondary index），辅助索引的“表记录指针”称为“书签”（bookmark），实际上是主键值，如下图所示，可以看到，所有的辅助索引都包含主键列，所有的InnoDB表都是通过主键来聚簇的。 InnoDB存储引擎teacher表的聚簇索引与辅助索引 ** 说明 ** 这里为了更直观地描述索引，图中将表的索引制作成了一个表格。事实上，表的索引往往通过更为复杂的数据结构（例如双向链表、B+树btree、hash等数据结构）实现，从而可以大幅提升数据的检索效率。 MyISAM存储引擎的表支持主索引，并且还可以采用压缩机制（Packed：Packed的说明如下表所示）存储索引的关键字，比如第一个关键字的值为“her”，第二关键字的值为“here”，那么第二关键字会被存储为“3, e”。 InnoDB存储引擎的表支持聚簇索引。由于创建聚簇索引时需要对“索引”中的数据以及表中的数据进行排序，为了避免更新数据（例如插入数据）耗费过多的时间，建议将InnoDB表的主键设置为自增型字段。 ** （9）索引与数据结构是什么关系？ ** 数据库中的索引关键字在索引文件中的存储规则远比词典中的“音节表”复杂得多。为了有效提升数据检索效率，索引通常使用平衡树（btree）或者哈希表等复杂的数据结构进行“编排”。当然在操作数据库的过程中，数据库用户并不会感觉到这些数据结构的存在，原因在于SQL语句（例如select语句等）已经实现了复杂数据结构的“封装”，在执行这些SQL语句时，其底层操作实际上执行的是复杂数据结构的操作。 ** （10）索引非常重要，同一个表中，表的索引越多越好吗？ ** 如果没有索引， MySQL必须从第1条记录开始，甚至读完整个表才能找出相关的记录，表越大，花费的时间越多。有了索引，索引就可以帮助数据库用户快速地找出相关的记录，并且索引由MySQL自动维护，但这不意味着表的索引越多越好。 索引确实可以提高检索效率，但要记住，索引是冗余数据，冗余数据不仅需要额外的存储空间，而且还需要额外的维护（虽然不需要人为的维护） 。 如果索引过多，在更新数据（添加、修改或者删除）时，除了需要修改表中的数据外，还需要对该表的所有索引进行维护，以维持表字段值和索引关键字值之间的一致性，反而降低了数据的更新速度。实践表明，当修改表记录的操作特别频繁时，过多的索引会导致硬盘I/O次数明显增加，反而会显著地降低服务器性能，甚至可能会导致服务器宕机。不恰当的索引不但于事无补，反而会降低系统性能。因此，索引是把双刃剑，并不是越多越好，哪些字段（或字段组合）更适合选作索引的关键字？ 索引关键字的选取原则索引的设计往往需要一定的技巧，掌握了这些技巧，可以确保索引能够大幅地提升数据的检索效率，弥补索引在数据更新方面带来的缺陷。 ** 原则1：表的某个字段值的离散度越高，该字段越适合选作索引的关键字。 ** 考虑现实生活中的场景：学生甲到别的学校找学生乙，但甲只知道乙的性别，那么学生甲要想找到乙，无异于“大海捞针”。原因很简单，性别字段的值要么是男，要么是女，取值离散度较低（Cardinality的值最多为2），因此，性别字段就没有必要选作索引的关键字了。 如果甲知道的是乙的学号，情况就比较乐观了，因为对于一个学校而言，有多少名学生，就会有多少个学号与之相对应。学号的取值特别离散，因此，比较适合选作学生表索引的关键字。 主键字段以及唯一性约束字段适合选作索引的关键字，原因就是这些字段的值非常离散。尤其是在主键字段创建索引时， Cardinality的值就等于该表的行数。MySQL在处理主键约束以及唯一性约束时，考虑得比较周全。数据库用户创建主键约束的同时，MySQL会自动创建主索引（primary index），且索引名称为PRIMARY；数据库用户创建唯一性约束的同时，MySQL会自动地创建唯一性索引（unique index），默认情况下，索引名为唯一性约束的字段名。 ** 原则2：占用储存空间少的字段更适合选作索引的关键字。 ** 如果索引中关键字的值占用的存储空间较多，那么检索效率势必会造成影响。例如，与字符串字段相比，整数字段占用的存储空间较少，因此，较为适合选作索引的关键字。 ** 原则3：储存空间固定的字段更适合选作索引的关键字。 ** 与text类型的字段相比， char类型的字段较为适合选作索引的关键字。 ** 原则4：where子句中经常使用的字段应该创建索引，分组字段或者排序字段应该创建索引，两个表的连接字段应该创建索引。 ** 引入索引的目的是提高数据的检索效率，因此索引关键字的选择与select语句息息相关。这句话有两个方面的含义：select语句的设计可以决定索引的设计；索引的设计也同样影响着select语句的设计。例如原则1与原则2，可以影响select语句的设计；而select语句中的where子句、group by子句以及order by子句，又可以影响索引的设计。两个表的连接字段应该创建索引，外键约束一经创建，MySQL会自动地创建与外键相对应的索引，这是由于外键字段通常是两个表的连接字段。 ** 原则5：更新频繁的字段不适合创建索引，不会出现在where子句中的字段不应该创建索引。 ** ** 原则6：最左前缀原则。 ** 复合索引还有另外一个优点，它通过被称为“最左前缀”（leftmost prefixing）的概念体现出来。假设向一个表的多个字段（例如firstname、lastname、address）创建复合索引（索引名为fname_lname_address）。当where查询条件是以下各种字段的组合时，MySQL将使用fname_lname_address索引。其他情况将无法使用fname_lname_address索引。 firstname， lastname， addressfirstname， lastnamefirstname 可以这样理解：一个复合索引（firstname、lastname、address）等效于（firstname、lastname、age）、（firstname、lastname）以及（firstname）三个索引。 基于最左前缀原则，应该尽量避免创建重复的索引，例如创建了fname_lname_address索引后，就无需在first_name字段上单独创建一个索引。 ** 原则7：尽量使用前缀索引。 ** 例如，仅仅在姓名（例如“张三”）中的姓氏部分（“张”）创建索引，从而可以节省索引的存储空间，提高检索效率。 当然，索引的设计技巧还有很多，而且不是千篇一律的，更不是照本宣料的，没有索引的表同样可以完成数据检索任务。索引的设计没有对错之分，只有合适与不合适之分。与数据库的设计一样，索引的设计同样需要数据库开发人员经验的积累以及智慧的沉淀，同时需要依据系统各自的特点设计出更好的索引，在“加快检索效率”与“降低更新速度”之间做好平衡，从而大幅提升数据库的整体性能。 索引与约束MySQL中表的索引与约束之间存在怎样的关系？约束分为主键约束、唯一性约束、默认值约束、检查约束、非空约束以及外键约束。其中，主键约束、唯一性约束以及外键约束与索引的联系较为紧密。 约束主要用于保证业务逻辑操作数据库时数据的完整性；而索引则是将关键字数据以某种数据结构的方式存储到外存，用于提升数据的检索性能。约束是逻辑层面的概念；而索引既有逻辑上的概念，更是一种物理存储方式，且事实存在，需要耗费一定的存储空间。 对于一个MySQL数据库表而言，主键约束、唯一性约束以及外键约束是基于索引实现的。因此，创建主键约束的同时，会自动创建一个主索引，且主索引名与主键约束名相同（PRIMARY）；创建唯一性约束的同时，会自动创建一个唯一性索引，且唯一性索引名与唯一性约束名相同；创建外键约束的同时，会自动创建一个普通索引，且索引名与外键约束名相同。 在MySQL数据库中，删除了唯一性索引，对应的唯一性约束也将自动删除。若不考虑存储空间方面的因素，唯一性索引就是唯一性约束。 创建索引通过前面知识的讲解，我们已经将索引分为聚簇索引、主索引、唯一性索引、普通索引、复合索引等。如果数据库表的存储引擎是MyISAM，那么创建主键约束的同时， MySQL会自动地创建主索引。如果数据库表的存储引擎是InnoDB，那么创建主键约束的同时， MySQL会自动地创建聚簇索引。 MySQL还支持全文索引（fulltext），当查询数据量大的字符串信息时，使用全文索引可以大幅提升字符串的检索效率。需要注意的是，全文索引只能创建在char， varchar或者text字符串类型的字段上，且全文索引不支持前缀索引。 ** 说明 **从MySQL3.23.23版本开始，MyISAM存储引擎的表最先支持全文索引；从MySQL5.6版本开始，InnoDB存储引擎的表才支持全文索引。 创建索引的方法有两种：创建表的同时创建索引，在已有表上创建索引。 ** 方法一：创建表的同时创建索引。 ** 使用这种方法创建索引时，可以一次性地创建一个表的多个索引（例如唯一性索引、普通索引、复合索引等），其语法格式与创建表的语法格式基本相同（注意粗体字部分的代码） 12345678910create table表名 (字段名1 数据类型[约束条件]，字段名2 数据类型[约束条件]，...[其他约束条件]，[其他约束条件]，...[unique | fulltext ] index [索引名] (字段名[（长度）] [asc | desc])) engine=存储引擎类型 default charset=字符集类型 ** 说明 ** “[]”表示可选项，“[]”里面的“|”表示将各选项隔开，“（）”表示必选项。 长度表示索引中关键字的字符长度，关键字的值可以是数据库表中字段值的一部分，这种索引称为“前缀索引”。 asc与desc为可选参数，分别表示升序与降序，不过目前这两个可选参数没有实际的作用，索引中所有关键字的值均以升序存储。 使用下面的SQL语句创建了一个存储引擎为MyISAM、默认字符集为gbk的书籍book表，其中定义了主键isbn、书名name、简介brief_introduction、价格price以及出版时间publish_time，并在该表分别定义了唯一性索引isbn_unique、普通索引name_index、全文索引brief_fulltext以及复合索引complex_index。 1234567891011create table book( isbn char(20) primary key, name char(100) not null, brief_introduction text not null, price decimal(6,2), publish_time date not null, unique index isbn_unique (isbn), index name_index (name (20)), fulltext index brief_fulltext (name,brief_introduction), index complex_index (price,publish_time) ) engine=MyISAM default charset=gbk; ** 说明 **从MySQL5.6开始， InnoDB存储引擎的表已经支持全文索引，因此book表的存储引擎也可以设置为InnoDB。 ** 方法二：在已有表上创建索引。 ** 在已有表上创建索引有两种语法格式，这两种语法格式的共同特征是需要指定在哪个表上创建索引，语法格式分别如下。 语法格式一： 1create [unique | fulltext ] index 索引名 on 表名(字段名[(长度)] [asc | desc ]） 语法格式二： 1alter table 表名 add [ unique | fulltext ] index 索引名(字段名[(长度)][asc | desc]) 例如，向课程course表的课程描述description字段添加全文索引，可以使用下面的SOL语句，执行结果如下。 1alter table course add fulltext index description_fulltext (description); 在已有表上创建索引 该SQL语句等效于： 1create fulltext index description_fulltext on course (description) 删除索引如果某些索引降低了数据库的性能，或者根本就没有必要使用该索引，此时可以考虑将该索引删除，删除索引的语法格式如下。 1drop index 索引名 on 表名 例如，删除书籍book表的复合索引complex_index，可以使用下面的SQL语句实现该功能。 1drop index complex_index on book;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7安装GitLab]]></title>
    <url>%2F2018%2F11%2F21%2FCentOS7%E5%AE%89%E8%A3%85GitLab%2F</url>
    <content type="text"></content>
  </entry>
</search>
